import os
import io
import csv
import re
import pandas as pd
from datetime import datetime
from flask import Flask, render_template, request, jsonify, session, send_file, g
from flask_session import Session
from flask_cors import CORS
from openpyxl import Workbook
from openpyxl.utils.exceptions import IllegalCharacterError
from openpyxl.utils import get_column_letter
import mysql.connector
from mysql.connector import errorcode
import bcrypt
import paramiko
import json
import logging
from io import StringIO
import numexpr
import numpy as np
import logging
from typing import Dict,Tuple, List
import pandas as pd
import numexpr
import logging
import pandas as pd
import re
from datetime import datetime, timedelta
import pandas as pd
from openpyxl import Workbook
from openpyxl.utils import get_column_letter
import logging
import json
import mysql.connector
from io import BytesIO
import operator
from typing import Tuple, List
from dotenv import load_dotenv
load_dotenv()

logging.basicConfig(
    level=logging.DEBUG,
    format='%(asctime)s %(levelname)s: %(message)s',
    handlers=[logging.FileHandler('app.log'), logging.StreamHandler()]
)

# Helper functions for auto column detection
def detect_column_type(series):
    """Automatically detect column data type using pattern analysis"""
    non_null = series.dropna().astype(str)
    if non_null.empty:
        return "Text"
    
    # Email pattern detection
    if non_null.str.match(r'^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+

def create_app():
    """Application factory pattern for different environments"""
    # Set the path to the frontend dist folder
    current_dir = os.path.dirname(os.path.abspath(__file__))
    frontend_dist_path = os.path.join(current_dir, '..', '..', 'Keansa-Ai-Suite2025may-frontend11', 'dist')
    frontend_dist_path = os.path.abspath(frontend_dist_path)
    
    # Create Flask application instance
    app = Flask(__name__, static_folder=frontend_dist_path, static_url_path='')
    CORS(app, supports_credentials=True, origins=["http://localhost:3000", "http://localhost:8080", "http://localhost:5000", "*"])

    app.secret_key = os.urandom(24).hex()
    app.config['SESSION_TYPE'] = 'filesystem'
    app.config['SESSION_FILE_DIR'] = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'sessions')
    app.config['SESSION_COOKIE_SAMESITE'] = 'Lax'
    app.config['SESSION_COOKIE_HTTPONLY'] = True
    app.config['SESSION_COOKIE_SECURE'] = False
    app.config['PERMANENT_SESSION_LIFETIME'] = 86400  # 24 hours
    app.config['UPLOAD_FOLDER'] = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'uploads')
    Session(app)

    # Ensure directories exist
    try:
        os.makedirs(app.config['UPLOAD_FOLDER'], exist_ok=True)
        os.makedirs(app.config['SESSION_FILE_DIR'], exist_ok=True)
    except OSError as e:
        logging.error(f"Failed to create directories: {e}")

    # Register cleanup handlers
    app.teardown_appcontext(close_db)
    
    # Register all routes directly in create_app
    
    # Static file serving for React frontend
    @app.route('/', defaults={'path': ''})
    @app.route('/<path:path>')
    def serve(path):
        if path and os.path.exists(os.path.join(app.static_folder, path)):
            return app.send_static_file(path)
        return app.send_static_file('index.html')

    # Health check endpoint
    @app.route('/health', methods=['GET'])
    def health_check():
        return jsonify({
            'status': 'healthy',
            'timestamp': datetime.now().isoformat(),
            'version': '2.0.0'
        })

    # Authentication endpoint - both old and new paths
    @app.route('/authenticate', methods=['POST'])
    @app.route('/api/auth/authenticate', methods=['POST'])
    def authenticate():
        try:
            email = request.form.get('username') or request.form.get('email')
            password = request.form.get('password')
            logging.debug(f"Login attempt: email={email}, password={'*' * len(password) if password else 'None'}")
            
            if not email or not password:
                logging.warning(f"Login failed: Email or password missing")
                return jsonify({'success': False, 'message': 'Email and password are required'}), 400

            # Check for admin login
            if email == "admin" and password == "admin":
                session['loggedin'] = True
                session['user_email'] = "admin@example.com"
                session['user_id'] = 1
                session.permanent = True
                logging.info(f"Admin login successful. Session: {dict(session)}")
                return jsonify({'success': True, 'message': 'Login successful', 'user': {'email': 'admin@example.com', 'id': 1}}), 200

            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("SELECT * FROM login_details WHERE LOWER(email) = LOWER(%s)", (email.lower(),))
            account = cursor.fetchone()
            cursor.close()
            
            if account:
                if bcrypt.checkpw(password.encode('utf-8'), account['password'].encode('utf-8')):
                    session['loggedin'] = True
                    session['user_email'] = account['email']
                    session['user_id'] = account['id']
                    session.permanent = True
                    logging.info(f"User {email} logged in successfully. Session: {dict(session)}")
                    return jsonify({
                        'success': True,
                        'message': 'Login successful',
                        'user': {'email': account['email'], 'id': account['id']}
                    }), 200
                else:
                    logging.warning(f"Invalid password for {email}")
                    return jsonify({'success': False, 'message': 'Invalid credentials'}), 401
            else:
                logging.warning(f"Email {email} not found")
                return jsonify({'success': False, 'message': 'Invalid credentials'}), 401
        except Exception as e:
            logging.error(f"Unexpected error during login: {str(e)}")
            return jsonify({'success': False, 'message': f'Unexpected error: {str(e)}'}), 500

    @app.route('/check-auth', methods=['GET'])
    @app.route('/api/auth/check-auth', methods=['GET'])
    def check_auth():
        try:
            logging.debug(f"Checking auth with session: {dict(session)}")
            if 'loggedin' in session and 'user_id' in session:
                conn = get_db_connection()
                cursor = conn.cursor(dictionary=True)
                cursor.execute("SELECT email, first_name FROM login_details WHERE id = %s", (session['user_id'],))
                user = cursor.fetchone()
                cursor.close()
                if user:
                    logging.info(f"User {session.get('user_email')} is authenticated")
                    return jsonify({
                        'success': True,
                        'user': {
                            'email': user['email'],
                            'id': session['user_id'],
                            'first_name': user['first_name']
                        }
                    })
                else:
                    logging.warning("User not found in database")  
                    session.clear()
                    return jsonify({'success': False, 'message': 'User not found'}), 401
            logging.warning("User not authenticated")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        except Exception as e:
            logging.error(f"Error in check-auth endpoint: {str(e)}")
            return jsonify({'success': False, 'message': f'Server error: {str(e)}'}), 500

    @app.route('/register', methods=['POST'])
    @app.route('/api/auth/register', methods=['POST'])
    def register():
        first_name = request.form.get('first_name')
        last_name = request.form.get('last_name')
        email = request.form.get('email')
        mobile = request.form.get('mobile')
        password = request.form.get('password')
        confirm_password = request.form.get('confirm_password')

        if not all([first_name, last_name, email, mobile, password, confirm_password]):
            return jsonify({'success': False, 'message': 'All fields are required'}), 400
        if password != confirm_password:
            return jsonify({'success': False, 'message': 'Passwords do not match'}), 400

        hashed_password = bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
        try:
            conn = get_db_connection()
            cursor = conn.cursor()
            cursor.execute("""
                INSERT INTO login_details (first_name, last_name, email, mobile, password)
                VALUES (%s, %s, %s, %s, %s)
            """, (first_name, last_name, email, mobile, hashed_password))
            user_id = cursor.lastrowid
            conn.commit()
            cursor.close()
            session['loggedin'] = True
            session['user_email'] = email
            session['user_id'] = user_id
            return jsonify({
                'success': True,
                'message': 'Registration successful',
                'user': {'email': email, 'id': user_id}
            }), 200
        except mysql.connector.Error as e:
            logging.error(f"Database error during registration: {str(e)}")
            return jsonify({'success': False, 'message': f'Registration error: {str(e)}'}), 500

    @app.route('/logout', methods=['POST'])
    @app.route('/api/auth/logout', methods=['POST'])
    def logout():
        logging.info(f"User {session.get('user_email', 'unknown')} logged out")
        session.clear()
        return jsonify({'success': True, 'message': 'Logged out successfully'})

    # Template routes
    @app.route('/templates', methods=['GET'])
    @app.route('/api/templates', methods=['GET'])
    def get_templates():
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /templates: session missing")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("""
                SELECT template_id, template_name, created_at, status
                FROM excel_templates
                WHERE user_id = %s AND status = 'ACTIVE'
                ORDER BY created_at DESC
                LIMIT 100
            """, (session['user_id'],))
            templates = cursor.fetchall()
            cursor.close()
            logging.info(f"Fetched {len(templates)} templates for user {session['user_id']}")
            return jsonify({'success': True, 'templates': templates})
        except mysql.connector.Error as e:
            logging.error(f'Error fetching templates: {str(e)}')
            return jsonify({'success': False, 'message': f'Error fetching templates: {str(e)}'}), 500
        except Exception as e:
            logging.error(f'Unexpected error fetching templates: {str(e)}')
            return jsonify({'success': False, 'message': f'Unexpected error: {str(e)}'}), 500

    # Rule Configuration routes
    @app.route('/rule-configurations', methods=['GET'])
    @app.route('/api/validation/rule-configurations', methods=['GET'])
    def get_rule_configurations():
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning(f"Unauthorized access to /rule-configurations: session={dict(session)}")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            user_id = session['user_id']
            logging.debug(f"Fetching rule configurations for user_id: {user_id}")

            # Main query to fetch templates with configured rules
            cursor.execute("""
                SELECT 
                    t.template_id, 
                    t.template_name, 
                    t.created_at, 
                    COUNT(cvr.column_validation_id) as rule_count
                FROM excel_templates t
                LEFT JOIN template_columns tc ON t.template_id = tc.template_id
                LEFT JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                WHERE t.user_id = %s AND t.status = 'ACTIVE' AND t.is_corrected = FALSE
                GROUP BY t.template_id, t.template_name, t.created_at
                HAVING rule_count > 0
                ORDER BY t.created_at DESC
                LIMIT 100
            """, (user_id,))
            templates = cursor.fetchall()
            logging.debug(f"Fetched rule-configured templates: {templates}")

            cursor.close()

            if not templates:
                logging.info(f"No templates with rules found for user_id: {user_id}")
            else:
                logging.info(f"Found {len(templates)} templates with rules for user_id: {user_id}")

            return jsonify({'success': True, 'templates': templates})
        except mysql.connector.Error as e:
            logging.error(f"Database error fetching rule configurations: {str(e)}")
            return jsonify({'success': False, 'message': f"Database error: {str(e)}"}), 500
        except Exception as e:
            logging.error(f"Unexpected error fetching rule configurations: {str(e)}")
            return jsonify({'success': False, 'message': f"Unexpected error: {str(e)}"}), 500

    # File upload route
    @app.route('/upload', methods=['POST'])
    @app.route('/api/templates/upload', methods=['POST'])
    @app.route('/api/upload', methods=['POST'])  # Additional common path
    def upload():
        logging.info(f"Upload endpoint called: {request.endpoint}, method: {request.method}")
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /upload: session missing")
            return jsonify({'error': 'Not logged in'}), 401
        if 'file' not in request.files:
            logging.warning("No file provided in upload request")
            return jsonify({'error': 'No file uploaded'}), 400
        file = request.files['file']
        if file.filename == '':
            logging.warning("No file selected in upload request")
            return jsonify({'error': 'No file selected'}), 400
        
        file_path = os.path.join(app.config['UPLOAD_FOLDER'], file.filename)
        try:
            file.save(file_path)
            logging.info(f"File saved: {file_path}")
        except Exception as e:
            logging.error(f"Failed to save file {file.filename}: {str(e)}")
            return jsonify({'error': f'Failed to save file: {str(e)}'}), 500

        try:
            # Read the file to get sheets and headers
            if file.filename.endswith('.xlsx') or file.filename.endswith('.xls'):
                xl = pd.ExcelFile(file_path)
                sheets = {sheet_name: pd.read_excel(file_path, sheet_name=sheet_name, header=None) 
                         for sheet_name in xl.sheet_names}
            elif file.filename.endswith(('.txt', '.csv', '.dat')):
                df = pd.read_csv(file_path, header=None, encoding='utf-8')
                sheets = {'Sheet1': df}
            else:
                logging.error("Unsupported file type")
                return jsonify({'error': 'Unsupported file type'}), 400
            
            logging.debug(f"Sheets extracted: {list(sheets.keys())}")
        except Exception as e:
            logging.error(f"Failed to read file {file_path}: {str(e)}")
            return jsonify({'error': f'Failed to read file: {str(e)}'}), 400

        try:
            sheet_names = list(sheets.keys())
            if not sheet_names:
                logging.error("No sheets found in the file")
                return jsonify({'error': 'No sheets found in the file'}), 400
            sheet_name = sheet_names[0]
            df = sheets[sheet_name]
            
            # Find header row
            header_row = 0
            for i in range(min(len(df), 10)):
                row = df.iloc[i].dropna()
                if not row.empty and all(isinstance(x, str) for x in row if pd.notna(x)):
                    header_row = i
                    break
                    
            headers = df.iloc[header_row].tolist()
            logging.debug(f"Headers extracted: {headers}")
            
            if not headers or all(not h for h in headers):
                logging.error("No valid headers found in file")
                return jsonify({'error': 'No valid headers found in the file'}), 400
        except Exception as e:
            logging.error(f"Error processing file {file.filename}: {str(e)}")
            return jsonify({'error': f'Error processing file: {str(e)}'}), 400

        # Clear existing session data
        for key in ['df', 'header_row', 'headers', 'sheet_name', 'current_step', 'selected_headers', 'validations', 'error_cell_locations', 'data_rows', 'corrected_file_path']:
            session.pop(key, None)

        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)

            # Check if template exists
            cursor.execute("""
                SELECT template_id, headers, sheet_name
                FROM excel_templates
                WHERE template_name = %s AND user_id = %s AND status = 'ACTIVE'
                ORDER BY created_at DESC
            """, (file.filename, session['user_id']))
            existing_templates = cursor.fetchall()
            logging.info(f"Found {len(existing_templates)} existing templates with name {file.filename}")

            template_id = None
            has_existing_rules = False
            validations = {}
            selected_headers = []

            # Check for matching template
            matching_template = None
            for template in existing_templates:
                stored_headers = json.loads(template['headers']) if template['headers'] else []
                stored_sheet_name = template['sheet_name']
                if stored_headers == headers and stored_sheet_name == sheet_name:
                    matching_template = template
                    break

            if matching_template:
                template_id = matching_template['template_id']
                # Check for existing rules
                cursor.execute("""
                    SELECT tc.column_name, vrt.rule_name
                    FROM template_columns tc
                    JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                    JOIN validation_rule_types vrt ON cvr.rule_type_id = vrt.rule_type_id
                    WHERE tc.template_id = %s AND tc.is_selected = TRUE
                """, (template_id,))
                rules_data = cursor.fetchall()
                for row in rules_data:
                    column_name = row['column_name']
                    rule_name = row['rule_name']
                    if column_name not in validations:
                        validations[column_name] = []
                    validations[column_name].append(rule_name)
                    if column_name not in selected_headers:
                        selected_headers.append(column_name)
                has_existing_rules = len(validations) > 0
            else:
                # New template
                cursor.execute("""
                    INSERT INTO excel_templates (template_name, user_id, sheet_name, headers, is_corrected)
                    VALUES (%s, %s, %s, %s, %s)
                """, (file.filename, session['user_id'], sheet_name, json.dumps(headers), False))
                template_id = cursor.lastrowid
                column_data = [(template_id, header, i + 1, False) for i, header in enumerate(headers)]
                cursor.executemany("""
                    INSERT INTO template_columns (template_id, column_name, column_position, is_selected)
                    VALUES (%s, %s, %s, %s)
                """, column_data)

            conn.commit()
            cursor.close()

            # Store session data
            session['file_path'] = file_path
            session['template_id'] = template_id
            session['df'] = df.to_json()
            session['header_row'] = header_row
            session['headers'] = headers
            session['sheet_name'] = sheet_name
            session['current_step'] = 1 if not has_existing_rules else 3
            session['validations'] = validations
            session['selected_headers'] = selected_headers
            session['has_existing_rules'] = has_existing_rules

            logging.info(f"Upload processed: template_id={template_id}, filename={file.filename}, has_existing_rules={has_existing_rules}")

            return jsonify({
                'success': True,
                'sheets': {sheet_name: {'headers': headers}},
                'file_name': file.filename,
                'template_id': template_id,
                'has_existing_rules': has_existing_rules,
                'sheet_name': sheet_name,
                'skip_to_step_3': has_existing_rules
            })
        except mysql.connector.Error as e:
            logging.error(f'Error saving template: {str(e)}')
            return jsonify({'error': f'Error saving template: {str(e)}'}), 500
        except Exception as e:
            logging.error(f'Unexpected error saving template: {str(e)}')
            return jsonify({'error': f'Unexpected error: {str(e)}'}), 500

    # Multi-step workflow endpoints
    @app.route('/step/1', methods=['GET', 'POST'])
    @app.route('/api/step/1', methods=['GET', 'POST'])
    def step_one():
        if 'loggedin' not in session:
            return jsonify({'error': 'Not logged in'}), 401
        
        if request.method == 'POST':
            try:
                headers = request.form.getlist('headers')
                new_header_row = request.form.get('new_header_row')
                logging.debug(f"Step 1 submitted: headers={headers}, new_header_row={new_header_row}")
                
                if not headers:
                    logging.error("No headers provided in step 1")
                    return jsonify({'success': False, 'message': 'No headers provided'}), 400
                    
                if 'template_id' not in session:
                    logging.error("Session missing template_id")
                    return jsonify({'success': False, 'message': 'Session data missing'}), 400

                template_id = session['template_id']
                
                # Get the dataframe from session for auto-detection
                df_json = session.get('df')
                if df_json:
                    df = pd.read_json(StringIO(df_json))
                    session_headers = session.get('headers', [])
                    df.columns = session_headers
                    header_row = session.get('header_row', 0)
                    df = df.iloc[header_row + 1:].reset_index(drop=True)
                    
                    # Auto-detect rules for selected headers
                    validations = assign_default_rules_to_columns(df, headers)
                    session['validations'] = validations
                    logging.debug(f"Auto-assigned rules: {validations}")
                else:
                    validations = {}

                session['selected_headers'] = headers
                session['current_step'] = 2

                # Mark selected headers in the database
                conn = get_db_connection()
                cursor = conn.cursor()
                cursor.execute("UPDATE template_columns SET is_selected = FALSE WHERE template_id = %s", (template_id,))
                for header in headers:
                    cursor.execute("""
                        UPDATE template_columns
                        SET is_selected = TRUE
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    
                    # Get column_id and add auto-detected rules
                    cursor.execute("""
                        SELECT column_id FROM template_columns
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    result = cursor.fetchone()
                    if result:
                        column_id = result[0]
                        for rule_name in validations.get(header, []):
                            cursor.execute("""
                                SELECT rule_type_id FROM validation_rule_types
                                WHERE rule_name = %s AND is_custom = FALSE
                            """, (rule_name,))
                            rule_result = cursor.fetchone()
                            if rule_result:
                                rule_type_id = rule_result[0]
                                cursor.execute("""
                                    INSERT IGNORE INTO column_validation_rules (column_id, rule_type_id, rule_config)
                                    VALUES (%s, %s, %s)
                                """, (column_id, rule_type_id, '{}'))
                
                conn.commit()
                cursor.close()

                logging.info(f"Step 1 completed: headers={headers}, auto-assigned rules={validations}")
                return jsonify({'success': True, 'headers': headers, 'validations': validations})
            except Exception as e:
                logging.error(f"Error in step 1: {str(e)}")
                return jsonify({'success': False, 'message': str(e)}), 500
        
        # GET request - return current headers
        headers = session.get('headers', [])
        return jsonify({'headers': headers})

    @app.route('/step/2', methods=['GET', 'POST'])
    @app.route('/api/step/2', methods=['GET', 'POST'])
    def step_two():
        if 'loggedin' not in session:
            return jsonify({'error': 'Not logged in'}), 401
            
        if request.method == 'POST':
            try:
                action = request.form.get('action', 'save')
                validations = {}
                for key, values in request.form.lists():
                    if key.startswith('validations_'):
                        header = key.replace('validations_', '')
                        validations[header] = values
                        
                logging.debug(f"Step 2 submitted: action={action}, validations={validations}")
                
                template_id = session.get('template_id')
                if not template_id:
                    return jsonify({'success': False, 'message': 'Session data missing'}), 400

                # Save validations to database
                conn = get_db_connection()
                cursor = conn.cursor()
                
                # Clear existing rules
                cursor.execute("""
                    DELETE FROM column_validation_rules
                    WHERE column_id IN (
                        SELECT column_id FROM template_columns WHERE template_id = %s
                    )
                """, (template_id,))
                
                # Add new rules
                for header, rules in validations.items():
                    cursor.execute("""
                        SELECT column_id FROM template_columns
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    result = cursor.fetchone()
                    if not result:
                        continue
                    column_id = result[0]
                    
                    for rule_name in rules:
                        cursor.execute("""
                            SELECT rule_type_id FROM validation_rule_types
                            WHERE rule_name = %s
                        """, (rule_name,))
                        result = cursor.fetchone()
                        if result:
                            rule_type_id = result[0]
                            cursor.execute("""
                                INSERT IGNORE INTO column_validation_rules (column_id, rule_type_id, rule_config)
                                VALUES (%s, %s, %s)
                            """, (column_id, rule_type_id, '{}'))
                
                conn.commit()
                cursor.close()

                session['validations'] = validations
                session['current_step'] = 3 if action == 'review' else 2
                
                logging.info(f"Step 2 completed: action={action}, validations={validations}")
                return jsonify({'success': True, 'message': 'Step 2 completed successfully'})
            except Exception as e:
                logging.error(f"Error in step 2: {str(e)}")
                return jsonify({'success': False, 'message': str(e)}), 500
        
        # GET request
        selected_headers = session.get('selected_headers', [])
        return jsonify({'selected_headers': selected_headers})

    # Rules endpoint
    @app.route('/rules', methods=['GET'])
    @app.route('/api/rules', methods=['GET'])
    def get_rules():
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            
            cursor.execute("""
                SELECT rule_type_id AS rule_id, rule_name, description, parameters, is_custom, 
                       column_name, template_id, source_format, target_format, data_type, is_active
                FROM validation_rule_types
            """)
            rules = cursor.fetchall()
            cursor.close()
            
            logging.info(f"Returning {len(rules)} rules from getRules endpoint")
            return jsonify({'success': True, 'rules': rules})
        except mysql.connector.Error as e:
            logging.error(f"Database error fetching rules: {str(e)}")
            return jsonify({'success': False, 'message': str(e)}), 500
        except Exception as e:
            logging.error(f"Unexpected error fetching rules: {str(e)}")
            return jsonify({'success': False, 'message': str(e)}), 500

    # Template details endpoint
    @app.route('/template/<int:template_id>/<sheet_name>', methods=['GET'])
    @app.route('/api/template/<int:template_id>/<sheet_name>', methods=['GET'])
    def get_template(template_id, sheet_name):
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /template: session missing")
            return jsonify({'error': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("""
                SELECT template_name, sheet_name, headers
                FROM excel_templates
                WHERE template_id = %s AND user_id = %s AND status = 'ACTIVE'
            """, (template_id, session['user_id']))
            template_record = cursor.fetchone()
            
            if not template_record:
                logging.error(f"Template not found for template_id: {template_id}, user_id: {session['user_id']}")
                cursor.close()
                return jsonify({'error': 'Template not found'}), 404

            headers = json.loads(template_record['headers']) if template_record['headers'] else []
            stored_sheet_name = template_record['sheet_name'] or sheet_name
            file_path = os.path.join(app.config['UPLOAD_FOLDER'], template_record['template_name'])
            
            cursor.execute("""
                SELECT COUNT(*) as rule_count
                FROM template_columns tc
                JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                WHERE tc.template_id = %s AND tc.is_selected = TRUE
            """, (template_id,))
            rule_count = cursor.fetchone()['rule_count']
            has_existing_rules = rule_count > 0
            
            cursor.close()
            
            return jsonify({
                'success': True,
                'sheets': {stored_sheet_name: {'headers': headers}},
                'file_name': template_record['template_name'],
                'file_path': file_path,
                'sheet_name': stored_sheet_name,
                'has_existing_rules': has_existing_rules
            })
        except mysql.connector.Error as e:
            logging.error(f"Database error in get_template: {str(e)}")
            return jsonify({'error': f'Database error: {str(e)}'}), 500
        except Exception as e:
            logging.error(f"Unexpected error in get_template: {str(e)}")
            return jsonify({'error': f'Unexpected error: {str(e)}'}), 500

    # Debug route to show all registered routes
    @app.route('/debug/routes', methods=['GET'])
    def list_routes():
        routes = []
        for rule in app.url_map.iter_rules():
            routes.append({
                'endpoint': rule.endpoint,
                'methods': list(rule.methods),
                'rule': rule.rule
            })
        return jsonify(routes)

    # 404 handler to debug missing routes
    @app.errorhandler(404)
    def not_found_handler(error):
        logging.error(f"404 Error: {request.method} {request.url} not found")
        logging.error(f"Available routes: {[rule.rule for rule in app.url_map.iter_rules()]}")
        return jsonify({
            'error': 'Endpoint not found', 
            'method': request.method,
            'url': request.url,
            'path': request.path
        }), 404

    return app

def initialize_app_data():
    """Initialize database and create default data"""
    try:
        logging.info("Initializing database schema...")
        init_db()
        
        logging.info("Creating admin user...")
        create_admin_user()
        
        logging.info("Creating default validation rules...")
        create_default_validation_rules()
        
        logging.info("Application initialization completed successfully")
    except Exception as e:
        logging.error(f"Failed to initialize application: {e}")
        raise

DB_CONFIG = {
    'host': os.getenv('MYSQL_HOST', 'localhost'),
    'user': os.getenv('MYSQL_USER', 'root'),
    'password': os.getenv('MYSQL_PASSWORD', 'Keansa@2024'),
    'database': os.getenv('MYSQL_DATABASE', 'data_validation_2'),
}

def get_db_connection():
    if 'db' not in g:
        try:
            conn = mysql.connector.connect(
                host=DB_CONFIG['host'],
                user=DB_CONFIG['user'],
                password=DB_CONFIG['password']
            )
            cursor = conn.cursor()
            cursor.execute(f"CREATE DATABASE IF NOT EXISTS {DB_CONFIG['database']}")
            cursor.close()
            conn.close()
            g.db = mysql.connector.connect(**DB_CONFIG)
            logging.info("Database connection established successfully")
        except mysql.connector.Error as err:
            if err.errno == errorcode.ER_ACCESS_DENIED_ERROR:
                logging.error("Database connection failed: Access denied for user - check username/password")
            elif err.errno == errorcode.ER_BAD_DB_ERROR:
                logging.error("Database connection failed: Database does not exist")
            else:
                logging.error(f"Database connection failed: {err}")
            raise Exception(f"Failed to connect to database: {str(err)}")
    return g.db

def close_db(error):
    db = g.pop('db', None)
    if db is not None:
        db.close()

def init_db():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        tables = [
            """
            CREATE TABLE IF NOT EXISTS login_details (
                id INT AUTO_INCREMENT PRIMARY KEY,
                first_name VARCHAR(100),
                last_name VARCHAR(100),
                email VARCHAR(255) UNIQUE,
                mobile VARCHAR(10),
                password VARCHAR(255)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS excel_templates (
                template_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_name VARCHAR(255) NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
                user_id INT NOT NULL,
                sheet_name VARCHAR(255),
                headers JSON,
                status ENUM('ACTIVE', 'INACTIVE') DEFAULT 'ACTIVE',
                is_corrected BOOLEAN DEFAULT FALSE,
                remote_file_path VARCHAR(512),
                FOREIGN KEY (user_id) REFERENCES login_details(id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS template_columns (
                column_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_id BIGINT NOT NULL,
                column_name VARCHAR(255) NOT NULL,
                column_position INT NOT NULL,
                is_validation_enabled BOOLEAN DEFAULT FALSE,
                is_selected BOOLEAN DEFAULT FALSE,
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE,
                UNIQUE (template_id, column_name)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_rule_types (
                rule_type_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                rule_name VARCHAR(255) NOT NULL,
                description TEXT,
                parameters TEXT,
                is_active BOOLEAN DEFAULT TRUE,
                is_custom BOOLEAN DEFAULT FALSE,
                column_name VARCHAR(255),
                template_id BIGINT,
                data_type VARCHAR(50),
                source_format VARCHAR(50),
                target_format VARCHAR(50),
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS column_validation_rules (
                column_validation_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                column_id BIGINT NOT NULL,
                rule_type_id BIGINT NOT NULL,
                rule_config JSON,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (column_id) REFERENCES template_columns(column_id) ON DELETE CASCADE,
                FOREIGN KEY (rule_type_id) REFERENCES validation_rule_types(rule_type_id) ON DELETE RESTRICT,
                UNIQUE (column_id, rule_type_id)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_history (
                history_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_id BIGINT NOT NULL,
                template_name VARCHAR(255) NOT NULL,
                error_count INT NOT NULL,
                corrected_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                corrected_file_path VARCHAR(512) NOT NULL,
                user_id INT NOT NULL,
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE,
                FOREIGN KEY (user_id) REFERENCES login_details(id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_corrections (
                correction_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                history_id BIGINT NOT NULL,
                row_index INT NOT NULL,
                column_name VARCHAR(255) NOT NULL,
                original_value TEXT,
                corrected_value TEXT,
                rule_failed VARCHAR(255) DEFAULT NULL,
                FOREIGN KEY (history_id) REFERENCES validation_history(history_id) ON DELETE CASCADE
            )
            """
        ]
        for table_sql in tables:
            cursor.execute(table_sql)
        
        # Add missing columns if they don't exist
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'source_format'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN source_format VARCHAR(50)")
            logging.info("Added source_format column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'target_format'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN target_format VARCHAR(50)")
            logging.info("Added target_format column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'data_type'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN data_type VARCHAR(50)")
            logging.info("Added data_type column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM excel_templates LIKE 'remote_file_path'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE excel_templates ADD COLUMN remote_file_path VARCHAR(512)")
            logging.info("Added remote_file_path column to excel_templates table")
            
        cursor.execute("SHOW COLUMNS FROM template_columns LIKE 'is_selected'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE template_columns ADD COLUMN is_selected BOOLEAN DEFAULT FALSE")
            logging.info("Added is_selected column to template_columns table")
            
        conn.commit()
        cursor.close()
        logging.info("Database tables initialized")
    except Exception as e:
        logging.error(f"Failed to initialize database: {str(e)}")
        raise

def create_admin_user():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        admin_password = bcrypt.hashpw('admin'.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
        cursor.execute("""
            INSERT IGNORE INTO login_details (first_name, last_name, email, mobile, password)
            VALUES (%s, %s, %s, %s, %s)
        """, ('Admin', 'User', 'admin@example.com', '1234567890', admin_password))
        conn.commit()
        cursor.close()
        logging.info("Admin user created or already exists")
    except Exception as e:
        logging.error(f"Failed to create admin user: {str(e)}")
        raise

def create_default_validation_rules():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        default_rules = [
            ("Required", "Ensures the field is not null", '{"allow_null": false}', None, None, None),
            ("Int", "Validates integer format", '{"format": "integer"}', None, None, "Int"),
            ("Float", "Validates number format (integer or decimal)", '{"format": "float"}', None, None, "Float"),
            ("Text", "Allows text with quotes and parentheses", '{"allow_special": false}', None, None, "Text"),
            ("Email", "Validates email format", '{"regex": "^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\\\.[a-zA-Z0-9-.]+$"}', None, None, "Email"),
            ("Date(DD-MM-YYYY)", "Validates date format DD-MM-YYYY", '{"format": "%d-%m-%Y"}', "DD-MM-YYYY", None, "Date"),
            ("Boolean", "Validates boolean format (true/false or 0/1)", '{"format": "boolean"}', None, None, "Boolean"),
            ("Alphanumeric", "Validates alphanumeric format", '{"format": "alphanumeric"}', None, None, "Alphanumeric")
        ]
        cursor.executemany("""
            INSERT IGNORE INTO validation_rule_types (rule_name, description, parameters, is_custom, source_format, target_format, data_type)
            VALUES (%s, %s, %s, %s, %s, %s, %s)
        """, [(name, desc, params, False, source, target, dtype) for name, desc, params, source, target, dtype in default_rules])
        conn.commit()
        cursor.close()
        logging.info("Default validation rules ensured successfully")
    except Exception as e:
        logging.error(f"Failed to ensure default validation rules: {str(e)}")
        raise

if __name__ == '__main__':
    try:
        # Create the application using factory pattern
        app = create_app()
        
        # Initialize database and default data within app context
        with app.app_context():
            initialize_app_data()
        
        # Get port from environment or use default
        port = int(os.getenv('PORT', 5000))
        
        # Start the application server
        logging.info("Starting Flask server...")
        app.run(debug=True, host='0.0.0.0', port=port)
        
    except Exception as e:
        logging.error(f"Failed to start application: {e}")
        raise
).all():
        return "Email"
    
    # Date pattern detection
    try:
        pd.to_datetime(non_null, format="%d-%m-%Y")
        return "Date"
    except Exception:
        try:
            pd.to_datetime(non_null, format="%Y-%m-%d")
            return "Date"
        except Exception:
            pass
    
    # Boolean detection
    if non_null.str.lower().isin(['true', 'false', '0', '1']).all():
        return "Boolean"
    
    # Numeric detection
    if non_null.str.match(r'^-?\d+

def create_app():
    """Application factory pattern for different environments"""
    # Set the path to the frontend dist folder
    current_dir = os.path.dirname(os.path.abspath(__file__))
    frontend_dist_path = os.path.join(current_dir, '..', '..', 'Keansa-Ai-Suite2025may-frontend11', 'dist')
    frontend_dist_path = os.path.abspath(frontend_dist_path)
    
    # Create Flask application instance
    app = Flask(__name__, static_folder=frontend_dist_path, static_url_path='')
    CORS(app, supports_credentials=True, origins=["http://localhost:3000", "http://localhost:8080", "http://localhost:5000", "*"])

    app.secret_key = os.urandom(24).hex()
    app.config['SESSION_TYPE'] = 'filesystem'
    app.config['SESSION_FILE_DIR'] = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'sessions')
    app.config['SESSION_COOKIE_SAMESITE'] = 'Lax'
    app.config['SESSION_COOKIE_HTTPONLY'] = True
    app.config['SESSION_COOKIE_SECURE'] = False
    app.config['PERMANENT_SESSION_LIFETIME'] = 86400  # 24 hours
    app.config['UPLOAD_FOLDER'] = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'uploads')
    Session(app)

    # Ensure directories exist
    try:
        os.makedirs(app.config['UPLOAD_FOLDER'], exist_ok=True)
        os.makedirs(app.config['SESSION_FILE_DIR'], exist_ok=True)
    except OSError as e:
        logging.error(f"Failed to create directories: {e}")

    # Register cleanup handlers
    app.teardown_appcontext(close_db)
    
    # Register all routes directly in create_app
    
    # Static file serving for React frontend
    @app.route('/', defaults={'path': ''})
    @app.route('/<path:path>')
    def serve(path):
        if path and os.path.exists(os.path.join(app.static_folder, path)):
            return app.send_static_file(path)
        return app.send_static_file('index.html')

    # Health check endpoint
    @app.route('/health', methods=['GET'])
    def health_check():
        return jsonify({
            'status': 'healthy',
            'timestamp': datetime.now().isoformat(),
            'version': '2.0.0'
        })

    # Authentication endpoint - both old and new paths
    @app.route('/authenticate', methods=['POST'])
    @app.route('/api/auth/authenticate', methods=['POST'])
    def authenticate():
        try:
            email = request.form.get('username') or request.form.get('email')
            password = request.form.get('password')
            logging.debug(f"Login attempt: email={email}, password={'*' * len(password) if password else 'None'}")
            
            if not email or not password:
                logging.warning(f"Login failed: Email or password missing")
                return jsonify({'success': False, 'message': 'Email and password are required'}), 400

            # Check for admin login
            if email == "admin" and password == "admin":
                session['loggedin'] = True
                session['user_email'] = "admin@example.com"
                session['user_id'] = 1
                session.permanent = True
                logging.info(f"Admin login successful. Session: {dict(session)}")
                return jsonify({'success': True, 'message': 'Login successful', 'user': {'email': 'admin@example.com', 'id': 1}}), 200

            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("SELECT * FROM login_details WHERE LOWER(email) = LOWER(%s)", (email.lower(),))
            account = cursor.fetchone()
            cursor.close()
            
            if account:
                if bcrypt.checkpw(password.encode('utf-8'), account['password'].encode('utf-8')):
                    session['loggedin'] = True
                    session['user_email'] = account['email']
                    session['user_id'] = account['id']
                    session.permanent = True
                    logging.info(f"User {email} logged in successfully. Session: {dict(session)}")
                    return jsonify({
                        'success': True,
                        'message': 'Login successful',
                        'user': {'email': account['email'], 'id': account['id']}
                    }), 200
                else:
                    logging.warning(f"Invalid password for {email}")
                    return jsonify({'success': False, 'message': 'Invalid credentials'}), 401
            else:
                logging.warning(f"Email {email} not found")
                return jsonify({'success': False, 'message': 'Invalid credentials'}), 401
        except Exception as e:
            logging.error(f"Unexpected error during login: {str(e)}")
            return jsonify({'success': False, 'message': f'Unexpected error: {str(e)}'}), 500

    @app.route('/check-auth', methods=['GET'])
    @app.route('/api/auth/check-auth', methods=['GET'])
    def check_auth():
        try:
            logging.debug(f"Checking auth with session: {dict(session)}")
            if 'loggedin' in session and 'user_id' in session:
                conn = get_db_connection()
                cursor = conn.cursor(dictionary=True)
                cursor.execute("SELECT email, first_name FROM login_details WHERE id = %s", (session['user_id'],))
                user = cursor.fetchone()
                cursor.close()
                if user:
                    logging.info(f"User {session.get('user_email')} is authenticated")
                    return jsonify({
                        'success': True,
                        'user': {
                            'email': user['email'],
                            'id': session['user_id'],
                            'first_name': user['first_name']
                        }
                    })
                else:
                    logging.warning("User not found in database")  
                    session.clear()
                    return jsonify({'success': False, 'message': 'User not found'}), 401
            logging.warning("User not authenticated")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        except Exception as e:
            logging.error(f"Error in check-auth endpoint: {str(e)}")
            return jsonify({'success': False, 'message': f'Server error: {str(e)}'}), 500

    @app.route('/register', methods=['POST'])
    @app.route('/api/auth/register', methods=['POST'])
    def register():
        first_name = request.form.get('first_name')
        last_name = request.form.get('last_name')
        email = request.form.get('email')
        mobile = request.form.get('mobile')
        password = request.form.get('password')
        confirm_password = request.form.get('confirm_password')

        if not all([first_name, last_name, email, mobile, password, confirm_password]):
            return jsonify({'success': False, 'message': 'All fields are required'}), 400
        if password != confirm_password:
            return jsonify({'success': False, 'message': 'Passwords do not match'}), 400

        hashed_password = bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
        try:
            conn = get_db_connection()
            cursor = conn.cursor()
            cursor.execute("""
                INSERT INTO login_details (first_name, last_name, email, mobile, password)
                VALUES (%s, %s, %s, %s, %s)
            """, (first_name, last_name, email, mobile, hashed_password))
            user_id = cursor.lastrowid
            conn.commit()
            cursor.close()
            session['loggedin'] = True
            session['user_email'] = email
            session['user_id'] = user_id
            return jsonify({
                'success': True,
                'message': 'Registration successful',
                'user': {'email': email, 'id': user_id}
            }), 200
        except mysql.connector.Error as e:
            logging.error(f"Database error during registration: {str(e)}")
            return jsonify({'success': False, 'message': f'Registration error: {str(e)}'}), 500

    @app.route('/logout', methods=['POST'])
    @app.route('/api/auth/logout', methods=['POST'])
    def logout():
        logging.info(f"User {session.get('user_email', 'unknown')} logged out")
        session.clear()
        return jsonify({'success': True, 'message': 'Logged out successfully'})

    # Template routes
    @app.route('/templates', methods=['GET'])
    @app.route('/api/templates', methods=['GET'])
    def get_templates():
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /templates: session missing")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("""
                SELECT template_id, template_name, created_at, status
                FROM excel_templates
                WHERE user_id = %s AND status = 'ACTIVE'
                ORDER BY created_at DESC
                LIMIT 100
            """, (session['user_id'],))
            templates = cursor.fetchall()
            cursor.close()
            logging.info(f"Fetched {len(templates)} templates for user {session['user_id']}")
            return jsonify({'success': True, 'templates': templates})
        except mysql.connector.Error as e:
            logging.error(f'Error fetching templates: {str(e)}')
            return jsonify({'success': False, 'message': f'Error fetching templates: {str(e)}'}), 500
        except Exception as e:
            logging.error(f'Unexpected error fetching templates: {str(e)}')
            return jsonify({'success': False, 'message': f'Unexpected error: {str(e)}'}), 500

    # Rule Configuration routes
    @app.route('/rule-configurations', methods=['GET'])
    @app.route('/api/validation/rule-configurations', methods=['GET'])
    def get_rule_configurations():
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning(f"Unauthorized access to /rule-configurations: session={dict(session)}")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            user_id = session['user_id']
            logging.debug(f"Fetching rule configurations for user_id: {user_id}")

            # Main query to fetch templates with configured rules
            cursor.execute("""
                SELECT 
                    t.template_id, 
                    t.template_name, 
                    t.created_at, 
                    COUNT(cvr.column_validation_id) as rule_count
                FROM excel_templates t
                LEFT JOIN template_columns tc ON t.template_id = tc.template_id
                LEFT JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                WHERE t.user_id = %s AND t.status = 'ACTIVE' AND t.is_corrected = FALSE
                GROUP BY t.template_id, t.template_name, t.created_at
                HAVING rule_count > 0
                ORDER BY t.created_at DESC
                LIMIT 100
            """, (user_id,))
            templates = cursor.fetchall()
            logging.debug(f"Fetched rule-configured templates: {templates}")

            cursor.close()

            if not templates:
                logging.info(f"No templates with rules found for user_id: {user_id}")
            else:
                logging.info(f"Found {len(templates)} templates with rules for user_id: {user_id}")

            return jsonify({'success': True, 'templates': templates})
        except mysql.connector.Error as e:
            logging.error(f"Database error fetching rule configurations: {str(e)}")
            return jsonify({'success': False, 'message': f"Database error: {str(e)}"}), 500
        except Exception as e:
            logging.error(f"Unexpected error fetching rule configurations: {str(e)}")
            return jsonify({'success': False, 'message': f"Unexpected error: {str(e)}"}), 500

    # File upload route
    @app.route('/upload', methods=['POST'])
    @app.route('/api/templates/upload', methods=['POST'])
    @app.route('/api/upload', methods=['POST'])  # Additional common path
    def upload():
        logging.info(f"Upload endpoint called: {request.endpoint}, method: {request.method}")
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /upload: session missing")
            return jsonify({'error': 'Not logged in'}), 401
        if 'file' not in request.files:
            logging.warning("No file provided in upload request")
            return jsonify({'error': 'No file uploaded'}), 400
        file = request.files['file']
        if file.filename == '':
            logging.warning("No file selected in upload request")
            return jsonify({'error': 'No file selected'}), 400
        
        file_path = os.path.join(app.config['UPLOAD_FOLDER'], file.filename)
        try:
            file.save(file_path)
            logging.info(f"File saved: {file_path}")
        except Exception as e:
            logging.error(f"Failed to save file {file.filename}: {str(e)}")
            return jsonify({'error': f'Failed to save file: {str(e)}'}), 500

        try:
            # Read the file to get sheets and headers
            if file.filename.endswith('.xlsx') or file.filename.endswith('.xls'):
                xl = pd.ExcelFile(file_path)
                sheets = {sheet_name: pd.read_excel(file_path, sheet_name=sheet_name, header=None) 
                         for sheet_name in xl.sheet_names}
            elif file.filename.endswith(('.txt', '.csv', '.dat')):
                df = pd.read_csv(file_path, header=None, encoding='utf-8')
                sheets = {'Sheet1': df}
            else:
                logging.error("Unsupported file type")
                return jsonify({'error': 'Unsupported file type'}), 400
            
            logging.debug(f"Sheets extracted: {list(sheets.keys())}")
        except Exception as e:
            logging.error(f"Failed to read file {file_path}: {str(e)}")
            return jsonify({'error': f'Failed to read file: {str(e)}'}), 400

        try:
            sheet_names = list(sheets.keys())
            if not sheet_names:
                logging.error("No sheets found in the file")
                return jsonify({'error': 'No sheets found in the file'}), 400
            sheet_name = sheet_names[0]
            df = sheets[sheet_name]
            
            # Find header row
            header_row = 0
            for i in range(min(len(df), 10)):
                row = df.iloc[i].dropna()
                if not row.empty and all(isinstance(x, str) for x in row if pd.notna(x)):
                    header_row = i
                    break
                    
            headers = df.iloc[header_row].tolist()
            logging.debug(f"Headers extracted: {headers}")
            
            if not headers or all(not h for h in headers):
                logging.error("No valid headers found in file")
                return jsonify({'error': 'No valid headers found in the file'}), 400
        except Exception as e:
            logging.error(f"Error processing file {file.filename}: {str(e)}")
            return jsonify({'error': f'Error processing file: {str(e)}'}), 400

        # Clear existing session data
        for key in ['df', 'header_row', 'headers', 'sheet_name', 'current_step', 'selected_headers', 'validations', 'error_cell_locations', 'data_rows', 'corrected_file_path']:
            session.pop(key, None)

        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)

            # Check if template exists
            cursor.execute("""
                SELECT template_id, headers, sheet_name
                FROM excel_templates
                WHERE template_name = %s AND user_id = %s AND status = 'ACTIVE'
                ORDER BY created_at DESC
            """, (file.filename, session['user_id']))
            existing_templates = cursor.fetchall()
            logging.info(f"Found {len(existing_templates)} existing templates with name {file.filename}")

            template_id = None
            has_existing_rules = False
            validations = {}
            selected_headers = []

            # Check for matching template
            matching_template = None
            for template in existing_templates:
                stored_headers = json.loads(template['headers']) if template['headers'] else []
                stored_sheet_name = template['sheet_name']
                if stored_headers == headers and stored_sheet_name == sheet_name:
                    matching_template = template
                    break

            if matching_template:
                template_id = matching_template['template_id']
                # Check for existing rules
                cursor.execute("""
                    SELECT tc.column_name, vrt.rule_name
                    FROM template_columns tc
                    JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                    JOIN validation_rule_types vrt ON cvr.rule_type_id = vrt.rule_type_id
                    WHERE tc.template_id = %s AND tc.is_selected = TRUE
                """, (template_id,))
                rules_data = cursor.fetchall()
                for row in rules_data:
                    column_name = row['column_name']
                    rule_name = row['rule_name']
                    if column_name not in validations:
                        validations[column_name] = []
                    validations[column_name].append(rule_name)
                    if column_name not in selected_headers:
                        selected_headers.append(column_name)
                has_existing_rules = len(validations) > 0
            else:
                # New template
                cursor.execute("""
                    INSERT INTO excel_templates (template_name, user_id, sheet_name, headers, is_corrected)
                    VALUES (%s, %s, %s, %s, %s)
                """, (file.filename, session['user_id'], sheet_name, json.dumps(headers), False))
                template_id = cursor.lastrowid
                column_data = [(template_id, header, i + 1, False) for i, header in enumerate(headers)]
                cursor.executemany("""
                    INSERT INTO template_columns (template_id, column_name, column_position, is_selected)
                    VALUES (%s, %s, %s, %s)
                """, column_data)

            conn.commit()
            cursor.close()

            # Store session data
            session['file_path'] = file_path
            session['template_id'] = template_id
            session['df'] = df.to_json()
            session['header_row'] = header_row
            session['headers'] = headers
            session['sheet_name'] = sheet_name
            session['current_step'] = 1 if not has_existing_rules else 3
            session['validations'] = validations
            session['selected_headers'] = selected_headers
            session['has_existing_rules'] = has_existing_rules

            logging.info(f"Upload processed: template_id={template_id}, filename={file.filename}, has_existing_rules={has_existing_rules}")

            return jsonify({
                'success': True,
                'sheets': {sheet_name: {'headers': headers}},
                'file_name': file.filename,
                'template_id': template_id,
                'has_existing_rules': has_existing_rules,
                'sheet_name': sheet_name,
                'skip_to_step_3': has_existing_rules
            })
        except mysql.connector.Error as e:
            logging.error(f'Error saving template: {str(e)}')
            return jsonify({'error': f'Error saving template: {str(e)}'}), 500
        except Exception as e:
            logging.error(f'Unexpected error saving template: {str(e)}')
            return jsonify({'error': f'Unexpected error: {str(e)}'}), 500

    # Multi-step workflow endpoints
    @app.route('/step/1', methods=['GET', 'POST'])
    @app.route('/api/step/1', methods=['GET', 'POST'])
    def step_one():
        if 'loggedin' not in session:
            return jsonify({'error': 'Not logged in'}), 401
        
        if request.method == 'POST':
            try:
                headers = request.form.getlist('headers')
                new_header_row = request.form.get('new_header_row')
                logging.debug(f"Step 1 submitted: headers={headers}, new_header_row={new_header_row}")
                
                if not headers:
                    logging.error("No headers provided in step 1")
                    return jsonify({'success': False, 'message': 'No headers provided'}), 400
                    
                if 'template_id' not in session:
                    logging.error("Session missing template_id")
                    return jsonify({'success': False, 'message': 'Session data missing'}), 400

                template_id = session['template_id']
                
                # Get the dataframe from session for auto-detection
                df_json = session.get('df')
                if df_json:
                    df = pd.read_json(StringIO(df_json))
                    session_headers = session.get('headers', [])
                    df.columns = session_headers
                    header_row = session.get('header_row', 0)
                    df = df.iloc[header_row + 1:].reset_index(drop=True)
                    
                    # Auto-detect rules for selected headers
                    validations = assign_default_rules_to_columns(df, headers)
                    session['validations'] = validations
                    logging.debug(f"Auto-assigned rules: {validations}")
                else:
                    validations = {}

                session['selected_headers'] = headers
                session['current_step'] = 2

                # Mark selected headers in the database
                conn = get_db_connection()
                cursor = conn.cursor()
                cursor.execute("UPDATE template_columns SET is_selected = FALSE WHERE template_id = %s", (template_id,))
                for header in headers:
                    cursor.execute("""
                        UPDATE template_columns
                        SET is_selected = TRUE
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    
                    # Get column_id and add auto-detected rules
                    cursor.execute("""
                        SELECT column_id FROM template_columns
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    result = cursor.fetchone()
                    if result:
                        column_id = result[0]
                        for rule_name in validations.get(header, []):
                            cursor.execute("""
                                SELECT rule_type_id FROM validation_rule_types
                                WHERE rule_name = %s AND is_custom = FALSE
                            """, (rule_name,))
                            rule_result = cursor.fetchone()
                            if rule_result:
                                rule_type_id = rule_result[0]
                                cursor.execute("""
                                    INSERT IGNORE INTO column_validation_rules (column_id, rule_type_id, rule_config)
                                    VALUES (%s, %s, %s)
                                """, (column_id, rule_type_id, '{}'))
                
                conn.commit()
                cursor.close()

                logging.info(f"Step 1 completed: headers={headers}, auto-assigned rules={validations}")
                return jsonify({'success': True, 'headers': headers, 'validations': validations})
            except Exception as e:
                logging.error(f"Error in step 1: {str(e)}")
                return jsonify({'success': False, 'message': str(e)}), 500
        
        # GET request - return current headers
        headers = session.get('headers', [])
        return jsonify({'headers': headers})

    @app.route('/step/2', methods=['GET', 'POST'])
    @app.route('/api/step/2', methods=['GET', 'POST'])
    def step_two():
        if 'loggedin' not in session:
            return jsonify({'error': 'Not logged in'}), 401
            
        if request.method == 'POST':
            try:
                action = request.form.get('action', 'save')
                validations = {}
                for key, values in request.form.lists():
                    if key.startswith('validations_'):
                        header = key.replace('validations_', '')
                        validations[header] = values
                        
                logging.debug(f"Step 2 submitted: action={action}, validations={validations}")
                
                template_id = session.get('template_id')
                if not template_id:
                    return jsonify({'success': False, 'message': 'Session data missing'}), 400

                # Save validations to database
                conn = get_db_connection()
                cursor = conn.cursor()
                
                # Clear existing rules
                cursor.execute("""
                    DELETE FROM column_validation_rules
                    WHERE column_id IN (
                        SELECT column_id FROM template_columns WHERE template_id = %s
                    )
                """, (template_id,))
                
                # Add new rules
                for header, rules in validations.items():
                    cursor.execute("""
                        SELECT column_id FROM template_columns
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    result = cursor.fetchone()
                    if not result:
                        continue
                    column_id = result[0]
                    
                    for rule_name in rules:
                        cursor.execute("""
                            SELECT rule_type_id FROM validation_rule_types
                            WHERE rule_name = %s
                        """, (rule_name,))
                        result = cursor.fetchone()
                        if result:
                            rule_type_id = result[0]
                            cursor.execute("""
                                INSERT IGNORE INTO column_validation_rules (column_id, rule_type_id, rule_config)
                                VALUES (%s, %s, %s)
                            """, (column_id, rule_type_id, '{}'))
                
                conn.commit()
                cursor.close()

                session['validations'] = validations
                session['current_step'] = 3 if action == 'review' else 2
                
                logging.info(f"Step 2 completed: action={action}, validations={validations}")
                return jsonify({'success': True, 'message': 'Step 2 completed successfully'})
            except Exception as e:
                logging.error(f"Error in step 2: {str(e)}")
                return jsonify({'success': False, 'message': str(e)}), 500
        
        # GET request
        selected_headers = session.get('selected_headers', [])
        return jsonify({'selected_headers': selected_headers})

    # Rules endpoint
    @app.route('/rules', methods=['GET'])
    @app.route('/api/rules', methods=['GET'])
    def get_rules():
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            
            cursor.execute("""
                SELECT rule_type_id AS rule_id, rule_name, description, parameters, is_custom, 
                       column_name, template_id, source_format, target_format, data_type, is_active
                FROM validation_rule_types
            """)
            rules = cursor.fetchall()
            cursor.close()
            
            logging.info(f"Returning {len(rules)} rules from getRules endpoint")
            return jsonify({'success': True, 'rules': rules})
        except mysql.connector.Error as e:
            logging.error(f"Database error fetching rules: {str(e)}")
            return jsonify({'success': False, 'message': str(e)}), 500
        except Exception as e:
            logging.error(f"Unexpected error fetching rules: {str(e)}")
            return jsonify({'success': False, 'message': str(e)}), 500

    # Template details endpoint
    @app.route('/template/<int:template_id>/<sheet_name>', methods=['GET'])
    @app.route('/api/template/<int:template_id>/<sheet_name>', methods=['GET'])
    def get_template(template_id, sheet_name):
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /template: session missing")
            return jsonify({'error': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("""
                SELECT template_name, sheet_name, headers
                FROM excel_templates
                WHERE template_id = %s AND user_id = %s AND status = 'ACTIVE'
            """, (template_id, session['user_id']))
            template_record = cursor.fetchone()
            
            if not template_record:
                logging.error(f"Template not found for template_id: {template_id}, user_id: {session['user_id']}")
                cursor.close()
                return jsonify({'error': 'Template not found'}), 404

            headers = json.loads(template_record['headers']) if template_record['headers'] else []
            stored_sheet_name = template_record['sheet_name'] or sheet_name
            file_path = os.path.join(app.config['UPLOAD_FOLDER'], template_record['template_name'])
            
            cursor.execute("""
                SELECT COUNT(*) as rule_count
                FROM template_columns tc
                JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                WHERE tc.template_id = %s AND tc.is_selected = TRUE
            """, (template_id,))
            rule_count = cursor.fetchone()['rule_count']
            has_existing_rules = rule_count > 0
            
            cursor.close()
            
            return jsonify({
                'success': True,
                'sheets': {stored_sheet_name: {'headers': headers}},
                'file_name': template_record['template_name'],
                'file_path': file_path,
                'sheet_name': stored_sheet_name,
                'has_existing_rules': has_existing_rules
            })
        except mysql.connector.Error as e:
            logging.error(f"Database error in get_template: {str(e)}")
            return jsonify({'error': f'Database error: {str(e)}'}), 500
        except Exception as e:
            logging.error(f"Unexpected error in get_template: {str(e)}")
            return jsonify({'error': f'Unexpected error: {str(e)}'}), 500

    # Debug route to show all registered routes
    @app.route('/debug/routes', methods=['GET'])
    def list_routes():
        routes = []
        for rule in app.url_map.iter_rules():
            routes.append({
                'endpoint': rule.endpoint,
                'methods': list(rule.methods),
                'rule': rule.rule
            })
        return jsonify(routes)

    # 404 handler to debug missing routes
    @app.errorhandler(404)
    def not_found_handler(error):
        logging.error(f"404 Error: {request.method} {request.url} not found")
        logging.error(f"Available routes: {[rule.rule for rule in app.url_map.iter_rules()]}")
        return jsonify({
            'error': 'Endpoint not found', 
            'method': request.method,
            'url': request.url,
            'path': request.path
        }), 404

    return app

def initialize_app_data():
    """Initialize database and create default data"""
    try:
        logging.info("Initializing database schema...")
        init_db()
        
        logging.info("Creating admin user...")
        create_admin_user()
        
        logging.info("Creating default validation rules...")
        create_default_validation_rules()
        
        logging.info("Application initialization completed successfully")
    except Exception as e:
        logging.error(f"Failed to initialize application: {e}")
        raise

DB_CONFIG = {
    'host': os.getenv('MYSQL_HOST', 'localhost'),
    'user': os.getenv('MYSQL_USER', 'root'),
    'password': os.getenv('MYSQL_PASSWORD', 'Keansa@2024'),
    'database': os.getenv('MYSQL_DATABASE', 'data_validation_2'),
}

def get_db_connection():
    if 'db' not in g:
        try:
            conn = mysql.connector.connect(
                host=DB_CONFIG['host'],
                user=DB_CONFIG['user'],
                password=DB_CONFIG['password']
            )
            cursor = conn.cursor()
            cursor.execute(f"CREATE DATABASE IF NOT EXISTS {DB_CONFIG['database']}")
            cursor.close()
            conn.close()
            g.db = mysql.connector.connect(**DB_CONFIG)
            logging.info("Database connection established successfully")
        except mysql.connector.Error as err:
            if err.errno == errorcode.ER_ACCESS_DENIED_ERROR:
                logging.error("Database connection failed: Access denied for user - check username/password")
            elif err.errno == errorcode.ER_BAD_DB_ERROR:
                logging.error("Database connection failed: Database does not exist")
            else:
                logging.error(f"Database connection failed: {err}")
            raise Exception(f"Failed to connect to database: {str(err)}")
    return g.db

def close_db(error):
    db = g.pop('db', None)
    if db is not None:
        db.close()

def init_db():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        tables = [
            """
            CREATE TABLE IF NOT EXISTS login_details (
                id INT AUTO_INCREMENT PRIMARY KEY,
                first_name VARCHAR(100),
                last_name VARCHAR(100),
                email VARCHAR(255) UNIQUE,
                mobile VARCHAR(10),
                password VARCHAR(255)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS excel_templates (
                template_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_name VARCHAR(255) NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
                user_id INT NOT NULL,
                sheet_name VARCHAR(255),
                headers JSON,
                status ENUM('ACTIVE', 'INACTIVE') DEFAULT 'ACTIVE',
                is_corrected BOOLEAN DEFAULT FALSE,
                remote_file_path VARCHAR(512),
                FOREIGN KEY (user_id) REFERENCES login_details(id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS template_columns (
                column_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_id BIGINT NOT NULL,
                column_name VARCHAR(255) NOT NULL,
                column_position INT NOT NULL,
                is_validation_enabled BOOLEAN DEFAULT FALSE,
                is_selected BOOLEAN DEFAULT FALSE,
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE,
                UNIQUE (template_id, column_name)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_rule_types (
                rule_type_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                rule_name VARCHAR(255) NOT NULL,
                description TEXT,
                parameters TEXT,
                is_active BOOLEAN DEFAULT TRUE,
                is_custom BOOLEAN DEFAULT FALSE,
                column_name VARCHAR(255),
                template_id BIGINT,
                data_type VARCHAR(50),
                source_format VARCHAR(50),
                target_format VARCHAR(50),
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS column_validation_rules (
                column_validation_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                column_id BIGINT NOT NULL,
                rule_type_id BIGINT NOT NULL,
                rule_config JSON,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (column_id) REFERENCES template_columns(column_id) ON DELETE CASCADE,
                FOREIGN KEY (rule_type_id) REFERENCES validation_rule_types(rule_type_id) ON DELETE RESTRICT,
                UNIQUE (column_id, rule_type_id)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_history (
                history_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_id BIGINT NOT NULL,
                template_name VARCHAR(255) NOT NULL,
                error_count INT NOT NULL,
                corrected_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                corrected_file_path VARCHAR(512) NOT NULL,
                user_id INT NOT NULL,
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE,
                FOREIGN KEY (user_id) REFERENCES login_details(id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_corrections (
                correction_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                history_id BIGINT NOT NULL,
                row_index INT NOT NULL,
                column_name VARCHAR(255) NOT NULL,
                original_value TEXT,
                corrected_value TEXT,
                rule_failed VARCHAR(255) DEFAULT NULL,
                FOREIGN KEY (history_id) REFERENCES validation_history(history_id) ON DELETE CASCADE
            )
            """
        ]
        for table_sql in tables:
            cursor.execute(table_sql)
        
        # Add missing columns if they don't exist
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'source_format'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN source_format VARCHAR(50)")
            logging.info("Added source_format column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'target_format'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN target_format VARCHAR(50)")
            logging.info("Added target_format column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'data_type'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN data_type VARCHAR(50)")
            logging.info("Added data_type column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM excel_templates LIKE 'remote_file_path'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE excel_templates ADD COLUMN remote_file_path VARCHAR(512)")
            logging.info("Added remote_file_path column to excel_templates table")
            
        cursor.execute("SHOW COLUMNS FROM template_columns LIKE 'is_selected'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE template_columns ADD COLUMN is_selected BOOLEAN DEFAULT FALSE")
            logging.info("Added is_selected column to template_columns table")
            
        conn.commit()
        cursor.close()
        logging.info("Database tables initialized")
    except Exception as e:
        logging.error(f"Failed to initialize database: {str(e)}")
        raise

def create_admin_user():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        admin_password = bcrypt.hashpw('admin'.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
        cursor.execute("""
            INSERT IGNORE INTO login_details (first_name, last_name, email, mobile, password)
            VALUES (%s, %s, %s, %s, %s)
        """, ('Admin', 'User', 'admin@example.com', '1234567890', admin_password))
        conn.commit()
        cursor.close()
        logging.info("Admin user created or already exists")
    except Exception as e:
        logging.error(f"Failed to create admin user: {str(e)}")
        raise

def create_default_validation_rules():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        default_rules = [
            ("Required", "Ensures the field is not null", '{"allow_null": false}', None, None, None),
            ("Int", "Validates integer format", '{"format": "integer"}', None, None, "Int"),
            ("Float", "Validates number format (integer or decimal)", '{"format": "float"}', None, None, "Float"),
            ("Text", "Allows text with quotes and parentheses", '{"allow_special": false}', None, None, "Text"),
            ("Email", "Validates email format", '{"regex": "^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\\\.[a-zA-Z0-9-.]+$"}', None, None, "Email"),
            ("Date(DD-MM-YYYY)", "Validates date format DD-MM-YYYY", '{"format": "%d-%m-%Y"}', "DD-MM-YYYY", None, "Date"),
            ("Boolean", "Validates boolean format (true/false or 0/1)", '{"format": "boolean"}', None, None, "Boolean"),
            ("Alphanumeric", "Validates alphanumeric format", '{"format": "alphanumeric"}', None, None, "Alphanumeric")
        ]
        cursor.executemany("""
            INSERT IGNORE INTO validation_rule_types (rule_name, description, parameters, is_custom, source_format, target_format, data_type)
            VALUES (%s, %s, %s, %s, %s, %s, %s)
        """, [(name, desc, params, False, source, target, dtype) for name, desc, params, source, target, dtype in default_rules])
        conn.commit()
        cursor.close()
        logging.info("Default validation rules ensured successfully")
    except Exception as e:
        logging.error(f"Failed to ensure default validation rules: {str(e)}")
        raise

if __name__ == '__main__':
    try:
        # Create the application using factory pattern
        app = create_app()
        
        # Initialize database and default data within app context
        with app.app_context():
            initialize_app_data()
        
        # Get port from environment or use default
        port = int(os.getenv('PORT', 5000))
        
        # Start the application server
        logging.info("Starting Flask server...")
        app.run(debug=True, host='0.0.0.0', port=port)
        
    except Exception as e:
        logging.error(f"Failed to start application: {e}")
        raise
).all():
        return "Int"
    
    if non_null.str.match(r'^-?\d+(\.\d+)?

def create_app():
    """Application factory pattern for different environments"""
    # Set the path to the frontend dist folder
    current_dir = os.path.dirname(os.path.abspath(__file__))
    frontend_dist_path = os.path.join(current_dir, '..', '..', 'Keansa-Ai-Suite2025may-frontend11', 'dist')
    frontend_dist_path = os.path.abspath(frontend_dist_path)
    
    # Create Flask application instance
    app = Flask(__name__, static_folder=frontend_dist_path, static_url_path='')
    CORS(app, supports_credentials=True, origins=["http://localhost:3000", "http://localhost:8080", "http://localhost:5000", "*"])

    app.secret_key = os.urandom(24).hex()
    app.config['SESSION_TYPE'] = 'filesystem'
    app.config['SESSION_FILE_DIR'] = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'sessions')
    app.config['SESSION_COOKIE_SAMESITE'] = 'Lax'
    app.config['SESSION_COOKIE_HTTPONLY'] = True
    app.config['SESSION_COOKIE_SECURE'] = False
    app.config['PERMANENT_SESSION_LIFETIME'] = 86400  # 24 hours
    app.config['UPLOAD_FOLDER'] = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'uploads')
    Session(app)

    # Ensure directories exist
    try:
        os.makedirs(app.config['UPLOAD_FOLDER'], exist_ok=True)
        os.makedirs(app.config['SESSION_FILE_DIR'], exist_ok=True)
    except OSError as e:
        logging.error(f"Failed to create directories: {e}")

    # Register cleanup handlers
    app.teardown_appcontext(close_db)
    
    # Register all routes directly in create_app
    
    # Static file serving for React frontend
    @app.route('/', defaults={'path': ''})
    @app.route('/<path:path>')
    def serve(path):
        if path and os.path.exists(os.path.join(app.static_folder, path)):
            return app.send_static_file(path)
        return app.send_static_file('index.html')

    # Health check endpoint
    @app.route('/health', methods=['GET'])
    def health_check():
        return jsonify({
            'status': 'healthy',
            'timestamp': datetime.now().isoformat(),
            'version': '2.0.0'
        })

    # Authentication endpoint - both old and new paths
    @app.route('/authenticate', methods=['POST'])
    @app.route('/api/auth/authenticate', methods=['POST'])
    def authenticate():
        try:
            email = request.form.get('username') or request.form.get('email')
            password = request.form.get('password')
            logging.debug(f"Login attempt: email={email}, password={'*' * len(password) if password else 'None'}")
            
            if not email or not password:
                logging.warning(f"Login failed: Email or password missing")
                return jsonify({'success': False, 'message': 'Email and password are required'}), 400

            # Check for admin login
            if email == "admin" and password == "admin":
                session['loggedin'] = True
                session['user_email'] = "admin@example.com"
                session['user_id'] = 1
                session.permanent = True
                logging.info(f"Admin login successful. Session: {dict(session)}")
                return jsonify({'success': True, 'message': 'Login successful', 'user': {'email': 'admin@example.com', 'id': 1}}), 200

            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("SELECT * FROM login_details WHERE LOWER(email) = LOWER(%s)", (email.lower(),))
            account = cursor.fetchone()
            cursor.close()
            
            if account:
                if bcrypt.checkpw(password.encode('utf-8'), account['password'].encode('utf-8')):
                    session['loggedin'] = True
                    session['user_email'] = account['email']
                    session['user_id'] = account['id']
                    session.permanent = True
                    logging.info(f"User {email} logged in successfully. Session: {dict(session)}")
                    return jsonify({
                        'success': True,
                        'message': 'Login successful',
                        'user': {'email': account['email'], 'id': account['id']}
                    }), 200
                else:
                    logging.warning(f"Invalid password for {email}")
                    return jsonify({'success': False, 'message': 'Invalid credentials'}), 401
            else:
                logging.warning(f"Email {email} not found")
                return jsonify({'success': False, 'message': 'Invalid credentials'}), 401
        except Exception as e:
            logging.error(f"Unexpected error during login: {str(e)}")
            return jsonify({'success': False, 'message': f'Unexpected error: {str(e)}'}), 500

    @app.route('/check-auth', methods=['GET'])
    @app.route('/api/auth/check-auth', methods=['GET'])
    def check_auth():
        try:
            logging.debug(f"Checking auth with session: {dict(session)}")
            if 'loggedin' in session and 'user_id' in session:
                conn = get_db_connection()
                cursor = conn.cursor(dictionary=True)
                cursor.execute("SELECT email, first_name FROM login_details WHERE id = %s", (session['user_id'],))
                user = cursor.fetchone()
                cursor.close()
                if user:
                    logging.info(f"User {session.get('user_email')} is authenticated")
                    return jsonify({
                        'success': True,
                        'user': {
                            'email': user['email'],
                            'id': session['user_id'],
                            'first_name': user['first_name']
                        }
                    })
                else:
                    logging.warning("User not found in database")  
                    session.clear()
                    return jsonify({'success': False, 'message': 'User not found'}), 401
            logging.warning("User not authenticated")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        except Exception as e:
            logging.error(f"Error in check-auth endpoint: {str(e)}")
            return jsonify({'success': False, 'message': f'Server error: {str(e)}'}), 500

    @app.route('/register', methods=['POST'])
    @app.route('/api/auth/register', methods=['POST'])
    def register():
        first_name = request.form.get('first_name')
        last_name = request.form.get('last_name')
        email = request.form.get('email')
        mobile = request.form.get('mobile')
        password = request.form.get('password')
        confirm_password = request.form.get('confirm_password')

        if not all([first_name, last_name, email, mobile, password, confirm_password]):
            return jsonify({'success': False, 'message': 'All fields are required'}), 400
        if password != confirm_password:
            return jsonify({'success': False, 'message': 'Passwords do not match'}), 400

        hashed_password = bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
        try:
            conn = get_db_connection()
            cursor = conn.cursor()
            cursor.execute("""
                INSERT INTO login_details (first_name, last_name, email, mobile, password)
                VALUES (%s, %s, %s, %s, %s)
            """, (first_name, last_name, email, mobile, hashed_password))
            user_id = cursor.lastrowid
            conn.commit()
            cursor.close()
            session['loggedin'] = True
            session['user_email'] = email
            session['user_id'] = user_id
            return jsonify({
                'success': True,
                'message': 'Registration successful',
                'user': {'email': email, 'id': user_id}
            }), 200
        except mysql.connector.Error as e:
            logging.error(f"Database error during registration: {str(e)}")
            return jsonify({'success': False, 'message': f'Registration error: {str(e)}'}), 500

    @app.route('/logout', methods=['POST'])
    @app.route('/api/auth/logout', methods=['POST'])
    def logout():
        logging.info(f"User {session.get('user_email', 'unknown')} logged out")
        session.clear()
        return jsonify({'success': True, 'message': 'Logged out successfully'})

    # Template routes
    @app.route('/templates', methods=['GET'])
    @app.route('/api/templates', methods=['GET'])
    def get_templates():
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /templates: session missing")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("""
                SELECT template_id, template_name, created_at, status
                FROM excel_templates
                WHERE user_id = %s AND status = 'ACTIVE'
                ORDER BY created_at DESC
                LIMIT 100
            """, (session['user_id'],))
            templates = cursor.fetchall()
            cursor.close()
            logging.info(f"Fetched {len(templates)} templates for user {session['user_id']}")
            return jsonify({'success': True, 'templates': templates})
        except mysql.connector.Error as e:
            logging.error(f'Error fetching templates: {str(e)}')
            return jsonify({'success': False, 'message': f'Error fetching templates: {str(e)}'}), 500
        except Exception as e:
            logging.error(f'Unexpected error fetching templates: {str(e)}')
            return jsonify({'success': False, 'message': f'Unexpected error: {str(e)}'}), 500

    # Rule Configuration routes
    @app.route('/rule-configurations', methods=['GET'])
    @app.route('/api/validation/rule-configurations', methods=['GET'])
    def get_rule_configurations():
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning(f"Unauthorized access to /rule-configurations: session={dict(session)}")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            user_id = session['user_id']
            logging.debug(f"Fetching rule configurations for user_id: {user_id}")

            # Main query to fetch templates with configured rules
            cursor.execute("""
                SELECT 
                    t.template_id, 
                    t.template_name, 
                    t.created_at, 
                    COUNT(cvr.column_validation_id) as rule_count
                FROM excel_templates t
                LEFT JOIN template_columns tc ON t.template_id = tc.template_id
                LEFT JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                WHERE t.user_id = %s AND t.status = 'ACTIVE' AND t.is_corrected = FALSE
                GROUP BY t.template_id, t.template_name, t.created_at
                HAVING rule_count > 0
                ORDER BY t.created_at DESC
                LIMIT 100
            """, (user_id,))
            templates = cursor.fetchall()
            logging.debug(f"Fetched rule-configured templates: {templates}")

            cursor.close()

            if not templates:
                logging.info(f"No templates with rules found for user_id: {user_id}")
            else:
                logging.info(f"Found {len(templates)} templates with rules for user_id: {user_id}")

            return jsonify({'success': True, 'templates': templates})
        except mysql.connector.Error as e:
            logging.error(f"Database error fetching rule configurations: {str(e)}")
            return jsonify({'success': False, 'message': f"Database error: {str(e)}"}), 500
        except Exception as e:
            logging.error(f"Unexpected error fetching rule configurations: {str(e)}")
            return jsonify({'success': False, 'message': f"Unexpected error: {str(e)}"}), 500

    # File upload route
    @app.route('/upload', methods=['POST'])
    @app.route('/api/templates/upload', methods=['POST'])
    @app.route('/api/upload', methods=['POST'])  # Additional common path
    def upload():
        logging.info(f"Upload endpoint called: {request.endpoint}, method: {request.method}")
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /upload: session missing")
            return jsonify({'error': 'Not logged in'}), 401
        if 'file' not in request.files:
            logging.warning("No file provided in upload request")
            return jsonify({'error': 'No file uploaded'}), 400
        file = request.files['file']
        if file.filename == '':
            logging.warning("No file selected in upload request")
            return jsonify({'error': 'No file selected'}), 400
        
        file_path = os.path.join(app.config['UPLOAD_FOLDER'], file.filename)
        try:
            file.save(file_path)
            logging.info(f"File saved: {file_path}")
        except Exception as e:
            logging.error(f"Failed to save file {file.filename}: {str(e)}")
            return jsonify({'error': f'Failed to save file: {str(e)}'}), 500

        try:
            # Read the file to get sheets and headers
            if file.filename.endswith('.xlsx') or file.filename.endswith('.xls'):
                xl = pd.ExcelFile(file_path)
                sheets = {sheet_name: pd.read_excel(file_path, sheet_name=sheet_name, header=None) 
                         for sheet_name in xl.sheet_names}
            elif file.filename.endswith(('.txt', '.csv', '.dat')):
                df = pd.read_csv(file_path, header=None, encoding='utf-8')
                sheets = {'Sheet1': df}
            else:
                logging.error("Unsupported file type")
                return jsonify({'error': 'Unsupported file type'}), 400
            
            logging.debug(f"Sheets extracted: {list(sheets.keys())}")
        except Exception as e:
            logging.error(f"Failed to read file {file_path}: {str(e)}")
            return jsonify({'error': f'Failed to read file: {str(e)}'}), 400

        try:
            sheet_names = list(sheets.keys())
            if not sheet_names:
                logging.error("No sheets found in the file")
                return jsonify({'error': 'No sheets found in the file'}), 400
            sheet_name = sheet_names[0]
            df = sheets[sheet_name]
            
            # Find header row
            header_row = 0
            for i in range(min(len(df), 10)):
                row = df.iloc[i].dropna()
                if not row.empty and all(isinstance(x, str) for x in row if pd.notna(x)):
                    header_row = i
                    break
                    
            headers = df.iloc[header_row].tolist()
            logging.debug(f"Headers extracted: {headers}")
            
            if not headers or all(not h for h in headers):
                logging.error("No valid headers found in file")
                return jsonify({'error': 'No valid headers found in the file'}), 400
        except Exception as e:
            logging.error(f"Error processing file {file.filename}: {str(e)}")
            return jsonify({'error': f'Error processing file: {str(e)}'}), 400

        # Clear existing session data
        for key in ['df', 'header_row', 'headers', 'sheet_name', 'current_step', 'selected_headers', 'validations', 'error_cell_locations', 'data_rows', 'corrected_file_path']:
            session.pop(key, None)

        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)

            # Check if template exists
            cursor.execute("""
                SELECT template_id, headers, sheet_name
                FROM excel_templates
                WHERE template_name = %s AND user_id = %s AND status = 'ACTIVE'
                ORDER BY created_at DESC
            """, (file.filename, session['user_id']))
            existing_templates = cursor.fetchall()
            logging.info(f"Found {len(existing_templates)} existing templates with name {file.filename}")

            template_id = None
            has_existing_rules = False
            validations = {}
            selected_headers = []

            # Check for matching template
            matching_template = None
            for template in existing_templates:
                stored_headers = json.loads(template['headers']) if template['headers'] else []
                stored_sheet_name = template['sheet_name']
                if stored_headers == headers and stored_sheet_name == sheet_name:
                    matching_template = template
                    break

            if matching_template:
                template_id = matching_template['template_id']
                # Check for existing rules
                cursor.execute("""
                    SELECT tc.column_name, vrt.rule_name
                    FROM template_columns tc
                    JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                    JOIN validation_rule_types vrt ON cvr.rule_type_id = vrt.rule_type_id
                    WHERE tc.template_id = %s AND tc.is_selected = TRUE
                """, (template_id,))
                rules_data = cursor.fetchall()
                for row in rules_data:
                    column_name = row['column_name']
                    rule_name = row['rule_name']
                    if column_name not in validations:
                        validations[column_name] = []
                    validations[column_name].append(rule_name)
                    if column_name not in selected_headers:
                        selected_headers.append(column_name)
                has_existing_rules = len(validations) > 0
            else:
                # New template
                cursor.execute("""
                    INSERT INTO excel_templates (template_name, user_id, sheet_name, headers, is_corrected)
                    VALUES (%s, %s, %s, %s, %s)
                """, (file.filename, session['user_id'], sheet_name, json.dumps(headers), False))
                template_id = cursor.lastrowid
                column_data = [(template_id, header, i + 1, False) for i, header in enumerate(headers)]
                cursor.executemany("""
                    INSERT INTO template_columns (template_id, column_name, column_position, is_selected)
                    VALUES (%s, %s, %s, %s)
                """, column_data)

            conn.commit()
            cursor.close()

            # Store session data
            session['file_path'] = file_path
            session['template_id'] = template_id
            session['df'] = df.to_json()
            session['header_row'] = header_row
            session['headers'] = headers
            session['sheet_name'] = sheet_name
            session['current_step'] = 1 if not has_existing_rules else 3
            session['validations'] = validations
            session['selected_headers'] = selected_headers
            session['has_existing_rules'] = has_existing_rules

            logging.info(f"Upload processed: template_id={template_id}, filename={file.filename}, has_existing_rules={has_existing_rules}")

            return jsonify({
                'success': True,
                'sheets': {sheet_name: {'headers': headers}},
                'file_name': file.filename,
                'template_id': template_id,
                'has_existing_rules': has_existing_rules,
                'sheet_name': sheet_name,
                'skip_to_step_3': has_existing_rules
            })
        except mysql.connector.Error as e:
            logging.error(f'Error saving template: {str(e)}')
            return jsonify({'error': f'Error saving template: {str(e)}'}), 500
        except Exception as e:
            logging.error(f'Unexpected error saving template: {str(e)}')
            return jsonify({'error': f'Unexpected error: {str(e)}'}), 500

    # Multi-step workflow endpoints
    @app.route('/step/1', methods=['GET', 'POST'])
    @app.route('/api/step/1', methods=['GET', 'POST'])
    def step_one():
        if 'loggedin' not in session:
            return jsonify({'error': 'Not logged in'}), 401
        
        if request.method == 'POST':
            try:
                headers = request.form.getlist('headers')
                new_header_row = request.form.get('new_header_row')
                logging.debug(f"Step 1 submitted: headers={headers}, new_header_row={new_header_row}")
                
                if not headers:
                    logging.error("No headers provided in step 1")
                    return jsonify({'success': False, 'message': 'No headers provided'}), 400
                    
                if 'template_id' not in session:
                    logging.error("Session missing template_id")
                    return jsonify({'success': False, 'message': 'Session data missing'}), 400

                template_id = session['template_id']
                
                # Get the dataframe from session for auto-detection
                df_json = session.get('df')
                if df_json:
                    df = pd.read_json(StringIO(df_json))
                    session_headers = session.get('headers', [])
                    df.columns = session_headers
                    header_row = session.get('header_row', 0)
                    df = df.iloc[header_row + 1:].reset_index(drop=True)
                    
                    # Auto-detect rules for selected headers
                    validations = assign_default_rules_to_columns(df, headers)
                    session['validations'] = validations
                    logging.debug(f"Auto-assigned rules: {validations}")
                else:
                    validations = {}

                session['selected_headers'] = headers
                session['current_step'] = 2

                # Mark selected headers in the database
                conn = get_db_connection()
                cursor = conn.cursor()
                cursor.execute("UPDATE template_columns SET is_selected = FALSE WHERE template_id = %s", (template_id,))
                for header in headers:
                    cursor.execute("""
                        UPDATE template_columns
                        SET is_selected = TRUE
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    
                    # Get column_id and add auto-detected rules
                    cursor.execute("""
                        SELECT column_id FROM template_columns
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    result = cursor.fetchone()
                    if result:
                        column_id = result[0]
                        for rule_name in validations.get(header, []):
                            cursor.execute("""
                                SELECT rule_type_id FROM validation_rule_types
                                WHERE rule_name = %s AND is_custom = FALSE
                            """, (rule_name,))
                            rule_result = cursor.fetchone()
                            if rule_result:
                                rule_type_id = rule_result[0]
                                cursor.execute("""
                                    INSERT IGNORE INTO column_validation_rules (column_id, rule_type_id, rule_config)
                                    VALUES (%s, %s, %s)
                                """, (column_id, rule_type_id, '{}'))
                
                conn.commit()
                cursor.close()

                logging.info(f"Step 1 completed: headers={headers}, auto-assigned rules={validations}")
                return jsonify({'success': True, 'headers': headers, 'validations': validations})
            except Exception as e:
                logging.error(f"Error in step 1: {str(e)}")
                return jsonify({'success': False, 'message': str(e)}), 500
        
        # GET request - return current headers
        headers = session.get('headers', [])
        return jsonify({'headers': headers})

    @app.route('/step/2', methods=['GET', 'POST'])
    @app.route('/api/step/2', methods=['GET', 'POST'])
    def step_two():
        if 'loggedin' not in session:
            return jsonify({'error': 'Not logged in'}), 401
            
        if request.method == 'POST':
            try:
                action = request.form.get('action', 'save')
                validations = {}
                for key, values in request.form.lists():
                    if key.startswith('validations_'):
                        header = key.replace('validations_', '')
                        validations[header] = values
                        
                logging.debug(f"Step 2 submitted: action={action}, validations={validations}")
                
                template_id = session.get('template_id')
                if not template_id:
                    return jsonify({'success': False, 'message': 'Session data missing'}), 400

                # Save validations to database
                conn = get_db_connection()
                cursor = conn.cursor()
                
                # Clear existing rules
                cursor.execute("""
                    DELETE FROM column_validation_rules
                    WHERE column_id IN (
                        SELECT column_id FROM template_columns WHERE template_id = %s
                    )
                """, (template_id,))
                
                # Add new rules
                for header, rules in validations.items():
                    cursor.execute("""
                        SELECT column_id FROM template_columns
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    result = cursor.fetchone()
                    if not result:
                        continue
                    column_id = result[0]
                    
                    for rule_name in rules:
                        cursor.execute("""
                            SELECT rule_type_id FROM validation_rule_types
                            WHERE rule_name = %s
                        """, (rule_name,))
                        result = cursor.fetchone()
                        if result:
                            rule_type_id = result[0]
                            cursor.execute("""
                                INSERT IGNORE INTO column_validation_rules (column_id, rule_type_id, rule_config)
                                VALUES (%s, %s, %s)
                            """, (column_id, rule_type_id, '{}'))
                
                conn.commit()
                cursor.close()

                session['validations'] = validations
                session['current_step'] = 3 if action == 'review' else 2
                
                logging.info(f"Step 2 completed: action={action}, validations={validations}")
                return jsonify({'success': True, 'message': 'Step 2 completed successfully'})
            except Exception as e:
                logging.error(f"Error in step 2: {str(e)}")
                return jsonify({'success': False, 'message': str(e)}), 500
        
        # GET request
        selected_headers = session.get('selected_headers', [])
        return jsonify({'selected_headers': selected_headers})

    # Rules endpoint
    @app.route('/rules', methods=['GET'])
    @app.route('/api/rules', methods=['GET'])
    def get_rules():
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            
            cursor.execute("""
                SELECT rule_type_id AS rule_id, rule_name, description, parameters, is_custom, 
                       column_name, template_id, source_format, target_format, data_type, is_active
                FROM validation_rule_types
            """)
            rules = cursor.fetchall()
            cursor.close()
            
            logging.info(f"Returning {len(rules)} rules from getRules endpoint")
            return jsonify({'success': True, 'rules': rules})
        except mysql.connector.Error as e:
            logging.error(f"Database error fetching rules: {str(e)}")
            return jsonify({'success': False, 'message': str(e)}), 500
        except Exception as e:
            logging.error(f"Unexpected error fetching rules: {str(e)}")
            return jsonify({'success': False, 'message': str(e)}), 500

    # Template details endpoint
    @app.route('/template/<int:template_id>/<sheet_name>', methods=['GET'])
    @app.route('/api/template/<int:template_id>/<sheet_name>', methods=['GET'])
    def get_template(template_id, sheet_name):
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /template: session missing")
            return jsonify({'error': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("""
                SELECT template_name, sheet_name, headers
                FROM excel_templates
                WHERE template_id = %s AND user_id = %s AND status = 'ACTIVE'
            """, (template_id, session['user_id']))
            template_record = cursor.fetchone()
            
            if not template_record:
                logging.error(f"Template not found for template_id: {template_id}, user_id: {session['user_id']}")
                cursor.close()
                return jsonify({'error': 'Template not found'}), 404

            headers = json.loads(template_record['headers']) if template_record['headers'] else []
            stored_sheet_name = template_record['sheet_name'] or sheet_name
            file_path = os.path.join(app.config['UPLOAD_FOLDER'], template_record['template_name'])
            
            cursor.execute("""
                SELECT COUNT(*) as rule_count
                FROM template_columns tc
                JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                WHERE tc.template_id = %s AND tc.is_selected = TRUE
            """, (template_id,))
            rule_count = cursor.fetchone()['rule_count']
            has_existing_rules = rule_count > 0
            
            cursor.close()
            
            return jsonify({
                'success': True,
                'sheets': {stored_sheet_name: {'headers': headers}},
                'file_name': template_record['template_name'],
                'file_path': file_path,
                'sheet_name': stored_sheet_name,
                'has_existing_rules': has_existing_rules
            })
        except mysql.connector.Error as e:
            logging.error(f"Database error in get_template: {str(e)}")
            return jsonify({'error': f'Database error: {str(e)}'}), 500
        except Exception as e:
            logging.error(f"Unexpected error in get_template: {str(e)}")
            return jsonify({'error': f'Unexpected error: {str(e)}'}), 500

    # Debug route to show all registered routes
    @app.route('/debug/routes', methods=['GET'])
    def list_routes():
        routes = []
        for rule in app.url_map.iter_rules():
            routes.append({
                'endpoint': rule.endpoint,
                'methods': list(rule.methods),
                'rule': rule.rule
            })
        return jsonify(routes)

    # 404 handler to debug missing routes
    @app.errorhandler(404)
    def not_found_handler(error):
        logging.error(f"404 Error: {request.method} {request.url} not found")
        logging.error(f"Available routes: {[rule.rule for rule in app.url_map.iter_rules()]}")
        return jsonify({
            'error': 'Endpoint not found', 
            'method': request.method,
            'url': request.url,
            'path': request.path
        }), 404

    return app

def initialize_app_data():
    """Initialize database and create default data"""
    try:
        logging.info("Initializing database schema...")
        init_db()
        
        logging.info("Creating admin user...")
        create_admin_user()
        
        logging.info("Creating default validation rules...")
        create_default_validation_rules()
        
        logging.info("Application initialization completed successfully")
    except Exception as e:
        logging.error(f"Failed to initialize application: {e}")
        raise

DB_CONFIG = {
    'host': os.getenv('MYSQL_HOST', 'localhost'),
    'user': os.getenv('MYSQL_USER', 'root'),
    'password': os.getenv('MYSQL_PASSWORD', 'Keansa@2024'),
    'database': os.getenv('MYSQL_DATABASE', 'data_validation_2'),
}

def get_db_connection():
    if 'db' not in g:
        try:
            conn = mysql.connector.connect(
                host=DB_CONFIG['host'],
                user=DB_CONFIG['user'],
                password=DB_CONFIG['password']
            )
            cursor = conn.cursor()
            cursor.execute(f"CREATE DATABASE IF NOT EXISTS {DB_CONFIG['database']}")
            cursor.close()
            conn.close()
            g.db = mysql.connector.connect(**DB_CONFIG)
            logging.info("Database connection established successfully")
        except mysql.connector.Error as err:
            if err.errno == errorcode.ER_ACCESS_DENIED_ERROR:
                logging.error("Database connection failed: Access denied for user - check username/password")
            elif err.errno == errorcode.ER_BAD_DB_ERROR:
                logging.error("Database connection failed: Database does not exist")
            else:
                logging.error(f"Database connection failed: {err}")
            raise Exception(f"Failed to connect to database: {str(err)}")
    return g.db

def close_db(error):
    db = g.pop('db', None)
    if db is not None:
        db.close()

def init_db():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        tables = [
            """
            CREATE TABLE IF NOT EXISTS login_details (
                id INT AUTO_INCREMENT PRIMARY KEY,
                first_name VARCHAR(100),
                last_name VARCHAR(100),
                email VARCHAR(255) UNIQUE,
                mobile VARCHAR(10),
                password VARCHAR(255)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS excel_templates (
                template_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_name VARCHAR(255) NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
                user_id INT NOT NULL,
                sheet_name VARCHAR(255),
                headers JSON,
                status ENUM('ACTIVE', 'INACTIVE') DEFAULT 'ACTIVE',
                is_corrected BOOLEAN DEFAULT FALSE,
                remote_file_path VARCHAR(512),
                FOREIGN KEY (user_id) REFERENCES login_details(id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS template_columns (
                column_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_id BIGINT NOT NULL,
                column_name VARCHAR(255) NOT NULL,
                column_position INT NOT NULL,
                is_validation_enabled BOOLEAN DEFAULT FALSE,
                is_selected BOOLEAN DEFAULT FALSE,
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE,
                UNIQUE (template_id, column_name)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_rule_types (
                rule_type_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                rule_name VARCHAR(255) NOT NULL,
                description TEXT,
                parameters TEXT,
                is_active BOOLEAN DEFAULT TRUE,
                is_custom BOOLEAN DEFAULT FALSE,
                column_name VARCHAR(255),
                template_id BIGINT,
                data_type VARCHAR(50),
                source_format VARCHAR(50),
                target_format VARCHAR(50),
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS column_validation_rules (
                column_validation_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                column_id BIGINT NOT NULL,
                rule_type_id BIGINT NOT NULL,
                rule_config JSON,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (column_id) REFERENCES template_columns(column_id) ON DELETE CASCADE,
                FOREIGN KEY (rule_type_id) REFERENCES validation_rule_types(rule_type_id) ON DELETE RESTRICT,
                UNIQUE (column_id, rule_type_id)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_history (
                history_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_id BIGINT NOT NULL,
                template_name VARCHAR(255) NOT NULL,
                error_count INT NOT NULL,
                corrected_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                corrected_file_path VARCHAR(512) NOT NULL,
                user_id INT NOT NULL,
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE,
                FOREIGN KEY (user_id) REFERENCES login_details(id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_corrections (
                correction_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                history_id BIGINT NOT NULL,
                row_index INT NOT NULL,
                column_name VARCHAR(255) NOT NULL,
                original_value TEXT,
                corrected_value TEXT,
                rule_failed VARCHAR(255) DEFAULT NULL,
                FOREIGN KEY (history_id) REFERENCES validation_history(history_id) ON DELETE CASCADE
            )
            """
        ]
        for table_sql in tables:
            cursor.execute(table_sql)
        
        # Add missing columns if they don't exist
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'source_format'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN source_format VARCHAR(50)")
            logging.info("Added source_format column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'target_format'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN target_format VARCHAR(50)")
            logging.info("Added target_format column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'data_type'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN data_type VARCHAR(50)")
            logging.info("Added data_type column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM excel_templates LIKE 'remote_file_path'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE excel_templates ADD COLUMN remote_file_path VARCHAR(512)")
            logging.info("Added remote_file_path column to excel_templates table")
            
        cursor.execute("SHOW COLUMNS FROM template_columns LIKE 'is_selected'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE template_columns ADD COLUMN is_selected BOOLEAN DEFAULT FALSE")
            logging.info("Added is_selected column to template_columns table")
            
        conn.commit()
        cursor.close()
        logging.info("Database tables initialized")
    except Exception as e:
        logging.error(f"Failed to initialize database: {str(e)}")
        raise

def create_admin_user():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        admin_password = bcrypt.hashpw('admin'.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
        cursor.execute("""
            INSERT IGNORE INTO login_details (first_name, last_name, email, mobile, password)
            VALUES (%s, %s, %s, %s, %s)
        """, ('Admin', 'User', 'admin@example.com', '1234567890', admin_password))
        conn.commit()
        cursor.close()
        logging.info("Admin user created or already exists")
    except Exception as e:
        logging.error(f"Failed to create admin user: {str(e)}")
        raise

def create_default_validation_rules():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        default_rules = [
            ("Required", "Ensures the field is not null", '{"allow_null": false}', None, None, None),
            ("Int", "Validates integer format", '{"format": "integer"}', None, None, "Int"),
            ("Float", "Validates number format (integer or decimal)", '{"format": "float"}', None, None, "Float"),
            ("Text", "Allows text with quotes and parentheses", '{"allow_special": false}', None, None, "Text"),
            ("Email", "Validates email format", '{"regex": "^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\\\.[a-zA-Z0-9-.]+$"}', None, None, "Email"),
            ("Date(DD-MM-YYYY)", "Validates date format DD-MM-YYYY", '{"format": "%d-%m-%Y"}', "DD-MM-YYYY", None, "Date"),
            ("Boolean", "Validates boolean format (true/false or 0/1)", '{"format": "boolean"}', None, None, "Boolean"),
            ("Alphanumeric", "Validates alphanumeric format", '{"format": "alphanumeric"}', None, None, "Alphanumeric")
        ]
        cursor.executemany("""
            INSERT IGNORE INTO validation_rule_types (rule_name, description, parameters, is_custom, source_format, target_format, data_type)
            VALUES (%s, %s, %s, %s, %s, %s, %s)
        """, [(name, desc, params, False, source, target, dtype) for name, desc, params, source, target, dtype in default_rules])
        conn.commit()
        cursor.close()
        logging.info("Default validation rules ensured successfully")
    except Exception as e:
        logging.error(f"Failed to ensure default validation rules: {str(e)}")
        raise

if __name__ == '__main__':
    try:
        # Create the application using factory pattern
        app = create_app()
        
        # Initialize database and default data within app context
        with app.app_context():
            initialize_app_data()
        
        # Get port from environment or use default
        port = int(os.getenv('PORT', 5000))
        
        # Start the application server
        logging.info("Starting Flask server...")
        app.run(debug=True, host='0.0.0.0', port=port)
        
    except Exception as e:
        logging.error(f"Failed to start application: {e}")
        raise
).all():
        return "Float"
    
    # Alphanumeric detection
    if non_null.str.match(r'^[a-zA-Z0-9]+

def create_app():
    """Application factory pattern for different environments"""
    # Set the path to the frontend dist folder
    current_dir = os.path.dirname(os.path.abspath(__file__))
    frontend_dist_path = os.path.join(current_dir, '..', '..', 'Keansa-Ai-Suite2025may-frontend11', 'dist')
    frontend_dist_path = os.path.abspath(frontend_dist_path)
    
    # Create Flask application instance
    app = Flask(__name__, static_folder=frontend_dist_path, static_url_path='')
    CORS(app, supports_credentials=True, origins=["http://localhost:3000", "http://localhost:8080", "http://localhost:5000", "*"])

    app.secret_key = os.urandom(24).hex()
    app.config['SESSION_TYPE'] = 'filesystem'
    app.config['SESSION_FILE_DIR'] = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'sessions')
    app.config['SESSION_COOKIE_SAMESITE'] = 'Lax'
    app.config['SESSION_COOKIE_HTTPONLY'] = True
    app.config['SESSION_COOKIE_SECURE'] = False
    app.config['PERMANENT_SESSION_LIFETIME'] = 86400  # 24 hours
    app.config['UPLOAD_FOLDER'] = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'uploads')
    Session(app)

    # Ensure directories exist
    try:
        os.makedirs(app.config['UPLOAD_FOLDER'], exist_ok=True)
        os.makedirs(app.config['SESSION_FILE_DIR'], exist_ok=True)
    except OSError as e:
        logging.error(f"Failed to create directories: {e}")

    # Register cleanup handlers
    app.teardown_appcontext(close_db)
    
    # Register all routes directly in create_app
    
    # Static file serving for React frontend
    @app.route('/', defaults={'path': ''})
    @app.route('/<path:path>')
    def serve(path):
        if path and os.path.exists(os.path.join(app.static_folder, path)):
            return app.send_static_file(path)
        return app.send_static_file('index.html')

    # Health check endpoint
    @app.route('/health', methods=['GET'])
    def health_check():
        return jsonify({
            'status': 'healthy',
            'timestamp': datetime.now().isoformat(),
            'version': '2.0.0'
        })

    # Authentication endpoint - both old and new paths
    @app.route('/authenticate', methods=['POST'])
    @app.route('/api/auth/authenticate', methods=['POST'])
    def authenticate():
        try:
            email = request.form.get('username') or request.form.get('email')
            password = request.form.get('password')
            logging.debug(f"Login attempt: email={email}, password={'*' * len(password) if password else 'None'}")
            
            if not email or not password:
                logging.warning(f"Login failed: Email or password missing")
                return jsonify({'success': False, 'message': 'Email and password are required'}), 400

            # Check for admin login
            if email == "admin" and password == "admin":
                session['loggedin'] = True
                session['user_email'] = "admin@example.com"
                session['user_id'] = 1
                session.permanent = True
                logging.info(f"Admin login successful. Session: {dict(session)}")
                return jsonify({'success': True, 'message': 'Login successful', 'user': {'email': 'admin@example.com', 'id': 1}}), 200

            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("SELECT * FROM login_details WHERE LOWER(email) = LOWER(%s)", (email.lower(),))
            account = cursor.fetchone()
            cursor.close()
            
            if account:
                if bcrypt.checkpw(password.encode('utf-8'), account['password'].encode('utf-8')):
                    session['loggedin'] = True
                    session['user_email'] = account['email']
                    session['user_id'] = account['id']
                    session.permanent = True
                    logging.info(f"User {email} logged in successfully. Session: {dict(session)}")
                    return jsonify({
                        'success': True,
                        'message': 'Login successful',
                        'user': {'email': account['email'], 'id': account['id']}
                    }), 200
                else:
                    logging.warning(f"Invalid password for {email}")
                    return jsonify({'success': False, 'message': 'Invalid credentials'}), 401
            else:
                logging.warning(f"Email {email} not found")
                return jsonify({'success': False, 'message': 'Invalid credentials'}), 401
        except Exception as e:
            logging.error(f"Unexpected error during login: {str(e)}")
            return jsonify({'success': False, 'message': f'Unexpected error: {str(e)}'}), 500

    @app.route('/check-auth', methods=['GET'])
    @app.route('/api/auth/check-auth', methods=['GET'])
    def check_auth():
        try:
            logging.debug(f"Checking auth with session: {dict(session)}")
            if 'loggedin' in session and 'user_id' in session:
                conn = get_db_connection()
                cursor = conn.cursor(dictionary=True)
                cursor.execute("SELECT email, first_name FROM login_details WHERE id = %s", (session['user_id'],))
                user = cursor.fetchone()
                cursor.close()
                if user:
                    logging.info(f"User {session.get('user_email')} is authenticated")
                    return jsonify({
                        'success': True,
                        'user': {
                            'email': user['email'],
                            'id': session['user_id'],
                            'first_name': user['first_name']
                        }
                    })
                else:
                    logging.warning("User not found in database")  
                    session.clear()
                    return jsonify({'success': False, 'message': 'User not found'}), 401
            logging.warning("User not authenticated")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        except Exception as e:
            logging.error(f"Error in check-auth endpoint: {str(e)}")
            return jsonify({'success': False, 'message': f'Server error: {str(e)}'}), 500

    @app.route('/register', methods=['POST'])
    @app.route('/api/auth/register', methods=['POST'])
    def register():
        first_name = request.form.get('first_name')
        last_name = request.form.get('last_name')
        email = request.form.get('email')
        mobile = request.form.get('mobile')
        password = request.form.get('password')
        confirm_password = request.form.get('confirm_password')

        if not all([first_name, last_name, email, mobile, password, confirm_password]):
            return jsonify({'success': False, 'message': 'All fields are required'}), 400
        if password != confirm_password:
            return jsonify({'success': False, 'message': 'Passwords do not match'}), 400

        hashed_password = bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
        try:
            conn = get_db_connection()
            cursor = conn.cursor()
            cursor.execute("""
                INSERT INTO login_details (first_name, last_name, email, mobile, password)
                VALUES (%s, %s, %s, %s, %s)
            """, (first_name, last_name, email, mobile, hashed_password))
            user_id = cursor.lastrowid
            conn.commit()
            cursor.close()
            session['loggedin'] = True
            session['user_email'] = email
            session['user_id'] = user_id
            return jsonify({
                'success': True,
                'message': 'Registration successful',
                'user': {'email': email, 'id': user_id}
            }), 200
        except mysql.connector.Error as e:
            logging.error(f"Database error during registration: {str(e)}")
            return jsonify({'success': False, 'message': f'Registration error: {str(e)}'}), 500

    @app.route('/logout', methods=['POST'])
    @app.route('/api/auth/logout', methods=['POST'])
    def logout():
        logging.info(f"User {session.get('user_email', 'unknown')} logged out")
        session.clear()
        return jsonify({'success': True, 'message': 'Logged out successfully'})

    # Template routes
    @app.route('/templates', methods=['GET'])
    @app.route('/api/templates', methods=['GET'])
    def get_templates():
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /templates: session missing")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("""
                SELECT template_id, template_name, created_at, status
                FROM excel_templates
                WHERE user_id = %s AND status = 'ACTIVE'
                ORDER BY created_at DESC
                LIMIT 100
            """, (session['user_id'],))
            templates = cursor.fetchall()
            cursor.close()
            logging.info(f"Fetched {len(templates)} templates for user {session['user_id']}")
            return jsonify({'success': True, 'templates': templates})
        except mysql.connector.Error as e:
            logging.error(f'Error fetching templates: {str(e)}')
            return jsonify({'success': False, 'message': f'Error fetching templates: {str(e)}'}), 500
        except Exception as e:
            logging.error(f'Unexpected error fetching templates: {str(e)}')
            return jsonify({'success': False, 'message': f'Unexpected error: {str(e)}'}), 500

    # Rule Configuration routes
    @app.route('/rule-configurations', methods=['GET'])
    @app.route('/api/validation/rule-configurations', methods=['GET'])
    def get_rule_configurations():
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning(f"Unauthorized access to /rule-configurations: session={dict(session)}")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            user_id = session['user_id']
            logging.debug(f"Fetching rule configurations for user_id: {user_id}")

            # Main query to fetch templates with configured rules
            cursor.execute("""
                SELECT 
                    t.template_id, 
                    t.template_name, 
                    t.created_at, 
                    COUNT(cvr.column_validation_id) as rule_count
                FROM excel_templates t
                LEFT JOIN template_columns tc ON t.template_id = tc.template_id
                LEFT JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                WHERE t.user_id = %s AND t.status = 'ACTIVE' AND t.is_corrected = FALSE
                GROUP BY t.template_id, t.template_name, t.created_at
                HAVING rule_count > 0
                ORDER BY t.created_at DESC
                LIMIT 100
            """, (user_id,))
            templates = cursor.fetchall()
            logging.debug(f"Fetched rule-configured templates: {templates}")

            cursor.close()

            if not templates:
                logging.info(f"No templates with rules found for user_id: {user_id}")
            else:
                logging.info(f"Found {len(templates)} templates with rules for user_id: {user_id}")

            return jsonify({'success': True, 'templates': templates})
        except mysql.connector.Error as e:
            logging.error(f"Database error fetching rule configurations: {str(e)}")
            return jsonify({'success': False, 'message': f"Database error: {str(e)}"}), 500
        except Exception as e:
            logging.error(f"Unexpected error fetching rule configurations: {str(e)}")
            return jsonify({'success': False, 'message': f"Unexpected error: {str(e)}"}), 500

    # File upload route
    @app.route('/upload', methods=['POST'])
    @app.route('/api/templates/upload', methods=['POST'])
    @app.route('/api/upload', methods=['POST'])  # Additional common path
    def upload():
        logging.info(f"Upload endpoint called: {request.endpoint}, method: {request.method}")
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /upload: session missing")
            return jsonify({'error': 'Not logged in'}), 401
        if 'file' not in request.files:
            logging.warning("No file provided in upload request")
            return jsonify({'error': 'No file uploaded'}), 400
        file = request.files['file']
        if file.filename == '':
            logging.warning("No file selected in upload request")
            return jsonify({'error': 'No file selected'}), 400
        
        file_path = os.path.join(app.config['UPLOAD_FOLDER'], file.filename)
        try:
            file.save(file_path)
            logging.info(f"File saved: {file_path}")
        except Exception as e:
            logging.error(f"Failed to save file {file.filename}: {str(e)}")
            return jsonify({'error': f'Failed to save file: {str(e)}'}), 500

        try:
            # Read the file to get sheets and headers
            if file.filename.endswith('.xlsx') or file.filename.endswith('.xls'):
                xl = pd.ExcelFile(file_path)
                sheets = {sheet_name: pd.read_excel(file_path, sheet_name=sheet_name, header=None) 
                         for sheet_name in xl.sheet_names}
            elif file.filename.endswith(('.txt', '.csv', '.dat')):
                df = pd.read_csv(file_path, header=None, encoding='utf-8')
                sheets = {'Sheet1': df}
            else:
                logging.error("Unsupported file type")
                return jsonify({'error': 'Unsupported file type'}), 400
            
            logging.debug(f"Sheets extracted: {list(sheets.keys())}")
        except Exception as e:
            logging.error(f"Failed to read file {file_path}: {str(e)}")
            return jsonify({'error': f'Failed to read file: {str(e)}'}), 400

        try:
            sheet_names = list(sheets.keys())
            if not sheet_names:
                logging.error("No sheets found in the file")
                return jsonify({'error': 'No sheets found in the file'}), 400
            sheet_name = sheet_names[0]
            df = sheets[sheet_name]
            
            # Find header row
            header_row = 0
            for i in range(min(len(df), 10)):
                row = df.iloc[i].dropna()
                if not row.empty and all(isinstance(x, str) for x in row if pd.notna(x)):
                    header_row = i
                    break
                    
            headers = df.iloc[header_row].tolist()
            logging.debug(f"Headers extracted: {headers}")
            
            if not headers or all(not h for h in headers):
                logging.error("No valid headers found in file")
                return jsonify({'error': 'No valid headers found in the file'}), 400
        except Exception as e:
            logging.error(f"Error processing file {file.filename}: {str(e)}")
            return jsonify({'error': f'Error processing file: {str(e)}'}), 400

        # Clear existing session data
        for key in ['df', 'header_row', 'headers', 'sheet_name', 'current_step', 'selected_headers', 'validations', 'error_cell_locations', 'data_rows', 'corrected_file_path']:
            session.pop(key, None)

        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)

            # Check if template exists
            cursor.execute("""
                SELECT template_id, headers, sheet_name
                FROM excel_templates
                WHERE template_name = %s AND user_id = %s AND status = 'ACTIVE'
                ORDER BY created_at DESC
            """, (file.filename, session['user_id']))
            existing_templates = cursor.fetchall()
            logging.info(f"Found {len(existing_templates)} existing templates with name {file.filename}")

            template_id = None
            has_existing_rules = False
            validations = {}
            selected_headers = []

            # Check for matching template
            matching_template = None
            for template in existing_templates:
                stored_headers = json.loads(template['headers']) if template['headers'] else []
                stored_sheet_name = template['sheet_name']
                if stored_headers == headers and stored_sheet_name == sheet_name:
                    matching_template = template
                    break

            if matching_template:
                template_id = matching_template['template_id']
                # Check for existing rules
                cursor.execute("""
                    SELECT tc.column_name, vrt.rule_name
                    FROM template_columns tc
                    JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                    JOIN validation_rule_types vrt ON cvr.rule_type_id = vrt.rule_type_id
                    WHERE tc.template_id = %s AND tc.is_selected = TRUE
                """, (template_id,))
                rules_data = cursor.fetchall()
                for row in rules_data:
                    column_name = row['column_name']
                    rule_name = row['rule_name']
                    if column_name not in validations:
                        validations[column_name] = []
                    validations[column_name].append(rule_name)
                    if column_name not in selected_headers:
                        selected_headers.append(column_name)
                has_existing_rules = len(validations) > 0
            else:
                # New template
                cursor.execute("""
                    INSERT INTO excel_templates (template_name, user_id, sheet_name, headers, is_corrected)
                    VALUES (%s, %s, %s, %s, %s)
                """, (file.filename, session['user_id'], sheet_name, json.dumps(headers), False))
                template_id = cursor.lastrowid
                column_data = [(template_id, header, i + 1, False) for i, header in enumerate(headers)]
                cursor.executemany("""
                    INSERT INTO template_columns (template_id, column_name, column_position, is_selected)
                    VALUES (%s, %s, %s, %s)
                """, column_data)

            conn.commit()
            cursor.close()

            # Store session data
            session['file_path'] = file_path
            session['template_id'] = template_id
            session['df'] = df.to_json()
            session['header_row'] = header_row
            session['headers'] = headers
            session['sheet_name'] = sheet_name
            session['current_step'] = 1 if not has_existing_rules else 3
            session['validations'] = validations
            session['selected_headers'] = selected_headers
            session['has_existing_rules'] = has_existing_rules

            logging.info(f"Upload processed: template_id={template_id}, filename={file.filename}, has_existing_rules={has_existing_rules}")

            return jsonify({
                'success': True,
                'sheets': {sheet_name: {'headers': headers}},
                'file_name': file.filename,
                'template_id': template_id,
                'has_existing_rules': has_existing_rules,
                'sheet_name': sheet_name,
                'skip_to_step_3': has_existing_rules
            })
        except mysql.connector.Error as e:
            logging.error(f'Error saving template: {str(e)}')
            return jsonify({'error': f'Error saving template: {str(e)}'}), 500
        except Exception as e:
            logging.error(f'Unexpected error saving template: {str(e)}')
            return jsonify({'error': f'Unexpected error: {str(e)}'}), 500

    # Multi-step workflow endpoints
    @app.route('/step/1', methods=['GET', 'POST'])
    @app.route('/api/step/1', methods=['GET', 'POST'])
    def step_one():
        if 'loggedin' not in session:
            return jsonify({'error': 'Not logged in'}), 401
        
        if request.method == 'POST':
            try:
                headers = request.form.getlist('headers')
                new_header_row = request.form.get('new_header_row')
                logging.debug(f"Step 1 submitted: headers={headers}, new_header_row={new_header_row}")
                
                if not headers:
                    logging.error("No headers provided in step 1")
                    return jsonify({'success': False, 'message': 'No headers provided'}), 400
                    
                if 'template_id' not in session:
                    logging.error("Session missing template_id")
                    return jsonify({'success': False, 'message': 'Session data missing'}), 400

                template_id = session['template_id']
                
                # Get the dataframe from session for auto-detection
                df_json = session.get('df')
                if df_json:
                    df = pd.read_json(StringIO(df_json))
                    session_headers = session.get('headers', [])
                    df.columns = session_headers
                    header_row = session.get('header_row', 0)
                    df = df.iloc[header_row + 1:].reset_index(drop=True)
                    
                    # Auto-detect rules for selected headers
                    validations = assign_default_rules_to_columns(df, headers)
                    session['validations'] = validations
                    logging.debug(f"Auto-assigned rules: {validations}")
                else:
                    validations = {}

                session['selected_headers'] = headers
                session['current_step'] = 2

                # Mark selected headers in the database
                conn = get_db_connection()
                cursor = conn.cursor()
                cursor.execute("UPDATE template_columns SET is_selected = FALSE WHERE template_id = %s", (template_id,))
                for header in headers:
                    cursor.execute("""
                        UPDATE template_columns
                        SET is_selected = TRUE
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    
                    # Get column_id and add auto-detected rules
                    cursor.execute("""
                        SELECT column_id FROM template_columns
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    result = cursor.fetchone()
                    if result:
                        column_id = result[0]
                        for rule_name in validations.get(header, []):
                            cursor.execute("""
                                SELECT rule_type_id FROM validation_rule_types
                                WHERE rule_name = %s AND is_custom = FALSE
                            """, (rule_name,))
                            rule_result = cursor.fetchone()
                            if rule_result:
                                rule_type_id = rule_result[0]
                                cursor.execute("""
                                    INSERT IGNORE INTO column_validation_rules (column_id, rule_type_id, rule_config)
                                    VALUES (%s, %s, %s)
                                """, (column_id, rule_type_id, '{}'))
                
                conn.commit()
                cursor.close()

                logging.info(f"Step 1 completed: headers={headers}, auto-assigned rules={validations}")
                return jsonify({'success': True, 'headers': headers, 'validations': validations})
            except Exception as e:
                logging.error(f"Error in step 1: {str(e)}")
                return jsonify({'success': False, 'message': str(e)}), 500
        
        # GET request - return current headers
        headers = session.get('headers', [])
        return jsonify({'headers': headers})

    @app.route('/step/2', methods=['GET', 'POST'])
    @app.route('/api/step/2', methods=['GET', 'POST'])
    def step_two():
        if 'loggedin' not in session:
            return jsonify({'error': 'Not logged in'}), 401
            
        if request.method == 'POST':
            try:
                action = request.form.get('action', 'save')
                validations = {}
                for key, values in request.form.lists():
                    if key.startswith('validations_'):
                        header = key.replace('validations_', '')
                        validations[header] = values
                        
                logging.debug(f"Step 2 submitted: action={action}, validations={validations}")
                
                template_id = session.get('template_id')
                if not template_id:
                    return jsonify({'success': False, 'message': 'Session data missing'}), 400

                # Save validations to database
                conn = get_db_connection()
                cursor = conn.cursor()
                
                # Clear existing rules
                cursor.execute("""
                    DELETE FROM column_validation_rules
                    WHERE column_id IN (
                        SELECT column_id FROM template_columns WHERE template_id = %s
                    )
                """, (template_id,))
                
                # Add new rules
                for header, rules in validations.items():
                    cursor.execute("""
                        SELECT column_id FROM template_columns
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    result = cursor.fetchone()
                    if not result:
                        continue
                    column_id = result[0]
                    
                    for rule_name in rules:
                        cursor.execute("""
                            SELECT rule_type_id FROM validation_rule_types
                            WHERE rule_name = %s
                        """, (rule_name,))
                        result = cursor.fetchone()
                        if result:
                            rule_type_id = result[0]
                            cursor.execute("""
                                INSERT IGNORE INTO column_validation_rules (column_id, rule_type_id, rule_config)
                                VALUES (%s, %s, %s)
                            """, (column_id, rule_type_id, '{}'))
                
                conn.commit()
                cursor.close()

                session['validations'] = validations
                session['current_step'] = 3 if action == 'review' else 2
                
                logging.info(f"Step 2 completed: action={action}, validations={validations}")
                return jsonify({'success': True, 'message': 'Step 2 completed successfully'})
            except Exception as e:
                logging.error(f"Error in step 2: {str(e)}")
                return jsonify({'success': False, 'message': str(e)}), 500
        
        # GET request
        selected_headers = session.get('selected_headers', [])
        return jsonify({'selected_headers': selected_headers})

    # Rules endpoint
    @app.route('/rules', methods=['GET'])
    @app.route('/api/rules', methods=['GET'])
    def get_rules():
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            
            cursor.execute("""
                SELECT rule_type_id AS rule_id, rule_name, description, parameters, is_custom, 
                       column_name, template_id, source_format, target_format, data_type, is_active
                FROM validation_rule_types
            """)
            rules = cursor.fetchall()
            cursor.close()
            
            logging.info(f"Returning {len(rules)} rules from getRules endpoint")
            return jsonify({'success': True, 'rules': rules})
        except mysql.connector.Error as e:
            logging.error(f"Database error fetching rules: {str(e)}")
            return jsonify({'success': False, 'message': str(e)}), 500
        except Exception as e:
            logging.error(f"Unexpected error fetching rules: {str(e)}")
            return jsonify({'success': False, 'message': str(e)}), 500

    # Template details endpoint
    @app.route('/template/<int:template_id>/<sheet_name>', methods=['GET'])
    @app.route('/api/template/<int:template_id>/<sheet_name>', methods=['GET'])
    def get_template(template_id, sheet_name):
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /template: session missing")
            return jsonify({'error': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("""
                SELECT template_name, sheet_name, headers
                FROM excel_templates
                WHERE template_id = %s AND user_id = %s AND status = 'ACTIVE'
            """, (template_id, session['user_id']))
            template_record = cursor.fetchone()
            
            if not template_record:
                logging.error(f"Template not found for template_id: {template_id}, user_id: {session['user_id']}")
                cursor.close()
                return jsonify({'error': 'Template not found'}), 404

            headers = json.loads(template_record['headers']) if template_record['headers'] else []
            stored_sheet_name = template_record['sheet_name'] or sheet_name
            file_path = os.path.join(app.config['UPLOAD_FOLDER'], template_record['template_name'])
            
            cursor.execute("""
                SELECT COUNT(*) as rule_count
                FROM template_columns tc
                JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                WHERE tc.template_id = %s AND tc.is_selected = TRUE
            """, (template_id,))
            rule_count = cursor.fetchone()['rule_count']
            has_existing_rules = rule_count > 0
            
            cursor.close()
            
            return jsonify({
                'success': True,
                'sheets': {stored_sheet_name: {'headers': headers}},
                'file_name': template_record['template_name'],
                'file_path': file_path,
                'sheet_name': stored_sheet_name,
                'has_existing_rules': has_existing_rules
            })
        except mysql.connector.Error as e:
            logging.error(f"Database error in get_template: {str(e)}")
            return jsonify({'error': f'Database error: {str(e)}'}), 500
        except Exception as e:
            logging.error(f"Unexpected error in get_template: {str(e)}")
            return jsonify({'error': f'Unexpected error: {str(e)}'}), 500

    # Debug route to show all registered routes
    @app.route('/debug/routes', methods=['GET'])
    def list_routes():
        routes = []
        for rule in app.url_map.iter_rules():
            routes.append({
                'endpoint': rule.endpoint,
                'methods': list(rule.methods),
                'rule': rule.rule
            })
        return jsonify(routes)

    # 404 handler to debug missing routes
    @app.errorhandler(404)
    def not_found_handler(error):
        logging.error(f"404 Error: {request.method} {request.url} not found")
        logging.error(f"Available routes: {[rule.rule for rule in app.url_map.iter_rules()]}")
        return jsonify({
            'error': 'Endpoint not found', 
            'method': request.method,
            'url': request.url,
            'path': request.path
        }), 404

    return app

def initialize_app_data():
    """Initialize database and create default data"""
    try:
        logging.info("Initializing database schema...")
        init_db()
        
        logging.info("Creating admin user...")
        create_admin_user()
        
        logging.info("Creating default validation rules...")
        create_default_validation_rules()
        
        logging.info("Application initialization completed successfully")
    except Exception as e:
        logging.error(f"Failed to initialize application: {e}")
        raise

DB_CONFIG = {
    'host': os.getenv('MYSQL_HOST', 'localhost'),
    'user': os.getenv('MYSQL_USER', 'root'),
    'password': os.getenv('MYSQL_PASSWORD', 'Keansa@2024'),
    'database': os.getenv('MYSQL_DATABASE', 'data_validation_2'),
}

def get_db_connection():
    if 'db' not in g:
        try:
            conn = mysql.connector.connect(
                host=DB_CONFIG['host'],
                user=DB_CONFIG['user'],
                password=DB_CONFIG['password']
            )
            cursor = conn.cursor()
            cursor.execute(f"CREATE DATABASE IF NOT EXISTS {DB_CONFIG['database']}")
            cursor.close()
            conn.close()
            g.db = mysql.connector.connect(**DB_CONFIG)
            logging.info("Database connection established successfully")
        except mysql.connector.Error as err:
            if err.errno == errorcode.ER_ACCESS_DENIED_ERROR:
                logging.error("Database connection failed: Access denied for user - check username/password")
            elif err.errno == errorcode.ER_BAD_DB_ERROR:
                logging.error("Database connection failed: Database does not exist")
            else:
                logging.error(f"Database connection failed: {err}")
            raise Exception(f"Failed to connect to database: {str(err)}")
    return g.db

def close_db(error):
    db = g.pop('db', None)
    if db is not None:
        db.close()

def init_db():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        tables = [
            """
            CREATE TABLE IF NOT EXISTS login_details (
                id INT AUTO_INCREMENT PRIMARY KEY,
                first_name VARCHAR(100),
                last_name VARCHAR(100),
                email VARCHAR(255) UNIQUE,
                mobile VARCHAR(10),
                password VARCHAR(255)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS excel_templates (
                template_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_name VARCHAR(255) NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
                user_id INT NOT NULL,
                sheet_name VARCHAR(255),
                headers JSON,
                status ENUM('ACTIVE', 'INACTIVE') DEFAULT 'ACTIVE',
                is_corrected BOOLEAN DEFAULT FALSE,
                remote_file_path VARCHAR(512),
                FOREIGN KEY (user_id) REFERENCES login_details(id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS template_columns (
                column_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_id BIGINT NOT NULL,
                column_name VARCHAR(255) NOT NULL,
                column_position INT NOT NULL,
                is_validation_enabled BOOLEAN DEFAULT FALSE,
                is_selected BOOLEAN DEFAULT FALSE,
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE,
                UNIQUE (template_id, column_name)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_rule_types (
                rule_type_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                rule_name VARCHAR(255) NOT NULL,
                description TEXT,
                parameters TEXT,
                is_active BOOLEAN DEFAULT TRUE,
                is_custom BOOLEAN DEFAULT FALSE,
                column_name VARCHAR(255),
                template_id BIGINT,
                data_type VARCHAR(50),
                source_format VARCHAR(50),
                target_format VARCHAR(50),
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS column_validation_rules (
                column_validation_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                column_id BIGINT NOT NULL,
                rule_type_id BIGINT NOT NULL,
                rule_config JSON,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (column_id) REFERENCES template_columns(column_id) ON DELETE CASCADE,
                FOREIGN KEY (rule_type_id) REFERENCES validation_rule_types(rule_type_id) ON DELETE RESTRICT,
                UNIQUE (column_id, rule_type_id)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_history (
                history_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_id BIGINT NOT NULL,
                template_name VARCHAR(255) NOT NULL,
                error_count INT NOT NULL,
                corrected_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                corrected_file_path VARCHAR(512) NOT NULL,
                user_id INT NOT NULL,
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE,
                FOREIGN KEY (user_id) REFERENCES login_details(id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_corrections (
                correction_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                history_id BIGINT NOT NULL,
                row_index INT NOT NULL,
                column_name VARCHAR(255) NOT NULL,
                original_value TEXT,
                corrected_value TEXT,
                rule_failed VARCHAR(255) DEFAULT NULL,
                FOREIGN KEY (history_id) REFERENCES validation_history(history_id) ON DELETE CASCADE
            )
            """
        ]
        for table_sql in tables:
            cursor.execute(table_sql)
        
        # Add missing columns if they don't exist
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'source_format'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN source_format VARCHAR(50)")
            logging.info("Added source_format column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'target_format'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN target_format VARCHAR(50)")
            logging.info("Added target_format column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'data_type'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN data_type VARCHAR(50)")
            logging.info("Added data_type column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM excel_templates LIKE 'remote_file_path'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE excel_templates ADD COLUMN remote_file_path VARCHAR(512)")
            logging.info("Added remote_file_path column to excel_templates table")
            
        cursor.execute("SHOW COLUMNS FROM template_columns LIKE 'is_selected'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE template_columns ADD COLUMN is_selected BOOLEAN DEFAULT FALSE")
            logging.info("Added is_selected column to template_columns table")
            
        conn.commit()
        cursor.close()
        logging.info("Database tables initialized")
    except Exception as e:
        logging.error(f"Failed to initialize database: {str(e)}")
        raise

def create_admin_user():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        admin_password = bcrypt.hashpw('admin'.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
        cursor.execute("""
            INSERT IGNORE INTO login_details (first_name, last_name, email, mobile, password)
            VALUES (%s, %s, %s, %s, %s)
        """, ('Admin', 'User', 'admin@example.com', '1234567890', admin_password))
        conn.commit()
        cursor.close()
        logging.info("Admin user created or already exists")
    except Exception as e:
        logging.error(f"Failed to create admin user: {str(e)}")
        raise

def create_default_validation_rules():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        default_rules = [
            ("Required", "Ensures the field is not null", '{"allow_null": false}', None, None, None),
            ("Int", "Validates integer format", '{"format": "integer"}', None, None, "Int"),
            ("Float", "Validates number format (integer or decimal)", '{"format": "float"}', None, None, "Float"),
            ("Text", "Allows text with quotes and parentheses", '{"allow_special": false}', None, None, "Text"),
            ("Email", "Validates email format", '{"regex": "^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\\\.[a-zA-Z0-9-.]+$"}', None, None, "Email"),
            ("Date(DD-MM-YYYY)", "Validates date format DD-MM-YYYY", '{"format": "%d-%m-%Y"}', "DD-MM-YYYY", None, "Date"),
            ("Boolean", "Validates boolean format (true/false or 0/1)", '{"format": "boolean"}', None, None, "Boolean"),
            ("Alphanumeric", "Validates alphanumeric format", '{"format": "alphanumeric"}', None, None, "Alphanumeric")
        ]
        cursor.executemany("""
            INSERT IGNORE INTO validation_rule_types (rule_name, description, parameters, is_custom, source_format, target_format, data_type)
            VALUES (%s, %s, %s, %s, %s, %s, %s)
        """, [(name, desc, params, False, source, target, dtype) for name, desc, params, source, target, dtype in default_rules])
        conn.commit()
        cursor.close()
        logging.info("Default validation rules ensured successfully")
    except Exception as e:
        logging.error(f"Failed to ensure default validation rules: {str(e)}")
        raise

if __name__ == '__main__':
    try:
        # Create the application using factory pattern
        app = create_app()
        
        # Initialize database and default data within app context
        with app.app_context():
            initialize_app_data()
        
        # Get port from environment or use default
        port = int(os.getenv('PORT', 5000))
        
        # Start the application server
        logging.info("Starting Flask server...")
        app.run(debug=True, host='0.0.0.0', port=port)
        
    except Exception as e:
        logging.error(f"Failed to start application: {e}")
        raise
).all():
        return "Alphanumeric"
    
    return "Text"

def assign_default_rules_to_columns(df, headers):
    """Intelligently assign validation rules based on column content"""
    assignments = {}
    
    for col in headers:
        if col not in df.columns:
            logging.warning(f"Column {col} not found in dataframe")
            continue
            
        col_type = detect_column_type(df[col])
        rules = ["Required"]  # Default rule for all columns
        
        # Special handling for optional columns
        if not any(col.lower().startswith(prefix) for prefix in
                  ["name", "address", "phone", "username", "status", "period"]):
            rules.append(col_type)
        else:
            rules.append("Text")  # Optional text fields
        
        assignments[col] = rules
    
    return assignments

def create_app():
    """Application factory pattern for different environments"""
    # Set the path to the frontend dist folder
    current_dir = os.path.dirname(os.path.abspath(__file__))
    frontend_dist_path = os.path.join(current_dir, '..', '..', 'Keansa-Ai-Suite2025may-frontend11', 'dist')
    frontend_dist_path = os.path.abspath(frontend_dist_path)
    
    # Create Flask application instance
    app = Flask(__name__, static_folder=frontend_dist_path, static_url_path='')
    CORS(app, supports_credentials=True, origins=["http://localhost:3000", "http://localhost:8080", "http://localhost:5000", "*"])

    app.secret_key = os.urandom(24).hex()
    app.config['SESSION_TYPE'] = 'filesystem'
    app.config['SESSION_FILE_DIR'] = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'sessions')
    app.config['SESSION_COOKIE_SAMESITE'] = 'Lax'
    app.config['SESSION_COOKIE_HTTPONLY'] = True
    app.config['SESSION_COOKIE_SECURE'] = False
    app.config['PERMANENT_SESSION_LIFETIME'] = 86400  # 24 hours
    app.config['UPLOAD_FOLDER'] = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'uploads')
    Session(app)

    # Ensure directories exist
    try:
        os.makedirs(app.config['UPLOAD_FOLDER'], exist_ok=True)
        os.makedirs(app.config['SESSION_FILE_DIR'], exist_ok=True)
    except OSError as e:
        logging.error(f"Failed to create directories: {e}")

    # Register cleanup handlers
    app.teardown_appcontext(close_db)
    
    # Register all routes directly in create_app
    
    # Static file serving for React frontend
    @app.route('/', defaults={'path': ''})
    @app.route('/<path:path>')
    def serve(path):
        if path and os.path.exists(os.path.join(app.static_folder, path)):
            return app.send_static_file(path)
        return app.send_static_file('index.html')

    # Health check endpoint
    @app.route('/health', methods=['GET'])
    def health_check():
        return jsonify({
            'status': 'healthy',
            'timestamp': datetime.now().isoformat(),
            'version': '2.0.0'
        })

    # Authentication endpoint - both old and new paths
    @app.route('/authenticate', methods=['POST'])
    @app.route('/api/auth/authenticate', methods=['POST'])
    def authenticate():
        try:
            email = request.form.get('username') or request.form.get('email')
            password = request.form.get('password')
            logging.debug(f"Login attempt: email={email}, password={'*' * len(password) if password else 'None'}")
            
            if not email or not password:
                logging.warning(f"Login failed: Email or password missing")
                return jsonify({'success': False, 'message': 'Email and password are required'}), 400

            # Check for admin login
            if email == "admin" and password == "admin":
                session['loggedin'] = True
                session['user_email'] = "admin@example.com"
                session['user_id'] = 1
                session.permanent = True
                logging.info(f"Admin login successful. Session: {dict(session)}")
                return jsonify({'success': True, 'message': 'Login successful', 'user': {'email': 'admin@example.com', 'id': 1}}), 200

            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("SELECT * FROM login_details WHERE LOWER(email) = LOWER(%s)", (email.lower(),))
            account = cursor.fetchone()
            cursor.close()
            
            if account:
                if bcrypt.checkpw(password.encode('utf-8'), account['password'].encode('utf-8')):
                    session['loggedin'] = True
                    session['user_email'] = account['email']
                    session['user_id'] = account['id']
                    session.permanent = True
                    logging.info(f"User {email} logged in successfully. Session: {dict(session)}")
                    return jsonify({
                        'success': True,
                        'message': 'Login successful',
                        'user': {'email': account['email'], 'id': account['id']}
                    }), 200
                else:
                    logging.warning(f"Invalid password for {email}")
                    return jsonify({'success': False, 'message': 'Invalid credentials'}), 401
            else:
                logging.warning(f"Email {email} not found")
                return jsonify({'success': False, 'message': 'Invalid credentials'}), 401
        except Exception as e:
            logging.error(f"Unexpected error during login: {str(e)}")
            return jsonify({'success': False, 'message': f'Unexpected error: {str(e)}'}), 500

    @app.route('/check-auth', methods=['GET'])
    @app.route('/api/auth/check-auth', methods=['GET'])
    def check_auth():
        try:
            logging.debug(f"Checking auth with session: {dict(session)}")
            if 'loggedin' in session and 'user_id' in session:
                conn = get_db_connection()
                cursor = conn.cursor(dictionary=True)
                cursor.execute("SELECT email, first_name FROM login_details WHERE id = %s", (session['user_id'],))
                user = cursor.fetchone()
                cursor.close()
                if user:
                    logging.info(f"User {session.get('user_email')} is authenticated")
                    return jsonify({
                        'success': True,
                        'user': {
                            'email': user['email'],
                            'id': session['user_id'],
                            'first_name': user['first_name']
                        }
                    })
                else:
                    logging.warning("User not found in database")  
                    session.clear()
                    return jsonify({'success': False, 'message': 'User not found'}), 401
            logging.warning("User not authenticated")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        except Exception as e:
            logging.error(f"Error in check-auth endpoint: {str(e)}")
            return jsonify({'success': False, 'message': f'Server error: {str(e)}'}), 500

    @app.route('/register', methods=['POST'])
    @app.route('/api/auth/register', methods=['POST'])
    def register():
        first_name = request.form.get('first_name')
        last_name = request.form.get('last_name')
        email = request.form.get('email')
        mobile = request.form.get('mobile')
        password = request.form.get('password')
        confirm_password = request.form.get('confirm_password')

        if not all([first_name, last_name, email, mobile, password, confirm_password]):
            return jsonify({'success': False, 'message': 'All fields are required'}), 400
        if password != confirm_password:
            return jsonify({'success': False, 'message': 'Passwords do not match'}), 400

        hashed_password = bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
        try:
            conn = get_db_connection()
            cursor = conn.cursor()
            cursor.execute("""
                INSERT INTO login_details (first_name, last_name, email, mobile, password)
                VALUES (%s, %s, %s, %s, %s)
            """, (first_name, last_name, email, mobile, hashed_password))
            user_id = cursor.lastrowid
            conn.commit()
            cursor.close()
            session['loggedin'] = True
            session['user_email'] = email
            session['user_id'] = user_id
            return jsonify({
                'success': True,
                'message': 'Registration successful',
                'user': {'email': email, 'id': user_id}
            }), 200
        except mysql.connector.Error as e:
            logging.error(f"Database error during registration: {str(e)}")
            return jsonify({'success': False, 'message': f'Registration error: {str(e)}'}), 500

    @app.route('/logout', methods=['POST'])
    @app.route('/api/auth/logout', methods=['POST'])
    def logout():
        logging.info(f"User {session.get('user_email', 'unknown')} logged out")
        session.clear()
        return jsonify({'success': True, 'message': 'Logged out successfully'})

    # Template routes
    @app.route('/templates', methods=['GET'])
    @app.route('/api/templates', methods=['GET'])
    def get_templates():
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /templates: session missing")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("""
                SELECT template_id, template_name, created_at, status
                FROM excel_templates
                WHERE user_id = %s AND status = 'ACTIVE'
                ORDER BY created_at DESC
                LIMIT 100
            """, (session['user_id'],))
            templates = cursor.fetchall()
            cursor.close()
            logging.info(f"Fetched {len(templates)} templates for user {session['user_id']}")
            return jsonify({'success': True, 'templates': templates})
        except mysql.connector.Error as e:
            logging.error(f'Error fetching templates: {str(e)}')
            return jsonify({'success': False, 'message': f'Error fetching templates: {str(e)}'}), 500
        except Exception as e:
            logging.error(f'Unexpected error fetching templates: {str(e)}')
            return jsonify({'success': False, 'message': f'Unexpected error: {str(e)}'}), 500

    # Rule Configuration routes
    @app.route('/rule-configurations', methods=['GET'])
    @app.route('/api/validation/rule-configurations', methods=['GET'])
    def get_rule_configurations():
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning(f"Unauthorized access to /rule-configurations: session={dict(session)}")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            user_id = session['user_id']
            logging.debug(f"Fetching rule configurations for user_id: {user_id}")

            # Main query to fetch templates with configured rules
            cursor.execute("""
                SELECT 
                    t.template_id, 
                    t.template_name, 
                    t.created_at, 
                    COUNT(cvr.column_validation_id) as rule_count
                FROM excel_templates t
                LEFT JOIN template_columns tc ON t.template_id = tc.template_id
                LEFT JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                WHERE t.user_id = %s AND t.status = 'ACTIVE' AND t.is_corrected = FALSE
                GROUP BY t.template_id, t.template_name, t.created_at
                HAVING rule_count > 0
                ORDER BY t.created_at DESC
                LIMIT 100
            """, (user_id,))
            templates = cursor.fetchall()
            logging.debug(f"Fetched rule-configured templates: {templates}")

            cursor.close()

            if not templates:
                logging.info(f"No templates with rules found for user_id: {user_id}")
            else:
                logging.info(f"Found {len(templates)} templates with rules for user_id: {user_id}")

            return jsonify({'success': True, 'templates': templates})
        except mysql.connector.Error as e:
            logging.error(f"Database error fetching rule configurations: {str(e)}")
            return jsonify({'success': False, 'message': f"Database error: {str(e)}"}), 500
        except Exception as e:
            logging.error(f"Unexpected error fetching rule configurations: {str(e)}")
            return jsonify({'success': False, 'message': f"Unexpected error: {str(e)}"}), 500

    # File upload route
    @app.route('/upload', methods=['POST'])
    @app.route('/api/templates/upload', methods=['POST'])
    @app.route('/api/upload', methods=['POST'])  # Additional common path
    def upload():
        logging.info(f"Upload endpoint called: {request.endpoint}, method: {request.method}")
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /upload: session missing")
            return jsonify({'error': 'Not logged in'}), 401
        if 'file' not in request.files:
            logging.warning("No file provided in upload request")
            return jsonify({'error': 'No file uploaded'}), 400
        file = request.files['file']
        if file.filename == '':
            logging.warning("No file selected in upload request")
            return jsonify({'error': 'No file selected'}), 400
        
        file_path = os.path.join(app.config['UPLOAD_FOLDER'], file.filename)
        try:
            file.save(file_path)
            logging.info(f"File saved: {file_path}")
        except Exception as e:
            logging.error(f"Failed to save file {file.filename}: {str(e)}")
            return jsonify({'error': f'Failed to save file: {str(e)}'}), 500

        try:
            # Read the file to get sheets and headers
            if file.filename.endswith('.xlsx') or file.filename.endswith('.xls'):
                xl = pd.ExcelFile(file_path)
                sheets = {sheet_name: pd.read_excel(file_path, sheet_name=sheet_name, header=None) 
                         for sheet_name in xl.sheet_names}
            elif file.filename.endswith(('.txt', '.csv', '.dat')):
                df = pd.read_csv(file_path, header=None, encoding='utf-8')
                sheets = {'Sheet1': df}
            else:
                logging.error("Unsupported file type")
                return jsonify({'error': 'Unsupported file type'}), 400
            
            logging.debug(f"Sheets extracted: {list(sheets.keys())}")
        except Exception as e:
            logging.error(f"Failed to read file {file_path}: {str(e)}")
            return jsonify({'error': f'Failed to read file: {str(e)}'}), 400

        try:
            sheet_names = list(sheets.keys())
            if not sheet_names:
                logging.error("No sheets found in the file")
                return jsonify({'error': 'No sheets found in the file'}), 400
            sheet_name = sheet_names[0]
            df = sheets[sheet_name]
            
            # Find header row
            header_row = 0
            for i in range(min(len(df), 10)):
                row = df.iloc[i].dropna()
                if not row.empty and all(isinstance(x, str) for x in row if pd.notna(x)):
                    header_row = i
                    break
                    
            headers = df.iloc[header_row].tolist()
            logging.debug(f"Headers extracted: {headers}")
            
            if not headers or all(not h for h in headers):
                logging.error("No valid headers found in file")
                return jsonify({'error': 'No valid headers found in the file'}), 400
        except Exception as e:
            logging.error(f"Error processing file {file.filename}: {str(e)}")
            return jsonify({'error': f'Error processing file: {str(e)}'}), 400

        # Clear existing session data
        for key in ['df', 'header_row', 'headers', 'sheet_name', 'current_step', 'selected_headers', 'validations', 'error_cell_locations', 'data_rows', 'corrected_file_path']:
            session.pop(key, None)

        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)

            # Check if template exists
            cursor.execute("""
                SELECT template_id, headers, sheet_name
                FROM excel_templates
                WHERE template_name = %s AND user_id = %s AND status = 'ACTIVE'
                ORDER BY created_at DESC
            """, (file.filename, session['user_id']))
            existing_templates = cursor.fetchall()
            logging.info(f"Found {len(existing_templates)} existing templates with name {file.filename}")

            template_id = None
            has_existing_rules = False
            validations = {}
            selected_headers = []

            # Check for matching template
            matching_template = None
            for template in existing_templates:
                stored_headers = json.loads(template['headers']) if template['headers'] else []
                stored_sheet_name = template['sheet_name']
                if stored_headers == headers and stored_sheet_name == sheet_name:
                    matching_template = template
                    break

            if matching_template:
                template_id = matching_template['template_id']
                # Check for existing rules
                cursor.execute("""
                    SELECT tc.column_name, vrt.rule_name
                    FROM template_columns tc
                    JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                    JOIN validation_rule_types vrt ON cvr.rule_type_id = vrt.rule_type_id
                    WHERE tc.template_id = %s AND tc.is_selected = TRUE
                """, (template_id,))
                rules_data = cursor.fetchall()
                for row in rules_data:
                    column_name = row['column_name']
                    rule_name = row['rule_name']
                    if column_name not in validations:
                        validations[column_name] = []
                    validations[column_name].append(rule_name)
                    if column_name not in selected_headers:
                        selected_headers.append(column_name)
                has_existing_rules = len(validations) > 0
            else:
                # New template
                cursor.execute("""
                    INSERT INTO excel_templates (template_name, user_id, sheet_name, headers, is_corrected)
                    VALUES (%s, %s, %s, %s, %s)
                """, (file.filename, session['user_id'], sheet_name, json.dumps(headers), False))
                template_id = cursor.lastrowid
                column_data = [(template_id, header, i + 1, False) for i, header in enumerate(headers)]
                cursor.executemany("""
                    INSERT INTO template_columns (template_id, column_name, column_position, is_selected)
                    VALUES (%s, %s, %s, %s)
                """, column_data)

            conn.commit()
            cursor.close()

            # Store session data
            session['file_path'] = file_path
            session['template_id'] = template_id
            session['df'] = df.to_json()
            session['header_row'] = header_row
            session['headers'] = headers
            session['sheet_name'] = sheet_name
            session['current_step'] = 1 if not has_existing_rules else 3
            session['validations'] = validations
            session['selected_headers'] = selected_headers
            session['has_existing_rules'] = has_existing_rules

            logging.info(f"Upload processed: template_id={template_id}, filename={file.filename}, has_existing_rules={has_existing_rules}")

            return jsonify({
                'success': True,
                'sheets': {sheet_name: {'headers': headers}},
                'file_name': file.filename,
                'template_id': template_id,
                'has_existing_rules': has_existing_rules,
                'sheet_name': sheet_name,
                'skip_to_step_3': has_existing_rules
            })
        except mysql.connector.Error as e:
            logging.error(f'Error saving template: {str(e)}')
            return jsonify({'error': f'Error saving template: {str(e)}'}), 500
        except Exception as e:
            logging.error(f'Unexpected error saving template: {str(e)}')
            return jsonify({'error': f'Unexpected error: {str(e)}'}), 500

    # Multi-step workflow endpoints
    @app.route('/step/1', methods=['GET', 'POST'])
    @app.route('/api/step/1', methods=['GET', 'POST'])
    def step_one():
        if 'loggedin' not in session:
            return jsonify({'error': 'Not logged in'}), 401
        
        if request.method == 'POST':
            try:
                headers = request.form.getlist('headers')
                new_header_row = request.form.get('new_header_row')
                logging.debug(f"Step 1 submitted: headers={headers}, new_header_row={new_header_row}")
                
                if not headers:
                    logging.error("No headers provided in step 1")
                    return jsonify({'success': False, 'message': 'No headers provided'}), 400
                    
                if 'template_id' not in session:
                    logging.error("Session missing template_id")
                    return jsonify({'success': False, 'message': 'Session data missing'}), 400

                template_id = session['template_id']
                
                # Get the dataframe from session for auto-detection
                df_json = session.get('df')
                if df_json:
                    df = pd.read_json(StringIO(df_json))
                    session_headers = session.get('headers', [])
                    df.columns = session_headers
                    header_row = session.get('header_row', 0)
                    df = df.iloc[header_row + 1:].reset_index(drop=True)
                    
                    # Auto-detect rules for selected headers
                    validations = assign_default_rules_to_columns(df, headers)
                    session['validations'] = validations
                    logging.debug(f"Auto-assigned rules: {validations}")
                else:
                    validations = {}

                session['selected_headers'] = headers
                session['current_step'] = 2

                # Mark selected headers in the database
                conn = get_db_connection()
                cursor = conn.cursor()
                cursor.execute("UPDATE template_columns SET is_selected = FALSE WHERE template_id = %s", (template_id,))
                for header in headers:
                    cursor.execute("""
                        UPDATE template_columns
                        SET is_selected = TRUE
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    
                    # Get column_id and add auto-detected rules
                    cursor.execute("""
                        SELECT column_id FROM template_columns
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    result = cursor.fetchone()
                    if result:
                        column_id = result[0]
                        for rule_name in validations.get(header, []):
                            cursor.execute("""
                                SELECT rule_type_id FROM validation_rule_types
                                WHERE rule_name = %s AND is_custom = FALSE
                            """, (rule_name,))
                            rule_result = cursor.fetchone()
                            if rule_result:
                                rule_type_id = rule_result[0]
                                cursor.execute("""
                                    INSERT IGNORE INTO column_validation_rules (column_id, rule_type_id, rule_config)
                                    VALUES (%s, %s, %s)
                                """, (column_id, rule_type_id, '{}'))
                
                conn.commit()
                cursor.close()

                logging.info(f"Step 1 completed: headers={headers}, auto-assigned rules={validations}")
                return jsonify({'success': True, 'headers': headers, 'validations': validations})
            except Exception as e:
                logging.error(f"Error in step 1: {str(e)}")
                return jsonify({'success': False, 'message': str(e)}), 500
        
        # GET request - return current headers
        headers = session.get('headers', [])
        return jsonify({'headers': headers})

    @app.route('/step/2', methods=['GET', 'POST'])
    @app.route('/api/step/2', methods=['GET', 'POST'])
    def step_two():
        if 'loggedin' not in session:
            return jsonify({'error': 'Not logged in'}), 401
            
        if request.method == 'POST':
            try:
                action = request.form.get('action', 'save')
                validations = {}
                for key, values in request.form.lists():
                    if key.startswith('validations_'):
                        header = key.replace('validations_', '')
                        validations[header] = values
                        
                logging.debug(f"Step 2 submitted: action={action}, validations={validations}")
                
                template_id = session.get('template_id')
                if not template_id:
                    return jsonify({'success': False, 'message': 'Session data missing'}), 400

                # Save validations to database
                conn = get_db_connection()
                cursor = conn.cursor()
                
                # Clear existing rules
                cursor.execute("""
                    DELETE FROM column_validation_rules
                    WHERE column_id IN (
                        SELECT column_id FROM template_columns WHERE template_id = %s
                    )
                """, (template_id,))
                
                # Add new rules
                for header, rules in validations.items():
                    cursor.execute("""
                        SELECT column_id FROM template_columns
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    result = cursor.fetchone()
                    if not result:
                        continue
                    column_id = result[0]
                    
                    for rule_name in rules:
                        cursor.execute("""
                            SELECT rule_type_id FROM validation_rule_types
                            WHERE rule_name = %s
                        """, (rule_name,))
                        result = cursor.fetchone()
                        if result:
                            rule_type_id = result[0]
                            cursor.execute("""
                                INSERT IGNORE INTO column_validation_rules (column_id, rule_type_id, rule_config)
                                VALUES (%s, %s, %s)
                            """, (column_id, rule_type_id, '{}'))
                
                conn.commit()
                cursor.close()

                session['validations'] = validations
                session['current_step'] = 3 if action == 'review' else 2
                
                logging.info(f"Step 2 completed: action={action}, validations={validations}")
                return jsonify({'success': True, 'message': 'Step 2 completed successfully'})
            except Exception as e:
                logging.error(f"Error in step 2: {str(e)}")
                return jsonify({'success': False, 'message': str(e)}), 500
        
        # GET request
        selected_headers = session.get('selected_headers', [])
        return jsonify({'selected_headers': selected_headers})

    # Rules endpoint
    @app.route('/rules', methods=['GET'])
    @app.route('/api/rules', methods=['GET'])
    def get_rules():
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            
            cursor.execute("""
                SELECT rule_type_id AS rule_id, rule_name, description, parameters, is_custom, 
                       column_name, template_id, source_format, target_format, data_type, is_active
                FROM validation_rule_types
            """)
            rules = cursor.fetchall()
            cursor.close()
            
            logging.info(f"Returning {len(rules)} rules from getRules endpoint")
            return jsonify({'success': True, 'rules': rules})
        except mysql.connector.Error as e:
            logging.error(f"Database error fetching rules: {str(e)}")
            return jsonify({'success': False, 'message': str(e)}), 500
        except Exception as e:
            logging.error(f"Unexpected error fetching rules: {str(e)}")
            return jsonify({'success': False, 'message': str(e)}), 500

    # Template details endpoint
    @app.route('/template/<int:template_id>/<sheet_name>', methods=['GET'])
    @app.route('/api/template/<int:template_id>/<sheet_name>', methods=['GET'])
    def get_template(template_id, sheet_name):
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /template: session missing")
            return jsonify({'error': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("""
                SELECT template_name, sheet_name, headers
                FROM excel_templates
                WHERE template_id = %s AND user_id = %s AND status = 'ACTIVE'
            """, (template_id, session['user_id']))
            template_record = cursor.fetchone()
            
            if not template_record:
                logging.error(f"Template not found for template_id: {template_id}, user_id: {session['user_id']}")
                cursor.close()
                return jsonify({'error': 'Template not found'}), 404

            headers = json.loads(template_record['headers']) if template_record['headers'] else []
            stored_sheet_name = template_record['sheet_name'] or sheet_name
            file_path = os.path.join(app.config['UPLOAD_FOLDER'], template_record['template_name'])
            
            cursor.execute("""
                SELECT COUNT(*) as rule_count
                FROM template_columns tc
                JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                WHERE tc.template_id = %s AND tc.is_selected = TRUE
            """, (template_id,))
            rule_count = cursor.fetchone()['rule_count']
            has_existing_rules = rule_count > 0
            
            cursor.close()
            
            return jsonify({
                'success': True,
                'sheets': {stored_sheet_name: {'headers': headers}},
                'file_name': template_record['template_name'],
                'file_path': file_path,
                'sheet_name': stored_sheet_name,
                'has_existing_rules': has_existing_rules
            })
        except mysql.connector.Error as e:
            logging.error(f"Database error in get_template: {str(e)}")
            return jsonify({'error': f'Database error: {str(e)}'}), 500
        except Exception as e:
            logging.error(f"Unexpected error in get_template: {str(e)}")
            return jsonify({'error': f'Unexpected error: {str(e)}'}), 500

    # Debug route to show all registered routes
    @app.route('/debug/routes', methods=['GET'])
    def list_routes():
        routes = []
        for rule in app.url_map.iter_rules():
            routes.append({
                'endpoint': rule.endpoint,
                'methods': list(rule.methods),
                'rule': rule.rule
            })
        return jsonify(routes)

    # 404 handler to debug missing routes
    @app.errorhandler(404)
    def not_found_handler(error):
        logging.error(f"404 Error: {request.method} {request.url} not found")
        logging.error(f"Available routes: {[rule.rule for rule in app.url_map.iter_rules()]}")
        return jsonify({
            'error': 'Endpoint not found', 
            'method': request.method,
            'url': request.url,
            'path': request.path
        }), 404

    return app

def initialize_app_data():
    """Initialize database and create default data"""
    try:
        logging.info("Initializing database schema...")
        init_db()
        
        logging.info("Creating admin user...")
        create_admin_user()
        
        logging.info("Creating default validation rules...")
        create_default_validation_rules()
        
        logging.info("Application initialization completed successfully")
    except Exception as e:
        logging.error(f"Failed to initialize application: {e}")
        raise

DB_CONFIG = {
    'host': os.getenv('MYSQL_HOST', 'localhost'),
    'user': os.getenv('MYSQL_USER', 'root'),
    'password': os.getenv('MYSQL_PASSWORD', 'Keansa@2024'),
    'database': os.getenv('MYSQL_DATABASE', 'data_validation_2'),
}

def get_db_connection():
    if 'db' not in g:
        try:
            conn = mysql.connector.connect(
                host=DB_CONFIG['host'],
                user=DB_CONFIG['user'],
                password=DB_CONFIG['password']
            )
            cursor = conn.cursor()
            cursor.execute(f"CREATE DATABASE IF NOT EXISTS {DB_CONFIG['database']}")
            cursor.close()
            conn.close()
            g.db = mysql.connector.connect(**DB_CONFIG)
            logging.info("Database connection established successfully")
        except mysql.connector.Error as err:
            if err.errno == errorcode.ER_ACCESS_DENIED_ERROR:
                logging.error("Database connection failed: Access denied for user - check username/password")
            elif err.errno == errorcode.ER_BAD_DB_ERROR:
                logging.error("Database connection failed: Database does not exist")
            else:
                logging.error(f"Database connection failed: {err}")
            raise Exception(f"Failed to connect to database: {str(err)}")
    return g.db

def close_db(error):
    db = g.pop('db', None)
    if db is not None:
        db.close()

def init_db():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        tables = [
            """
            CREATE TABLE IF NOT EXISTS login_details (
                id INT AUTO_INCREMENT PRIMARY KEY,
                first_name VARCHAR(100),
                last_name VARCHAR(100),
                email VARCHAR(255) UNIQUE,
                mobile VARCHAR(10),
                password VARCHAR(255)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS excel_templates (
                template_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_name VARCHAR(255) NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
                user_id INT NOT NULL,
                sheet_name VARCHAR(255),
                headers JSON,
                status ENUM('ACTIVE', 'INACTIVE') DEFAULT 'ACTIVE',
                is_corrected BOOLEAN DEFAULT FALSE,
                remote_file_path VARCHAR(512),
                FOREIGN KEY (user_id) REFERENCES login_details(id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS template_columns (
                column_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_id BIGINT NOT NULL,
                column_name VARCHAR(255) NOT NULL,
                column_position INT NOT NULL,
                is_validation_enabled BOOLEAN DEFAULT FALSE,
                is_selected BOOLEAN DEFAULT FALSE,
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE,
                UNIQUE (template_id, column_name)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_rule_types (
                rule_type_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                rule_name VARCHAR(255) NOT NULL,
                description TEXT,
                parameters TEXT,
                is_active BOOLEAN DEFAULT TRUE,
                is_custom BOOLEAN DEFAULT FALSE,
                column_name VARCHAR(255),
                template_id BIGINT,
                data_type VARCHAR(50),
                source_format VARCHAR(50),
                target_format VARCHAR(50),
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS column_validation_rules (
                column_validation_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                column_id BIGINT NOT NULL,
                rule_type_id BIGINT NOT NULL,
                rule_config JSON,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (column_id) REFERENCES template_columns(column_id) ON DELETE CASCADE,
                FOREIGN KEY (rule_type_id) REFERENCES validation_rule_types(rule_type_id) ON DELETE RESTRICT,
                UNIQUE (column_id, rule_type_id)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_history (
                history_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_id BIGINT NOT NULL,
                template_name VARCHAR(255) NOT NULL,
                error_count INT NOT NULL,
                corrected_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                corrected_file_path VARCHAR(512) NOT NULL,
                user_id INT NOT NULL,
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE,
                FOREIGN KEY (user_id) REFERENCES login_details(id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_corrections (
                correction_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                history_id BIGINT NOT NULL,
                row_index INT NOT NULL,
                column_name VARCHAR(255) NOT NULL,
                original_value TEXT,
                corrected_value TEXT,
                rule_failed VARCHAR(255) DEFAULT NULL,
                FOREIGN KEY (history_id) REFERENCES validation_history(history_id) ON DELETE CASCADE
            )
            """
        ]
        for table_sql in tables:
            cursor.execute(table_sql)
        
        # Add missing columns if they don't exist
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'source_format'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN source_format VARCHAR(50)")
            logging.info("Added source_format column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'target_format'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN target_format VARCHAR(50)")
            logging.info("Added target_format column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'data_type'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN data_type VARCHAR(50)")
            logging.info("Added data_type column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM excel_templates LIKE 'remote_file_path'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE excel_templates ADD COLUMN remote_file_path VARCHAR(512)")
            logging.info("Added remote_file_path column to excel_templates table")
            
        cursor.execute("SHOW COLUMNS FROM template_columns LIKE 'is_selected'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE template_columns ADD COLUMN is_selected BOOLEAN DEFAULT FALSE")
            logging.info("Added is_selected column to template_columns table")
            
        conn.commit()
        cursor.close()
        logging.info("Database tables initialized")
    except Exception as e:
        logging.error(f"Failed to initialize database: {str(e)}")
        raise

def create_admin_user():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        admin_password = bcrypt.hashpw('admin'.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
        cursor.execute("""
            INSERT IGNORE INTO login_details (first_name, last_name, email, mobile, password)
            VALUES (%s, %s, %s, %s, %s)
        """, ('Admin', 'User', 'admin@example.com', '1234567890', admin_password))
        conn.commit()
        cursor.close()
        logging.info("Admin user created or already exists")
    except Exception as e:
        logging.error(f"Failed to create admin user: {str(e)}")
        raise

def create_default_validation_rules():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        default_rules = [
            ("Required", "Ensures the field is not null", '{"allow_null": false}', None, None, None),
            ("Int", "Validates integer format", '{"format": "integer"}', None, None, "Int"),
            ("Float", "Validates number format (integer or decimal)", '{"format": "float"}', None, None, "Float"),
            ("Text", "Allows text with quotes and parentheses", '{"allow_special": false}', None, None, "Text"),
            ("Email", "Validates email format", '{"regex": "^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\\\.[a-zA-Z0-9-.]+$"}', None, None, "Email"),
            ("Date(DD-MM-YYYY)", "Validates date format DD-MM-YYYY", '{"format": "%d-%m-%Y"}', "DD-MM-YYYY", None, "Date"),
            ("Boolean", "Validates boolean format (true/false or 0/1)", '{"format": "boolean"}', None, None, "Boolean"),
            ("Alphanumeric", "Validates alphanumeric format", '{"format": "alphanumeric"}', None, None, "Alphanumeric")
        ]
        cursor.executemany("""
            INSERT IGNORE INTO validation_rule_types (rule_name, description, parameters, is_custom, source_format, target_format, data_type)
            VALUES (%s, %s, %s, %s, %s, %s, %s)
        """, [(name, desc, params, False, source, target, dtype) for name, desc, params, source, target, dtype in default_rules])
        conn.commit()
        cursor.close()
        logging.info("Default validation rules ensured successfully")
    except Exception as e:
        logging.error(f"Failed to ensure default validation rules: {str(e)}")
        raise

if __name__ == '__main__':
    try:
        # Create the application using factory pattern
        app = create_app()
        
        # Initialize database and default data within app context
        with app.app_context():
            initialize_app_data()
        
        # Get port from environment or use default
        port = int(os.getenv('PORT', 5000))
        
        # Start the application server
        logging.info("Starting Flask server...")
        app.run(debug=True, host='0.0.0.0', port=port)
        
    except Exception as e:
        logging.error(f"Failed to start application: {e}")
        raise
).any():
        return "Email"

def create_app():
    """Application factory pattern for different environments"""
    # Set the path to the frontend dist folder
    current_dir = os.path.dirname(os.path.abspath(__file__))
    frontend_dist_path = os.path.join(current_dir, '..', '..', 'Keansa-Ai-Suite2025may-frontend11', 'dist')
    frontend_dist_path = os.path.abspath(frontend_dist_path)
    
    # Create Flask application instance
    app = Flask(__name__, static_folder=frontend_dist_path, static_url_path='')
    CORS(app, supports_credentials=True, origins=["http://localhost:3000", "http://localhost:8080", "http://localhost:5000", "*"])

    app.secret_key = os.urandom(24).hex()
    app.config['SESSION_TYPE'] = 'filesystem'
    app.config['SESSION_FILE_DIR'] = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'sessions')
    app.config['SESSION_COOKIE_SAMESITE'] = 'Lax'
    app.config['SESSION_COOKIE_HTTPONLY'] = True
    app.config['SESSION_COOKIE_SECURE'] = False
    app.config['PERMANENT_SESSION_LIFETIME'] = 86400  # 24 hours
    app.config['UPLOAD_FOLDER'] = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'uploads')
    Session(app)

    # Ensure directories exist
    try:
        os.makedirs(app.config['UPLOAD_FOLDER'], exist_ok=True)
        os.makedirs(app.config['SESSION_FILE_DIR'], exist_ok=True)
    except OSError as e:
        logging.error(f"Failed to create directories: {e}")

    # Register cleanup handlers
    app.teardown_appcontext(close_db)
    
    # Register all routes directly in create_app
    
    # Static file serving for React frontend
    @app.route('/', defaults={'path': ''})
    @app.route('/<path:path>')
    def serve(path):
        if path and os.path.exists(os.path.join(app.static_folder, path)):
            return app.send_static_file(path)
        return app.send_static_file('index.html')

    # Health check endpoint
    @app.route('/health', methods=['GET'])
    def health_check():
        return jsonify({
            'status': 'healthy',
            'timestamp': datetime.now().isoformat(),
            'version': '2.0.0'
        })

    # Authentication endpoint - both old and new paths
    @app.route('/authenticate', methods=['POST'])
    @app.route('/api/auth/authenticate', methods=['POST'])
    def authenticate():
        try:
            email = request.form.get('username') or request.form.get('email')
            password = request.form.get('password')
            logging.debug(f"Login attempt: email={email}, password={'*' * len(password) if password else 'None'}")
            
            if not email or not password:
                logging.warning(f"Login failed: Email or password missing")
                return jsonify({'success': False, 'message': 'Email and password are required'}), 400

            # Check for admin login
            if email == "admin" and password == "admin":
                session['loggedin'] = True
                session['user_email'] = "admin@example.com"
                session['user_id'] = 1
                session.permanent = True
                logging.info(f"Admin login successful. Session: {dict(session)}")
                return jsonify({'success': True, 'message': 'Login successful', 'user': {'email': 'admin@example.com', 'id': 1}}), 200

            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("SELECT * FROM login_details WHERE LOWER(email) = LOWER(%s)", (email.lower(),))
            account = cursor.fetchone()
            cursor.close()
            
            if account:
                if bcrypt.checkpw(password.encode('utf-8'), account['password'].encode('utf-8')):
                    session['loggedin'] = True
                    session['user_email'] = account['email']
                    session['user_id'] = account['id']
                    session.permanent = True
                    logging.info(f"User {email} logged in successfully. Session: {dict(session)}")
                    return jsonify({
                        'success': True,
                        'message': 'Login successful',
                        'user': {'email': account['email'], 'id': account['id']}
                    }), 200
                else:
                    logging.warning(f"Invalid password for {email}")
                    return jsonify({'success': False, 'message': 'Invalid credentials'}), 401
            else:
                logging.warning(f"Email {email} not found")
                return jsonify({'success': False, 'message': 'Invalid credentials'}), 401
        except Exception as e:
            logging.error(f"Unexpected error during login: {str(e)}")
            return jsonify({'success': False, 'message': f'Unexpected error: {str(e)}'}), 500

    @app.route('/check-auth', methods=['GET'])
    @app.route('/api/auth/check-auth', methods=['GET'])
    def check_auth():
        try:
            logging.debug(f"Checking auth with session: {dict(session)}")
            if 'loggedin' in session and 'user_id' in session:
                conn = get_db_connection()
                cursor = conn.cursor(dictionary=True)
                cursor.execute("SELECT email, first_name FROM login_details WHERE id = %s", (session['user_id'],))
                user = cursor.fetchone()
                cursor.close()
                if user:
                    logging.info(f"User {session.get('user_email')} is authenticated")
                    return jsonify({
                        'success': True,
                        'user': {
                            'email': user['email'],
                            'id': session['user_id'],
                            'first_name': user['first_name']
                        }
                    })
                else:
                    logging.warning("User not found in database")  
                    session.clear()
                    return jsonify({'success': False, 'message': 'User not found'}), 401
            logging.warning("User not authenticated")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        except Exception as e:
            logging.error(f"Error in check-auth endpoint: {str(e)}")
            return jsonify({'success': False, 'message': f'Server error: {str(e)}'}), 500

    @app.route('/register', methods=['POST'])
    @app.route('/api/auth/register', methods=['POST'])
    def register():
        first_name = request.form.get('first_name')
        last_name = request.form.get('last_name')
        email = request.form.get('email')
        mobile = request.form.get('mobile')
        password = request.form.get('password')
        confirm_password = request.form.get('confirm_password')

        if not all([first_name, last_name, email, mobile, password, confirm_password]):
            return jsonify({'success': False, 'message': 'All fields are required'}), 400
        if password != confirm_password:
            return jsonify({'success': False, 'message': 'Passwords do not match'}), 400

        hashed_password = bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
        try:
            conn = get_db_connection()
            cursor = conn.cursor()
            cursor.execute("""
                INSERT INTO login_details (first_name, last_name, email, mobile, password)
                VALUES (%s, %s, %s, %s, %s)
            """, (first_name, last_name, email, mobile, hashed_password))
            user_id = cursor.lastrowid
            conn.commit()
            cursor.close()
            session['loggedin'] = True
            session['user_email'] = email
            session['user_id'] = user_id
            return jsonify({
                'success': True,
                'message': 'Registration successful',
                'user': {'email': email, 'id': user_id}
            }), 200
        except mysql.connector.Error as e:
            logging.error(f"Database error during registration: {str(e)}")
            return jsonify({'success': False, 'message': f'Registration error: {str(e)}'}), 500

    @app.route('/logout', methods=['POST'])
    @app.route('/api/auth/logout', methods=['POST'])
    def logout():
        logging.info(f"User {session.get('user_email', 'unknown')} logged out")
        session.clear()
        return jsonify({'success': True, 'message': 'Logged out successfully'})

    # Template routes
    @app.route('/templates', methods=['GET'])
    @app.route('/api/templates', methods=['GET'])
    def get_templates():
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /templates: session missing")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("""
                SELECT template_id, template_name, created_at, status
                FROM excel_templates
                WHERE user_id = %s AND status = 'ACTIVE'
                ORDER BY created_at DESC
                LIMIT 100
            """, (session['user_id'],))
            templates = cursor.fetchall()
            cursor.close()
            logging.info(f"Fetched {len(templates)} templates for user {session['user_id']}")
            return jsonify({'success': True, 'templates': templates})
        except mysql.connector.Error as e:
            logging.error(f'Error fetching templates: {str(e)}')
            return jsonify({'success': False, 'message': f'Error fetching templates: {str(e)}'}), 500
        except Exception as e:
            logging.error(f'Unexpected error fetching templates: {str(e)}')
            return jsonify({'success': False, 'message': f'Unexpected error: {str(e)}'}), 500

    # Rule Configuration routes
    @app.route('/rule-configurations', methods=['GET'])
    @app.route('/api/validation/rule-configurations', methods=['GET'])
    def get_rule_configurations():
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning(f"Unauthorized access to /rule-configurations: session={dict(session)}")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            user_id = session['user_id']
            logging.debug(f"Fetching rule configurations for user_id: {user_id}")

            # Main query to fetch templates with configured rules
            cursor.execute("""
                SELECT 
                    t.template_id, 
                    t.template_name, 
                    t.created_at, 
                    COUNT(cvr.column_validation_id) as rule_count
                FROM excel_templates t
                LEFT JOIN template_columns tc ON t.template_id = tc.template_id
                LEFT JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                WHERE t.user_id = %s AND t.status = 'ACTIVE' AND t.is_corrected = FALSE
                GROUP BY t.template_id, t.template_name, t.created_at
                HAVING rule_count > 0
                ORDER BY t.created_at DESC
                LIMIT 100
            """, (user_id,))
            templates = cursor.fetchall()
            logging.debug(f"Fetched rule-configured templates: {templates}")

            cursor.close()

            if not templates:
                logging.info(f"No templates with rules found for user_id: {user_id}")
            else:
                logging.info(f"Found {len(templates)} templates with rules for user_id: {user_id}")

            return jsonify({'success': True, 'templates': templates})
        except mysql.connector.Error as e:
            logging.error(f"Database error fetching rule configurations: {str(e)}")
            return jsonify({'success': False, 'message': f"Database error: {str(e)}"}), 500
        except Exception as e:
            logging.error(f"Unexpected error fetching rule configurations: {str(e)}")
            return jsonify({'success': False, 'message': f"Unexpected error: {str(e)}"}), 500

    # File upload route
    @app.route('/upload', methods=['POST'])
    @app.route('/api/templates/upload', methods=['POST'])
    @app.route('/api/upload', methods=['POST'])  # Additional common path
    def upload():
        logging.info(f"Upload endpoint called: {request.endpoint}, method: {request.method}")
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /upload: session missing")
            return jsonify({'error': 'Not logged in'}), 401
        if 'file' not in request.files:
            logging.warning("No file provided in upload request")
            return jsonify({'error': 'No file uploaded'}), 400
        file = request.files['file']
        if file.filename == '':
            logging.warning("No file selected in upload request")
            return jsonify({'error': 'No file selected'}), 400
        
        file_path = os.path.join(app.config['UPLOAD_FOLDER'], file.filename)
        try:
            file.save(file_path)
            logging.info(f"File saved: {file_path}")
        except Exception as e:
            logging.error(f"Failed to save file {file.filename}: {str(e)}")
            return jsonify({'error': f'Failed to save file: {str(e)}'}), 500

        try:
            # Read the file to get sheets and headers
            if file.filename.endswith('.xlsx') or file.filename.endswith('.xls'):
                xl = pd.ExcelFile(file_path)
                sheets = {sheet_name: pd.read_excel(file_path, sheet_name=sheet_name, header=None) 
                         for sheet_name in xl.sheet_names}
            elif file.filename.endswith(('.txt', '.csv', '.dat')):
                df = pd.read_csv(file_path, header=None, encoding='utf-8')
                sheets = {'Sheet1': df}
            else:
                logging.error("Unsupported file type")
                return jsonify({'error': 'Unsupported file type'}), 400
            
            logging.debug(f"Sheets extracted: {list(sheets.keys())}")
        except Exception as e:
            logging.error(f"Failed to read file {file_path}: {str(e)}")
            return jsonify({'error': f'Failed to read file: {str(e)}'}), 400

        try:
            sheet_names = list(sheets.keys())
            if not sheet_names:
                logging.error("No sheets found in the file")
                return jsonify({'error': 'No sheets found in the file'}), 400
            sheet_name = sheet_names[0]
            df = sheets[sheet_name]
            
            # Find header row
            header_row = 0
            for i in range(min(len(df), 10)):
                row = df.iloc[i].dropna()
                if not row.empty and all(isinstance(x, str) for x in row if pd.notna(x)):
                    header_row = i
                    break
                    
            headers = df.iloc[header_row].tolist()
            logging.debug(f"Headers extracted: {headers}")
            
            if not headers or all(not h for h in headers):
                logging.error("No valid headers found in file")
                return jsonify({'error': 'No valid headers found in the file'}), 400
        except Exception as e:
            logging.error(f"Error processing file {file.filename}: {str(e)}")
            return jsonify({'error': f'Error processing file: {str(e)}'}), 400

        # Clear existing session data
        for key in ['df', 'header_row', 'headers', 'sheet_name', 'current_step', 'selected_headers', 'validations', 'error_cell_locations', 'data_rows', 'corrected_file_path']:
            session.pop(key, None)

        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)

            # Check if template exists
            cursor.execute("""
                SELECT template_id, headers, sheet_name
                FROM excel_templates
                WHERE template_name = %s AND user_id = %s AND status = 'ACTIVE'
                ORDER BY created_at DESC
            """, (file.filename, session['user_id']))
            existing_templates = cursor.fetchall()
            logging.info(f"Found {len(existing_templates)} existing templates with name {file.filename}")

            template_id = None
            has_existing_rules = False
            validations = {}
            selected_headers = []

            # Check for matching template
            matching_template = None
            for template in existing_templates:
                stored_headers = json.loads(template['headers']) if template['headers'] else []
                stored_sheet_name = template['sheet_name']
                if stored_headers == headers and stored_sheet_name == sheet_name:
                    matching_template = template
                    break

            if matching_template:
                template_id = matching_template['template_id']
                # Check for existing rules
                cursor.execute("""
                    SELECT tc.column_name, vrt.rule_name
                    FROM template_columns tc
                    JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                    JOIN validation_rule_types vrt ON cvr.rule_type_id = vrt.rule_type_id
                    WHERE tc.template_id = %s AND tc.is_selected = TRUE
                """, (template_id,))
                rules_data = cursor.fetchall()
                for row in rules_data:
                    column_name = row['column_name']
                    rule_name = row['rule_name']
                    if column_name not in validations:
                        validations[column_name] = []
                    validations[column_name].append(rule_name)
                    if column_name not in selected_headers:
                        selected_headers.append(column_name)
                has_existing_rules = len(validations) > 0
            else:
                # New template
                cursor.execute("""
                    INSERT INTO excel_templates (template_name, user_id, sheet_name, headers, is_corrected)
                    VALUES (%s, %s, %s, %s, %s)
                """, (file.filename, session['user_id'], sheet_name, json.dumps(headers), False))
                template_id = cursor.lastrowid
                column_data = [(template_id, header, i + 1, False) for i, header in enumerate(headers)]
                cursor.executemany("""
                    INSERT INTO template_columns (template_id, column_name, column_position, is_selected)
                    VALUES (%s, %s, %s, %s)
                """, column_data)

            conn.commit()
            cursor.close()

            # Store session data
            session['file_path'] = file_path
            session['template_id'] = template_id
            session['df'] = df.to_json()
            session['header_row'] = header_row
            session['headers'] = headers
            session['sheet_name'] = sheet_name
            session['current_step'] = 1 if not has_existing_rules else 3
            session['validations'] = validations
            session['selected_headers'] = selected_headers
            session['has_existing_rules'] = has_existing_rules

            logging.info(f"Upload processed: template_id={template_id}, filename={file.filename}, has_existing_rules={has_existing_rules}")

            return jsonify({
                'success': True,
                'sheets': {sheet_name: {'headers': headers}},
                'file_name': file.filename,
                'template_id': template_id,
                'has_existing_rules': has_existing_rules,
                'sheet_name': sheet_name,
                'skip_to_step_3': has_existing_rules
            })
        except mysql.connector.Error as e:
            logging.error(f'Error saving template: {str(e)}')
            return jsonify({'error': f'Error saving template: {str(e)}'}), 500
        except Exception as e:
            logging.error(f'Unexpected error saving template: {str(e)}')
            return jsonify({'error': f'Unexpected error: {str(e)}'}), 500

    # Multi-step workflow endpoints
    @app.route('/step/1', methods=['GET', 'POST'])
    @app.route('/api/step/1', methods=['GET', 'POST'])
    def step_one():
        if 'loggedin' not in session:
            return jsonify({'error': 'Not logged in'}), 401
        
        if request.method == 'POST':
            try:
                headers = request.form.getlist('headers')
                new_header_row = request.form.get('new_header_row')
                logging.debug(f"Step 1 submitted: headers={headers}, new_header_row={new_header_row}")
                
                if not headers:
                    logging.error("No headers provided in step 1")
                    return jsonify({'success': False, 'message': 'No headers provided'}), 400
                    
                if 'template_id' not in session:
                    logging.error("Session missing template_id")
                    return jsonify({'success': False, 'message': 'Session data missing'}), 400

                template_id = session['template_id']
                
                # Get the dataframe from session for auto-detection
                df_json = session.get('df')
                if df_json:
                    df = pd.read_json(StringIO(df_json))
                    session_headers = session.get('headers', [])
                    df.columns = session_headers
                    header_row = session.get('header_row', 0)
                    df = df.iloc[header_row + 1:].reset_index(drop=True)
                    
                    # Auto-detect rules for selected headers
                    validations = assign_default_rules_to_columns(df, headers)
                    session['validations'] = validations
                    logging.debug(f"Auto-assigned rules: {validations}")
                else:
                    validations = {}

                session['selected_headers'] = headers
                session['current_step'] = 2

                # Mark selected headers in the database
                conn = get_db_connection()
                cursor = conn.cursor()
                cursor.execute("UPDATE template_columns SET is_selected = FALSE WHERE template_id = %s", (template_id,))
                for header in headers:
                    cursor.execute("""
                        UPDATE template_columns
                        SET is_selected = TRUE
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    
                    # Get column_id and add auto-detected rules
                    cursor.execute("""
                        SELECT column_id FROM template_columns
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    result = cursor.fetchone()
                    if result:
                        column_id = result[0]
                        for rule_name in validations.get(header, []):
                            cursor.execute("""
                                SELECT rule_type_id FROM validation_rule_types
                                WHERE rule_name = %s AND is_custom = FALSE
                            """, (rule_name,))
                            rule_result = cursor.fetchone()
                            if rule_result:
                                rule_type_id = rule_result[0]
                                cursor.execute("""
                                    INSERT IGNORE INTO column_validation_rules (column_id, rule_type_id, rule_config)
                                    VALUES (%s, %s, %s)
                                """, (column_id, rule_type_id, '{}'))
                
                conn.commit()
                cursor.close()

                logging.info(f"Step 1 completed: headers={headers}, auto-assigned rules={validations}")
                return jsonify({'success': True, 'headers': headers, 'validations': validations})
            except Exception as e:
                logging.error(f"Error in step 1: {str(e)}")
                return jsonify({'success': False, 'message': str(e)}), 500
        
        # GET request - return current headers
        headers = session.get('headers', [])
        return jsonify({'headers': headers})

    @app.route('/step/2', methods=['GET', 'POST'])
    @app.route('/api/step/2', methods=['GET', 'POST'])
    def step_two():
        if 'loggedin' not in session:
            return jsonify({'error': 'Not logged in'}), 401
            
        if request.method == 'POST':
            try:
                action = request.form.get('action', 'save')
                validations = {}
                for key, values in request.form.lists():
                    if key.startswith('validations_'):
                        header = key.replace('validations_', '')
                        validations[header] = values
                        
                logging.debug(f"Step 2 submitted: action={action}, validations={validations}")
                
                template_id = session.get('template_id')
                if not template_id:
                    return jsonify({'success': False, 'message': 'Session data missing'}), 400

                # Save validations to database
                conn = get_db_connection()
                cursor = conn.cursor()
                
                # Clear existing rules
                cursor.execute("""
                    DELETE FROM column_validation_rules
                    WHERE column_id IN (
                        SELECT column_id FROM template_columns WHERE template_id = %s
                    )
                """, (template_id,))
                
                # Add new rules
                for header, rules in validations.items():
                    cursor.execute("""
                        SELECT column_id FROM template_columns
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    result = cursor.fetchone()
                    if not result:
                        continue
                    column_id = result[0]
                    
                    for rule_name in rules:
                        cursor.execute("""
                            SELECT rule_type_id FROM validation_rule_types
                            WHERE rule_name = %s
                        """, (rule_name,))
                        result = cursor.fetchone()
                        if result:
                            rule_type_id = result[0]
                            cursor.execute("""
                                INSERT IGNORE INTO column_validation_rules (column_id, rule_type_id, rule_config)
                                VALUES (%s, %s, %s)
                            """, (column_id, rule_type_id, '{}'))
                
                conn.commit()
                cursor.close()

                session['validations'] = validations
                session['current_step'] = 3 if action == 'review' else 2
                
                logging.info(f"Step 2 completed: action={action}, validations={validations}")
                return jsonify({'success': True, 'message': 'Step 2 completed successfully'})
            except Exception as e:
                logging.error(f"Error in step 2: {str(e)}")
                return jsonify({'success': False, 'message': str(e)}), 500
        
        # GET request
        selected_headers = session.get('selected_headers', [])
        return jsonify({'selected_headers': selected_headers})

    # Rules endpoint
    @app.route('/rules', methods=['GET'])
    @app.route('/api/rules', methods=['GET'])
    def get_rules():
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            
            cursor.execute("""
                SELECT rule_type_id AS rule_id, rule_name, description, parameters, is_custom, 
                       column_name, template_id, source_format, target_format, data_type, is_active
                FROM validation_rule_types
            """)
            rules = cursor.fetchall()
            cursor.close()
            
            logging.info(f"Returning {len(rules)} rules from getRules endpoint")
            return jsonify({'success': True, 'rules': rules})
        except mysql.connector.Error as e:
            logging.error(f"Database error fetching rules: {str(e)}")
            return jsonify({'success': False, 'message': str(e)}), 500
        except Exception as e:
            logging.error(f"Unexpected error fetching rules: {str(e)}")
            return jsonify({'success': False, 'message': str(e)}), 500

    # Template details endpoint
    @app.route('/template/<int:template_id>/<sheet_name>', methods=['GET'])
    @app.route('/api/template/<int:template_id>/<sheet_name>', methods=['GET'])
    def get_template(template_id, sheet_name):
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /template: session missing")
            return jsonify({'error': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("""
                SELECT template_name, sheet_name, headers
                FROM excel_templates
                WHERE template_id = %s AND user_id = %s AND status = 'ACTIVE'
            """, (template_id, session['user_id']))
            template_record = cursor.fetchone()
            
            if not template_record:
                logging.error(f"Template not found for template_id: {template_id}, user_id: {session['user_id']}")
                cursor.close()
                return jsonify({'error': 'Template not found'}), 404

            headers = json.loads(template_record['headers']) if template_record['headers'] else []
            stored_sheet_name = template_record['sheet_name'] or sheet_name
            file_path = os.path.join(app.config['UPLOAD_FOLDER'], template_record['template_name'])
            
            cursor.execute("""
                SELECT COUNT(*) as rule_count
                FROM template_columns tc
                JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                WHERE tc.template_id = %s AND tc.is_selected = TRUE
            """, (template_id,))
            rule_count = cursor.fetchone()['rule_count']
            has_existing_rules = rule_count > 0
            
            cursor.close()
            
            return jsonify({
                'success': True,
                'sheets': {stored_sheet_name: {'headers': headers}},
                'file_name': template_record['template_name'],
                'file_path': file_path,
                'sheet_name': stored_sheet_name,
                'has_existing_rules': has_existing_rules
            })
        except mysql.connector.Error as e:
            logging.error(f"Database error in get_template: {str(e)}")
            return jsonify({'error': f'Database error: {str(e)}'}), 500
        except Exception as e:
            logging.error(f"Unexpected error in get_template: {str(e)}")
            return jsonify({'error': f'Unexpected error: {str(e)}'}), 500

    # Debug route to show all registered routes
    @app.route('/debug/routes', methods=['GET'])
    def list_routes():
        routes = []
        for rule in app.url_map.iter_rules():
            routes.append({
                'endpoint': rule.endpoint,
                'methods': list(rule.methods),
                'rule': rule.rule
            })
        return jsonify(routes)

    # 404 handler to debug missing routes
    @app.errorhandler(404)
    def not_found_handler(error):
        logging.error(f"404 Error: {request.method} {request.url} not found")
        logging.error(f"Available routes: {[rule.rule for rule in app.url_map.iter_rules()]}")
        return jsonify({
            'error': 'Endpoint not found', 
            'method': request.method,
            'url': request.url,
            'path': request.path
        }), 404

    return app

def initialize_app_data():
    """Initialize database and create default data"""
    try:
        logging.info("Initializing database schema...")
        init_db()
        
        logging.info("Creating admin user...")
        create_admin_user()
        
        logging.info("Creating default validation rules...")
        create_default_validation_rules()
        
        logging.info("Application initialization completed successfully")
    except Exception as e:
        logging.error(f"Failed to initialize application: {e}")
        raise

DB_CONFIG = {
    'host': os.getenv('MYSQL_HOST', 'localhost'),
    'user': os.getenv('MYSQL_USER', 'root'),
    'password': os.getenv('MYSQL_PASSWORD', 'Keansa@2024'),
    'database': os.getenv('MYSQL_DATABASE', 'data_validation_2'),
}

def get_db_connection():
    if 'db' not in g:
        try:
            conn = mysql.connector.connect(
                host=DB_CONFIG['host'],
                user=DB_CONFIG['user'],
                password=DB_CONFIG['password']
            )
            cursor = conn.cursor()
            cursor.execute(f"CREATE DATABASE IF NOT EXISTS {DB_CONFIG['database']}")
            cursor.close()
            conn.close()
            g.db = mysql.connector.connect(**DB_CONFIG)
            logging.info("Database connection established successfully")
        except mysql.connector.Error as err:
            if err.errno == errorcode.ER_ACCESS_DENIED_ERROR:
                logging.error("Database connection failed: Access denied for user - check username/password")
            elif err.errno == errorcode.ER_BAD_DB_ERROR:
                logging.error("Database connection failed: Database does not exist")
            else:
                logging.error(f"Database connection failed: {err}")
            raise Exception(f"Failed to connect to database: {str(err)}")
    return g.db

def close_db(error):
    db = g.pop('db', None)
    if db is not None:
        db.close()

def init_db():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        tables = [
            """
            CREATE TABLE IF NOT EXISTS login_details (
                id INT AUTO_INCREMENT PRIMARY KEY,
                first_name VARCHAR(100),
                last_name VARCHAR(100),
                email VARCHAR(255) UNIQUE,
                mobile VARCHAR(10),
                password VARCHAR(255)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS excel_templates (
                template_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_name VARCHAR(255) NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
                user_id INT NOT NULL,
                sheet_name VARCHAR(255),
                headers JSON,
                status ENUM('ACTIVE', 'INACTIVE') DEFAULT 'ACTIVE',
                is_corrected BOOLEAN DEFAULT FALSE,
                remote_file_path VARCHAR(512),
                FOREIGN KEY (user_id) REFERENCES login_details(id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS template_columns (
                column_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_id BIGINT NOT NULL,
                column_name VARCHAR(255) NOT NULL,
                column_position INT NOT NULL,
                is_validation_enabled BOOLEAN DEFAULT FALSE,
                is_selected BOOLEAN DEFAULT FALSE,
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE,
                UNIQUE (template_id, column_name)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_rule_types (
                rule_type_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                rule_name VARCHAR(255) NOT NULL,
                description TEXT,
                parameters TEXT,
                is_active BOOLEAN DEFAULT TRUE,
                is_custom BOOLEAN DEFAULT FALSE,
                column_name VARCHAR(255),
                template_id BIGINT,
                data_type VARCHAR(50),
                source_format VARCHAR(50),
                target_format VARCHAR(50),
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS column_validation_rules (
                column_validation_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                column_id BIGINT NOT NULL,
                rule_type_id BIGINT NOT NULL,
                rule_config JSON,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (column_id) REFERENCES template_columns(column_id) ON DELETE CASCADE,
                FOREIGN KEY (rule_type_id) REFERENCES validation_rule_types(rule_type_id) ON DELETE RESTRICT,
                UNIQUE (column_id, rule_type_id)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_history (
                history_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_id BIGINT NOT NULL,
                template_name VARCHAR(255) NOT NULL,
                error_count INT NOT NULL,
                corrected_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                corrected_file_path VARCHAR(512) NOT NULL,
                user_id INT NOT NULL,
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE,
                FOREIGN KEY (user_id) REFERENCES login_details(id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_corrections (
                correction_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                history_id BIGINT NOT NULL,
                row_index INT NOT NULL,
                column_name VARCHAR(255) NOT NULL,
                original_value TEXT,
                corrected_value TEXT,
                rule_failed VARCHAR(255) DEFAULT NULL,
                FOREIGN KEY (history_id) REFERENCES validation_history(history_id) ON DELETE CASCADE
            )
            """
        ]
        for table_sql in tables:
            cursor.execute(table_sql)
        
        # Add missing columns if they don't exist
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'source_format'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN source_format VARCHAR(50)")
            logging.info("Added source_format column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'target_format'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN target_format VARCHAR(50)")
            logging.info("Added target_format column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'data_type'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN data_type VARCHAR(50)")
            logging.info("Added data_type column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM excel_templates LIKE 'remote_file_path'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE excel_templates ADD COLUMN remote_file_path VARCHAR(512)")
            logging.info("Added remote_file_path column to excel_templates table")
            
        cursor.execute("SHOW COLUMNS FROM template_columns LIKE 'is_selected'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE template_columns ADD COLUMN is_selected BOOLEAN DEFAULT FALSE")
            logging.info("Added is_selected column to template_columns table")
            
        conn.commit()
        cursor.close()
        logging.info("Database tables initialized")
    except Exception as e:
        logging.error(f"Failed to initialize database: {str(e)}")
        raise

def create_admin_user():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        admin_password = bcrypt.hashpw('admin'.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
        cursor.execute("""
            INSERT IGNORE INTO login_details (first_name, last_name, email, mobile, password)
            VALUES (%s, %s, %s, %s, %s)
        """, ('Admin', 'User', 'admin@example.com', '1234567890', admin_password))
        conn.commit()
        cursor.close()
        logging.info("Admin user created or already exists")
    except Exception as e:
        logging.error(f"Failed to create admin user: {str(e)}")
        raise

def create_default_validation_rules():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        default_rules = [
            ("Required", "Ensures the field is not null", '{"allow_null": false}', None, None, None),
            ("Int", "Validates integer format", '{"format": "integer"}', None, None, "Int"),
            ("Float", "Validates number format (integer or decimal)", '{"format": "float"}', None, None, "Float"),
            ("Text", "Allows text with quotes and parentheses", '{"allow_special": false}', None, None, "Text"),
            ("Email", "Validates email format", '{"regex": "^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\\\.[a-zA-Z0-9-.]+$"}', None, None, "Email"),
            ("Date(DD-MM-YYYY)", "Validates date format DD-MM-YYYY", '{"format": "%d-%m-%Y"}', "DD-MM-YYYY", None, "Date"),
            ("Boolean", "Validates boolean format (true/false or 0/1)", '{"format": "boolean"}', None, None, "Boolean"),
            ("Alphanumeric", "Validates alphanumeric format", '{"format": "alphanumeric"}', None, None, "Alphanumeric")
        ]
        cursor.executemany("""
            INSERT IGNORE INTO validation_rule_types (rule_name, description, parameters, is_custom, source_format, target_format, data_type)
            VALUES (%s, %s, %s, %s, %s, %s, %s)
        """, [(name, desc, params, False, source, target, dtype) for name, desc, params, source, target, dtype in default_rules])
        conn.commit()
        cursor.close()
        logging.info("Default validation rules ensured successfully")
    except Exception as e:
        logging.error(f"Failed to ensure default validation rules: {str(e)}")
        raise

if __name__ == '__main__':
    try:
        # Create the application using factory pattern
        app = create_app()
        
        # Initialize database and default data within app context
        with app.app_context():
            initialize_app_data()
        
        # Get port from environment or use default
        port = int(os.getenv('PORT', 5000))
        
        # Start the application server
        logging.info("Starting Flask server...")
        app.run(debug=True, host='0.0.0.0', port=port)
        
    except Exception as e:
        logging.error(f"Failed to start application: {e}")
        raise
).all():
        return "Email"
    
    # Date pattern detection
    try:
        pd.to_datetime(non_null, format="%d-%m-%Y")
        return "Date"
    except Exception:
        try:
            pd.to_datetime(non_null, format="%Y-%m-%d")
            return "Date"
        except Exception:
            pass
    
    # Boolean detection
    if non_null.str.lower().isin(['true', 'false', '0', '1']).all():
        return "Boolean"
    
    # Numeric detection
    if non_null.str.match(r'^-?\d+

def create_app():
    """Application factory pattern for different environments"""
    # Set the path to the frontend dist folder
    current_dir = os.path.dirname(os.path.abspath(__file__))
    frontend_dist_path = os.path.join(current_dir, '..', '..', 'Keansa-Ai-Suite2025may-frontend11', 'dist')
    frontend_dist_path = os.path.abspath(frontend_dist_path)
    
    # Create Flask application instance
    app = Flask(__name__, static_folder=frontend_dist_path, static_url_path='')
    CORS(app, supports_credentials=True, origins=["http://localhost:3000", "http://localhost:8080", "http://localhost:5000", "*"])

    app.secret_key = os.urandom(24).hex()
    app.config['SESSION_TYPE'] = 'filesystem'
    app.config['SESSION_FILE_DIR'] = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'sessions')
    app.config['SESSION_COOKIE_SAMESITE'] = 'Lax'
    app.config['SESSION_COOKIE_HTTPONLY'] = True
    app.config['SESSION_COOKIE_SECURE'] = False
    app.config['PERMANENT_SESSION_LIFETIME'] = 86400  # 24 hours
    app.config['UPLOAD_FOLDER'] = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'uploads')
    Session(app)

    # Ensure directories exist
    try:
        os.makedirs(app.config['UPLOAD_FOLDER'], exist_ok=True)
        os.makedirs(app.config['SESSION_FILE_DIR'], exist_ok=True)
    except OSError as e:
        logging.error(f"Failed to create directories: {e}")

    # Register cleanup handlers
    app.teardown_appcontext(close_db)
    
    # Register all routes directly in create_app
    
    # Static file serving for React frontend
    @app.route('/', defaults={'path': ''})
    @app.route('/<path:path>')
    def serve(path):
        if path and os.path.exists(os.path.join(app.static_folder, path)):
            return app.send_static_file(path)
        return app.send_static_file('index.html')

    # Health check endpoint
    @app.route('/health', methods=['GET'])
    def health_check():
        return jsonify({
            'status': 'healthy',
            'timestamp': datetime.now().isoformat(),
            'version': '2.0.0'
        })

    # Authentication endpoint - both old and new paths
    @app.route('/authenticate', methods=['POST'])
    @app.route('/api/auth/authenticate', methods=['POST'])
    def authenticate():
        try:
            email = request.form.get('username') or request.form.get('email')
            password = request.form.get('password')
            logging.debug(f"Login attempt: email={email}, password={'*' * len(password) if password else 'None'}")
            
            if not email or not password:
                logging.warning(f"Login failed: Email or password missing")
                return jsonify({'success': False, 'message': 'Email and password are required'}), 400

            # Check for admin login
            if email == "admin" and password == "admin":
                session['loggedin'] = True
                session['user_email'] = "admin@example.com"
                session['user_id'] = 1
                session.permanent = True
                logging.info(f"Admin login successful. Session: {dict(session)}")
                return jsonify({'success': True, 'message': 'Login successful', 'user': {'email': 'admin@example.com', 'id': 1}}), 200

            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("SELECT * FROM login_details WHERE LOWER(email) = LOWER(%s)", (email.lower(),))
            account = cursor.fetchone()
            cursor.close()
            
            if account:
                if bcrypt.checkpw(password.encode('utf-8'), account['password'].encode('utf-8')):
                    session['loggedin'] = True
                    session['user_email'] = account['email']
                    session['user_id'] = account['id']
                    session.permanent = True
                    logging.info(f"User {email} logged in successfully. Session: {dict(session)}")
                    return jsonify({
                        'success': True,
                        'message': 'Login successful',
                        'user': {'email': account['email'], 'id': account['id']}
                    }), 200
                else:
                    logging.warning(f"Invalid password for {email}")
                    return jsonify({'success': False, 'message': 'Invalid credentials'}), 401
            else:
                logging.warning(f"Email {email} not found")
                return jsonify({'success': False, 'message': 'Invalid credentials'}), 401
        except Exception as e:
            logging.error(f"Unexpected error during login: {str(e)}")
            return jsonify({'success': False, 'message': f'Unexpected error: {str(e)}'}), 500

    @app.route('/check-auth', methods=['GET'])
    @app.route('/api/auth/check-auth', methods=['GET'])
    def check_auth():
        try:
            logging.debug(f"Checking auth with session: {dict(session)}")
            if 'loggedin' in session and 'user_id' in session:
                conn = get_db_connection()
                cursor = conn.cursor(dictionary=True)
                cursor.execute("SELECT email, first_name FROM login_details WHERE id = %s", (session['user_id'],))
                user = cursor.fetchone()
                cursor.close()
                if user:
                    logging.info(f"User {session.get('user_email')} is authenticated")
                    return jsonify({
                        'success': True,
                        'user': {
                            'email': user['email'],
                            'id': session['user_id'],
                            'first_name': user['first_name']
                        }
                    })
                else:
                    logging.warning("User not found in database")  
                    session.clear()
                    return jsonify({'success': False, 'message': 'User not found'}), 401
            logging.warning("User not authenticated")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        except Exception as e:
            logging.error(f"Error in check-auth endpoint: {str(e)}")
            return jsonify({'success': False, 'message': f'Server error: {str(e)}'}), 500

    @app.route('/register', methods=['POST'])
    @app.route('/api/auth/register', methods=['POST'])
    def register():
        first_name = request.form.get('first_name')
        last_name = request.form.get('last_name')
        email = request.form.get('email')
        mobile = request.form.get('mobile')
        password = request.form.get('password')
        confirm_password = request.form.get('confirm_password')

        if not all([first_name, last_name, email, mobile, password, confirm_password]):
            return jsonify({'success': False, 'message': 'All fields are required'}), 400
        if password != confirm_password:
            return jsonify({'success': False, 'message': 'Passwords do not match'}), 400

        hashed_password = bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
        try:
            conn = get_db_connection()
            cursor = conn.cursor()
            cursor.execute("""
                INSERT INTO login_details (first_name, last_name, email, mobile, password)
                VALUES (%s, %s, %s, %s, %s)
            """, (first_name, last_name, email, mobile, hashed_password))
            user_id = cursor.lastrowid
            conn.commit()
            cursor.close()
            session['loggedin'] = True
            session['user_email'] = email
            session['user_id'] = user_id
            return jsonify({
                'success': True,
                'message': 'Registration successful',
                'user': {'email': email, 'id': user_id}
            }), 200
        except mysql.connector.Error as e:
            logging.error(f"Database error during registration: {str(e)}")
            return jsonify({'success': False, 'message': f'Registration error: {str(e)}'}), 500

    @app.route('/logout', methods=['POST'])
    @app.route('/api/auth/logout', methods=['POST'])
    def logout():
        logging.info(f"User {session.get('user_email', 'unknown')} logged out")
        session.clear()
        return jsonify({'success': True, 'message': 'Logged out successfully'})

    # Template routes
    @app.route('/templates', methods=['GET'])
    @app.route('/api/templates', methods=['GET'])
    def get_templates():
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /templates: session missing")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("""
                SELECT template_id, template_name, created_at, status
                FROM excel_templates
                WHERE user_id = %s AND status = 'ACTIVE'
                ORDER BY created_at DESC
                LIMIT 100
            """, (session['user_id'],))
            templates = cursor.fetchall()
            cursor.close()
            logging.info(f"Fetched {len(templates)} templates for user {session['user_id']}")
            return jsonify({'success': True, 'templates': templates})
        except mysql.connector.Error as e:
            logging.error(f'Error fetching templates: {str(e)}')
            return jsonify({'success': False, 'message': f'Error fetching templates: {str(e)}'}), 500
        except Exception as e:
            logging.error(f'Unexpected error fetching templates: {str(e)}')
            return jsonify({'success': False, 'message': f'Unexpected error: {str(e)}'}), 500

    # Rule Configuration routes
    @app.route('/rule-configurations', methods=['GET'])
    @app.route('/api/validation/rule-configurations', methods=['GET'])
    def get_rule_configurations():
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning(f"Unauthorized access to /rule-configurations: session={dict(session)}")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            user_id = session['user_id']
            logging.debug(f"Fetching rule configurations for user_id: {user_id}")

            # Main query to fetch templates with configured rules
            cursor.execute("""
                SELECT 
                    t.template_id, 
                    t.template_name, 
                    t.created_at, 
                    COUNT(cvr.column_validation_id) as rule_count
                FROM excel_templates t
                LEFT JOIN template_columns tc ON t.template_id = tc.template_id
                LEFT JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                WHERE t.user_id = %s AND t.status = 'ACTIVE' AND t.is_corrected = FALSE
                GROUP BY t.template_id, t.template_name, t.created_at
                HAVING rule_count > 0
                ORDER BY t.created_at DESC
                LIMIT 100
            """, (user_id,))
            templates = cursor.fetchall()
            logging.debug(f"Fetched rule-configured templates: {templates}")

            cursor.close()

            if not templates:
                logging.info(f"No templates with rules found for user_id: {user_id}")
            else:
                logging.info(f"Found {len(templates)} templates with rules for user_id: {user_id}")

            return jsonify({'success': True, 'templates': templates})
        except mysql.connector.Error as e:
            logging.error(f"Database error fetching rule configurations: {str(e)}")
            return jsonify({'success': False, 'message': f"Database error: {str(e)}"}), 500
        except Exception as e:
            logging.error(f"Unexpected error fetching rule configurations: {str(e)}")
            return jsonify({'success': False, 'message': f"Unexpected error: {str(e)}"}), 500

    # File upload route
    @app.route('/upload', methods=['POST'])
    @app.route('/api/templates/upload', methods=['POST'])
    @app.route('/api/upload', methods=['POST'])  # Additional common path
    def upload():
        logging.info(f"Upload endpoint called: {request.endpoint}, method: {request.method}")
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /upload: session missing")
            return jsonify({'error': 'Not logged in'}), 401
        if 'file' not in request.files:
            logging.warning("No file provided in upload request")
            return jsonify({'error': 'No file uploaded'}), 400
        file = request.files['file']
        if file.filename == '':
            logging.warning("No file selected in upload request")
            return jsonify({'error': 'No file selected'}), 400
        
        file_path = os.path.join(app.config['UPLOAD_FOLDER'], file.filename)
        try:
            file.save(file_path)
            logging.info(f"File saved: {file_path}")
        except Exception as e:
            logging.error(f"Failed to save file {file.filename}: {str(e)}")
            return jsonify({'error': f'Failed to save file: {str(e)}'}), 500

        try:
            # Read the file to get sheets and headers
            if file.filename.endswith('.xlsx') or file.filename.endswith('.xls'):
                xl = pd.ExcelFile(file_path)
                sheets = {sheet_name: pd.read_excel(file_path, sheet_name=sheet_name, header=None) 
                         for sheet_name in xl.sheet_names}
            elif file.filename.endswith(('.txt', '.csv', '.dat')):
                df = pd.read_csv(file_path, header=None, encoding='utf-8')
                sheets = {'Sheet1': df}
            else:
                logging.error("Unsupported file type")
                return jsonify({'error': 'Unsupported file type'}), 400
            
            logging.debug(f"Sheets extracted: {list(sheets.keys())}")
        except Exception as e:
            logging.error(f"Failed to read file {file_path}: {str(e)}")
            return jsonify({'error': f'Failed to read file: {str(e)}'}), 400

        try:
            sheet_names = list(sheets.keys())
            if not sheet_names:
                logging.error("No sheets found in the file")
                return jsonify({'error': 'No sheets found in the file'}), 400
            sheet_name = sheet_names[0]
            df = sheets[sheet_name]
            
            # Find header row
            header_row = 0
            for i in range(min(len(df), 10)):
                row = df.iloc[i].dropna()
                if not row.empty and all(isinstance(x, str) for x in row if pd.notna(x)):
                    header_row = i
                    break
                    
            headers = df.iloc[header_row].tolist()
            logging.debug(f"Headers extracted: {headers}")
            
            if not headers or all(not h for h in headers):
                logging.error("No valid headers found in file")
                return jsonify({'error': 'No valid headers found in the file'}), 400
        except Exception as e:
            logging.error(f"Error processing file {file.filename}: {str(e)}")
            return jsonify({'error': f'Error processing file: {str(e)}'}), 400

        # Clear existing session data
        for key in ['df', 'header_row', 'headers', 'sheet_name', 'current_step', 'selected_headers', 'validations', 'error_cell_locations', 'data_rows', 'corrected_file_path']:
            session.pop(key, None)

        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)

            # Check if template exists
            cursor.execute("""
                SELECT template_id, headers, sheet_name
                FROM excel_templates
                WHERE template_name = %s AND user_id = %s AND status = 'ACTIVE'
                ORDER BY created_at DESC
            """, (file.filename, session['user_id']))
            existing_templates = cursor.fetchall()
            logging.info(f"Found {len(existing_templates)} existing templates with name {file.filename}")

            template_id = None
            has_existing_rules = False
            validations = {}
            selected_headers = []

            # Check for matching template
            matching_template = None
            for template in existing_templates:
                stored_headers = json.loads(template['headers']) if template['headers'] else []
                stored_sheet_name = template['sheet_name']
                if stored_headers == headers and stored_sheet_name == sheet_name:
                    matching_template = template
                    break

            if matching_template:
                template_id = matching_template['template_id']
                # Check for existing rules
                cursor.execute("""
                    SELECT tc.column_name, vrt.rule_name
                    FROM template_columns tc
                    JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                    JOIN validation_rule_types vrt ON cvr.rule_type_id = vrt.rule_type_id
                    WHERE tc.template_id = %s AND tc.is_selected = TRUE
                """, (template_id,))
                rules_data = cursor.fetchall()
                for row in rules_data:
                    column_name = row['column_name']
                    rule_name = row['rule_name']
                    if column_name not in validations:
                        validations[column_name] = []
                    validations[column_name].append(rule_name)
                    if column_name not in selected_headers:
                        selected_headers.append(column_name)
                has_existing_rules = len(validations) > 0
            else:
                # New template
                cursor.execute("""
                    INSERT INTO excel_templates (template_name, user_id, sheet_name, headers, is_corrected)
                    VALUES (%s, %s, %s, %s, %s)
                """, (file.filename, session['user_id'], sheet_name, json.dumps(headers), False))
                template_id = cursor.lastrowid
                column_data = [(template_id, header, i + 1, False) for i, header in enumerate(headers)]
                cursor.executemany("""
                    INSERT INTO template_columns (template_id, column_name, column_position, is_selected)
                    VALUES (%s, %s, %s, %s)
                """, column_data)

            conn.commit()
            cursor.close()

            # Store session data
            session['file_path'] = file_path
            session['template_id'] = template_id
            session['df'] = df.to_json()
            session['header_row'] = header_row
            session['headers'] = headers
            session['sheet_name'] = sheet_name
            session['current_step'] = 1 if not has_existing_rules else 3
            session['validations'] = validations
            session['selected_headers'] = selected_headers
            session['has_existing_rules'] = has_existing_rules

            logging.info(f"Upload processed: template_id={template_id}, filename={file.filename}, has_existing_rules={has_existing_rules}")

            return jsonify({
                'success': True,
                'sheets': {sheet_name: {'headers': headers}},
                'file_name': file.filename,
                'template_id': template_id,
                'has_existing_rules': has_existing_rules,
                'sheet_name': sheet_name,
                'skip_to_step_3': has_existing_rules
            })
        except mysql.connector.Error as e:
            logging.error(f'Error saving template: {str(e)}')
            return jsonify({'error': f'Error saving template: {str(e)}'}), 500
        except Exception as e:
            logging.error(f'Unexpected error saving template: {str(e)}')
            return jsonify({'error': f'Unexpected error: {str(e)}'}), 500

    # Multi-step workflow endpoints
    @app.route('/step/1', methods=['GET', 'POST'])
    @app.route('/api/step/1', methods=['GET', 'POST'])
    def step_one():
        if 'loggedin' not in session:
            return jsonify({'error': 'Not logged in'}), 401
        
        if request.method == 'POST':
            try:
                headers = request.form.getlist('headers')
                new_header_row = request.form.get('new_header_row')
                logging.debug(f"Step 1 submitted: headers={headers}, new_header_row={new_header_row}")
                
                if not headers:
                    logging.error("No headers provided in step 1")
                    return jsonify({'success': False, 'message': 'No headers provided'}), 400
                    
                if 'template_id' not in session:
                    logging.error("Session missing template_id")
                    return jsonify({'success': False, 'message': 'Session data missing'}), 400

                template_id = session['template_id']
                
                # Get the dataframe from session for auto-detection
                df_json = session.get('df')
                if df_json:
                    df = pd.read_json(StringIO(df_json))
                    session_headers = session.get('headers', [])
                    df.columns = session_headers
                    header_row = session.get('header_row', 0)
                    df = df.iloc[header_row + 1:].reset_index(drop=True)
                    
                    # Auto-detect rules for selected headers
                    validations = assign_default_rules_to_columns(df, headers)
                    session['validations'] = validations
                    logging.debug(f"Auto-assigned rules: {validations}")
                else:
                    validations = {}

                session['selected_headers'] = headers
                session['current_step'] = 2

                # Mark selected headers in the database
                conn = get_db_connection()
                cursor = conn.cursor()
                cursor.execute("UPDATE template_columns SET is_selected = FALSE WHERE template_id = %s", (template_id,))
                for header in headers:
                    cursor.execute("""
                        UPDATE template_columns
                        SET is_selected = TRUE
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    
                    # Get column_id and add auto-detected rules
                    cursor.execute("""
                        SELECT column_id FROM template_columns
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    result = cursor.fetchone()
                    if result:
                        column_id = result[0]
                        for rule_name in validations.get(header, []):
                            cursor.execute("""
                                SELECT rule_type_id FROM validation_rule_types
                                WHERE rule_name = %s AND is_custom = FALSE
                            """, (rule_name,))
                            rule_result = cursor.fetchone()
                            if rule_result:
                                rule_type_id = rule_result[0]
                                cursor.execute("""
                                    INSERT IGNORE INTO column_validation_rules (column_id, rule_type_id, rule_config)
                                    VALUES (%s, %s, %s)
                                """, (column_id, rule_type_id, '{}'))
                
                conn.commit()
                cursor.close()

                logging.info(f"Step 1 completed: headers={headers}, auto-assigned rules={validations}")
                return jsonify({'success': True, 'headers': headers, 'validations': validations})
            except Exception as e:
                logging.error(f"Error in step 1: {str(e)}")
                return jsonify({'success': False, 'message': str(e)}), 500
        
        # GET request - return current headers
        headers = session.get('headers', [])
        return jsonify({'headers': headers})

    @app.route('/step/2', methods=['GET', 'POST'])
    @app.route('/api/step/2', methods=['GET', 'POST'])
    def step_two():
        if 'loggedin' not in session:
            return jsonify({'error': 'Not logged in'}), 401
            
        if request.method == 'POST':
            try:
                action = request.form.get('action', 'save')
                validations = {}
                for key, values in request.form.lists():
                    if key.startswith('validations_'):
                        header = key.replace('validations_', '')
                        validations[header] = values
                        
                logging.debug(f"Step 2 submitted: action={action}, validations={validations}")
                
                template_id = session.get('template_id')
                if not template_id:
                    return jsonify({'success': False, 'message': 'Session data missing'}), 400

                # Save validations to database
                conn = get_db_connection()
                cursor = conn.cursor()
                
                # Clear existing rules
                cursor.execute("""
                    DELETE FROM column_validation_rules
                    WHERE column_id IN (
                        SELECT column_id FROM template_columns WHERE template_id = %s
                    )
                """, (template_id,))
                
                # Add new rules
                for header, rules in validations.items():
                    cursor.execute("""
                        SELECT column_id FROM template_columns
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    result = cursor.fetchone()
                    if not result:
                        continue
                    column_id = result[0]
                    
                    for rule_name in rules:
                        cursor.execute("""
                            SELECT rule_type_id FROM validation_rule_types
                            WHERE rule_name = %s
                        """, (rule_name,))
                        result = cursor.fetchone()
                        if result:
                            rule_type_id = result[0]
                            cursor.execute("""
                                INSERT IGNORE INTO column_validation_rules (column_id, rule_type_id, rule_config)
                                VALUES (%s, %s, %s)
                            """, (column_id, rule_type_id, '{}'))
                
                conn.commit()
                cursor.close()

                session['validations'] = validations
                session['current_step'] = 3 if action == 'review' else 2
                
                logging.info(f"Step 2 completed: action={action}, validations={validations}")
                return jsonify({'success': True, 'message': 'Step 2 completed successfully'})
            except Exception as e:
                logging.error(f"Error in step 2: {str(e)}")
                return jsonify({'success': False, 'message': str(e)}), 500
        
        # GET request
        selected_headers = session.get('selected_headers', [])
        return jsonify({'selected_headers': selected_headers})

    # Rules endpoint
    @app.route('/rules', methods=['GET'])
    @app.route('/api/rules', methods=['GET'])
    def get_rules():
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            
            cursor.execute("""
                SELECT rule_type_id AS rule_id, rule_name, description, parameters, is_custom, 
                       column_name, template_id, source_format, target_format, data_type, is_active
                FROM validation_rule_types
            """)
            rules = cursor.fetchall()
            cursor.close()
            
            logging.info(f"Returning {len(rules)} rules from getRules endpoint")
            return jsonify({'success': True, 'rules': rules})
        except mysql.connector.Error as e:
            logging.error(f"Database error fetching rules: {str(e)}")
            return jsonify({'success': False, 'message': str(e)}), 500
        except Exception as e:
            logging.error(f"Unexpected error fetching rules: {str(e)}")
            return jsonify({'success': False, 'message': str(e)}), 500

    # Template details endpoint
    @app.route('/template/<int:template_id>/<sheet_name>', methods=['GET'])
    @app.route('/api/template/<int:template_id>/<sheet_name>', methods=['GET'])
    def get_template(template_id, sheet_name):
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /template: session missing")
            return jsonify({'error': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("""
                SELECT template_name, sheet_name, headers
                FROM excel_templates
                WHERE template_id = %s AND user_id = %s AND status = 'ACTIVE'
            """, (template_id, session['user_id']))
            template_record = cursor.fetchone()
            
            if not template_record:
                logging.error(f"Template not found for template_id: {template_id}, user_id: {session['user_id']}")
                cursor.close()
                return jsonify({'error': 'Template not found'}), 404

            headers = json.loads(template_record['headers']) if template_record['headers'] else []
            stored_sheet_name = template_record['sheet_name'] or sheet_name
            file_path = os.path.join(app.config['UPLOAD_FOLDER'], template_record['template_name'])
            
            cursor.execute("""
                SELECT COUNT(*) as rule_count
                FROM template_columns tc
                JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                WHERE tc.template_id = %s AND tc.is_selected = TRUE
            """, (template_id,))
            rule_count = cursor.fetchone()['rule_count']
            has_existing_rules = rule_count > 0
            
            cursor.close()
            
            return jsonify({
                'success': True,
                'sheets': {stored_sheet_name: {'headers': headers}},
                'file_name': template_record['template_name'],
                'file_path': file_path,
                'sheet_name': stored_sheet_name,
                'has_existing_rules': has_existing_rules
            })
        except mysql.connector.Error as e:
            logging.error(f"Database error in get_template: {str(e)}")
            return jsonify({'error': f'Database error: {str(e)}'}), 500
        except Exception as e:
            logging.error(f"Unexpected error in get_template: {str(e)}")
            return jsonify({'error': f'Unexpected error: {str(e)}'}), 500

    # Debug route to show all registered routes
    @app.route('/debug/routes', methods=['GET'])
    def list_routes():
        routes = []
        for rule in app.url_map.iter_rules():
            routes.append({
                'endpoint': rule.endpoint,
                'methods': list(rule.methods),
                'rule': rule.rule
            })
        return jsonify(routes)

    # 404 handler to debug missing routes
    @app.errorhandler(404)
    def not_found_handler(error):
        logging.error(f"404 Error: {request.method} {request.url} not found")
        logging.error(f"Available routes: {[rule.rule for rule in app.url_map.iter_rules()]}")
        return jsonify({
            'error': 'Endpoint not found', 
            'method': request.method,
            'url': request.url,
            'path': request.path
        }), 404

    return app

def initialize_app_data():
    """Initialize database and create default data"""
    try:
        logging.info("Initializing database schema...")
        init_db()
        
        logging.info("Creating admin user...")
        create_admin_user()
        
        logging.info("Creating default validation rules...")
        create_default_validation_rules()
        
        logging.info("Application initialization completed successfully")
    except Exception as e:
        logging.error(f"Failed to initialize application: {e}")
        raise

DB_CONFIG = {
    'host': os.getenv('MYSQL_HOST', 'localhost'),
    'user': os.getenv('MYSQL_USER', 'root'),
    'password': os.getenv('MYSQL_PASSWORD', 'Keansa@2024'),
    'database': os.getenv('MYSQL_DATABASE', 'data_validation_2'),
}

def get_db_connection():
    if 'db' not in g:
        try:
            conn = mysql.connector.connect(
                host=DB_CONFIG['host'],
                user=DB_CONFIG['user'],
                password=DB_CONFIG['password']
            )
            cursor = conn.cursor()
            cursor.execute(f"CREATE DATABASE IF NOT EXISTS {DB_CONFIG['database']}")
            cursor.close()
            conn.close()
            g.db = mysql.connector.connect(**DB_CONFIG)
            logging.info("Database connection established successfully")
        except mysql.connector.Error as err:
            if err.errno == errorcode.ER_ACCESS_DENIED_ERROR:
                logging.error("Database connection failed: Access denied for user - check username/password")
            elif err.errno == errorcode.ER_BAD_DB_ERROR:
                logging.error("Database connection failed: Database does not exist")
            else:
                logging.error(f"Database connection failed: {err}")
            raise Exception(f"Failed to connect to database: {str(err)}")
    return g.db

def close_db(error):
    db = g.pop('db', None)
    if db is not None:
        db.close()

def init_db():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        tables = [
            """
            CREATE TABLE IF NOT EXISTS login_details (
                id INT AUTO_INCREMENT PRIMARY KEY,
                first_name VARCHAR(100),
                last_name VARCHAR(100),
                email VARCHAR(255) UNIQUE,
                mobile VARCHAR(10),
                password VARCHAR(255)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS excel_templates (
                template_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_name VARCHAR(255) NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
                user_id INT NOT NULL,
                sheet_name VARCHAR(255),
                headers JSON,
                status ENUM('ACTIVE', 'INACTIVE') DEFAULT 'ACTIVE',
                is_corrected BOOLEAN DEFAULT FALSE,
                remote_file_path VARCHAR(512),
                FOREIGN KEY (user_id) REFERENCES login_details(id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS template_columns (
                column_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_id BIGINT NOT NULL,
                column_name VARCHAR(255) NOT NULL,
                column_position INT NOT NULL,
                is_validation_enabled BOOLEAN DEFAULT FALSE,
                is_selected BOOLEAN DEFAULT FALSE,
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE,
                UNIQUE (template_id, column_name)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_rule_types (
                rule_type_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                rule_name VARCHAR(255) NOT NULL,
                description TEXT,
                parameters TEXT,
                is_active BOOLEAN DEFAULT TRUE,
                is_custom BOOLEAN DEFAULT FALSE,
                column_name VARCHAR(255),
                template_id BIGINT,
                data_type VARCHAR(50),
                source_format VARCHAR(50),
                target_format VARCHAR(50),
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS column_validation_rules (
                column_validation_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                column_id BIGINT NOT NULL,
                rule_type_id BIGINT NOT NULL,
                rule_config JSON,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (column_id) REFERENCES template_columns(column_id) ON DELETE CASCADE,
                FOREIGN KEY (rule_type_id) REFERENCES validation_rule_types(rule_type_id) ON DELETE RESTRICT,
                UNIQUE (column_id, rule_type_id)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_history (
                history_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_id BIGINT NOT NULL,
                template_name VARCHAR(255) NOT NULL,
                error_count INT NOT NULL,
                corrected_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                corrected_file_path VARCHAR(512) NOT NULL,
                user_id INT NOT NULL,
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE,
                FOREIGN KEY (user_id) REFERENCES login_details(id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_corrections (
                correction_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                history_id BIGINT NOT NULL,
                row_index INT NOT NULL,
                column_name VARCHAR(255) NOT NULL,
                original_value TEXT,
                corrected_value TEXT,
                rule_failed VARCHAR(255) DEFAULT NULL,
                FOREIGN KEY (history_id) REFERENCES validation_history(history_id) ON DELETE CASCADE
            )
            """
        ]
        for table_sql in tables:
            cursor.execute(table_sql)
        
        # Add missing columns if they don't exist
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'source_format'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN source_format VARCHAR(50)")
            logging.info("Added source_format column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'target_format'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN target_format VARCHAR(50)")
            logging.info("Added target_format column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'data_type'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN data_type VARCHAR(50)")
            logging.info("Added data_type column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM excel_templates LIKE 'remote_file_path'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE excel_templates ADD COLUMN remote_file_path VARCHAR(512)")
            logging.info("Added remote_file_path column to excel_templates table")
            
        cursor.execute("SHOW COLUMNS FROM template_columns LIKE 'is_selected'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE template_columns ADD COLUMN is_selected BOOLEAN DEFAULT FALSE")
            logging.info("Added is_selected column to template_columns table")
            
        conn.commit()
        cursor.close()
        logging.info("Database tables initialized")
    except Exception as e:
        logging.error(f"Failed to initialize database: {str(e)}")
        raise

def create_admin_user():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        admin_password = bcrypt.hashpw('admin'.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
        cursor.execute("""
            INSERT IGNORE INTO login_details (first_name, last_name, email, mobile, password)
            VALUES (%s, %s, %s, %s, %s)
        """, ('Admin', 'User', 'admin@example.com', '1234567890', admin_password))
        conn.commit()
        cursor.close()
        logging.info("Admin user created or already exists")
    except Exception as e:
        logging.error(f"Failed to create admin user: {str(e)}")
        raise

def create_default_validation_rules():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        default_rules = [
            ("Required", "Ensures the field is not null", '{"allow_null": false}', None, None, None),
            ("Int", "Validates integer format", '{"format": "integer"}', None, None, "Int"),
            ("Float", "Validates number format (integer or decimal)", '{"format": "float"}', None, None, "Float"),
            ("Text", "Allows text with quotes and parentheses", '{"allow_special": false}', None, None, "Text"),
            ("Email", "Validates email format", '{"regex": "^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\\\.[a-zA-Z0-9-.]+$"}', None, None, "Email"),
            ("Date(DD-MM-YYYY)", "Validates date format DD-MM-YYYY", '{"format": "%d-%m-%Y"}', "DD-MM-YYYY", None, "Date"),
            ("Boolean", "Validates boolean format (true/false or 0/1)", '{"format": "boolean"}', None, None, "Boolean"),
            ("Alphanumeric", "Validates alphanumeric format", '{"format": "alphanumeric"}', None, None, "Alphanumeric")
        ]
        cursor.executemany("""
            INSERT IGNORE INTO validation_rule_types (rule_name, description, parameters, is_custom, source_format, target_format, data_type)
            VALUES (%s, %s, %s, %s, %s, %s, %s)
        """, [(name, desc, params, False, source, target, dtype) for name, desc, params, source, target, dtype in default_rules])
        conn.commit()
        cursor.close()
        logging.info("Default validation rules ensured successfully")
    except Exception as e:
        logging.error(f"Failed to ensure default validation rules: {str(e)}")
        raise

if __name__ == '__main__':
    try:
        # Create the application using factory pattern
        app = create_app()
        
        # Initialize database and default data within app context
        with app.app_context():
            initialize_app_data()
        
        # Get port from environment or use default
        port = int(os.getenv('PORT', 5000))
        
        # Start the application server
        logging.info("Starting Flask server...")
        app.run(debug=True, host='0.0.0.0', port=port)
        
    except Exception as e:
        logging.error(f"Failed to start application: {e}")
        raise
).all():
        return "Int"
    
    if non_null.str.match(r'^-?\d+(\.\d+)?

def create_app():
    """Application factory pattern for different environments"""
    # Set the path to the frontend dist folder
    current_dir = os.path.dirname(os.path.abspath(__file__))
    frontend_dist_path = os.path.join(current_dir, '..', '..', 'Keansa-Ai-Suite2025may-frontend11', 'dist')
    frontend_dist_path = os.path.abspath(frontend_dist_path)
    
    # Create Flask application instance
    app = Flask(__name__, static_folder=frontend_dist_path, static_url_path='')
    CORS(app, supports_credentials=True, origins=["http://localhost:3000", "http://localhost:8080", "http://localhost:5000", "*"])

    app.secret_key = os.urandom(24).hex()
    app.config['SESSION_TYPE'] = 'filesystem'
    app.config['SESSION_FILE_DIR'] = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'sessions')
    app.config['SESSION_COOKIE_SAMESITE'] = 'Lax'
    app.config['SESSION_COOKIE_HTTPONLY'] = True
    app.config['SESSION_COOKIE_SECURE'] = False
    app.config['PERMANENT_SESSION_LIFETIME'] = 86400  # 24 hours
    app.config['UPLOAD_FOLDER'] = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'uploads')
    Session(app)

    # Ensure directories exist
    try:
        os.makedirs(app.config['UPLOAD_FOLDER'], exist_ok=True)
        os.makedirs(app.config['SESSION_FILE_DIR'], exist_ok=True)
    except OSError as e:
        logging.error(f"Failed to create directories: {e}")

    # Register cleanup handlers
    app.teardown_appcontext(close_db)
    
    # Register all routes directly in create_app
    
    # Static file serving for React frontend
    @app.route('/', defaults={'path': ''})
    @app.route('/<path:path>')
    def serve(path):
        if path and os.path.exists(os.path.join(app.static_folder, path)):
            return app.send_static_file(path)
        return app.send_static_file('index.html')

    # Health check endpoint
    @app.route('/health', methods=['GET'])
    def health_check():
        return jsonify({
            'status': 'healthy',
            'timestamp': datetime.now().isoformat(),
            'version': '2.0.0'
        })

    # Authentication endpoint - both old and new paths
    @app.route('/authenticate', methods=['POST'])
    @app.route('/api/auth/authenticate', methods=['POST'])
    def authenticate():
        try:
            email = request.form.get('username') or request.form.get('email')
            password = request.form.get('password')
            logging.debug(f"Login attempt: email={email}, password={'*' * len(password) if password else 'None'}")
            
            if not email or not password:
                logging.warning(f"Login failed: Email or password missing")
                return jsonify({'success': False, 'message': 'Email and password are required'}), 400

            # Check for admin login
            if email == "admin" and password == "admin":
                session['loggedin'] = True
                session['user_email'] = "admin@example.com"
                session['user_id'] = 1
                session.permanent = True
                logging.info(f"Admin login successful. Session: {dict(session)}")
                return jsonify({'success': True, 'message': 'Login successful', 'user': {'email': 'admin@example.com', 'id': 1}}), 200

            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("SELECT * FROM login_details WHERE LOWER(email) = LOWER(%s)", (email.lower(),))
            account = cursor.fetchone()
            cursor.close()
            
            if account:
                if bcrypt.checkpw(password.encode('utf-8'), account['password'].encode('utf-8')):
                    session['loggedin'] = True
                    session['user_email'] = account['email']
                    session['user_id'] = account['id']
                    session.permanent = True
                    logging.info(f"User {email} logged in successfully. Session: {dict(session)}")
                    return jsonify({
                        'success': True,
                        'message': 'Login successful',
                        'user': {'email': account['email'], 'id': account['id']}
                    }), 200
                else:
                    logging.warning(f"Invalid password for {email}")
                    return jsonify({'success': False, 'message': 'Invalid credentials'}), 401
            else:
                logging.warning(f"Email {email} not found")
                return jsonify({'success': False, 'message': 'Invalid credentials'}), 401
        except Exception as e:
            logging.error(f"Unexpected error during login: {str(e)}")
            return jsonify({'success': False, 'message': f'Unexpected error: {str(e)}'}), 500

    @app.route('/check-auth', methods=['GET'])
    @app.route('/api/auth/check-auth', methods=['GET'])
    def check_auth():
        try:
            logging.debug(f"Checking auth with session: {dict(session)}")
            if 'loggedin' in session and 'user_id' in session:
                conn = get_db_connection()
                cursor = conn.cursor(dictionary=True)
                cursor.execute("SELECT email, first_name FROM login_details WHERE id = %s", (session['user_id'],))
                user = cursor.fetchone()
                cursor.close()
                if user:
                    logging.info(f"User {session.get('user_email')} is authenticated")
                    return jsonify({
                        'success': True,
                        'user': {
                            'email': user['email'],
                            'id': session['user_id'],
                            'first_name': user['first_name']
                        }
                    })
                else:
                    logging.warning("User not found in database")  
                    session.clear()
                    return jsonify({'success': False, 'message': 'User not found'}), 401
            logging.warning("User not authenticated")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        except Exception as e:
            logging.error(f"Error in check-auth endpoint: {str(e)}")
            return jsonify({'success': False, 'message': f'Server error: {str(e)}'}), 500

    @app.route('/register', methods=['POST'])
    @app.route('/api/auth/register', methods=['POST'])
    def register():
        first_name = request.form.get('first_name')
        last_name = request.form.get('last_name')
        email = request.form.get('email')
        mobile = request.form.get('mobile')
        password = request.form.get('password')
        confirm_password = request.form.get('confirm_password')

        if not all([first_name, last_name, email, mobile, password, confirm_password]):
            return jsonify({'success': False, 'message': 'All fields are required'}), 400
        if password != confirm_password:
            return jsonify({'success': False, 'message': 'Passwords do not match'}), 400

        hashed_password = bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
        try:
            conn = get_db_connection()
            cursor = conn.cursor()
            cursor.execute("""
                INSERT INTO login_details (first_name, last_name, email, mobile, password)
                VALUES (%s, %s, %s, %s, %s)
            """, (first_name, last_name, email, mobile, hashed_password))
            user_id = cursor.lastrowid
            conn.commit()
            cursor.close()
            session['loggedin'] = True
            session['user_email'] = email
            session['user_id'] = user_id
            return jsonify({
                'success': True,
                'message': 'Registration successful',
                'user': {'email': email, 'id': user_id}
            }), 200
        except mysql.connector.Error as e:
            logging.error(f"Database error during registration: {str(e)}")
            return jsonify({'success': False, 'message': f'Registration error: {str(e)}'}), 500

    @app.route('/logout', methods=['POST'])
    @app.route('/api/auth/logout', methods=['POST'])
    def logout():
        logging.info(f"User {session.get('user_email', 'unknown')} logged out")
        session.clear()
        return jsonify({'success': True, 'message': 'Logged out successfully'})

    # Template routes
    @app.route('/templates', methods=['GET'])
    @app.route('/api/templates', methods=['GET'])
    def get_templates():
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /templates: session missing")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("""
                SELECT template_id, template_name, created_at, status
                FROM excel_templates
                WHERE user_id = %s AND status = 'ACTIVE'
                ORDER BY created_at DESC
                LIMIT 100
            """, (session['user_id'],))
            templates = cursor.fetchall()
            cursor.close()
            logging.info(f"Fetched {len(templates)} templates for user {session['user_id']}")
            return jsonify({'success': True, 'templates': templates})
        except mysql.connector.Error as e:
            logging.error(f'Error fetching templates: {str(e)}')
            return jsonify({'success': False, 'message': f'Error fetching templates: {str(e)}'}), 500
        except Exception as e:
            logging.error(f'Unexpected error fetching templates: {str(e)}')
            return jsonify({'success': False, 'message': f'Unexpected error: {str(e)}'}), 500

    # Rule Configuration routes
    @app.route('/rule-configurations', methods=['GET'])
    @app.route('/api/validation/rule-configurations', methods=['GET'])
    def get_rule_configurations():
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning(f"Unauthorized access to /rule-configurations: session={dict(session)}")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            user_id = session['user_id']
            logging.debug(f"Fetching rule configurations for user_id: {user_id}")

            # Main query to fetch templates with configured rules
            cursor.execute("""
                SELECT 
                    t.template_id, 
                    t.template_name, 
                    t.created_at, 
                    COUNT(cvr.column_validation_id) as rule_count
                FROM excel_templates t
                LEFT JOIN template_columns tc ON t.template_id = tc.template_id
                LEFT JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                WHERE t.user_id = %s AND t.status = 'ACTIVE' AND t.is_corrected = FALSE
                GROUP BY t.template_id, t.template_name, t.created_at
                HAVING rule_count > 0
                ORDER BY t.created_at DESC
                LIMIT 100
            """, (user_id,))
            templates = cursor.fetchall()
            logging.debug(f"Fetched rule-configured templates: {templates}")

            cursor.close()

            if not templates:
                logging.info(f"No templates with rules found for user_id: {user_id}")
            else:
                logging.info(f"Found {len(templates)} templates with rules for user_id: {user_id}")

            return jsonify({'success': True, 'templates': templates})
        except mysql.connector.Error as e:
            logging.error(f"Database error fetching rule configurations: {str(e)}")
            return jsonify({'success': False, 'message': f"Database error: {str(e)}"}), 500
        except Exception as e:
            logging.error(f"Unexpected error fetching rule configurations: {str(e)}")
            return jsonify({'success': False, 'message': f"Unexpected error: {str(e)}"}), 500

    # File upload route
    @app.route('/upload', methods=['POST'])
    @app.route('/api/templates/upload', methods=['POST'])
    @app.route('/api/upload', methods=['POST'])  # Additional common path
    def upload():
        logging.info(f"Upload endpoint called: {request.endpoint}, method: {request.method}")
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /upload: session missing")
            return jsonify({'error': 'Not logged in'}), 401
        if 'file' not in request.files:
            logging.warning("No file provided in upload request")
            return jsonify({'error': 'No file uploaded'}), 400
        file = request.files['file']
        if file.filename == '':
            logging.warning("No file selected in upload request")
            return jsonify({'error': 'No file selected'}), 400
        
        file_path = os.path.join(app.config['UPLOAD_FOLDER'], file.filename)
        try:
            file.save(file_path)
            logging.info(f"File saved: {file_path}")
        except Exception as e:
            logging.error(f"Failed to save file {file.filename}: {str(e)}")
            return jsonify({'error': f'Failed to save file: {str(e)}'}), 500

        try:
            # Read the file to get sheets and headers
            if file.filename.endswith('.xlsx') or file.filename.endswith('.xls'):
                xl = pd.ExcelFile(file_path)
                sheets = {sheet_name: pd.read_excel(file_path, sheet_name=sheet_name, header=None) 
                         for sheet_name in xl.sheet_names}
            elif file.filename.endswith(('.txt', '.csv', '.dat')):
                df = pd.read_csv(file_path, header=None, encoding='utf-8')
                sheets = {'Sheet1': df}
            else:
                logging.error("Unsupported file type")
                return jsonify({'error': 'Unsupported file type'}), 400
            
            logging.debug(f"Sheets extracted: {list(sheets.keys())}")
        except Exception as e:
            logging.error(f"Failed to read file {file_path}: {str(e)}")
            return jsonify({'error': f'Failed to read file: {str(e)}'}), 400

        try:
            sheet_names = list(sheets.keys())
            if not sheet_names:
                logging.error("No sheets found in the file")
                return jsonify({'error': 'No sheets found in the file'}), 400
            sheet_name = sheet_names[0]
            df = sheets[sheet_name]
            
            # Find header row
            header_row = 0
            for i in range(min(len(df), 10)):
                row = df.iloc[i].dropna()
                if not row.empty and all(isinstance(x, str) for x in row if pd.notna(x)):
                    header_row = i
                    break
                    
            headers = df.iloc[header_row].tolist()
            logging.debug(f"Headers extracted: {headers}")
            
            if not headers or all(not h for h in headers):
                logging.error("No valid headers found in file")
                return jsonify({'error': 'No valid headers found in the file'}), 400
        except Exception as e:
            logging.error(f"Error processing file {file.filename}: {str(e)}")
            return jsonify({'error': f'Error processing file: {str(e)}'}), 400

        # Clear existing session data
        for key in ['df', 'header_row', 'headers', 'sheet_name', 'current_step', 'selected_headers', 'validations', 'error_cell_locations', 'data_rows', 'corrected_file_path']:
            session.pop(key, None)

        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)

            # Check if template exists
            cursor.execute("""
                SELECT template_id, headers, sheet_name
                FROM excel_templates
                WHERE template_name = %s AND user_id = %s AND status = 'ACTIVE'
                ORDER BY created_at DESC
            """, (file.filename, session['user_id']))
            existing_templates = cursor.fetchall()
            logging.info(f"Found {len(existing_templates)} existing templates with name {file.filename}")

            template_id = None
            has_existing_rules = False
            validations = {}
            selected_headers = []

            # Check for matching template
            matching_template = None
            for template in existing_templates:
                stored_headers = json.loads(template['headers']) if template['headers'] else []
                stored_sheet_name = template['sheet_name']
                if stored_headers == headers and stored_sheet_name == sheet_name:
                    matching_template = template
                    break

            if matching_template:
                template_id = matching_template['template_id']
                # Check for existing rules
                cursor.execute("""
                    SELECT tc.column_name, vrt.rule_name
                    FROM template_columns tc
                    JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                    JOIN validation_rule_types vrt ON cvr.rule_type_id = vrt.rule_type_id
                    WHERE tc.template_id = %s AND tc.is_selected = TRUE
                """, (template_id,))
                rules_data = cursor.fetchall()
                for row in rules_data:
                    column_name = row['column_name']
                    rule_name = row['rule_name']
                    if column_name not in validations:
                        validations[column_name] = []
                    validations[column_name].append(rule_name)
                    if column_name not in selected_headers:
                        selected_headers.append(column_name)
                has_existing_rules = len(validations) > 0
            else:
                # New template
                cursor.execute("""
                    INSERT INTO excel_templates (template_name, user_id, sheet_name, headers, is_corrected)
                    VALUES (%s, %s, %s, %s, %s)
                """, (file.filename, session['user_id'], sheet_name, json.dumps(headers), False))
                template_id = cursor.lastrowid
                column_data = [(template_id, header, i + 1, False) for i, header in enumerate(headers)]
                cursor.executemany("""
                    INSERT INTO template_columns (template_id, column_name, column_position, is_selected)
                    VALUES (%s, %s, %s, %s)
                """, column_data)

            conn.commit()
            cursor.close()

            # Store session data
            session['file_path'] = file_path
            session['template_id'] = template_id
            session['df'] = df.to_json()
            session['header_row'] = header_row
            session['headers'] = headers
            session['sheet_name'] = sheet_name
            session['current_step'] = 1 if not has_existing_rules else 3
            session['validations'] = validations
            session['selected_headers'] = selected_headers
            session['has_existing_rules'] = has_existing_rules

            logging.info(f"Upload processed: template_id={template_id}, filename={file.filename}, has_existing_rules={has_existing_rules}")

            return jsonify({
                'success': True,
                'sheets': {sheet_name: {'headers': headers}},
                'file_name': file.filename,
                'template_id': template_id,
                'has_existing_rules': has_existing_rules,
                'sheet_name': sheet_name,
                'skip_to_step_3': has_existing_rules
            })
        except mysql.connector.Error as e:
            logging.error(f'Error saving template: {str(e)}')
            return jsonify({'error': f'Error saving template: {str(e)}'}), 500
        except Exception as e:
            logging.error(f'Unexpected error saving template: {str(e)}')
            return jsonify({'error': f'Unexpected error: {str(e)}'}), 500

    # Multi-step workflow endpoints
    @app.route('/step/1', methods=['GET', 'POST'])
    @app.route('/api/step/1', methods=['GET', 'POST'])
    def step_one():
        if 'loggedin' not in session:
            return jsonify({'error': 'Not logged in'}), 401
        
        if request.method == 'POST':
            try:
                headers = request.form.getlist('headers')
                new_header_row = request.form.get('new_header_row')
                logging.debug(f"Step 1 submitted: headers={headers}, new_header_row={new_header_row}")
                
                if not headers:
                    logging.error("No headers provided in step 1")
                    return jsonify({'success': False, 'message': 'No headers provided'}), 400
                    
                if 'template_id' not in session:
                    logging.error("Session missing template_id")
                    return jsonify({'success': False, 'message': 'Session data missing'}), 400

                template_id = session['template_id']
                
                # Get the dataframe from session for auto-detection
                df_json = session.get('df')
                if df_json:
                    df = pd.read_json(StringIO(df_json))
                    session_headers = session.get('headers', [])
                    df.columns = session_headers
                    header_row = session.get('header_row', 0)
                    df = df.iloc[header_row + 1:].reset_index(drop=True)
                    
                    # Auto-detect rules for selected headers
                    validations = assign_default_rules_to_columns(df, headers)
                    session['validations'] = validations
                    logging.debug(f"Auto-assigned rules: {validations}")
                else:
                    validations = {}

                session['selected_headers'] = headers
                session['current_step'] = 2

                # Mark selected headers in the database
                conn = get_db_connection()
                cursor = conn.cursor()
                cursor.execute("UPDATE template_columns SET is_selected = FALSE WHERE template_id = %s", (template_id,))
                for header in headers:
                    cursor.execute("""
                        UPDATE template_columns
                        SET is_selected = TRUE
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    
                    # Get column_id and add auto-detected rules
                    cursor.execute("""
                        SELECT column_id FROM template_columns
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    result = cursor.fetchone()
                    if result:
                        column_id = result[0]
                        for rule_name in validations.get(header, []):
                            cursor.execute("""
                                SELECT rule_type_id FROM validation_rule_types
                                WHERE rule_name = %s AND is_custom = FALSE
                            """, (rule_name,))
                            rule_result = cursor.fetchone()
                            if rule_result:
                                rule_type_id = rule_result[0]
                                cursor.execute("""
                                    INSERT IGNORE INTO column_validation_rules (column_id, rule_type_id, rule_config)
                                    VALUES (%s, %s, %s)
                                """, (column_id, rule_type_id, '{}'))
                
                conn.commit()
                cursor.close()

                logging.info(f"Step 1 completed: headers={headers}, auto-assigned rules={validations}")
                return jsonify({'success': True, 'headers': headers, 'validations': validations})
            except Exception as e:
                logging.error(f"Error in step 1: {str(e)}")
                return jsonify({'success': False, 'message': str(e)}), 500
        
        # GET request - return current headers
        headers = session.get('headers', [])
        return jsonify({'headers': headers})

    @app.route('/step/2', methods=['GET', 'POST'])
    @app.route('/api/step/2', methods=['GET', 'POST'])
    def step_two():
        if 'loggedin' not in session:
            return jsonify({'error': 'Not logged in'}), 401
            
        if request.method == 'POST':
            try:
                action = request.form.get('action', 'save')
                validations = {}
                for key, values in request.form.lists():
                    if key.startswith('validations_'):
                        header = key.replace('validations_', '')
                        validations[header] = values
                        
                logging.debug(f"Step 2 submitted: action={action}, validations={validations}")
                
                template_id = session.get('template_id')
                if not template_id:
                    return jsonify({'success': False, 'message': 'Session data missing'}), 400

                # Save validations to database
                conn = get_db_connection()
                cursor = conn.cursor()
                
                # Clear existing rules
                cursor.execute("""
                    DELETE FROM column_validation_rules
                    WHERE column_id IN (
                        SELECT column_id FROM template_columns WHERE template_id = %s
                    )
                """, (template_id,))
                
                # Add new rules
                for header, rules in validations.items():
                    cursor.execute("""
                        SELECT column_id FROM template_columns
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    result = cursor.fetchone()
                    if not result:
                        continue
                    column_id = result[0]
                    
                    for rule_name in rules:
                        cursor.execute("""
                            SELECT rule_type_id FROM validation_rule_types
                            WHERE rule_name = %s
                        """, (rule_name,))
                        result = cursor.fetchone()
                        if result:
                            rule_type_id = result[0]
                            cursor.execute("""
                                INSERT IGNORE INTO column_validation_rules (column_id, rule_type_id, rule_config)
                                VALUES (%s, %s, %s)
                            """, (column_id, rule_type_id, '{}'))
                
                conn.commit()
                cursor.close()

                session['validations'] = validations
                session['current_step'] = 3 if action == 'review' else 2
                
                logging.info(f"Step 2 completed: action={action}, validations={validations}")
                return jsonify({'success': True, 'message': 'Step 2 completed successfully'})
            except Exception as e:
                logging.error(f"Error in step 2: {str(e)}")
                return jsonify({'success': False, 'message': str(e)}), 500
        
        # GET request
        selected_headers = session.get('selected_headers', [])
        return jsonify({'selected_headers': selected_headers})

    # Rules endpoint
    @app.route('/rules', methods=['GET'])
    @app.route('/api/rules', methods=['GET'])
    def get_rules():
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            
            cursor.execute("""
                SELECT rule_type_id AS rule_id, rule_name, description, parameters, is_custom, 
                       column_name, template_id, source_format, target_format, data_type, is_active
                FROM validation_rule_types
            """)
            rules = cursor.fetchall()
            cursor.close()
            
            logging.info(f"Returning {len(rules)} rules from getRules endpoint")
            return jsonify({'success': True, 'rules': rules})
        except mysql.connector.Error as e:
            logging.error(f"Database error fetching rules: {str(e)}")
            return jsonify({'success': False, 'message': str(e)}), 500
        except Exception as e:
            logging.error(f"Unexpected error fetching rules: {str(e)}")
            return jsonify({'success': False, 'message': str(e)}), 500

    # Template details endpoint
    @app.route('/template/<int:template_id>/<sheet_name>', methods=['GET'])
    @app.route('/api/template/<int:template_id>/<sheet_name>', methods=['GET'])
    def get_template(template_id, sheet_name):
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /template: session missing")
            return jsonify({'error': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("""
                SELECT template_name, sheet_name, headers
                FROM excel_templates
                WHERE template_id = %s AND user_id = %s AND status = 'ACTIVE'
            """, (template_id, session['user_id']))
            template_record = cursor.fetchone()
            
            if not template_record:
                logging.error(f"Template not found for template_id: {template_id}, user_id: {session['user_id']}")
                cursor.close()
                return jsonify({'error': 'Template not found'}), 404

            headers = json.loads(template_record['headers']) if template_record['headers'] else []
            stored_sheet_name = template_record['sheet_name'] or sheet_name
            file_path = os.path.join(app.config['UPLOAD_FOLDER'], template_record['template_name'])
            
            cursor.execute("""
                SELECT COUNT(*) as rule_count
                FROM template_columns tc
                JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                WHERE tc.template_id = %s AND tc.is_selected = TRUE
            """, (template_id,))
            rule_count = cursor.fetchone()['rule_count']
            has_existing_rules = rule_count > 0
            
            cursor.close()
            
            return jsonify({
                'success': True,
                'sheets': {stored_sheet_name: {'headers': headers}},
                'file_name': template_record['template_name'],
                'file_path': file_path,
                'sheet_name': stored_sheet_name,
                'has_existing_rules': has_existing_rules
            })
        except mysql.connector.Error as e:
            logging.error(f"Database error in get_template: {str(e)}")
            return jsonify({'error': f'Database error: {str(e)}'}), 500
        except Exception as e:
            logging.error(f"Unexpected error in get_template: {str(e)}")
            return jsonify({'error': f'Unexpected error: {str(e)}'}), 500

    # Debug route to show all registered routes
    @app.route('/debug/routes', methods=['GET'])
    def list_routes():
        routes = []
        for rule in app.url_map.iter_rules():
            routes.append({
                'endpoint': rule.endpoint,
                'methods': list(rule.methods),
                'rule': rule.rule
            })
        return jsonify(routes)

    # 404 handler to debug missing routes
    @app.errorhandler(404)
    def not_found_handler(error):
        logging.error(f"404 Error: {request.method} {request.url} not found")
        logging.error(f"Available routes: {[rule.rule for rule in app.url_map.iter_rules()]}")
        return jsonify({
            'error': 'Endpoint not found', 
            'method': request.method,
            'url': request.url,
            'path': request.path
        }), 404

    return app

def initialize_app_data():
    """Initialize database and create default data"""
    try:
        logging.info("Initializing database schema...")
        init_db()
        
        logging.info("Creating admin user...")
        create_admin_user()
        
        logging.info("Creating default validation rules...")
        create_default_validation_rules()
        
        logging.info("Application initialization completed successfully")
    except Exception as e:
        logging.error(f"Failed to initialize application: {e}")
        raise

DB_CONFIG = {
    'host': os.getenv('MYSQL_HOST', 'localhost'),
    'user': os.getenv('MYSQL_USER', 'root'),
    'password': os.getenv('MYSQL_PASSWORD', 'Keansa@2024'),
    'database': os.getenv('MYSQL_DATABASE', 'data_validation_2'),
}

def get_db_connection():
    if 'db' not in g:
        try:
            conn = mysql.connector.connect(
                host=DB_CONFIG['host'],
                user=DB_CONFIG['user'],
                password=DB_CONFIG['password']
            )
            cursor = conn.cursor()
            cursor.execute(f"CREATE DATABASE IF NOT EXISTS {DB_CONFIG['database']}")
            cursor.close()
            conn.close()
            g.db = mysql.connector.connect(**DB_CONFIG)
            logging.info("Database connection established successfully")
        except mysql.connector.Error as err:
            if err.errno == errorcode.ER_ACCESS_DENIED_ERROR:
                logging.error("Database connection failed: Access denied for user - check username/password")
            elif err.errno == errorcode.ER_BAD_DB_ERROR:
                logging.error("Database connection failed: Database does not exist")
            else:
                logging.error(f"Database connection failed: {err}")
            raise Exception(f"Failed to connect to database: {str(err)}")
    return g.db

def close_db(error):
    db = g.pop('db', None)
    if db is not None:
        db.close()

def init_db():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        tables = [
            """
            CREATE TABLE IF NOT EXISTS login_details (
                id INT AUTO_INCREMENT PRIMARY KEY,
                first_name VARCHAR(100),
                last_name VARCHAR(100),
                email VARCHAR(255) UNIQUE,
                mobile VARCHAR(10),
                password VARCHAR(255)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS excel_templates (
                template_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_name VARCHAR(255) NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
                user_id INT NOT NULL,
                sheet_name VARCHAR(255),
                headers JSON,
                status ENUM('ACTIVE', 'INACTIVE') DEFAULT 'ACTIVE',
                is_corrected BOOLEAN DEFAULT FALSE,
                remote_file_path VARCHAR(512),
                FOREIGN KEY (user_id) REFERENCES login_details(id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS template_columns (
                column_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_id BIGINT NOT NULL,
                column_name VARCHAR(255) NOT NULL,
                column_position INT NOT NULL,
                is_validation_enabled BOOLEAN DEFAULT FALSE,
                is_selected BOOLEAN DEFAULT FALSE,
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE,
                UNIQUE (template_id, column_name)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_rule_types (
                rule_type_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                rule_name VARCHAR(255) NOT NULL,
                description TEXT,
                parameters TEXT,
                is_active BOOLEAN DEFAULT TRUE,
                is_custom BOOLEAN DEFAULT FALSE,
                column_name VARCHAR(255),
                template_id BIGINT,
                data_type VARCHAR(50),
                source_format VARCHAR(50),
                target_format VARCHAR(50),
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS column_validation_rules (
                column_validation_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                column_id BIGINT NOT NULL,
                rule_type_id BIGINT NOT NULL,
                rule_config JSON,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (column_id) REFERENCES template_columns(column_id) ON DELETE CASCADE,
                FOREIGN KEY (rule_type_id) REFERENCES validation_rule_types(rule_type_id) ON DELETE RESTRICT,
                UNIQUE (column_id, rule_type_id)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_history (
                history_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_id BIGINT NOT NULL,
                template_name VARCHAR(255) NOT NULL,
                error_count INT NOT NULL,
                corrected_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                corrected_file_path VARCHAR(512) NOT NULL,
                user_id INT NOT NULL,
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE,
                FOREIGN KEY (user_id) REFERENCES login_details(id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_corrections (
                correction_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                history_id BIGINT NOT NULL,
                row_index INT NOT NULL,
                column_name VARCHAR(255) NOT NULL,
                original_value TEXT,
                corrected_value TEXT,
                rule_failed VARCHAR(255) DEFAULT NULL,
                FOREIGN KEY (history_id) REFERENCES validation_history(history_id) ON DELETE CASCADE
            )
            """
        ]
        for table_sql in tables:
            cursor.execute(table_sql)
        
        # Add missing columns if they don't exist
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'source_format'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN source_format VARCHAR(50)")
            logging.info("Added source_format column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'target_format'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN target_format VARCHAR(50)")
            logging.info("Added target_format column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'data_type'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN data_type VARCHAR(50)")
            logging.info("Added data_type column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM excel_templates LIKE 'remote_file_path'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE excel_templates ADD COLUMN remote_file_path VARCHAR(512)")
            logging.info("Added remote_file_path column to excel_templates table")
            
        cursor.execute("SHOW COLUMNS FROM template_columns LIKE 'is_selected'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE template_columns ADD COLUMN is_selected BOOLEAN DEFAULT FALSE")
            logging.info("Added is_selected column to template_columns table")
            
        conn.commit()
        cursor.close()
        logging.info("Database tables initialized")
    except Exception as e:
        logging.error(f"Failed to initialize database: {str(e)}")
        raise

def create_admin_user():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        admin_password = bcrypt.hashpw('admin'.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
        cursor.execute("""
            INSERT IGNORE INTO login_details (first_name, last_name, email, mobile, password)
            VALUES (%s, %s, %s, %s, %s)
        """, ('Admin', 'User', 'admin@example.com', '1234567890', admin_password))
        conn.commit()
        cursor.close()
        logging.info("Admin user created or already exists")
    except Exception as e:
        logging.error(f"Failed to create admin user: {str(e)}")
        raise

def create_default_validation_rules():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        default_rules = [
            ("Required", "Ensures the field is not null", '{"allow_null": false}', None, None, None),
            ("Int", "Validates integer format", '{"format": "integer"}', None, None, "Int"),
            ("Float", "Validates number format (integer or decimal)", '{"format": "float"}', None, None, "Float"),
            ("Text", "Allows text with quotes and parentheses", '{"allow_special": false}', None, None, "Text"),
            ("Email", "Validates email format", '{"regex": "^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\\\.[a-zA-Z0-9-.]+$"}', None, None, "Email"),
            ("Date(DD-MM-YYYY)", "Validates date format DD-MM-YYYY", '{"format": "%d-%m-%Y"}', "DD-MM-YYYY", None, "Date"),
            ("Boolean", "Validates boolean format (true/false or 0/1)", '{"format": "boolean"}', None, None, "Boolean"),
            ("Alphanumeric", "Validates alphanumeric format", '{"format": "alphanumeric"}', None, None, "Alphanumeric")
        ]
        cursor.executemany("""
            INSERT IGNORE INTO validation_rule_types (rule_name, description, parameters, is_custom, source_format, target_format, data_type)
            VALUES (%s, %s, %s, %s, %s, %s, %s)
        """, [(name, desc, params, False, source, target, dtype) for name, desc, params, source, target, dtype in default_rules])
        conn.commit()
        cursor.close()
        logging.info("Default validation rules ensured successfully")
    except Exception as e:
        logging.error(f"Failed to ensure default validation rules: {str(e)}")
        raise

if __name__ == '__main__':
    try:
        # Create the application using factory pattern
        app = create_app()
        
        # Initialize database and default data within app context
        with app.app_context():
            initialize_app_data()
        
        # Get port from environment or use default
        port = int(os.getenv('PORT', 5000))
        
        # Start the application server
        logging.info("Starting Flask server...")
        app.run(debug=True, host='0.0.0.0', port=port)
        
    except Exception as e:
        logging.error(f"Failed to start application: {e}")
        raise
).all():
        return "Float"
    
    # Alphanumeric detection
    if non_null.str.match(r'^[a-zA-Z0-9]+

def create_app():
    """Application factory pattern for different environments"""
    # Set the path to the frontend dist folder
    current_dir = os.path.dirname(os.path.abspath(__file__))
    frontend_dist_path = os.path.join(current_dir, '..', '..', 'Keansa-Ai-Suite2025may-frontend11', 'dist')
    frontend_dist_path = os.path.abspath(frontend_dist_path)
    
    # Create Flask application instance
    app = Flask(__name__, static_folder=frontend_dist_path, static_url_path='')
    CORS(app, supports_credentials=True, origins=["http://localhost:3000", "http://localhost:8080", "http://localhost:5000", "*"])

    app.secret_key = os.urandom(24).hex()
    app.config['SESSION_TYPE'] = 'filesystem'
    app.config['SESSION_FILE_DIR'] = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'sessions')
    app.config['SESSION_COOKIE_SAMESITE'] = 'Lax'
    app.config['SESSION_COOKIE_HTTPONLY'] = True
    app.config['SESSION_COOKIE_SECURE'] = False
    app.config['PERMANENT_SESSION_LIFETIME'] = 86400  # 24 hours
    app.config['UPLOAD_FOLDER'] = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'uploads')
    Session(app)

    # Ensure directories exist
    try:
        os.makedirs(app.config['UPLOAD_FOLDER'], exist_ok=True)
        os.makedirs(app.config['SESSION_FILE_DIR'], exist_ok=True)
    except OSError as e:
        logging.error(f"Failed to create directories: {e}")

    # Register cleanup handlers
    app.teardown_appcontext(close_db)
    
    # Register all routes directly in create_app
    
    # Static file serving for React frontend
    @app.route('/', defaults={'path': ''})
    @app.route('/<path:path>')
    def serve(path):
        if path and os.path.exists(os.path.join(app.static_folder, path)):
            return app.send_static_file(path)
        return app.send_static_file('index.html')

    # Health check endpoint
    @app.route('/health', methods=['GET'])
    def health_check():
        return jsonify({
            'status': 'healthy',
            'timestamp': datetime.now().isoformat(),
            'version': '2.0.0'
        })

    # Authentication endpoint - both old and new paths
    @app.route('/authenticate', methods=['POST'])
    @app.route('/api/auth/authenticate', methods=['POST'])
    def authenticate():
        try:
            email = request.form.get('username') or request.form.get('email')
            password = request.form.get('password')
            logging.debug(f"Login attempt: email={email}, password={'*' * len(password) if password else 'None'}")
            
            if not email or not password:
                logging.warning(f"Login failed: Email or password missing")
                return jsonify({'success': False, 'message': 'Email and password are required'}), 400

            # Check for admin login
            if email == "admin" and password == "admin":
                session['loggedin'] = True
                session['user_email'] = "admin@example.com"
                session['user_id'] = 1
                session.permanent = True
                logging.info(f"Admin login successful. Session: {dict(session)}")
                return jsonify({'success': True, 'message': 'Login successful', 'user': {'email': 'admin@example.com', 'id': 1}}), 200

            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("SELECT * FROM login_details WHERE LOWER(email) = LOWER(%s)", (email.lower(),))
            account = cursor.fetchone()
            cursor.close()
            
            if account:
                if bcrypt.checkpw(password.encode('utf-8'), account['password'].encode('utf-8')):
                    session['loggedin'] = True
                    session['user_email'] = account['email']
                    session['user_id'] = account['id']
                    session.permanent = True
                    logging.info(f"User {email} logged in successfully. Session: {dict(session)}")
                    return jsonify({
                        'success': True,
                        'message': 'Login successful',
                        'user': {'email': account['email'], 'id': account['id']}
                    }), 200
                else:
                    logging.warning(f"Invalid password for {email}")
                    return jsonify({'success': False, 'message': 'Invalid credentials'}), 401
            else:
                logging.warning(f"Email {email} not found")
                return jsonify({'success': False, 'message': 'Invalid credentials'}), 401
        except Exception as e:
            logging.error(f"Unexpected error during login: {str(e)}")
            return jsonify({'success': False, 'message': f'Unexpected error: {str(e)}'}), 500

    @app.route('/check-auth', methods=['GET'])
    @app.route('/api/auth/check-auth', methods=['GET'])
    def check_auth():
        try:
            logging.debug(f"Checking auth with session: {dict(session)}")
            if 'loggedin' in session and 'user_id' in session:
                conn = get_db_connection()
                cursor = conn.cursor(dictionary=True)
                cursor.execute("SELECT email, first_name FROM login_details WHERE id = %s", (session['user_id'],))
                user = cursor.fetchone()
                cursor.close()
                if user:
                    logging.info(f"User {session.get('user_email')} is authenticated")
                    return jsonify({
                        'success': True,
                        'user': {
                            'email': user['email'],
                            'id': session['user_id'],
                            'first_name': user['first_name']
                        }
                    })
                else:
                    logging.warning("User not found in database")  
                    session.clear()
                    return jsonify({'success': False, 'message': 'User not found'}), 401
            logging.warning("User not authenticated")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        except Exception as e:
            logging.error(f"Error in check-auth endpoint: {str(e)}")
            return jsonify({'success': False, 'message': f'Server error: {str(e)}'}), 500

    @app.route('/register', methods=['POST'])
    @app.route('/api/auth/register', methods=['POST'])
    def register():
        first_name = request.form.get('first_name')
        last_name = request.form.get('last_name')
        email = request.form.get('email')
        mobile = request.form.get('mobile')
        password = request.form.get('password')
        confirm_password = request.form.get('confirm_password')

        if not all([first_name, last_name, email, mobile, password, confirm_password]):
            return jsonify({'success': False, 'message': 'All fields are required'}), 400
        if password != confirm_password:
            return jsonify({'success': False, 'message': 'Passwords do not match'}), 400

        hashed_password = bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
        try:
            conn = get_db_connection()
            cursor = conn.cursor()
            cursor.execute("""
                INSERT INTO login_details (first_name, last_name, email, mobile, password)
                VALUES (%s, %s, %s, %s, %s)
            """, (first_name, last_name, email, mobile, hashed_password))
            user_id = cursor.lastrowid
            conn.commit()
            cursor.close()
            session['loggedin'] = True
            session['user_email'] = email
            session['user_id'] = user_id
            return jsonify({
                'success': True,
                'message': 'Registration successful',
                'user': {'email': email, 'id': user_id}
            }), 200
        except mysql.connector.Error as e:
            logging.error(f"Database error during registration: {str(e)}")
            return jsonify({'success': False, 'message': f'Registration error: {str(e)}'}), 500

    @app.route('/logout', methods=['POST'])
    @app.route('/api/auth/logout', methods=['POST'])
    def logout():
        logging.info(f"User {session.get('user_email', 'unknown')} logged out")
        session.clear()
        return jsonify({'success': True, 'message': 'Logged out successfully'})

    # Template routes
    @app.route('/templates', methods=['GET'])
    @app.route('/api/templates', methods=['GET'])
    def get_templates():
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /templates: session missing")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("""
                SELECT template_id, template_name, created_at, status
                FROM excel_templates
                WHERE user_id = %s AND status = 'ACTIVE'
                ORDER BY created_at DESC
                LIMIT 100
            """, (session['user_id'],))
            templates = cursor.fetchall()
            cursor.close()
            logging.info(f"Fetched {len(templates)} templates for user {session['user_id']}")
            return jsonify({'success': True, 'templates': templates})
        except mysql.connector.Error as e:
            logging.error(f'Error fetching templates: {str(e)}')
            return jsonify({'success': False, 'message': f'Error fetching templates: {str(e)}'}), 500
        except Exception as e:
            logging.error(f'Unexpected error fetching templates: {str(e)}')
            return jsonify({'success': False, 'message': f'Unexpected error: {str(e)}'}), 500

    # Rule Configuration routes
    @app.route('/rule-configurations', methods=['GET'])
    @app.route('/api/validation/rule-configurations', methods=['GET'])
    def get_rule_configurations():
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning(f"Unauthorized access to /rule-configurations: session={dict(session)}")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            user_id = session['user_id']
            logging.debug(f"Fetching rule configurations for user_id: {user_id}")

            # Main query to fetch templates with configured rules
            cursor.execute("""
                SELECT 
                    t.template_id, 
                    t.template_name, 
                    t.created_at, 
                    COUNT(cvr.column_validation_id) as rule_count
                FROM excel_templates t
                LEFT JOIN template_columns tc ON t.template_id = tc.template_id
                LEFT JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                WHERE t.user_id = %s AND t.status = 'ACTIVE' AND t.is_corrected = FALSE
                GROUP BY t.template_id, t.template_name, t.created_at
                HAVING rule_count > 0
                ORDER BY t.created_at DESC
                LIMIT 100
            """, (user_id,))
            templates = cursor.fetchall()
            logging.debug(f"Fetched rule-configured templates: {templates}")

            cursor.close()

            if not templates:
                logging.info(f"No templates with rules found for user_id: {user_id}")
            else:
                logging.info(f"Found {len(templates)} templates with rules for user_id: {user_id}")

            return jsonify({'success': True, 'templates': templates})
        except mysql.connector.Error as e:
            logging.error(f"Database error fetching rule configurations: {str(e)}")
            return jsonify({'success': False, 'message': f"Database error: {str(e)}"}), 500
        except Exception as e:
            logging.error(f"Unexpected error fetching rule configurations: {str(e)}")
            return jsonify({'success': False, 'message': f"Unexpected error: {str(e)}"}), 500

    # File upload route
    @app.route('/upload', methods=['POST'])
    @app.route('/api/templates/upload', methods=['POST'])
    @app.route('/api/upload', methods=['POST'])  # Additional common path
    def upload():
        logging.info(f"Upload endpoint called: {request.endpoint}, method: {request.method}")
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /upload: session missing")
            return jsonify({'error': 'Not logged in'}), 401
        if 'file' not in request.files:
            logging.warning("No file provided in upload request")
            return jsonify({'error': 'No file uploaded'}), 400
        file = request.files['file']
        if file.filename == '':
            logging.warning("No file selected in upload request")
            return jsonify({'error': 'No file selected'}), 400
        
        file_path = os.path.join(app.config['UPLOAD_FOLDER'], file.filename)
        try:
            file.save(file_path)
            logging.info(f"File saved: {file_path}")
        except Exception as e:
            logging.error(f"Failed to save file {file.filename}: {str(e)}")
            return jsonify({'error': f'Failed to save file: {str(e)}'}), 500

        try:
            # Read the file to get sheets and headers
            if file.filename.endswith('.xlsx') or file.filename.endswith('.xls'):
                xl = pd.ExcelFile(file_path)
                sheets = {sheet_name: pd.read_excel(file_path, sheet_name=sheet_name, header=None) 
                         for sheet_name in xl.sheet_names}
            elif file.filename.endswith(('.txt', '.csv', '.dat')):
                df = pd.read_csv(file_path, header=None, encoding='utf-8')
                sheets = {'Sheet1': df}
            else:
                logging.error("Unsupported file type")
                return jsonify({'error': 'Unsupported file type'}), 400
            
            logging.debug(f"Sheets extracted: {list(sheets.keys())}")
        except Exception as e:
            logging.error(f"Failed to read file {file_path}: {str(e)}")
            return jsonify({'error': f'Failed to read file: {str(e)}'}), 400

        try:
            sheet_names = list(sheets.keys())
            if not sheet_names:
                logging.error("No sheets found in the file")
                return jsonify({'error': 'No sheets found in the file'}), 400
            sheet_name = sheet_names[0]
            df = sheets[sheet_name]
            
            # Find header row
            header_row = 0
            for i in range(min(len(df), 10)):
                row = df.iloc[i].dropna()
                if not row.empty and all(isinstance(x, str) for x in row if pd.notna(x)):
                    header_row = i
                    break
                    
            headers = df.iloc[header_row].tolist()
            logging.debug(f"Headers extracted: {headers}")
            
            if not headers or all(not h for h in headers):
                logging.error("No valid headers found in file")
                return jsonify({'error': 'No valid headers found in the file'}), 400
        except Exception as e:
            logging.error(f"Error processing file {file.filename}: {str(e)}")
            return jsonify({'error': f'Error processing file: {str(e)}'}), 400

        # Clear existing session data
        for key in ['df', 'header_row', 'headers', 'sheet_name', 'current_step', 'selected_headers', 'validations', 'error_cell_locations', 'data_rows', 'corrected_file_path']:
            session.pop(key, None)

        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)

            # Check if template exists
            cursor.execute("""
                SELECT template_id, headers, sheet_name
                FROM excel_templates
                WHERE template_name = %s AND user_id = %s AND status = 'ACTIVE'
                ORDER BY created_at DESC
            """, (file.filename, session['user_id']))
            existing_templates = cursor.fetchall()
            logging.info(f"Found {len(existing_templates)} existing templates with name {file.filename}")

            template_id = None
            has_existing_rules = False
            validations = {}
            selected_headers = []

            # Check for matching template
            matching_template = None
            for template in existing_templates:
                stored_headers = json.loads(template['headers']) if template['headers'] else []
                stored_sheet_name = template['sheet_name']
                if stored_headers == headers and stored_sheet_name == sheet_name:
                    matching_template = template
                    break

            if matching_template:
                template_id = matching_template['template_id']
                # Check for existing rules
                cursor.execute("""
                    SELECT tc.column_name, vrt.rule_name
                    FROM template_columns tc
                    JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                    JOIN validation_rule_types vrt ON cvr.rule_type_id = vrt.rule_type_id
                    WHERE tc.template_id = %s AND tc.is_selected = TRUE
                """, (template_id,))
                rules_data = cursor.fetchall()
                for row in rules_data:
                    column_name = row['column_name']
                    rule_name = row['rule_name']
                    if column_name not in validations:
                        validations[column_name] = []
                    validations[column_name].append(rule_name)
                    if column_name not in selected_headers:
                        selected_headers.append(column_name)
                has_existing_rules = len(validations) > 0
            else:
                # New template
                cursor.execute("""
                    INSERT INTO excel_templates (template_name, user_id, sheet_name, headers, is_corrected)
                    VALUES (%s, %s, %s, %s, %s)
                """, (file.filename, session['user_id'], sheet_name, json.dumps(headers), False))
                template_id = cursor.lastrowid
                column_data = [(template_id, header, i + 1, False) for i, header in enumerate(headers)]
                cursor.executemany("""
                    INSERT INTO template_columns (template_id, column_name, column_position, is_selected)
                    VALUES (%s, %s, %s, %s)
                """, column_data)

            conn.commit()
            cursor.close()

            # Store session data
            session['file_path'] = file_path
            session['template_id'] = template_id
            session['df'] = df.to_json()
            session['header_row'] = header_row
            session['headers'] = headers
            session['sheet_name'] = sheet_name
            session['current_step'] = 1 if not has_existing_rules else 3
            session['validations'] = validations
            session['selected_headers'] = selected_headers
            session['has_existing_rules'] = has_existing_rules

            logging.info(f"Upload processed: template_id={template_id}, filename={file.filename}, has_existing_rules={has_existing_rules}")

            return jsonify({
                'success': True,
                'sheets': {sheet_name: {'headers': headers}},
                'file_name': file.filename,
                'template_id': template_id,
                'has_existing_rules': has_existing_rules,
                'sheet_name': sheet_name,
                'skip_to_step_3': has_existing_rules
            })
        except mysql.connector.Error as e:
            logging.error(f'Error saving template: {str(e)}')
            return jsonify({'error': f'Error saving template: {str(e)}'}), 500
        except Exception as e:
            logging.error(f'Unexpected error saving template: {str(e)}')
            return jsonify({'error': f'Unexpected error: {str(e)}'}), 500

    # Multi-step workflow endpoints
    @app.route('/step/1', methods=['GET', 'POST'])
    @app.route('/api/step/1', methods=['GET', 'POST'])
    def step_one():
        if 'loggedin' not in session:
            return jsonify({'error': 'Not logged in'}), 401
        
        if request.method == 'POST':
            try:
                headers = request.form.getlist('headers')
                new_header_row = request.form.get('new_header_row')
                logging.debug(f"Step 1 submitted: headers={headers}, new_header_row={new_header_row}")
                
                if not headers:
                    logging.error("No headers provided in step 1")
                    return jsonify({'success': False, 'message': 'No headers provided'}), 400
                    
                if 'template_id' not in session:
                    logging.error("Session missing template_id")
                    return jsonify({'success': False, 'message': 'Session data missing'}), 400

                template_id = session['template_id']
                
                # Get the dataframe from session for auto-detection
                df_json = session.get('df')
                if df_json:
                    df = pd.read_json(StringIO(df_json))
                    session_headers = session.get('headers', [])
                    df.columns = session_headers
                    header_row = session.get('header_row', 0)
                    df = df.iloc[header_row + 1:].reset_index(drop=True)
                    
                    # Auto-detect rules for selected headers
                    validations = assign_default_rules_to_columns(df, headers)
                    session['validations'] = validations
                    logging.debug(f"Auto-assigned rules: {validations}")
                else:
                    validations = {}

                session['selected_headers'] = headers
                session['current_step'] = 2

                # Mark selected headers in the database
                conn = get_db_connection()
                cursor = conn.cursor()
                cursor.execute("UPDATE template_columns SET is_selected = FALSE WHERE template_id = %s", (template_id,))
                for header in headers:
                    cursor.execute("""
                        UPDATE template_columns
                        SET is_selected = TRUE
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    
                    # Get column_id and add auto-detected rules
                    cursor.execute("""
                        SELECT column_id FROM template_columns
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    result = cursor.fetchone()
                    if result:
                        column_id = result[0]
                        for rule_name in validations.get(header, []):
                            cursor.execute("""
                                SELECT rule_type_id FROM validation_rule_types
                                WHERE rule_name = %s AND is_custom = FALSE
                            """, (rule_name,))
                            rule_result = cursor.fetchone()
                            if rule_result:
                                rule_type_id = rule_result[0]
                                cursor.execute("""
                                    INSERT IGNORE INTO column_validation_rules (column_id, rule_type_id, rule_config)
                                    VALUES (%s, %s, %s)
                                """, (column_id, rule_type_id, '{}'))
                
                conn.commit()
                cursor.close()

                logging.info(f"Step 1 completed: headers={headers}, auto-assigned rules={validations}")
                return jsonify({'success': True, 'headers': headers, 'validations': validations})
            except Exception as e:
                logging.error(f"Error in step 1: {str(e)}")
                return jsonify({'success': False, 'message': str(e)}), 500
        
        # GET request - return current headers
        headers = session.get('headers', [])
        return jsonify({'headers': headers})

    @app.route('/step/2', methods=['GET', 'POST'])
    @app.route('/api/step/2', methods=['GET', 'POST'])
    def step_two():
        if 'loggedin' not in session:
            return jsonify({'error': 'Not logged in'}), 401
            
        if request.method == 'POST':
            try:
                action = request.form.get('action', 'save')
                validations = {}
                for key, values in request.form.lists():
                    if key.startswith('validations_'):
                        header = key.replace('validations_', '')
                        validations[header] = values
                        
                logging.debug(f"Step 2 submitted: action={action}, validations={validations}")
                
                template_id = session.get('template_id')
                if not template_id:
                    return jsonify({'success': False, 'message': 'Session data missing'}), 400

                # Save validations to database
                conn = get_db_connection()
                cursor = conn.cursor()
                
                # Clear existing rules
                cursor.execute("""
                    DELETE FROM column_validation_rules
                    WHERE column_id IN (
                        SELECT column_id FROM template_columns WHERE template_id = %s
                    )
                """, (template_id,))
                
                # Add new rules
                for header, rules in validations.items():
                    cursor.execute("""
                        SELECT column_id FROM template_columns
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    result = cursor.fetchone()
                    if not result:
                        continue
                    column_id = result[0]
                    
                    for rule_name in rules:
                        cursor.execute("""
                            SELECT rule_type_id FROM validation_rule_types
                            WHERE rule_name = %s
                        """, (rule_name,))
                        result = cursor.fetchone()
                        if result:
                            rule_type_id = result[0]
                            cursor.execute("""
                                INSERT IGNORE INTO column_validation_rules (column_id, rule_type_id, rule_config)
                                VALUES (%s, %s, %s)
                            """, (column_id, rule_type_id, '{}'))
                
                conn.commit()
                cursor.close()

                session['validations'] = validations
                session['current_step'] = 3 if action == 'review' else 2
                
                logging.info(f"Step 2 completed: action={action}, validations={validations}")
                return jsonify({'success': True, 'message': 'Step 2 completed successfully'})
            except Exception as e:
                logging.error(f"Error in step 2: {str(e)}")
                return jsonify({'success': False, 'message': str(e)}), 500
        
        # GET request
        selected_headers = session.get('selected_headers', [])
        return jsonify({'selected_headers': selected_headers})

    # Rules endpoint
    @app.route('/rules', methods=['GET'])
    @app.route('/api/rules', methods=['GET'])
    def get_rules():
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            
            cursor.execute("""
                SELECT rule_type_id AS rule_id, rule_name, description, parameters, is_custom, 
                       column_name, template_id, source_format, target_format, data_type, is_active
                FROM validation_rule_types
            """)
            rules = cursor.fetchall()
            cursor.close()
            
            logging.info(f"Returning {len(rules)} rules from getRules endpoint")
            return jsonify({'success': True, 'rules': rules})
        except mysql.connector.Error as e:
            logging.error(f"Database error fetching rules: {str(e)}")
            return jsonify({'success': False, 'message': str(e)}), 500
        except Exception as e:
            logging.error(f"Unexpected error fetching rules: {str(e)}")
            return jsonify({'success': False, 'message': str(e)}), 500

    # Template details endpoint
    @app.route('/template/<int:template_id>/<sheet_name>', methods=['GET'])
    @app.route('/api/template/<int:template_id>/<sheet_name>', methods=['GET'])
    def get_template(template_id, sheet_name):
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /template: session missing")
            return jsonify({'error': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("""
                SELECT template_name, sheet_name, headers
                FROM excel_templates
                WHERE template_id = %s AND user_id = %s AND status = 'ACTIVE'
            """, (template_id, session['user_id']))
            template_record = cursor.fetchone()
            
            if not template_record:
                logging.error(f"Template not found for template_id: {template_id}, user_id: {session['user_id']}")
                cursor.close()
                return jsonify({'error': 'Template not found'}), 404

            headers = json.loads(template_record['headers']) if template_record['headers'] else []
            stored_sheet_name = template_record['sheet_name'] or sheet_name
            file_path = os.path.join(app.config['UPLOAD_FOLDER'], template_record['template_name'])
            
            cursor.execute("""
                SELECT COUNT(*) as rule_count
                FROM template_columns tc
                JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                WHERE tc.template_id = %s AND tc.is_selected = TRUE
            """, (template_id,))
            rule_count = cursor.fetchone()['rule_count']
            has_existing_rules = rule_count > 0
            
            cursor.close()
            
            return jsonify({
                'success': True,
                'sheets': {stored_sheet_name: {'headers': headers}},
                'file_name': template_record['template_name'],
                'file_path': file_path,
                'sheet_name': stored_sheet_name,
                'has_existing_rules': has_existing_rules
            })
        except mysql.connector.Error as e:
            logging.error(f"Database error in get_template: {str(e)}")
            return jsonify({'error': f'Database error: {str(e)}'}), 500
        except Exception as e:
            logging.error(f"Unexpected error in get_template: {str(e)}")
            return jsonify({'error': f'Unexpected error: {str(e)}'}), 500

    # Debug route to show all registered routes
    @app.route('/debug/routes', methods=['GET'])
    def list_routes():
        routes = []
        for rule in app.url_map.iter_rules():
            routes.append({
                'endpoint': rule.endpoint,
                'methods': list(rule.methods),
                'rule': rule.rule
            })
        return jsonify(routes)

    # 404 handler to debug missing routes
    @app.errorhandler(404)
    def not_found_handler(error):
        logging.error(f"404 Error: {request.method} {request.url} not found")
        logging.error(f"Available routes: {[rule.rule for rule in app.url_map.iter_rules()]}")
        return jsonify({
            'error': 'Endpoint not found', 
            'method': request.method,
            'url': request.url,
            'path': request.path
        }), 404

    return app

def initialize_app_data():
    """Initialize database and create default data"""
    try:
        logging.info("Initializing database schema...")
        init_db()
        
        logging.info("Creating admin user...")
        create_admin_user()
        
        logging.info("Creating default validation rules...")
        create_default_validation_rules()
        
        logging.info("Application initialization completed successfully")
    except Exception as e:
        logging.error(f"Failed to initialize application: {e}")
        raise

DB_CONFIG = {
    'host': os.getenv('MYSQL_HOST', 'localhost'),
    'user': os.getenv('MYSQL_USER', 'root'),
    'password': os.getenv('MYSQL_PASSWORD', 'Keansa@2024'),
    'database': os.getenv('MYSQL_DATABASE', 'data_validation_2'),
}

def get_db_connection():
    if 'db' not in g:
        try:
            conn = mysql.connector.connect(
                host=DB_CONFIG['host'],
                user=DB_CONFIG['user'],
                password=DB_CONFIG['password']
            )
            cursor = conn.cursor()
            cursor.execute(f"CREATE DATABASE IF NOT EXISTS {DB_CONFIG['database']}")
            cursor.close()
            conn.close()
            g.db = mysql.connector.connect(**DB_CONFIG)
            logging.info("Database connection established successfully")
        except mysql.connector.Error as err:
            if err.errno == errorcode.ER_ACCESS_DENIED_ERROR:
                logging.error("Database connection failed: Access denied for user - check username/password")
            elif err.errno == errorcode.ER_BAD_DB_ERROR:
                logging.error("Database connection failed: Database does not exist")
            else:
                logging.error(f"Database connection failed: {err}")
            raise Exception(f"Failed to connect to database: {str(err)}")
    return g.db

def close_db(error):
    db = g.pop('db', None)
    if db is not None:
        db.close()

def init_db():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        tables = [
            """
            CREATE TABLE IF NOT EXISTS login_details (
                id INT AUTO_INCREMENT PRIMARY KEY,
                first_name VARCHAR(100),
                last_name VARCHAR(100),
                email VARCHAR(255) UNIQUE,
                mobile VARCHAR(10),
                password VARCHAR(255)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS excel_templates (
                template_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_name VARCHAR(255) NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
                user_id INT NOT NULL,
                sheet_name VARCHAR(255),
                headers JSON,
                status ENUM('ACTIVE', 'INACTIVE') DEFAULT 'ACTIVE',
                is_corrected BOOLEAN DEFAULT FALSE,
                remote_file_path VARCHAR(512),
                FOREIGN KEY (user_id) REFERENCES login_details(id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS template_columns (
                column_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_id BIGINT NOT NULL,
                column_name VARCHAR(255) NOT NULL,
                column_position INT NOT NULL,
                is_validation_enabled BOOLEAN DEFAULT FALSE,
                is_selected BOOLEAN DEFAULT FALSE,
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE,
                UNIQUE (template_id, column_name)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_rule_types (
                rule_type_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                rule_name VARCHAR(255) NOT NULL,
                description TEXT,
                parameters TEXT,
                is_active BOOLEAN DEFAULT TRUE,
                is_custom BOOLEAN DEFAULT FALSE,
                column_name VARCHAR(255),
                template_id BIGINT,
                data_type VARCHAR(50),
                source_format VARCHAR(50),
                target_format VARCHAR(50),
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS column_validation_rules (
                column_validation_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                column_id BIGINT NOT NULL,
                rule_type_id BIGINT NOT NULL,
                rule_config JSON,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (column_id) REFERENCES template_columns(column_id) ON DELETE CASCADE,
                FOREIGN KEY (rule_type_id) REFERENCES validation_rule_types(rule_type_id) ON DELETE RESTRICT,
                UNIQUE (column_id, rule_type_id)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_history (
                history_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_id BIGINT NOT NULL,
                template_name VARCHAR(255) NOT NULL,
                error_count INT NOT NULL,
                corrected_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                corrected_file_path VARCHAR(512) NOT NULL,
                user_id INT NOT NULL,
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE,
                FOREIGN KEY (user_id) REFERENCES login_details(id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_corrections (
                correction_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                history_id BIGINT NOT NULL,
                row_index INT NOT NULL,
                column_name VARCHAR(255) NOT NULL,
                original_value TEXT,
                corrected_value TEXT,
                rule_failed VARCHAR(255) DEFAULT NULL,
                FOREIGN KEY (history_id) REFERENCES validation_history(history_id) ON DELETE CASCADE
            )
            """
        ]
        for table_sql in tables:
            cursor.execute(table_sql)
        
        # Add missing columns if they don't exist
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'source_format'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN source_format VARCHAR(50)")
            logging.info("Added source_format column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'target_format'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN target_format VARCHAR(50)")
            logging.info("Added target_format column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'data_type'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN data_type VARCHAR(50)")
            logging.info("Added data_type column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM excel_templates LIKE 'remote_file_path'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE excel_templates ADD COLUMN remote_file_path VARCHAR(512)")
            logging.info("Added remote_file_path column to excel_templates table")
            
        cursor.execute("SHOW COLUMNS FROM template_columns LIKE 'is_selected'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE template_columns ADD COLUMN is_selected BOOLEAN DEFAULT FALSE")
            logging.info("Added is_selected column to template_columns table")
            
        conn.commit()
        cursor.close()
        logging.info("Database tables initialized")
    except Exception as e:
        logging.error(f"Failed to initialize database: {str(e)}")
        raise

def create_admin_user():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        admin_password = bcrypt.hashpw('admin'.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
        cursor.execute("""
            INSERT IGNORE INTO login_details (first_name, last_name, email, mobile, password)
            VALUES (%s, %s, %s, %s, %s)
        """, ('Admin', 'User', 'admin@example.com', '1234567890', admin_password))
        conn.commit()
        cursor.close()
        logging.info("Admin user created or already exists")
    except Exception as e:
        logging.error(f"Failed to create admin user: {str(e)}")
        raise

def create_default_validation_rules():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        default_rules = [
            ("Required", "Ensures the field is not null", '{"allow_null": false}', None, None, None),
            ("Int", "Validates integer format", '{"format": "integer"}', None, None, "Int"),
            ("Float", "Validates number format (integer or decimal)", '{"format": "float"}', None, None, "Float"),
            ("Text", "Allows text with quotes and parentheses", '{"allow_special": false}', None, None, "Text"),
            ("Email", "Validates email format", '{"regex": "^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\\\.[a-zA-Z0-9-.]+$"}', None, None, "Email"),
            ("Date(DD-MM-YYYY)", "Validates date format DD-MM-YYYY", '{"format": "%d-%m-%Y"}', "DD-MM-YYYY", None, "Date"),
            ("Boolean", "Validates boolean format (true/false or 0/1)", '{"format": "boolean"}', None, None, "Boolean"),
            ("Alphanumeric", "Validates alphanumeric format", '{"format": "alphanumeric"}', None, None, "Alphanumeric")
        ]
        cursor.executemany("""
            INSERT IGNORE INTO validation_rule_types (rule_name, description, parameters, is_custom, source_format, target_format, data_type)
            VALUES (%s, %s, %s, %s, %s, %s, %s)
        """, [(name, desc, params, False, source, target, dtype) for name, desc, params, source, target, dtype in default_rules])
        conn.commit()
        cursor.close()
        logging.info("Default validation rules ensured successfully")
    except Exception as e:
        logging.error(f"Failed to ensure default validation rules: {str(e)}")
        raise

if __name__ == '__main__':
    try:
        # Create the application using factory pattern
        app = create_app()
        
        # Initialize database and default data within app context
        with app.app_context():
            initialize_app_data()
        
        # Get port from environment or use default
        port = int(os.getenv('PORT', 5000))
        
        # Start the application server
        logging.info("Starting Flask server...")
        app.run(debug=True, host='0.0.0.0', port=port)
        
    except Exception as e:
        logging.error(f"Failed to start application: {e}")
        raise
).all():
        return "Alphanumeric"
    
    return "Text"

def assign_default_rules_to_columns(df, headers):
    """Intelligently assign validation rules based on column content"""
    assignments = {}
    
    for col in headers:
        if col not in df.columns:
            logging.warning(f"Column {col} not found in dataframe")
            continue
            
        col_type = detect_column_type(df[col])
        rules = ["Required"]  # Default rule for all columns
        
        # Special handling for optional columns
        if not any(col.lower().startswith(prefix) for prefix in
                  ["name", "address", "phone", "username", "status", "period"]):
            rules.append(col_type)
        else:
            rules.append("Text")  # Optional text fields
        
        assignments[col] = rules
    
    return assignments

def create_app():
    """Application factory pattern for different environments"""
    # Set the path to the frontend dist folder
    current_dir = os.path.dirname(os.path.abspath(__file__))
    frontend_dist_path = os.path.join(current_dir, '..', '..', 'Keansa-Ai-Suite2025may-frontend11', 'dist')
    frontend_dist_path = os.path.abspath(frontend_dist_path)
    
    # Create Flask application instance
    app = Flask(__name__, static_folder=frontend_dist_path, static_url_path='')
    CORS(app, supports_credentials=True, origins=["http://localhost:3000", "http://localhost:8080", "http://localhost:5000", "*"])

    app.secret_key = os.urandom(24).hex()
    app.config['SESSION_TYPE'] = 'filesystem'
    app.config['SESSION_FILE_DIR'] = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'sessions')
    app.config['SESSION_COOKIE_SAMESITE'] = 'Lax'
    app.config['SESSION_COOKIE_HTTPONLY'] = True
    app.config['SESSION_COOKIE_SECURE'] = False
    app.config['PERMANENT_SESSION_LIFETIME'] = 86400  # 24 hours
    app.config['UPLOAD_FOLDER'] = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'uploads')
    Session(app)

    # Ensure directories exist
    try:
        os.makedirs(app.config['UPLOAD_FOLDER'], exist_ok=True)
        os.makedirs(app.config['SESSION_FILE_DIR'], exist_ok=True)
    except OSError as e:
        logging.error(f"Failed to create directories: {e}")

    # Register cleanup handlers
    app.teardown_appcontext(close_db)
    
    # Register all routes directly in create_app
    
    # Static file serving for React frontend
    @app.route('/', defaults={'path': ''})
    @app.route('/<path:path>')
    def serve(path):
        if path and os.path.exists(os.path.join(app.static_folder, path)):
            return app.send_static_file(path)
        return app.send_static_file('index.html')

    # Health check endpoint
    @app.route('/health', methods=['GET'])
    def health_check():
        return jsonify({
            'status': 'healthy',
            'timestamp': datetime.now().isoformat(),
            'version': '2.0.0'
        })

    # Authentication endpoint - both old and new paths
    @app.route('/authenticate', methods=['POST'])
    @app.route('/api/auth/authenticate', methods=['POST'])
    def authenticate():
        try:
            email = request.form.get('username') or request.form.get('email')
            password = request.form.get('password')
            logging.debug(f"Login attempt: email={email}, password={'*' * len(password) if password else 'None'}")
            
            if not email or not password:
                logging.warning(f"Login failed: Email or password missing")
                return jsonify({'success': False, 'message': 'Email and password are required'}), 400

            # Check for admin login
            if email == "admin" and password == "admin":
                session['loggedin'] = True
                session['user_email'] = "admin@example.com"
                session['user_id'] = 1
                session.permanent = True
                logging.info(f"Admin login successful. Session: {dict(session)}")
                return jsonify({'success': True, 'message': 'Login successful', 'user': {'email': 'admin@example.com', 'id': 1}}), 200

            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("SELECT * FROM login_details WHERE LOWER(email) = LOWER(%s)", (email.lower(),))
            account = cursor.fetchone()
            cursor.close()
            
            if account:
                if bcrypt.checkpw(password.encode('utf-8'), account['password'].encode('utf-8')):
                    session['loggedin'] = True
                    session['user_email'] = account['email']
                    session['user_id'] = account['id']
                    session.permanent = True
                    logging.info(f"User {email} logged in successfully. Session: {dict(session)}")
                    return jsonify({
                        'success': True,
                        'message': 'Login successful',
                        'user': {'email': account['email'], 'id': account['id']}
                    }), 200
                else:
                    logging.warning(f"Invalid password for {email}")
                    return jsonify({'success': False, 'message': 'Invalid credentials'}), 401
            else:
                logging.warning(f"Email {email} not found")
                return jsonify({'success': False, 'message': 'Invalid credentials'}), 401
        except Exception as e:
            logging.error(f"Unexpected error during login: {str(e)}")
            return jsonify({'success': False, 'message': f'Unexpected error: {str(e)}'}), 500

    @app.route('/check-auth', methods=['GET'])
    @app.route('/api/auth/check-auth', methods=['GET'])
    def check_auth():
        try:
            logging.debug(f"Checking auth with session: {dict(session)}")
            if 'loggedin' in session and 'user_id' in session:
                conn = get_db_connection()
                cursor = conn.cursor(dictionary=True)
                cursor.execute("SELECT email, first_name FROM login_details WHERE id = %s", (session['user_id'],))
                user = cursor.fetchone()
                cursor.close()
                if user:
                    logging.info(f"User {session.get('user_email')} is authenticated")
                    return jsonify({
                        'success': True,
                        'user': {
                            'email': user['email'],
                            'id': session['user_id'],
                            'first_name': user['first_name']
                        }
                    })
                else:
                    logging.warning("User not found in database")  
                    session.clear()
                    return jsonify({'success': False, 'message': 'User not found'}), 401
            logging.warning("User not authenticated")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        except Exception as e:
            logging.error(f"Error in check-auth endpoint: {str(e)}")
            return jsonify({'success': False, 'message': f'Server error: {str(e)}'}), 500

    @app.route('/register', methods=['POST'])
    @app.route('/api/auth/register', methods=['POST'])
    def register():
        first_name = request.form.get('first_name')
        last_name = request.form.get('last_name')
        email = request.form.get('email')
        mobile = request.form.get('mobile')
        password = request.form.get('password')
        confirm_password = request.form.get('confirm_password')

        if not all([first_name, last_name, email, mobile, password, confirm_password]):
            return jsonify({'success': False, 'message': 'All fields are required'}), 400
        if password != confirm_password:
            return jsonify({'success': False, 'message': 'Passwords do not match'}), 400

        hashed_password = bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
        try:
            conn = get_db_connection()
            cursor = conn.cursor()
            cursor.execute("""
                INSERT INTO login_details (first_name, last_name, email, mobile, password)
                VALUES (%s, %s, %s, %s, %s)
            """, (first_name, last_name, email, mobile, hashed_password))
            user_id = cursor.lastrowid
            conn.commit()
            cursor.close()
            session['loggedin'] = True
            session['user_email'] = email
            session['user_id'] = user_id
            return jsonify({
                'success': True,
                'message': 'Registration successful',
                'user': {'email': email, 'id': user_id}
            }), 200
        except mysql.connector.Error as e:
            logging.error(f"Database error during registration: {str(e)}")
            return jsonify({'success': False, 'message': f'Registration error: {str(e)}'}), 500

    @app.route('/logout', methods=['POST'])
    @app.route('/api/auth/logout', methods=['POST'])
    def logout():
        logging.info(f"User {session.get('user_email', 'unknown')} logged out")
        session.clear()
        return jsonify({'success': True, 'message': 'Logged out successfully'})

    # Template routes
    @app.route('/templates', methods=['GET'])
    @app.route('/api/templates', methods=['GET'])
    def get_templates():
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /templates: session missing")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("""
                SELECT template_id, template_name, created_at, status
                FROM excel_templates
                WHERE user_id = %s AND status = 'ACTIVE'
                ORDER BY created_at DESC
                LIMIT 100
            """, (session['user_id'],))
            templates = cursor.fetchall()
            cursor.close()
            logging.info(f"Fetched {len(templates)} templates for user {session['user_id']}")
            return jsonify({'success': True, 'templates': templates})
        except mysql.connector.Error as e:
            logging.error(f'Error fetching templates: {str(e)}')
            return jsonify({'success': False, 'message': f'Error fetching templates: {str(e)}'}), 500
        except Exception as e:
            logging.error(f'Unexpected error fetching templates: {str(e)}')
            return jsonify({'success': False, 'message': f'Unexpected error: {str(e)}'}), 500

    # Rule Configuration routes
    @app.route('/rule-configurations', methods=['GET'])
    @app.route('/api/validation/rule-configurations', methods=['GET'])
    def get_rule_configurations():
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning(f"Unauthorized access to /rule-configurations: session={dict(session)}")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            user_id = session['user_id']
            logging.debug(f"Fetching rule configurations for user_id: {user_id}")

            # Main query to fetch templates with configured rules
            cursor.execute("""
                SELECT 
                    t.template_id, 
                    t.template_name, 
                    t.created_at, 
                    COUNT(cvr.column_validation_id) as rule_count
                FROM excel_templates t
                LEFT JOIN template_columns tc ON t.template_id = tc.template_id
                LEFT JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                WHERE t.user_id = %s AND t.status = 'ACTIVE' AND t.is_corrected = FALSE
                GROUP BY t.template_id, t.template_name, t.created_at
                HAVING rule_count > 0
                ORDER BY t.created_at DESC
                LIMIT 100
            """, (user_id,))
            templates = cursor.fetchall()
            logging.debug(f"Fetched rule-configured templates: {templates}")

            cursor.close()

            if not templates:
                logging.info(f"No templates with rules found for user_id: {user_id}")
            else:
                logging.info(f"Found {len(templates)} templates with rules for user_id: {user_id}")

            return jsonify({'success': True, 'templates': templates})
        except mysql.connector.Error as e:
            logging.error(f"Database error fetching rule configurations: {str(e)}")
            return jsonify({'success': False, 'message': f"Database error: {str(e)}"}), 500
        except Exception as e:
            logging.error(f"Unexpected error fetching rule configurations: {str(e)}")
            return jsonify({'success': False, 'message': f"Unexpected error: {str(e)}"}), 500

    # File upload route
    @app.route('/upload', methods=['POST'])
    @app.route('/api/templates/upload', methods=['POST'])
    @app.route('/api/upload', methods=['POST'])  # Additional common path
    def upload():
        logging.info(f"Upload endpoint called: {request.endpoint}, method: {request.method}")
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /upload: session missing")
            return jsonify({'error': 'Not logged in'}), 401
        if 'file' not in request.files:
            logging.warning("No file provided in upload request")
            return jsonify({'error': 'No file uploaded'}), 400
        file = request.files['file']
        if file.filename == '':
            logging.warning("No file selected in upload request")
            return jsonify({'error': 'No file selected'}), 400
        
        file_path = os.path.join(app.config['UPLOAD_FOLDER'], file.filename)
        try:
            file.save(file_path)
            logging.info(f"File saved: {file_path}")
        except Exception as e:
            logging.error(f"Failed to save file {file.filename}: {str(e)}")
            return jsonify({'error': f'Failed to save file: {str(e)}'}), 500

        try:
            # Read the file to get sheets and headers
            if file.filename.endswith('.xlsx') or file.filename.endswith('.xls'):
                xl = pd.ExcelFile(file_path)
                sheets = {sheet_name: pd.read_excel(file_path, sheet_name=sheet_name, header=None) 
                         for sheet_name in xl.sheet_names}
            elif file.filename.endswith(('.txt', '.csv', '.dat')):
                df = pd.read_csv(file_path, header=None, encoding='utf-8')
                sheets = {'Sheet1': df}
            else:
                logging.error("Unsupported file type")
                return jsonify({'error': 'Unsupported file type'}), 400
            
            logging.debug(f"Sheets extracted: {list(sheets.keys())}")
        except Exception as e:
            logging.error(f"Failed to read file {file_path}: {str(e)}")
            return jsonify({'error': f'Failed to read file: {str(e)}'}), 400

        try:
            sheet_names = list(sheets.keys())
            if not sheet_names:
                logging.error("No sheets found in the file")
                return jsonify({'error': 'No sheets found in the file'}), 400
            sheet_name = sheet_names[0]
            df = sheets[sheet_name]
            
            # Find header row
            header_row = 0
            for i in range(min(len(df), 10)):
                row = df.iloc[i].dropna()
                if not row.empty and all(isinstance(x, str) for x in row if pd.notna(x)):
                    header_row = i
                    break
                    
            headers = df.iloc[header_row].tolist()
            logging.debug(f"Headers extracted: {headers}")
            
            if not headers or all(not h for h in headers):
                logging.error("No valid headers found in file")
                return jsonify({'error': 'No valid headers found in the file'}), 400
        except Exception as e:
            logging.error(f"Error processing file {file.filename}: {str(e)}")
            return jsonify({'error': f'Error processing file: {str(e)}'}), 400

        # Clear existing session data
        for key in ['df', 'header_row', 'headers', 'sheet_name', 'current_step', 'selected_headers', 'validations', 'error_cell_locations', 'data_rows', 'corrected_file_path']:
            session.pop(key, None)

        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)

            # Check if template exists
            cursor.execute("""
                SELECT template_id, headers, sheet_name
                FROM excel_templates
                WHERE template_name = %s AND user_id = %s AND status = 'ACTIVE'
                ORDER BY created_at DESC
            """, (file.filename, session['user_id']))
            existing_templates = cursor.fetchall()
            logging.info(f"Found {len(existing_templates)} existing templates with name {file.filename}")

            template_id = None
            has_existing_rules = False
            validations = {}
            selected_headers = []

            # Check for matching template
            matching_template = None
            for template in existing_templates:
                stored_headers = json.loads(template['headers']) if template['headers'] else []
                stored_sheet_name = template['sheet_name']
                if stored_headers == headers and stored_sheet_name == sheet_name:
                    matching_template = template
                    break

            if matching_template:
                template_id = matching_template['template_id']
                # Check for existing rules
                cursor.execute("""
                    SELECT tc.column_name, vrt.rule_name
                    FROM template_columns tc
                    JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                    JOIN validation_rule_types vrt ON cvr.rule_type_id = vrt.rule_type_id
                    WHERE tc.template_id = %s AND tc.is_selected = TRUE
                """, (template_id,))
                rules_data = cursor.fetchall()
                for row in rules_data:
                    column_name = row['column_name']
                    rule_name = row['rule_name']
                    if column_name not in validations:
                        validations[column_name] = []
                    validations[column_name].append(rule_name)
                    if column_name not in selected_headers:
                        selected_headers.append(column_name)
                has_existing_rules = len(validations) > 0
            else:
                # New template
                cursor.execute("""
                    INSERT INTO excel_templates (template_name, user_id, sheet_name, headers, is_corrected)
                    VALUES (%s, %s, %s, %s, %s)
                """, (file.filename, session['user_id'], sheet_name, json.dumps(headers), False))
                template_id = cursor.lastrowid
                column_data = [(template_id, header, i + 1, False) for i, header in enumerate(headers)]
                cursor.executemany("""
                    INSERT INTO template_columns (template_id, column_name, column_position, is_selected)
                    VALUES (%s, %s, %s, %s)
                """, column_data)

            conn.commit()
            cursor.close()

            # Store session data
            session['file_path'] = file_path
            session['template_id'] = template_id
            session['df'] = df.to_json()
            session['header_row'] = header_row
            session['headers'] = headers
            session['sheet_name'] = sheet_name
            session['current_step'] = 1 if not has_existing_rules else 3
            session['validations'] = validations
            session['selected_headers'] = selected_headers
            session['has_existing_rules'] = has_existing_rules

            logging.info(f"Upload processed: template_id={template_id}, filename={file.filename}, has_existing_rules={has_existing_rules}")

            return jsonify({
                'success': True,
                'sheets': {sheet_name: {'headers': headers}},
                'file_name': file.filename,
                'template_id': template_id,
                'has_existing_rules': has_existing_rules,
                'sheet_name': sheet_name,
                'skip_to_step_3': has_existing_rules
            })
        except mysql.connector.Error as e:
            logging.error(f'Error saving template: {str(e)}')
            return jsonify({'error': f'Error saving template: {str(e)}'}), 500
        except Exception as e:
            logging.error(f'Unexpected error saving template: {str(e)}')
            return jsonify({'error': f'Unexpected error: {str(e)}'}), 500

    # Multi-step workflow endpoints
    @app.route('/step/1', methods=['GET', 'POST'])
    @app.route('/api/step/1', methods=['GET', 'POST'])
    def step_one():
        if 'loggedin' not in session:
            return jsonify({'error': 'Not logged in'}), 401
        
        if request.method == 'POST':
            try:
                headers = request.form.getlist('headers')
                new_header_row = request.form.get('new_header_row')
                logging.debug(f"Step 1 submitted: headers={headers}, new_header_row={new_header_row}")
                
                if not headers:
                    logging.error("No headers provided in step 1")
                    return jsonify({'success': False, 'message': 'No headers provided'}), 400
                    
                if 'template_id' not in session:
                    logging.error("Session missing template_id")
                    return jsonify({'success': False, 'message': 'Session data missing'}), 400

                template_id = session['template_id']
                
                # Get the dataframe from session for auto-detection
                df_json = session.get('df')
                if df_json:
                    df = pd.read_json(StringIO(df_json))
                    session_headers = session.get('headers', [])
                    df.columns = session_headers
                    header_row = session.get('header_row', 0)
                    df = df.iloc[header_row + 1:].reset_index(drop=True)
                    
                    # Auto-detect rules for selected headers
                    validations = assign_default_rules_to_columns(df, headers)
                    session['validations'] = validations
                    logging.debug(f"Auto-assigned rules: {validations}")
                else:
                    validations = {}

                session['selected_headers'] = headers
                session['current_step'] = 2

                # Mark selected headers in the database
                conn = get_db_connection()
                cursor = conn.cursor()
                cursor.execute("UPDATE template_columns SET is_selected = FALSE WHERE template_id = %s", (template_id,))
                for header in headers:
                    cursor.execute("""
                        UPDATE template_columns
                        SET is_selected = TRUE
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    
                    # Get column_id and add auto-detected rules
                    cursor.execute("""
                        SELECT column_id FROM template_columns
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    result = cursor.fetchone()
                    if result:
                        column_id = result[0]
                        for rule_name in validations.get(header, []):
                            cursor.execute("""
                                SELECT rule_type_id FROM validation_rule_types
                                WHERE rule_name = %s AND is_custom = FALSE
                            """, (rule_name,))
                            rule_result = cursor.fetchone()
                            if rule_result:
                                rule_type_id = rule_result[0]
                                cursor.execute("""
                                    INSERT IGNORE INTO column_validation_rules (column_id, rule_type_id, rule_config)
                                    VALUES (%s, %s, %s)
                                """, (column_id, rule_type_id, '{}'))
                
                conn.commit()
                cursor.close()

                logging.info(f"Step 1 completed: headers={headers}, auto-assigned rules={validations}")
                return jsonify({'success': True, 'headers': headers, 'validations': validations})
            except Exception as e:
                logging.error(f"Error in step 1: {str(e)}")
                return jsonify({'success': False, 'message': str(e)}), 500
        
        # GET request - return current headers
        headers = session.get('headers', [])
        return jsonify({'headers': headers})

    @app.route('/step/2', methods=['GET', 'POST'])
    @app.route('/api/step/2', methods=['GET', 'POST'])
    def step_two():
        if 'loggedin' not in session:
            return jsonify({'error': 'Not logged in'}), 401
            
        if request.method == 'POST':
            try:
                action = request.form.get('action', 'save')
                validations = {}
                for key, values in request.form.lists():
                    if key.startswith('validations_'):
                        header = key.replace('validations_', '')
                        validations[header] = values
                        
                logging.debug(f"Step 2 submitted: action={action}, validations={validations}")
                
                template_id = session.get('template_id')
                if not template_id:
                    return jsonify({'success': False, 'message': 'Session data missing'}), 400

                # Save validations to database
                conn = get_db_connection()
                cursor = conn.cursor()
                
                # Clear existing rules
                cursor.execute("""
                    DELETE FROM column_validation_rules
                    WHERE column_id IN (
                        SELECT column_id FROM template_columns WHERE template_id = %s
                    )
                """, (template_id,))
                
                # Add new rules
                for header, rules in validations.items():
                    cursor.execute("""
                        SELECT column_id FROM template_columns
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    result = cursor.fetchone()
                    if not result:
                        continue
                    column_id = result[0]
                    
                    for rule_name in rules:
                        cursor.execute("""
                            SELECT rule_type_id FROM validation_rule_types
                            WHERE rule_name = %s
                        """, (rule_name,))
                        result = cursor.fetchone()
                        if result:
                            rule_type_id = result[0]
                            cursor.execute("""
                                INSERT IGNORE INTO column_validation_rules (column_id, rule_type_id, rule_config)
                                VALUES (%s, %s, %s)
                            """, (column_id, rule_type_id, '{}'))
                
                conn.commit()
                cursor.close()

                session['validations'] = validations
                session['current_step'] = 3 if action == 'review' else 2
                
                logging.info(f"Step 2 completed: action={action}, validations={validations}")
                return jsonify({'success': True, 'message': 'Step 2 completed successfully'})
            except Exception as e:
                logging.error(f"Error in step 2: {str(e)}")
                return jsonify({'success': False, 'message': str(e)}), 500
        
        # GET request
        selected_headers = session.get('selected_headers', [])
        return jsonify({'selected_headers': selected_headers})

    # Rules endpoint
    @app.route('/rules', methods=['GET'])
    @app.route('/api/rules', methods=['GET'])
    def get_rules():
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            
            cursor.execute("""
                SELECT rule_type_id AS rule_id, rule_name, description, parameters, is_custom, 
                       column_name, template_id, source_format, target_format, data_type, is_active
                FROM validation_rule_types
            """)
            rules = cursor.fetchall()
            cursor.close()
            
            logging.info(f"Returning {len(rules)} rules from getRules endpoint")
            return jsonify({'success': True, 'rules': rules})
        except mysql.connector.Error as e:
            logging.error(f"Database error fetching rules: {str(e)}")
            return jsonify({'success': False, 'message': str(e)}), 500
        except Exception as e:
            logging.error(f"Unexpected error fetching rules: {str(e)}")
            return jsonify({'success': False, 'message': str(e)}), 500

    # Template details endpoint
    @app.route('/template/<int:template_id>/<sheet_name>', methods=['GET'])
    @app.route('/api/template/<int:template_id>/<sheet_name>', methods=['GET'])
    def get_template(template_id, sheet_name):
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /template: session missing")
            return jsonify({'error': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("""
                SELECT template_name, sheet_name, headers
                FROM excel_templates
                WHERE template_id = %s AND user_id = %s AND status = 'ACTIVE'
            """, (template_id, session['user_id']))
            template_record = cursor.fetchone()
            
            if not template_record:
                logging.error(f"Template not found for template_id: {template_id}, user_id: {session['user_id']}")
                cursor.close()
                return jsonify({'error': 'Template not found'}), 404

            headers = json.loads(template_record['headers']) if template_record['headers'] else []
            stored_sheet_name = template_record['sheet_name'] or sheet_name
            file_path = os.path.join(app.config['UPLOAD_FOLDER'], template_record['template_name'])
            
            cursor.execute("""
                SELECT COUNT(*) as rule_count
                FROM template_columns tc
                JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                WHERE tc.template_id = %s AND tc.is_selected = TRUE
            """, (template_id,))
            rule_count = cursor.fetchone()['rule_count']
            has_existing_rules = rule_count > 0
            
            cursor.close()
            
            return jsonify({
                'success': True,
                'sheets': {stored_sheet_name: {'headers': headers}},
                'file_name': template_record['template_name'],
                'file_path': file_path,
                'sheet_name': stored_sheet_name,
                'has_existing_rules': has_existing_rules
            })
        except mysql.connector.Error as e:
            logging.error(f"Database error in get_template: {str(e)}")
            return jsonify({'error': f'Database error: {str(e)}'}), 500
        except Exception as e:
            logging.error(f"Unexpected error in get_template: {str(e)}")
            return jsonify({'error': f'Unexpected error: {str(e)}'}), 500

    # Debug route to show all registered routes
    @app.route('/debug/routes', methods=['GET'])
    def list_routes():
        routes = []
        for rule in app.url_map.iter_rules():
            routes.append({
                'endpoint': rule.endpoint,
                'methods': list(rule.methods),
                'rule': rule.rule
            })
        return jsonify(routes)

    # 404 handler to debug missing routes
    @app.errorhandler(404)
    def not_found_handler(error):
        logging.error(f"404 Error: {request.method} {request.url} not found")
        logging.error(f"Available routes: {[rule.rule for rule in app.url_map.iter_rules()]}")
        return jsonify({
            'error': 'Endpoint not found', 
            'method': request.method,
            'url': request.url,
            'path': request.path
        }), 404

    return app

def initialize_app_data():
    """Initialize database and create default data"""
    try:
        logging.info("Initializing database schema...")
        init_db()
        
        logging.info("Creating admin user...")
        create_admin_user()
        
        logging.info("Creating default validation rules...")
        create_default_validation_rules()
        
        logging.info("Application initialization completed successfully")
    except Exception as e:
        logging.error(f"Failed to initialize application: {e}")
        raise

DB_CONFIG = {
    'host': os.getenv('MYSQL_HOST', 'localhost'),
    'user': os.getenv('MYSQL_USER', 'root'),
    'password': os.getenv('MYSQL_PASSWORD', 'Keansa@2024'),
    'database': os.getenv('MYSQL_DATABASE', 'data_validation_2'),
}

def get_db_connection():
    if 'db' not in g:
        try:
            conn = mysql.connector.connect(
                host=DB_CONFIG['host'],
                user=DB_CONFIG['user'],
                password=DB_CONFIG['password']
            )
            cursor = conn.cursor()
            cursor.execute(f"CREATE DATABASE IF NOT EXISTS {DB_CONFIG['database']}")
            cursor.close()
            conn.close()
            g.db = mysql.connector.connect(**DB_CONFIG)
            logging.info("Database connection established successfully")
        except mysql.connector.Error as err:
            if err.errno == errorcode.ER_ACCESS_DENIED_ERROR:
                logging.error("Database connection failed: Access denied for user - check username/password")
            elif err.errno == errorcode.ER_BAD_DB_ERROR:
                logging.error("Database connection failed: Database does not exist")
            else:
                logging.error(f"Database connection failed: {err}")
            raise Exception(f"Failed to connect to database: {str(err)}")
    return g.db

def close_db(error):
    db = g.pop('db', None)
    if db is not None:
        db.close()

def init_db():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        tables = [
            """
            CREATE TABLE IF NOT EXISTS login_details (
                id INT AUTO_INCREMENT PRIMARY KEY,
                first_name VARCHAR(100),
                last_name VARCHAR(100),
                email VARCHAR(255) UNIQUE,
                mobile VARCHAR(10),
                password VARCHAR(255)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS excel_templates (
                template_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_name VARCHAR(255) NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
                user_id INT NOT NULL,
                sheet_name VARCHAR(255),
                headers JSON,
                status ENUM('ACTIVE', 'INACTIVE') DEFAULT 'ACTIVE',
                is_corrected BOOLEAN DEFAULT FALSE,
                remote_file_path VARCHAR(512),
                FOREIGN KEY (user_id) REFERENCES login_details(id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS template_columns (
                column_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_id BIGINT NOT NULL,
                column_name VARCHAR(255) NOT NULL,
                column_position INT NOT NULL,
                is_validation_enabled BOOLEAN DEFAULT FALSE,
                is_selected BOOLEAN DEFAULT FALSE,
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE,
                UNIQUE (template_id, column_name)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_rule_types (
                rule_type_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                rule_name VARCHAR(255) NOT NULL,
                description TEXT,
                parameters TEXT,
                is_active BOOLEAN DEFAULT TRUE,
                is_custom BOOLEAN DEFAULT FALSE,
                column_name VARCHAR(255),
                template_id BIGINT,
                data_type VARCHAR(50),
                source_format VARCHAR(50),
                target_format VARCHAR(50),
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS column_validation_rules (
                column_validation_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                column_id BIGINT NOT NULL,
                rule_type_id BIGINT NOT NULL,
                rule_config JSON,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (column_id) REFERENCES template_columns(column_id) ON DELETE CASCADE,
                FOREIGN KEY (rule_type_id) REFERENCES validation_rule_types(rule_type_id) ON DELETE RESTRICT,
                UNIQUE (column_id, rule_type_id)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_history (
                history_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_id BIGINT NOT NULL,
                template_name VARCHAR(255) NOT NULL,
                error_count INT NOT NULL,
                corrected_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                corrected_file_path VARCHAR(512) NOT NULL,
                user_id INT NOT NULL,
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE,
                FOREIGN KEY (user_id) REFERENCES login_details(id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_corrections (
                correction_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                history_id BIGINT NOT NULL,
                row_index INT NOT NULL,
                column_name VARCHAR(255) NOT NULL,
                original_value TEXT,
                corrected_value TEXT,
                rule_failed VARCHAR(255) DEFAULT NULL,
                FOREIGN KEY (history_id) REFERENCES validation_history(history_id) ON DELETE CASCADE
            )
            """
        ]
        for table_sql in tables:
            cursor.execute(table_sql)
        
        # Add missing columns if they don't exist
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'source_format'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN source_format VARCHAR(50)")
            logging.info("Added source_format column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'target_format'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN target_format VARCHAR(50)")
            logging.info("Added target_format column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'data_type'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN data_type VARCHAR(50)")
            logging.info("Added data_type column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM excel_templates LIKE 'remote_file_path'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE excel_templates ADD COLUMN remote_file_path VARCHAR(512)")
            logging.info("Added remote_file_path column to excel_templates table")
            
        cursor.execute("SHOW COLUMNS FROM template_columns LIKE 'is_selected'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE template_columns ADD COLUMN is_selected BOOLEAN DEFAULT FALSE")
            logging.info("Added is_selected column to template_columns table")
            
        conn.commit()
        cursor.close()
        logging.info("Database tables initialized")
    except Exception as e:
        logging.error(f"Failed to initialize database: {str(e)}")
        raise

def create_admin_user():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        admin_password = bcrypt.hashpw('admin'.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
        cursor.execute("""
            INSERT IGNORE INTO login_details (first_name, last_name, email, mobile, password)
            VALUES (%s, %s, %s, %s, %s)
        """, ('Admin', 'User', 'admin@example.com', '1234567890', admin_password))
        conn.commit()
        cursor.close()
        logging.info("Admin user created or already exists")
    except Exception as e:
        logging.error(f"Failed to create admin user: {str(e)}")
        raise

def create_default_validation_rules():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        default_rules = [
            ("Required", "Ensures the field is not null", '{"allow_null": false}', None, None, None),
            ("Int", "Validates integer format", '{"format": "integer"}', None, None, "Int"),
            ("Float", "Validates number format (integer or decimal)", '{"format": "float"}', None, None, "Float"),
            ("Text", "Allows text with quotes and parentheses", '{"allow_special": false}', None, None, "Text"),
            ("Email", "Validates email format", '{"regex": "^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\\\.[a-zA-Z0-9-.]+$"}', None, None, "Email"),
            ("Date(DD-MM-YYYY)", "Validates date format DD-MM-YYYY", '{"format": "%d-%m-%Y"}', "DD-MM-YYYY", None, "Date"),
            ("Boolean", "Validates boolean format (true/false or 0/1)", '{"format": "boolean"}', None, None, "Boolean"),
            ("Alphanumeric", "Validates alphanumeric format", '{"format": "alphanumeric"}', None, None, "Alphanumeric")
        ]
        cursor.executemany("""
            INSERT IGNORE INTO validation_rule_types (rule_name, description, parameters, is_custom, source_format, target_format, data_type)
            VALUES (%s, %s, %s, %s, %s, %s, %s)
        """, [(name, desc, params, False, source, target, dtype) for name, desc, params, source, target, dtype in default_rules])
        conn.commit()
        cursor.close()
        logging.info("Default validation rules ensured successfully")
    except Exception as e:
        logging.error(f"Failed to ensure default validation rules: {str(e)}")
        raise

if __name__ == '__main__':
    try:
        # Create the application using factory pattern
        app = create_app()
        
        # Initialize database and default data within app context
        with app.app_context():
            initialize_app_data()
        
        # Get port from environment or use default
        port = int(os.getenv('PORT', 5000))
        
        # Start the application server
        logging.info("Starting Flask server...")
        app.run(debug=True, host='0.0.0.0', port=port)
        
    except Exception as e:
        logging.error(f"Failed to start application: {e}")
        raise
).any():
        return "Email"
    
    # Date pattern detection
    try:
        pd.to_datetime(non_null, format="%d-%m-%Y")
        return "Date"
    except Exception:
        try:
            pd.to_datetime(non_null, format="%Y-%m-%d")
            return "Date"
        except Exception:
            pass
    
    # Boolean detection
    if non_null.str.lower().isin(['true', 'false', '0', '1']).all():
        return "Boolean"
    
    # Numeric detection
    if non_null.str.match(r'^-?\d+

def create_app():
    """Application factory pattern for different environments"""
    # Set the path to the frontend dist folder
    current_dir = os.path.dirname(os.path.abspath(__file__))
    frontend_dist_path = os.path.join(current_dir, '..', '..', 'Keansa-Ai-Suite2025may-frontend11', 'dist')
    frontend_dist_path = os.path.abspath(frontend_dist_path)
    
    # Create Flask application instance
    app = Flask(__name__, static_folder=frontend_dist_path, static_url_path='')
    CORS(app, supports_credentials=True, origins=["http://localhost:3000", "http://localhost:8080", "http://localhost:5000", "*"])

    app.secret_key = os.urandom(24).hex()
    app.config['SESSION_TYPE'] = 'filesystem'
    app.config['SESSION_FILE_DIR'] = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'sessions')
    app.config['SESSION_COOKIE_SAMESITE'] = 'Lax'
    app.config['SESSION_COOKIE_HTTPONLY'] = True
    app.config['SESSION_COOKIE_SECURE'] = False
    app.config['PERMANENT_SESSION_LIFETIME'] = 86400  # 24 hours
    app.config['UPLOAD_FOLDER'] = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'uploads')
    Session(app)

    # Ensure directories exist
    try:
        os.makedirs(app.config['UPLOAD_FOLDER'], exist_ok=True)
        os.makedirs(app.config['SESSION_FILE_DIR'], exist_ok=True)
    except OSError as e:
        logging.error(f"Failed to create directories: {e}")

    # Register cleanup handlers
    app.teardown_appcontext(close_db)
    
    # Register all routes directly in create_app
    
    # Static file serving for React frontend
    @app.route('/', defaults={'path': ''})
    @app.route('/<path:path>')
    def serve(path):
        if path and os.path.exists(os.path.join(app.static_folder, path)):
            return app.send_static_file(path)
        return app.send_static_file('index.html')

    # Health check endpoint
    @app.route('/health', methods=['GET'])
    def health_check():
        return jsonify({
            'status': 'healthy',
            'timestamp': datetime.now().isoformat(),
            'version': '2.0.0'
        })

    # Authentication endpoint - both old and new paths
    @app.route('/authenticate', methods=['POST'])
    @app.route('/api/auth/authenticate', methods=['POST'])
    def authenticate():
        try:
            email = request.form.get('username') or request.form.get('email')
            password = request.form.get('password')
            logging.debug(f"Login attempt: email={email}, password={'*' * len(password) if password else 'None'}")
            
            if not email or not password:
                logging.warning(f"Login failed: Email or password missing")
                return jsonify({'success': False, 'message': 'Email and password are required'}), 400

            # Check for admin login
            if email == "admin" and password == "admin":
                session['loggedin'] = True
                session['user_email'] = "admin@example.com"
                session['user_id'] = 1
                session.permanent = True
                logging.info(f"Admin login successful. Session: {dict(session)}")
                return jsonify({'success': True, 'message': 'Login successful', 'user': {'email': 'admin@example.com', 'id': 1}}), 200

            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("SELECT * FROM login_details WHERE LOWER(email) = LOWER(%s)", (email.lower(),))
            account = cursor.fetchone()
            cursor.close()
            
            if account:
                if bcrypt.checkpw(password.encode('utf-8'), account['password'].encode('utf-8')):
                    session['loggedin'] = True
                    session['user_email'] = account['email']
                    session['user_id'] = account['id']
                    session.permanent = True
                    logging.info(f"User {email} logged in successfully. Session: {dict(session)}")
                    return jsonify({
                        'success': True,
                        'message': 'Login successful',
                        'user': {'email': account['email'], 'id': account['id']}
                    }), 200
                else:
                    logging.warning(f"Invalid password for {email}")
                    return jsonify({'success': False, 'message': 'Invalid credentials'}), 401
            else:
                logging.warning(f"Email {email} not found")
                return jsonify({'success': False, 'message': 'Invalid credentials'}), 401
        except Exception as e:
            logging.error(f"Unexpected error during login: {str(e)}")
            return jsonify({'success': False, 'message': f'Unexpected error: {str(e)}'}), 500

    @app.route('/check-auth', methods=['GET'])
    @app.route('/api/auth/check-auth', methods=['GET'])
    def check_auth():
        try:
            logging.debug(f"Checking auth with session: {dict(session)}")
            if 'loggedin' in session and 'user_id' in session:
                conn = get_db_connection()
                cursor = conn.cursor(dictionary=True)
                cursor.execute("SELECT email, first_name FROM login_details WHERE id = %s", (session['user_id'],))
                user = cursor.fetchone()
                cursor.close()
                if user:
                    logging.info(f"User {session.get('user_email')} is authenticated")
                    return jsonify({
                        'success': True,
                        'user': {
                            'email': user['email'],
                            'id': session['user_id'],
                            'first_name': user['first_name']
                        }
                    })
                else:
                    logging.warning("User not found in database")  
                    session.clear()
                    return jsonify({'success': False, 'message': 'User not found'}), 401
            logging.warning("User not authenticated")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        except Exception as e:
            logging.error(f"Error in check-auth endpoint: {str(e)}")
            return jsonify({'success': False, 'message': f'Server error: {str(e)}'}), 500

    @app.route('/register', methods=['POST'])
    @app.route('/api/auth/register', methods=['POST'])
    def register():
        first_name = request.form.get('first_name')
        last_name = request.form.get('last_name')
        email = request.form.get('email')
        mobile = request.form.get('mobile')
        password = request.form.get('password')
        confirm_password = request.form.get('confirm_password')

        if not all([first_name, last_name, email, mobile, password, confirm_password]):
            return jsonify({'success': False, 'message': 'All fields are required'}), 400
        if password != confirm_password:
            return jsonify({'success': False, 'message': 'Passwords do not match'}), 400

        hashed_password = bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
        try:
            conn = get_db_connection()
            cursor = conn.cursor()
            cursor.execute("""
                INSERT INTO login_details (first_name, last_name, email, mobile, password)
                VALUES (%s, %s, %s, %s, %s)
            """, (first_name, last_name, email, mobile, hashed_password))
            user_id = cursor.lastrowid
            conn.commit()
            cursor.close()
            session['loggedin'] = True
            session['user_email'] = email
            session['user_id'] = user_id
            return jsonify({
                'success': True,
                'message': 'Registration successful',
                'user': {'email': email, 'id': user_id}
            }), 200
        except mysql.connector.Error as e:
            logging.error(f"Database error during registration: {str(e)}")
            return jsonify({'success': False, 'message': f'Registration error: {str(e)}'}), 500

    @app.route('/logout', methods=['POST'])
    @app.route('/api/auth/logout', methods=['POST'])
    def logout():
        logging.info(f"User {session.get('user_email', 'unknown')} logged out")
        session.clear()
        return jsonify({'success': True, 'message': 'Logged out successfully'})

    # Template routes
    @app.route('/templates', methods=['GET'])
    @app.route('/api/templates', methods=['GET'])
    def get_templates():
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /templates: session missing")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("""
                SELECT template_id, template_name, created_at, status
                FROM excel_templates
                WHERE user_id = %s AND status = 'ACTIVE'
                ORDER BY created_at DESC
                LIMIT 100
            """, (session['user_id'],))
            templates = cursor.fetchall()
            cursor.close()
            logging.info(f"Fetched {len(templates)} templates for user {session['user_id']}")
            return jsonify({'success': True, 'templates': templates})
        except mysql.connector.Error as e:
            logging.error(f'Error fetching templates: {str(e)}')
            return jsonify({'success': False, 'message': f'Error fetching templates: {str(e)}'}), 500
        except Exception as e:
            logging.error(f'Unexpected error fetching templates: {str(e)}')
            return jsonify({'success': False, 'message': f'Unexpected error: {str(e)}'}), 500

    # Rule Configuration routes
    @app.route('/rule-configurations', methods=['GET'])
    @app.route('/api/validation/rule-configurations', methods=['GET'])
    def get_rule_configurations():
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning(f"Unauthorized access to /rule-configurations: session={dict(session)}")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            user_id = session['user_id']
            logging.debug(f"Fetching rule configurations for user_id: {user_id}")

            # Main query to fetch templates with configured rules
            cursor.execute("""
                SELECT 
                    t.template_id, 
                    t.template_name, 
                    t.created_at, 
                    COUNT(cvr.column_validation_id) as rule_count
                FROM excel_templates t
                LEFT JOIN template_columns tc ON t.template_id = tc.template_id
                LEFT JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                WHERE t.user_id = %s AND t.status = 'ACTIVE' AND t.is_corrected = FALSE
                GROUP BY t.template_id, t.template_name, t.created_at
                HAVING rule_count > 0
                ORDER BY t.created_at DESC
                LIMIT 100
            """, (user_id,))
            templates = cursor.fetchall()
            logging.debug(f"Fetched rule-configured templates: {templates}")

            cursor.close()

            if not templates:
                logging.info(f"No templates with rules found for user_id: {user_id}")
            else:
                logging.info(f"Found {len(templates)} templates with rules for user_id: {user_id}")

            return jsonify({'success': True, 'templates': templates})
        except mysql.connector.Error as e:
            logging.error(f"Database error fetching rule configurations: {str(e)}")
            return jsonify({'success': False, 'message': f"Database error: {str(e)}"}), 500
        except Exception as e:
            logging.error(f"Unexpected error fetching rule configurations: {str(e)}")
            return jsonify({'success': False, 'message': f"Unexpected error: {str(e)}"}), 500

    # File upload route
    @app.route('/upload', methods=['POST'])
    @app.route('/api/templates/upload', methods=['POST'])
    @app.route('/api/upload', methods=['POST'])  # Additional common path
    def upload():
        logging.info(f"Upload endpoint called: {request.endpoint}, method: {request.method}")
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /upload: session missing")
            return jsonify({'error': 'Not logged in'}), 401
        if 'file' not in request.files:
            logging.warning("No file provided in upload request")
            return jsonify({'error': 'No file uploaded'}), 400
        file = request.files['file']
        if file.filename == '':
            logging.warning("No file selected in upload request")
            return jsonify({'error': 'No file selected'}), 400
        
        file_path = os.path.join(app.config['UPLOAD_FOLDER'], file.filename)
        try:
            file.save(file_path)
            logging.info(f"File saved: {file_path}")
        except Exception as e:
            logging.error(f"Failed to save file {file.filename}: {str(e)}")
            return jsonify({'error': f'Failed to save file: {str(e)}'}), 500

        try:
            # Read the file to get sheets and headers
            if file.filename.endswith('.xlsx') or file.filename.endswith('.xls'):
                xl = pd.ExcelFile(file_path)
                sheets = {sheet_name: pd.read_excel(file_path, sheet_name=sheet_name, header=None) 
                         for sheet_name in xl.sheet_names}
            elif file.filename.endswith(('.txt', '.csv', '.dat')):
                df = pd.read_csv(file_path, header=None, encoding='utf-8')
                sheets = {'Sheet1': df}
            else:
                logging.error("Unsupported file type")
                return jsonify({'error': 'Unsupported file type'}), 400
            
            logging.debug(f"Sheets extracted: {list(sheets.keys())}")
        except Exception as e:
            logging.error(f"Failed to read file {file_path}: {str(e)}")
            return jsonify({'error': f'Failed to read file: {str(e)}'}), 400

        try:
            sheet_names = list(sheets.keys())
            if not sheet_names:
                logging.error("No sheets found in the file")
                return jsonify({'error': 'No sheets found in the file'}), 400
            sheet_name = sheet_names[0]
            df = sheets[sheet_name]
            
            # Find header row
            header_row = 0
            for i in range(min(len(df), 10)):
                row = df.iloc[i].dropna()
                if not row.empty and all(isinstance(x, str) for x in row if pd.notna(x)):
                    header_row = i
                    break
                    
            headers = df.iloc[header_row].tolist()
            logging.debug(f"Headers extracted: {headers}")
            
            if not headers or all(not h for h in headers):
                logging.error("No valid headers found in file")
                return jsonify({'error': 'No valid headers found in the file'}), 400
        except Exception as e:
            logging.error(f"Error processing file {file.filename}: {str(e)}")
            return jsonify({'error': f'Error processing file: {str(e)}'}), 400

        # Clear existing session data
        for key in ['df', 'header_row', 'headers', 'sheet_name', 'current_step', 'selected_headers', 'validations', 'error_cell_locations', 'data_rows', 'corrected_file_path']:
            session.pop(key, None)

        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)

            # Check if template exists
            cursor.execute("""
                SELECT template_id, headers, sheet_name
                FROM excel_templates
                WHERE template_name = %s AND user_id = %s AND status = 'ACTIVE'
                ORDER BY created_at DESC
            """, (file.filename, session['user_id']))
            existing_templates = cursor.fetchall()
            logging.info(f"Found {len(existing_templates)} existing templates with name {file.filename}")

            template_id = None
            has_existing_rules = False
            validations = {}
            selected_headers = []

            # Check for matching template
            matching_template = None
            for template in existing_templates:
                stored_headers = json.loads(template['headers']) if template['headers'] else []
                stored_sheet_name = template['sheet_name']
                if stored_headers == headers and stored_sheet_name == sheet_name:
                    matching_template = template
                    break

            if matching_template:
                template_id = matching_template['template_id']
                # Check for existing rules
                cursor.execute("""
                    SELECT tc.column_name, vrt.rule_name
                    FROM template_columns tc
                    JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                    JOIN validation_rule_types vrt ON cvr.rule_type_id = vrt.rule_type_id
                    WHERE tc.template_id = %s AND tc.is_selected = TRUE
                """, (template_id,))
                rules_data = cursor.fetchall()
                for row in rules_data:
                    column_name = row['column_name']
                    rule_name = row['rule_name']
                    if column_name not in validations:
                        validations[column_name] = []
                    validations[column_name].append(rule_name)
                    if column_name not in selected_headers:
                        selected_headers.append(column_name)
                has_existing_rules = len(validations) > 0
            else:
                # New template
                cursor.execute("""
                    INSERT INTO excel_templates (template_name, user_id, sheet_name, headers, is_corrected)
                    VALUES (%s, %s, %s, %s, %s)
                """, (file.filename, session['user_id'], sheet_name, json.dumps(headers), False))
                template_id = cursor.lastrowid
                column_data = [(template_id, header, i + 1, False) for i, header in enumerate(headers)]
                cursor.executemany("""
                    INSERT INTO template_columns (template_id, column_name, column_position, is_selected)
                    VALUES (%s, %s, %s, %s)
                """, column_data)

            conn.commit()
            cursor.close()

            # Store session data
            session['file_path'] = file_path
            session['template_id'] = template_id
            session['df'] = df.to_json()
            session['header_row'] = header_row
            session['headers'] = headers
            session['sheet_name'] = sheet_name
            session['current_step'] = 1 if not has_existing_rules else 3
            session['validations'] = validations
            session['selected_headers'] = selected_headers
            session['has_existing_rules'] = has_existing_rules

            logging.info(f"Upload processed: template_id={template_id}, filename={file.filename}, has_existing_rules={has_existing_rules}")

            return jsonify({
                'success': True,
                'sheets': {sheet_name: {'headers': headers}},
                'file_name': file.filename,
                'template_id': template_id,
                'has_existing_rules': has_existing_rules,
                'sheet_name': sheet_name,
                'skip_to_step_3': has_existing_rules
            })
        except mysql.connector.Error as e:
            logging.error(f'Error saving template: {str(e)}')
            return jsonify({'error': f'Error saving template: {str(e)}'}), 500
        except Exception as e:
            logging.error(f'Unexpected error saving template: {str(e)}')
            return jsonify({'error': f'Unexpected error: {str(e)}'}), 500

    # Multi-step workflow endpoints
    @app.route('/step/1', methods=['GET', 'POST'])
    @app.route('/api/step/1', methods=['GET', 'POST'])
    def step_one():
        if 'loggedin' not in session:
            return jsonify({'error': 'Not logged in'}), 401
        
        if request.method == 'POST':
            try:
                headers = request.form.getlist('headers')
                new_header_row = request.form.get('new_header_row')
                logging.debug(f"Step 1 submitted: headers={headers}, new_header_row={new_header_row}")
                
                if not headers:
                    logging.error("No headers provided in step 1")
                    return jsonify({'success': False, 'message': 'No headers provided'}), 400
                    
                if 'template_id' not in session:
                    logging.error("Session missing template_id")
                    return jsonify({'success': False, 'message': 'Session data missing'}), 400

                template_id = session['template_id']
                
                # Get the dataframe from session for auto-detection
                df_json = session.get('df')
                if df_json:
                    df = pd.read_json(StringIO(df_json))
                    session_headers = session.get('headers', [])
                    df.columns = session_headers
                    header_row = session.get('header_row', 0)
                    df = df.iloc[header_row + 1:].reset_index(drop=True)
                    
                    # Auto-detect rules for selected headers
                    validations = assign_default_rules_to_columns(df, headers)
                    session['validations'] = validations
                    logging.debug(f"Auto-assigned rules: {validations}")
                else:
                    validations = {}

                session['selected_headers'] = headers
                session['current_step'] = 2

                # Mark selected headers in the database
                conn = get_db_connection()
                cursor = conn.cursor()
                cursor.execute("UPDATE template_columns SET is_selected = FALSE WHERE template_id = %s", (template_id,))
                for header in headers:
                    cursor.execute("""
                        UPDATE template_columns
                        SET is_selected = TRUE
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    
                    # Get column_id and add auto-detected rules
                    cursor.execute("""
                        SELECT column_id FROM template_columns
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    result = cursor.fetchone()
                    if result:
                        column_id = result[0]
                        for rule_name in validations.get(header, []):
                            cursor.execute("""
                                SELECT rule_type_id FROM validation_rule_types
                                WHERE rule_name = %s AND is_custom = FALSE
                            """, (rule_name,))
                            rule_result = cursor.fetchone()
                            if rule_result:
                                rule_type_id = rule_result[0]
                                cursor.execute("""
                                    INSERT IGNORE INTO column_validation_rules (column_id, rule_type_id, rule_config)
                                    VALUES (%s, %s, %s)
                                """, (column_id, rule_type_id, '{}'))
                
                conn.commit()
                cursor.close()

                logging.info(f"Step 1 completed: headers={headers}, auto-assigned rules={validations}")
                return jsonify({'success': True, 'headers': headers, 'validations': validations})
            except Exception as e:
                logging.error(f"Error in step 1: {str(e)}")
                return jsonify({'success': False, 'message': str(e)}), 500
        
        # GET request - return current headers
        headers = session.get('headers', [])
        return jsonify({'headers': headers})

    @app.route('/step/2', methods=['GET', 'POST'])
    @app.route('/api/step/2', methods=['GET', 'POST'])
    def step_two():
        if 'loggedin' not in session:
            return jsonify({'error': 'Not logged in'}), 401
            
        if request.method == 'POST':
            try:
                action = request.form.get('action', 'save')
                validations = {}
                for key, values in request.form.lists():
                    if key.startswith('validations_'):
                        header = key.replace('validations_', '')
                        validations[header] = values
                        
                logging.debug(f"Step 2 submitted: action={action}, validations={validations}")
                
                template_id = session.get('template_id')
                if not template_id:
                    return jsonify({'success': False, 'message': 'Session data missing'}), 400

                # Save validations to database
                conn = get_db_connection()
                cursor = conn.cursor()
                
                # Clear existing rules
                cursor.execute("""
                    DELETE FROM column_validation_rules
                    WHERE column_id IN (
                        SELECT column_id FROM template_columns WHERE template_id = %s
                    )
                """, (template_id,))
                
                # Add new rules
                for header, rules in validations.items():
                    cursor.execute("""
                        SELECT column_id FROM template_columns
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    result = cursor.fetchone()
                    if not result:
                        continue
                    column_id = result[0]
                    
                    for rule_name in rules:
                        cursor.execute("""
                            SELECT rule_type_id FROM validation_rule_types
                            WHERE rule_name = %s
                        """, (rule_name,))
                        result = cursor.fetchone()
                        if result:
                            rule_type_id = result[0]
                            cursor.execute("""
                                INSERT IGNORE INTO column_validation_rules (column_id, rule_type_id, rule_config)
                                VALUES (%s, %s, %s)
                            """, (column_id, rule_type_id, '{}'))
                
                conn.commit()
                cursor.close()

                session['validations'] = validations
                session['current_step'] = 3 if action == 'review' else 2
                
                logging.info(f"Step 2 completed: action={action}, validations={validations}")
                return jsonify({'success': True, 'message': 'Step 2 completed successfully'})
            except Exception as e:
                logging.error(f"Error in step 2: {str(e)}")
                return jsonify({'success': False, 'message': str(e)}), 500
        
        # GET request
        selected_headers = session.get('selected_headers', [])
        return jsonify({'selected_headers': selected_headers})

    # Rules endpoint
    @app.route('/rules', methods=['GET'])
    @app.route('/api/rules', methods=['GET'])
    def get_rules():
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            
            cursor.execute("""
                SELECT rule_type_id AS rule_id, rule_name, description, parameters, is_custom, 
                       column_name, template_id, source_format, target_format, data_type, is_active
                FROM validation_rule_types
            """)
            rules = cursor.fetchall()
            cursor.close()
            
            logging.info(f"Returning {len(rules)} rules from getRules endpoint")
            return jsonify({'success': True, 'rules': rules})
        except mysql.connector.Error as e:
            logging.error(f"Database error fetching rules: {str(e)}")
            return jsonify({'success': False, 'message': str(e)}), 500
        except Exception as e:
            logging.error(f"Unexpected error fetching rules: {str(e)}")
            return jsonify({'success': False, 'message': str(e)}), 500

    # Template details endpoint
    @app.route('/template/<int:template_id>/<sheet_name>', methods=['GET'])
    @app.route('/api/template/<int:template_id>/<sheet_name>', methods=['GET'])
    def get_template(template_id, sheet_name):
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /template: session missing")
            return jsonify({'error': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("""
                SELECT template_name, sheet_name, headers
                FROM excel_templates
                WHERE template_id = %s AND user_id = %s AND status = 'ACTIVE'
            """, (template_id, session['user_id']))
            template_record = cursor.fetchone()
            
            if not template_record:
                logging.error(f"Template not found for template_id: {template_id}, user_id: {session['user_id']}")
                cursor.close()
                return jsonify({'error': 'Template not found'}), 404

            headers = json.loads(template_record['headers']) if template_record['headers'] else []
            stored_sheet_name = template_record['sheet_name'] or sheet_name
            file_path = os.path.join(app.config['UPLOAD_FOLDER'], template_record['template_name'])
            
            cursor.execute("""
                SELECT COUNT(*) as rule_count
                FROM template_columns tc
                JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                WHERE tc.template_id = %s AND tc.is_selected = TRUE
            """, (template_id,))
            rule_count = cursor.fetchone()['rule_count']
            has_existing_rules = rule_count > 0
            
            cursor.close()
            
            return jsonify({
                'success': True,
                'sheets': {stored_sheet_name: {'headers': headers}},
                'file_name': template_record['template_name'],
                'file_path': file_path,
                'sheet_name': stored_sheet_name,
                'has_existing_rules': has_existing_rules
            })
        except mysql.connector.Error as e:
            logging.error(f"Database error in get_template: {str(e)}")
            return jsonify({'error': f'Database error: {str(e)}'}), 500
        except Exception as e:
            logging.error(f"Unexpected error in get_template: {str(e)}")
            return jsonify({'error': f'Unexpected error: {str(e)}'}), 500

    # Debug route to show all registered routes
    @app.route('/debug/routes', methods=['GET'])
    def list_routes():
        routes = []
        for rule in app.url_map.iter_rules():
            routes.append({
                'endpoint': rule.endpoint,
                'methods': list(rule.methods),
                'rule': rule.rule
            })
        return jsonify(routes)

    # 404 handler to debug missing routes
    @app.errorhandler(404)
    def not_found_handler(error):
        logging.error(f"404 Error: {request.method} {request.url} not found")
        logging.error(f"Available routes: {[rule.rule for rule in app.url_map.iter_rules()]}")
        return jsonify({
            'error': 'Endpoint not found', 
            'method': request.method,
            'url': request.url,
            'path': request.path
        }), 404

    return app

def initialize_app_data():
    """Initialize database and create default data"""
    try:
        logging.info("Initializing database schema...")
        init_db()
        
        logging.info("Creating admin user...")
        create_admin_user()
        
        logging.info("Creating default validation rules...")
        create_default_validation_rules()
        
        logging.info("Application initialization completed successfully")
    except Exception as e:
        logging.error(f"Failed to initialize application: {e}")
        raise

DB_CONFIG = {
    'host': os.getenv('MYSQL_HOST', 'localhost'),
    'user': os.getenv('MYSQL_USER', 'root'),
    'password': os.getenv('MYSQL_PASSWORD', 'Keansa@2024'),
    'database': os.getenv('MYSQL_DATABASE', 'data_validation_2'),
}

def get_db_connection():
    if 'db' not in g:
        try:
            conn = mysql.connector.connect(
                host=DB_CONFIG['host'],
                user=DB_CONFIG['user'],
                password=DB_CONFIG['password']
            )
            cursor = conn.cursor()
            cursor.execute(f"CREATE DATABASE IF NOT EXISTS {DB_CONFIG['database']}")
            cursor.close()
            conn.close()
            g.db = mysql.connector.connect(**DB_CONFIG)
            logging.info("Database connection established successfully")
        except mysql.connector.Error as err:
            if err.errno == errorcode.ER_ACCESS_DENIED_ERROR:
                logging.error("Database connection failed: Access denied for user - check username/password")
            elif err.errno == errorcode.ER_BAD_DB_ERROR:
                logging.error("Database connection failed: Database does not exist")
            else:
                logging.error(f"Database connection failed: {err}")
            raise Exception(f"Failed to connect to database: {str(err)}")
    return g.db

def close_db(error):
    db = g.pop('db', None)
    if db is not None:
        db.close()

def init_db():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        tables = [
            """
            CREATE TABLE IF NOT EXISTS login_details (
                id INT AUTO_INCREMENT PRIMARY KEY,
                first_name VARCHAR(100),
                last_name VARCHAR(100),
                email VARCHAR(255) UNIQUE,
                mobile VARCHAR(10),
                password VARCHAR(255)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS excel_templates (
                template_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_name VARCHAR(255) NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
                user_id INT NOT NULL,
                sheet_name VARCHAR(255),
                headers JSON,
                status ENUM('ACTIVE', 'INACTIVE') DEFAULT 'ACTIVE',
                is_corrected BOOLEAN DEFAULT FALSE,
                remote_file_path VARCHAR(512),
                FOREIGN KEY (user_id) REFERENCES login_details(id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS template_columns (
                column_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_id BIGINT NOT NULL,
                column_name VARCHAR(255) NOT NULL,
                column_position INT NOT NULL,
                is_validation_enabled BOOLEAN DEFAULT FALSE,
                is_selected BOOLEAN DEFAULT FALSE,
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE,
                UNIQUE (template_id, column_name)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_rule_types (
                rule_type_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                rule_name VARCHAR(255) NOT NULL,
                description TEXT,
                parameters TEXT,
                is_active BOOLEAN DEFAULT TRUE,
                is_custom BOOLEAN DEFAULT FALSE,
                column_name VARCHAR(255),
                template_id BIGINT,
                data_type VARCHAR(50),
                source_format VARCHAR(50),
                target_format VARCHAR(50),
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS column_validation_rules (
                column_validation_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                column_id BIGINT NOT NULL,
                rule_type_id BIGINT NOT NULL,
                rule_config JSON,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (column_id) REFERENCES template_columns(column_id) ON DELETE CASCADE,
                FOREIGN KEY (rule_type_id) REFERENCES validation_rule_types(rule_type_id) ON DELETE RESTRICT,
                UNIQUE (column_id, rule_type_id)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_history (
                history_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_id BIGINT NOT NULL,
                template_name VARCHAR(255) NOT NULL,
                error_count INT NOT NULL,
                corrected_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                corrected_file_path VARCHAR(512) NOT NULL,
                user_id INT NOT NULL,
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE,
                FOREIGN KEY (user_id) REFERENCES login_details(id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_corrections (
                correction_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                history_id BIGINT NOT NULL,
                row_index INT NOT NULL,
                column_name VARCHAR(255) NOT NULL,
                original_value TEXT,
                corrected_value TEXT,
                rule_failed VARCHAR(255) DEFAULT NULL,
                FOREIGN KEY (history_id) REFERENCES validation_history(history_id) ON DELETE CASCADE
            )
            """
        ]
        for table_sql in tables:
            cursor.execute(table_sql)
        
        # Add missing columns if they don't exist
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'source_format'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN source_format VARCHAR(50)")
            logging.info("Added source_format column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'target_format'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN target_format VARCHAR(50)")
            logging.info("Added target_format column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'data_type'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN data_type VARCHAR(50)")
            logging.info("Added data_type column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM excel_templates LIKE 'remote_file_path'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE excel_templates ADD COLUMN remote_file_path VARCHAR(512)")
            logging.info("Added remote_file_path column to excel_templates table")
            
        cursor.execute("SHOW COLUMNS FROM template_columns LIKE 'is_selected'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE template_columns ADD COLUMN is_selected BOOLEAN DEFAULT FALSE")
            logging.info("Added is_selected column to template_columns table")
            
        conn.commit()
        cursor.close()
        logging.info("Database tables initialized")
    except Exception as e:
        logging.error(f"Failed to initialize database: {str(e)}")
        raise

def create_admin_user():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        admin_password = bcrypt.hashpw('admin'.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
        cursor.execute("""
            INSERT IGNORE INTO login_details (first_name, last_name, email, mobile, password)
            VALUES (%s, %s, %s, %s, %s)
        """, ('Admin', 'User', 'admin@example.com', '1234567890', admin_password))
        conn.commit()
        cursor.close()
        logging.info("Admin user created or already exists")
    except Exception as e:
        logging.error(f"Failed to create admin user: {str(e)}")
        raise

def create_default_validation_rules():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        default_rules = [
            ("Required", "Ensures the field is not null", '{"allow_null": false}', None, None, None),
            ("Int", "Validates integer format", '{"format": "integer"}', None, None, "Int"),
            ("Float", "Validates number format (integer or decimal)", '{"format": "float"}', None, None, "Float"),
            ("Text", "Allows text with quotes and parentheses", '{"allow_special": false}', None, None, "Text"),
            ("Email", "Validates email format", '{"regex": "^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\\\.[a-zA-Z0-9-.]+$"}', None, None, "Email"),
            ("Date(DD-MM-YYYY)", "Validates date format DD-MM-YYYY", '{"format": "%d-%m-%Y"}', "DD-MM-YYYY", None, "Date"),
            ("Boolean", "Validates boolean format (true/false or 0/1)", '{"format": "boolean"}', None, None, "Boolean"),
            ("Alphanumeric", "Validates alphanumeric format", '{"format": "alphanumeric"}', None, None, "Alphanumeric")
        ]
        cursor.executemany("""
            INSERT IGNORE INTO validation_rule_types (rule_name, description, parameters, is_custom, source_format, target_format, data_type)
            VALUES (%s, %s, %s, %s, %s, %s, %s)
        """, [(name, desc, params, False, source, target, dtype) for name, desc, params, source, target, dtype in default_rules])
        conn.commit()
        cursor.close()
        logging.info("Default validation rules ensured successfully")
    except Exception as e:
        logging.error(f"Failed to ensure default validation rules: {str(e)}")
        raise

if __name__ == '__main__':
    try:
        # Create the application using factory pattern
        app = create_app()
        
        # Initialize database and default data within app context
        with app.app_context():
            initialize_app_data()
        
        # Get port from environment or use default
        port = int(os.getenv('PORT', 5000))
        
        # Start the application server
        logging.info("Starting Flask server...")
        app.run(debug=True, host='0.0.0.0', port=port)
        
    except Exception as e:
        logging.error(f"Failed to start application: {e}")
        raise
).all():
        return "Email"
    
    # Date pattern detection
    try:
        pd.to_datetime(non_null, format="%d-%m-%Y")
        return "Date"
    except Exception:
        try:
            pd.to_datetime(non_null, format="%Y-%m-%d")
            return "Date"
        except Exception:
            pass
    
    # Boolean detection
    if non_null.str.lower().isin(['true', 'false', '0', '1']).all():
        return "Boolean"
    
    # Numeric detection
    if non_null.str.match(r'^-?\d+

def create_app():
    """Application factory pattern for different environments"""
    # Set the path to the frontend dist folder
    current_dir = os.path.dirname(os.path.abspath(__file__))
    frontend_dist_path = os.path.join(current_dir, '..', '..', 'Keansa-Ai-Suite2025may-frontend11', 'dist')
    frontend_dist_path = os.path.abspath(frontend_dist_path)
    
    # Create Flask application instance
    app = Flask(__name__, static_folder=frontend_dist_path, static_url_path='')
    CORS(app, supports_credentials=True, origins=["http://localhost:3000", "http://localhost:8080", "http://localhost:5000", "*"])

    app.secret_key = os.urandom(24).hex()
    app.config['SESSION_TYPE'] = 'filesystem'
    app.config['SESSION_FILE_DIR'] = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'sessions')
    app.config['SESSION_COOKIE_SAMESITE'] = 'Lax'
    app.config['SESSION_COOKIE_HTTPONLY'] = True
    app.config['SESSION_COOKIE_SECURE'] = False
    app.config['PERMANENT_SESSION_LIFETIME'] = 86400  # 24 hours
    app.config['UPLOAD_FOLDER'] = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'uploads')
    Session(app)

    # Ensure directories exist
    try:
        os.makedirs(app.config['UPLOAD_FOLDER'], exist_ok=True)
        os.makedirs(app.config['SESSION_FILE_DIR'], exist_ok=True)
    except OSError as e:
        logging.error(f"Failed to create directories: {e}")

    # Register cleanup handlers
    app.teardown_appcontext(close_db)
    
    # Register all routes directly in create_app
    
    # Static file serving for React frontend
    @app.route('/', defaults={'path': ''})
    @app.route('/<path:path>')
    def serve(path):
        if path and os.path.exists(os.path.join(app.static_folder, path)):
            return app.send_static_file(path)
        return app.send_static_file('index.html')

    # Health check endpoint
    @app.route('/health', methods=['GET'])
    def health_check():
        return jsonify({
            'status': 'healthy',
            'timestamp': datetime.now().isoformat(),
            'version': '2.0.0'
        })

    # Authentication endpoint - both old and new paths
    @app.route('/authenticate', methods=['POST'])
    @app.route('/api/auth/authenticate', methods=['POST'])
    def authenticate():
        try:
            email = request.form.get('username') or request.form.get('email')
            password = request.form.get('password')
            logging.debug(f"Login attempt: email={email}, password={'*' * len(password) if password else 'None'}")
            
            if not email or not password:
                logging.warning(f"Login failed: Email or password missing")
                return jsonify({'success': False, 'message': 'Email and password are required'}), 400

            # Check for admin login
            if email == "admin" and password == "admin":
                session['loggedin'] = True
                session['user_email'] = "admin@example.com"
                session['user_id'] = 1
                session.permanent = True
                logging.info(f"Admin login successful. Session: {dict(session)}")
                return jsonify({'success': True, 'message': 'Login successful', 'user': {'email': 'admin@example.com', 'id': 1}}), 200

            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("SELECT * FROM login_details WHERE LOWER(email) = LOWER(%s)", (email.lower(),))
            account = cursor.fetchone()
            cursor.close()
            
            if account:
                if bcrypt.checkpw(password.encode('utf-8'), account['password'].encode('utf-8')):
                    session['loggedin'] = True
                    session['user_email'] = account['email']
                    session['user_id'] = account['id']
                    session.permanent = True
                    logging.info(f"User {email} logged in successfully. Session: {dict(session)}")
                    return jsonify({
                        'success': True,
                        'message': 'Login successful',
                        'user': {'email': account['email'], 'id': account['id']}
                    }), 200
                else:
                    logging.warning(f"Invalid password for {email}")
                    return jsonify({'success': False, 'message': 'Invalid credentials'}), 401
            else:
                logging.warning(f"Email {email} not found")
                return jsonify({'success': False, 'message': 'Invalid credentials'}), 401
        except Exception as e:
            logging.error(f"Unexpected error during login: {str(e)}")
            return jsonify({'success': False, 'message': f'Unexpected error: {str(e)}'}), 500

    @app.route('/check-auth', methods=['GET'])
    @app.route('/api/auth/check-auth', methods=['GET'])
    def check_auth():
        try:
            logging.debug(f"Checking auth with session: {dict(session)}")
            if 'loggedin' in session and 'user_id' in session:
                conn = get_db_connection()
                cursor = conn.cursor(dictionary=True)
                cursor.execute("SELECT email, first_name FROM login_details WHERE id = %s", (session['user_id'],))
                user = cursor.fetchone()
                cursor.close()
                if user:
                    logging.info(f"User {session.get('user_email')} is authenticated")
                    return jsonify({
                        'success': True,
                        'user': {
                            'email': user['email'],
                            'id': session['user_id'],
                            'first_name': user['first_name']
                        }
                    })
                else:
                    logging.warning("User not found in database")  
                    session.clear()
                    return jsonify({'success': False, 'message': 'User not found'}), 401
            logging.warning("User not authenticated")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        except Exception as e:
            logging.error(f"Error in check-auth endpoint: {str(e)}")
            return jsonify({'success': False, 'message': f'Server error: {str(e)}'}), 500

    @app.route('/register', methods=['POST'])
    @app.route('/api/auth/register', methods=['POST'])
    def register():
        first_name = request.form.get('first_name')
        last_name = request.form.get('last_name')
        email = request.form.get('email')
        mobile = request.form.get('mobile')
        password = request.form.get('password')
        confirm_password = request.form.get('confirm_password')

        if not all([first_name, last_name, email, mobile, password, confirm_password]):
            return jsonify({'success': False, 'message': 'All fields are required'}), 400
        if password != confirm_password:
            return jsonify({'success': False, 'message': 'Passwords do not match'}), 400

        hashed_password = bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
        try:
            conn = get_db_connection()
            cursor = conn.cursor()
            cursor.execute("""
                INSERT INTO login_details (first_name, last_name, email, mobile, password)
                VALUES (%s, %s, %s, %s, %s)
            """, (first_name, last_name, email, mobile, hashed_password))
            user_id = cursor.lastrowid
            conn.commit()
            cursor.close()
            session['loggedin'] = True
            session['user_email'] = email
            session['user_id'] = user_id
            return jsonify({
                'success': True,
                'message': 'Registration successful',
                'user': {'email': email, 'id': user_id}
            }), 200
        except mysql.connector.Error as e:
            logging.error(f"Database error during registration: {str(e)}")
            return jsonify({'success': False, 'message': f'Registration error: {str(e)}'}), 500

    @app.route('/logout', methods=['POST'])
    @app.route('/api/auth/logout', methods=['POST'])
    def logout():
        logging.info(f"User {session.get('user_email', 'unknown')} logged out")
        session.clear()
        return jsonify({'success': True, 'message': 'Logged out successfully'})

    # Template routes
    @app.route('/templates', methods=['GET'])
    @app.route('/api/templates', methods=['GET'])
    def get_templates():
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /templates: session missing")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("""
                SELECT template_id, template_name, created_at, status
                FROM excel_templates
                WHERE user_id = %s AND status = 'ACTIVE'
                ORDER BY created_at DESC
                LIMIT 100
            """, (session['user_id'],))
            templates = cursor.fetchall()
            cursor.close()
            logging.info(f"Fetched {len(templates)} templates for user {session['user_id']}")
            return jsonify({'success': True, 'templates': templates})
        except mysql.connector.Error as e:
            logging.error(f'Error fetching templates: {str(e)}')
            return jsonify({'success': False, 'message': f'Error fetching templates: {str(e)}'}), 500
        except Exception as e:
            logging.error(f'Unexpected error fetching templates: {str(e)}')
            return jsonify({'success': False, 'message': f'Unexpected error: {str(e)}'}), 500

    # Rule Configuration routes
    @app.route('/rule-configurations', methods=['GET'])
    @app.route('/api/validation/rule-configurations', methods=['GET'])
    def get_rule_configurations():
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning(f"Unauthorized access to /rule-configurations: session={dict(session)}")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            user_id = session['user_id']
            logging.debug(f"Fetching rule configurations for user_id: {user_id}")

            # Main query to fetch templates with configured rules
            cursor.execute("""
                SELECT 
                    t.template_id, 
                    t.template_name, 
                    t.created_at, 
                    COUNT(cvr.column_validation_id) as rule_count
                FROM excel_templates t
                LEFT JOIN template_columns tc ON t.template_id = tc.template_id
                LEFT JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                WHERE t.user_id = %s AND t.status = 'ACTIVE' AND t.is_corrected = FALSE
                GROUP BY t.template_id, t.template_name, t.created_at
                HAVING rule_count > 0
                ORDER BY t.created_at DESC
                LIMIT 100
            """, (user_id,))
            templates = cursor.fetchall()
            logging.debug(f"Fetched rule-configured templates: {templates}")

            cursor.close()

            if not templates:
                logging.info(f"No templates with rules found for user_id: {user_id}")
            else:
                logging.info(f"Found {len(templates)} templates with rules for user_id: {user_id}")

            return jsonify({'success': True, 'templates': templates})
        except mysql.connector.Error as e:
            logging.error(f"Database error fetching rule configurations: {str(e)}")
            return jsonify({'success': False, 'message': f"Database error: {str(e)}"}), 500
        except Exception as e:
            logging.error(f"Unexpected error fetching rule configurations: {str(e)}")
            return jsonify({'success': False, 'message': f"Unexpected error: {str(e)}"}), 500

    # File upload route
    @app.route('/upload', methods=['POST'])
    @app.route('/api/templates/upload', methods=['POST'])
    @app.route('/api/upload', methods=['POST'])  # Additional common path
    def upload():
        logging.info(f"Upload endpoint called: {request.endpoint}, method: {request.method}")
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /upload: session missing")
            return jsonify({'error': 'Not logged in'}), 401
        if 'file' not in request.files:
            logging.warning("No file provided in upload request")
            return jsonify({'error': 'No file uploaded'}), 400
        file = request.files['file']
        if file.filename == '':
            logging.warning("No file selected in upload request")
            return jsonify({'error': 'No file selected'}), 400
        
        file_path = os.path.join(app.config['UPLOAD_FOLDER'], file.filename)
        try:
            file.save(file_path)
            logging.info(f"File saved: {file_path}")
        except Exception as e:
            logging.error(f"Failed to save file {file.filename}: {str(e)}")
            return jsonify({'error': f'Failed to save file: {str(e)}'}), 500

        try:
            # Read the file to get sheets and headers
            if file.filename.endswith('.xlsx') or file.filename.endswith('.xls'):
                xl = pd.ExcelFile(file_path)
                sheets = {sheet_name: pd.read_excel(file_path, sheet_name=sheet_name, header=None) 
                         for sheet_name in xl.sheet_names}
            elif file.filename.endswith(('.txt', '.csv', '.dat')):
                df = pd.read_csv(file_path, header=None, encoding='utf-8')
                sheets = {'Sheet1': df}
            else:
                logging.error("Unsupported file type")
                return jsonify({'error': 'Unsupported file type'}), 400
            
            logging.debug(f"Sheets extracted: {list(sheets.keys())}")
        except Exception as e:
            logging.error(f"Failed to read file {file_path}: {str(e)}")
            return jsonify({'error': f'Failed to read file: {str(e)}'}), 400

        try:
            sheet_names = list(sheets.keys())
            if not sheet_names:
                logging.error("No sheets found in the file")
                return jsonify({'error': 'No sheets found in the file'}), 400
            sheet_name = sheet_names[0]
            df = sheets[sheet_name]
            
            # Find header row
            header_row = 0
            for i in range(min(len(df), 10)):
                row = df.iloc[i].dropna()
                if not row.empty and all(isinstance(x, str) for x in row if pd.notna(x)):
                    header_row = i
                    break
                    
            headers = df.iloc[header_row].tolist()
            logging.debug(f"Headers extracted: {headers}")
            
            if not headers or all(not h for h in headers):
                logging.error("No valid headers found in file")
                return jsonify({'error': 'No valid headers found in the file'}), 400
        except Exception as e:
            logging.error(f"Error processing file {file.filename}: {str(e)}")
            return jsonify({'error': f'Error processing file: {str(e)}'}), 400

        # Clear existing session data
        for key in ['df', 'header_row', 'headers', 'sheet_name', 'current_step', 'selected_headers', 'validations', 'error_cell_locations', 'data_rows', 'corrected_file_path']:
            session.pop(key, None)

        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)

            # Check if template exists
            cursor.execute("""
                SELECT template_id, headers, sheet_name
                FROM excel_templates
                WHERE template_name = %s AND user_id = %s AND status = 'ACTIVE'
                ORDER BY created_at DESC
            """, (file.filename, session['user_id']))
            existing_templates = cursor.fetchall()
            logging.info(f"Found {len(existing_templates)} existing templates with name {file.filename}")

            template_id = None
            has_existing_rules = False
            validations = {}
            selected_headers = []

            # Check for matching template
            matching_template = None
            for template in existing_templates:
                stored_headers = json.loads(template['headers']) if template['headers'] else []
                stored_sheet_name = template['sheet_name']
                if stored_headers == headers and stored_sheet_name == sheet_name:
                    matching_template = template
                    break

            if matching_template:
                template_id = matching_template['template_id']
                # Check for existing rules
                cursor.execute("""
                    SELECT tc.column_name, vrt.rule_name
                    FROM template_columns tc
                    JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                    JOIN validation_rule_types vrt ON cvr.rule_type_id = vrt.rule_type_id
                    WHERE tc.template_id = %s AND tc.is_selected = TRUE
                """, (template_id,))
                rules_data = cursor.fetchall()
                for row in rules_data:
                    column_name = row['column_name']
                    rule_name = row['rule_name']
                    if column_name not in validations:
                        validations[column_name] = []
                    validations[column_name].append(rule_name)
                    if column_name not in selected_headers:
                        selected_headers.append(column_name)
                has_existing_rules = len(validations) > 0
            else:
                # New template
                cursor.execute("""
                    INSERT INTO excel_templates (template_name, user_id, sheet_name, headers, is_corrected)
                    VALUES (%s, %s, %s, %s, %s)
                """, (file.filename, session['user_id'], sheet_name, json.dumps(headers), False))
                template_id = cursor.lastrowid
                column_data = [(template_id, header, i + 1, False) for i, header in enumerate(headers)]
                cursor.executemany("""
                    INSERT INTO template_columns (template_id, column_name, column_position, is_selected)
                    VALUES (%s, %s, %s, %s)
                """, column_data)

            conn.commit()
            cursor.close()

            # Store session data
            session['file_path'] = file_path
            session['template_id'] = template_id
            session['df'] = df.to_json()
            session['header_row'] = header_row
            session['headers'] = headers
            session['sheet_name'] = sheet_name
            session['current_step'] = 1 if not has_existing_rules else 3
            session['validations'] = validations
            session['selected_headers'] = selected_headers
            session['has_existing_rules'] = has_existing_rules

            logging.info(f"Upload processed: template_id={template_id}, filename={file.filename}, has_existing_rules={has_existing_rules}")

            return jsonify({
                'success': True,
                'sheets': {sheet_name: {'headers': headers}},
                'file_name': file.filename,
                'template_id': template_id,
                'has_existing_rules': has_existing_rules,
                'sheet_name': sheet_name,
                'skip_to_step_3': has_existing_rules
            })
        except mysql.connector.Error as e:
            logging.error(f'Error saving template: {str(e)}')
            return jsonify({'error': f'Error saving template: {str(e)}'}), 500
        except Exception as e:
            logging.error(f'Unexpected error saving template: {str(e)}')
            return jsonify({'error': f'Unexpected error: {str(e)}'}), 500

    # Multi-step workflow endpoints
    @app.route('/step/1', methods=['GET', 'POST'])
    @app.route('/api/step/1', methods=['GET', 'POST'])
    def step_one():
        if 'loggedin' not in session:
            return jsonify({'error': 'Not logged in'}), 401
        
        if request.method == 'POST':
            try:
                headers = request.form.getlist('headers')
                new_header_row = request.form.get('new_header_row')
                logging.debug(f"Step 1 submitted: headers={headers}, new_header_row={new_header_row}")
                
                if not headers:
                    logging.error("No headers provided in step 1")
                    return jsonify({'success': False, 'message': 'No headers provided'}), 400
                    
                if 'template_id' not in session:
                    logging.error("Session missing template_id")
                    return jsonify({'success': False, 'message': 'Session data missing'}), 400

                template_id = session['template_id']
                
                # Get the dataframe from session for auto-detection
                df_json = session.get('df')
                if df_json:
                    df = pd.read_json(StringIO(df_json))
                    session_headers = session.get('headers', [])
                    df.columns = session_headers
                    header_row = session.get('header_row', 0)
                    df = df.iloc[header_row + 1:].reset_index(drop=True)
                    
                    # Auto-detect rules for selected headers
                    validations = assign_default_rules_to_columns(df, headers)
                    session['validations'] = validations
                    logging.debug(f"Auto-assigned rules: {validations}")
                else:
                    validations = {}

                session['selected_headers'] = headers
                session['current_step'] = 2

                # Mark selected headers in the database
                conn = get_db_connection()
                cursor = conn.cursor()
                cursor.execute("UPDATE template_columns SET is_selected = FALSE WHERE template_id = %s", (template_id,))
                for header in headers:
                    cursor.execute("""
                        UPDATE template_columns
                        SET is_selected = TRUE
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    
                    # Get column_id and add auto-detected rules
                    cursor.execute("""
                        SELECT column_id FROM template_columns
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    result = cursor.fetchone()
                    if result:
                        column_id = result[0]
                        for rule_name in validations.get(header, []):
                            cursor.execute("""
                                SELECT rule_type_id FROM validation_rule_types
                                WHERE rule_name = %s AND is_custom = FALSE
                            """, (rule_name,))
                            rule_result = cursor.fetchone()
                            if rule_result:
                                rule_type_id = rule_result[0]
                                cursor.execute("""
                                    INSERT IGNORE INTO column_validation_rules (column_id, rule_type_id, rule_config)
                                    VALUES (%s, %s, %s)
                                """, (column_id, rule_type_id, '{}'))
                
                conn.commit()
                cursor.close()

                logging.info(f"Step 1 completed: headers={headers}, auto-assigned rules={validations}")
                return jsonify({'success': True, 'headers': headers, 'validations': validations})
            except Exception as e:
                logging.error(f"Error in step 1: {str(e)}")
                return jsonify({'success': False, 'message': str(e)}), 500
        
        # GET request - return current headers
        headers = session.get('headers', [])
        return jsonify({'headers': headers})

    @app.route('/step/2', methods=['GET', 'POST'])
    @app.route('/api/step/2', methods=['GET', 'POST'])
    def step_two():
        if 'loggedin' not in session:
            return jsonify({'error': 'Not logged in'}), 401
            
        if request.method == 'POST':
            try:
                action = request.form.get('action', 'save')
                validations = {}
                for key, values in request.form.lists():
                    if key.startswith('validations_'):
                        header = key.replace('validations_', '')
                        validations[header] = values
                        
                logging.debug(f"Step 2 submitted: action={action}, validations={validations}")
                
                template_id = session.get('template_id')
                if not template_id:
                    return jsonify({'success': False, 'message': 'Session data missing'}), 400

                # Save validations to database
                conn = get_db_connection()
                cursor = conn.cursor()
                
                # Clear existing rules
                cursor.execute("""
                    DELETE FROM column_validation_rules
                    WHERE column_id IN (
                        SELECT column_id FROM template_columns WHERE template_id = %s
                    )
                """, (template_id,))
                
                # Add new rules
                for header, rules in validations.items():
                    cursor.execute("""
                        SELECT column_id FROM template_columns
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    result = cursor.fetchone()
                    if not result:
                        continue
                    column_id = result[0]
                    
                    for rule_name in rules:
                        cursor.execute("""
                            SELECT rule_type_id FROM validation_rule_types
                            WHERE rule_name = %s
                        """, (rule_name,))
                        result = cursor.fetchone()
                        if result:
                            rule_type_id = result[0]
                            cursor.execute("""
                                INSERT IGNORE INTO column_validation_rules (column_id, rule_type_id, rule_config)
                                VALUES (%s, %s, %s)
                            """, (column_id, rule_type_id, '{}'))
                
                conn.commit()
                cursor.close()

                session['validations'] = validations
                session['current_step'] = 3 if action == 'review' else 2
                
                logging.info(f"Step 2 completed: action={action}, validations={validations}")
                return jsonify({'success': True, 'message': 'Step 2 completed successfully'})
            except Exception as e:
                logging.error(f"Error in step 2: {str(e)}")
                return jsonify({'success': False, 'message': str(e)}), 500
        
        # GET request
        selected_headers = session.get('selected_headers', [])
        return jsonify({'selected_headers': selected_headers})

    # Rules endpoint
    @app.route('/rules', methods=['GET'])
    @app.route('/api/rules', methods=['GET'])
    def get_rules():
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            
            cursor.execute("""
                SELECT rule_type_id AS rule_id, rule_name, description, parameters, is_custom, 
                       column_name, template_id, source_format, target_format, data_type, is_active
                FROM validation_rule_types
            """)
            rules = cursor.fetchall()
            cursor.close()
            
            logging.info(f"Returning {len(rules)} rules from getRules endpoint")
            return jsonify({'success': True, 'rules': rules})
        except mysql.connector.Error as e:
            logging.error(f"Database error fetching rules: {str(e)}")
            return jsonify({'success': False, 'message': str(e)}), 500
        except Exception as e:
            logging.error(f"Unexpected error fetching rules: {str(e)}")
            return jsonify({'success': False, 'message': str(e)}), 500

    # Template details endpoint
    @app.route('/template/<int:template_id>/<sheet_name>', methods=['GET'])
    @app.route('/api/template/<int:template_id>/<sheet_name>', methods=['GET'])
    def get_template(template_id, sheet_name):
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /template: session missing")
            return jsonify({'error': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("""
                SELECT template_name, sheet_name, headers
                FROM excel_templates
                WHERE template_id = %s AND user_id = %s AND status = 'ACTIVE'
            """, (template_id, session['user_id']))
            template_record = cursor.fetchone()
            
            if not template_record:
                logging.error(f"Template not found for template_id: {template_id}, user_id: {session['user_id']}")
                cursor.close()
                return jsonify({'error': 'Template not found'}), 404

            headers = json.loads(template_record['headers']) if template_record['headers'] else []
            stored_sheet_name = template_record['sheet_name'] or sheet_name
            file_path = os.path.join(app.config['UPLOAD_FOLDER'], template_record['template_name'])
            
            cursor.execute("""
                SELECT COUNT(*) as rule_count
                FROM template_columns tc
                JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                WHERE tc.template_id = %s AND tc.is_selected = TRUE
            """, (template_id,))
            rule_count = cursor.fetchone()['rule_count']
            has_existing_rules = rule_count > 0
            
            cursor.close()
            
            return jsonify({
                'success': True,
                'sheets': {stored_sheet_name: {'headers': headers}},
                'file_name': template_record['template_name'],
                'file_path': file_path,
                'sheet_name': stored_sheet_name,
                'has_existing_rules': has_existing_rules
            })
        except mysql.connector.Error as e:
            logging.error(f"Database error in get_template: {str(e)}")
            return jsonify({'error': f'Database error: {str(e)}'}), 500
        except Exception as e:
            logging.error(f"Unexpected error in get_template: {str(e)}")
            return jsonify({'error': f'Unexpected error: {str(e)}'}), 500

    # Debug route to show all registered routes
    @app.route('/debug/routes', methods=['GET'])
    def list_routes():
        routes = []
        for rule in app.url_map.iter_rules():
            routes.append({
                'endpoint': rule.endpoint,
                'methods': list(rule.methods),
                'rule': rule.rule
            })
        return jsonify(routes)

    # 404 handler to debug missing routes
    @app.errorhandler(404)
    def not_found_handler(error):
        logging.error(f"404 Error: {request.method} {request.url} not found")
        logging.error(f"Available routes: {[rule.rule for rule in app.url_map.iter_rules()]}")
        return jsonify({
            'error': 'Endpoint not found', 
            'method': request.method,
            'url': request.url,
            'path': request.path
        }), 404

    return app

def initialize_app_data():
    """Initialize database and create default data"""
    try:
        logging.info("Initializing database schema...")
        init_db()
        
        logging.info("Creating admin user...")
        create_admin_user()
        
        logging.info("Creating default validation rules...")
        create_default_validation_rules()
        
        logging.info("Application initialization completed successfully")
    except Exception as e:
        logging.error(f"Failed to initialize application: {e}")
        raise

DB_CONFIG = {
    'host': os.getenv('MYSQL_HOST', 'localhost'),
    'user': os.getenv('MYSQL_USER', 'root'),
    'password': os.getenv('MYSQL_PASSWORD', 'Keansa@2024'),
    'database': os.getenv('MYSQL_DATABASE', 'data_validation_2'),
}

def get_db_connection():
    if 'db' not in g:
        try:
            conn = mysql.connector.connect(
                host=DB_CONFIG['host'],
                user=DB_CONFIG['user'],
                password=DB_CONFIG['password']
            )
            cursor = conn.cursor()
            cursor.execute(f"CREATE DATABASE IF NOT EXISTS {DB_CONFIG['database']}")
            cursor.close()
            conn.close()
            g.db = mysql.connector.connect(**DB_CONFIG)
            logging.info("Database connection established successfully")
        except mysql.connector.Error as err:
            if err.errno == errorcode.ER_ACCESS_DENIED_ERROR:
                logging.error("Database connection failed: Access denied for user - check username/password")
            elif err.errno == errorcode.ER_BAD_DB_ERROR:
                logging.error("Database connection failed: Database does not exist")
            else:
                logging.error(f"Database connection failed: {err}")
            raise Exception(f"Failed to connect to database: {str(err)}")
    return g.db

def close_db(error):
    db = g.pop('db', None)
    if db is not None:
        db.close()

def init_db():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        tables = [
            """
            CREATE TABLE IF NOT EXISTS login_details (
                id INT AUTO_INCREMENT PRIMARY KEY,
                first_name VARCHAR(100),
                last_name VARCHAR(100),
                email VARCHAR(255) UNIQUE,
                mobile VARCHAR(10),
                password VARCHAR(255)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS excel_templates (
                template_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_name VARCHAR(255) NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
                user_id INT NOT NULL,
                sheet_name VARCHAR(255),
                headers JSON,
                status ENUM('ACTIVE', 'INACTIVE') DEFAULT 'ACTIVE',
                is_corrected BOOLEAN DEFAULT FALSE,
                remote_file_path VARCHAR(512),
                FOREIGN KEY (user_id) REFERENCES login_details(id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS template_columns (
                column_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_id BIGINT NOT NULL,
                column_name VARCHAR(255) NOT NULL,
                column_position INT NOT NULL,
                is_validation_enabled BOOLEAN DEFAULT FALSE,
                is_selected BOOLEAN DEFAULT FALSE,
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE,
                UNIQUE (template_id, column_name)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_rule_types (
                rule_type_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                rule_name VARCHAR(255) NOT NULL,
                description TEXT,
                parameters TEXT,
                is_active BOOLEAN DEFAULT TRUE,
                is_custom BOOLEAN DEFAULT FALSE,
                column_name VARCHAR(255),
                template_id BIGINT,
                data_type VARCHAR(50),
                source_format VARCHAR(50),
                target_format VARCHAR(50),
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS column_validation_rules (
                column_validation_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                column_id BIGINT NOT NULL,
                rule_type_id BIGINT NOT NULL,
                rule_config JSON,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (column_id) REFERENCES template_columns(column_id) ON DELETE CASCADE,
                FOREIGN KEY (rule_type_id) REFERENCES validation_rule_types(rule_type_id) ON DELETE RESTRICT,
                UNIQUE (column_id, rule_type_id)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_history (
                history_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_id BIGINT NOT NULL,
                template_name VARCHAR(255) NOT NULL,
                error_count INT NOT NULL,
                corrected_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                corrected_file_path VARCHAR(512) NOT NULL,
                user_id INT NOT NULL,
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE,
                FOREIGN KEY (user_id) REFERENCES login_details(id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_corrections (
                correction_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                history_id BIGINT NOT NULL,
                row_index INT NOT NULL,
                column_name VARCHAR(255) NOT NULL,
                original_value TEXT,
                corrected_value TEXT,
                rule_failed VARCHAR(255) DEFAULT NULL,
                FOREIGN KEY (history_id) REFERENCES validation_history(history_id) ON DELETE CASCADE
            )
            """
        ]
        for table_sql in tables:
            cursor.execute(table_sql)
        
        # Add missing columns if they don't exist
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'source_format'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN source_format VARCHAR(50)")
            logging.info("Added source_format column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'target_format'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN target_format VARCHAR(50)")
            logging.info("Added target_format column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'data_type'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN data_type VARCHAR(50)")
            logging.info("Added data_type column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM excel_templates LIKE 'remote_file_path'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE excel_templates ADD COLUMN remote_file_path VARCHAR(512)")
            logging.info("Added remote_file_path column to excel_templates table")
            
        cursor.execute("SHOW COLUMNS FROM template_columns LIKE 'is_selected'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE template_columns ADD COLUMN is_selected BOOLEAN DEFAULT FALSE")
            logging.info("Added is_selected column to template_columns table")
            
        conn.commit()
        cursor.close()
        logging.info("Database tables initialized")
    except Exception as e:
        logging.error(f"Failed to initialize database: {str(e)}")
        raise

def create_admin_user():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        admin_password = bcrypt.hashpw('admin'.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
        cursor.execute("""
            INSERT IGNORE INTO login_details (first_name, last_name, email, mobile, password)
            VALUES (%s, %s, %s, %s, %s)
        """, ('Admin', 'User', 'admin@example.com', '1234567890', admin_password))
        conn.commit()
        cursor.close()
        logging.info("Admin user created or already exists")
    except Exception as e:
        logging.error(f"Failed to create admin user: {str(e)}")
        raise

def create_default_validation_rules():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        default_rules = [
            ("Required", "Ensures the field is not null", '{"allow_null": false}', None, None, None),
            ("Int", "Validates integer format", '{"format": "integer"}', None, None, "Int"),
            ("Float", "Validates number format (integer or decimal)", '{"format": "float"}', None, None, "Float"),
            ("Text", "Allows text with quotes and parentheses", '{"allow_special": false}', None, None, "Text"),
            ("Email", "Validates email format", '{"regex": "^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\\\.[a-zA-Z0-9-.]+$"}', None, None, "Email"),
            ("Date(DD-MM-YYYY)", "Validates date format DD-MM-YYYY", '{"format": "%d-%m-%Y"}', "DD-MM-YYYY", None, "Date"),
            ("Boolean", "Validates boolean format (true/false or 0/1)", '{"format": "boolean"}', None, None, "Boolean"),
            ("Alphanumeric", "Validates alphanumeric format", '{"format": "alphanumeric"}', None, None, "Alphanumeric")
        ]
        cursor.executemany("""
            INSERT IGNORE INTO validation_rule_types (rule_name, description, parameters, is_custom, source_format, target_format, data_type)
            VALUES (%s, %s, %s, %s, %s, %s, %s)
        """, [(name, desc, params, False, source, target, dtype) for name, desc, params, source, target, dtype in default_rules])
        conn.commit()
        cursor.close()
        logging.info("Default validation rules ensured successfully")
    except Exception as e:
        logging.error(f"Failed to ensure default validation rules: {str(e)}")
        raise

if __name__ == '__main__':
    try:
        # Create the application using factory pattern
        app = create_app()
        
        # Initialize database and default data within app context
        with app.app_context():
            initialize_app_data()
        
        # Get port from environment or use default
        port = int(os.getenv('PORT', 5000))
        
        # Start the application server
        logging.info("Starting Flask server...")
        app.run(debug=True, host='0.0.0.0', port=port)
        
    except Exception as e:
        logging.error(f"Failed to start application: {e}")
        raise
).all():
        return "Int"
    
    if non_null.str.match(r'^-?\d+(\.\d+)?

def create_app():
    """Application factory pattern for different environments"""
    # Set the path to the frontend dist folder
    current_dir = os.path.dirname(os.path.abspath(__file__))
    frontend_dist_path = os.path.join(current_dir, '..', '..', 'Keansa-Ai-Suite2025may-frontend11', 'dist')
    frontend_dist_path = os.path.abspath(frontend_dist_path)
    
    # Create Flask application instance
    app = Flask(__name__, static_folder=frontend_dist_path, static_url_path='')
    CORS(app, supports_credentials=True, origins=["http://localhost:3000", "http://localhost:8080", "http://localhost:5000", "*"])

    app.secret_key = os.urandom(24).hex()
    app.config['SESSION_TYPE'] = 'filesystem'
    app.config['SESSION_FILE_DIR'] = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'sessions')
    app.config['SESSION_COOKIE_SAMESITE'] = 'Lax'
    app.config['SESSION_COOKIE_HTTPONLY'] = True
    app.config['SESSION_COOKIE_SECURE'] = False
    app.config['PERMANENT_SESSION_LIFETIME'] = 86400  # 24 hours
    app.config['UPLOAD_FOLDER'] = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'uploads')
    Session(app)

    # Ensure directories exist
    try:
        os.makedirs(app.config['UPLOAD_FOLDER'], exist_ok=True)
        os.makedirs(app.config['SESSION_FILE_DIR'], exist_ok=True)
    except OSError as e:
        logging.error(f"Failed to create directories: {e}")

    # Register cleanup handlers
    app.teardown_appcontext(close_db)
    
    # Register all routes directly in create_app
    
    # Static file serving for React frontend
    @app.route('/', defaults={'path': ''})
    @app.route('/<path:path>')
    def serve(path):
        if path and os.path.exists(os.path.join(app.static_folder, path)):
            return app.send_static_file(path)
        return app.send_static_file('index.html')

    # Health check endpoint
    @app.route('/health', methods=['GET'])
    def health_check():
        return jsonify({
            'status': 'healthy',
            'timestamp': datetime.now().isoformat(),
            'version': '2.0.0'
        })

    # Authentication endpoint - both old and new paths
    @app.route('/authenticate', methods=['POST'])
    @app.route('/api/auth/authenticate', methods=['POST'])
    def authenticate():
        try:
            email = request.form.get('username') or request.form.get('email')
            password = request.form.get('password')
            logging.debug(f"Login attempt: email={email}, password={'*' * len(password) if password else 'None'}")
            
            if not email or not password:
                logging.warning(f"Login failed: Email or password missing")
                return jsonify({'success': False, 'message': 'Email and password are required'}), 400

            # Check for admin login
            if email == "admin" and password == "admin":
                session['loggedin'] = True
                session['user_email'] = "admin@example.com"
                session['user_id'] = 1
                session.permanent = True
                logging.info(f"Admin login successful. Session: {dict(session)}")
                return jsonify({'success': True, 'message': 'Login successful', 'user': {'email': 'admin@example.com', 'id': 1}}), 200

            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("SELECT * FROM login_details WHERE LOWER(email) = LOWER(%s)", (email.lower(),))
            account = cursor.fetchone()
            cursor.close()
            
            if account:
                if bcrypt.checkpw(password.encode('utf-8'), account['password'].encode('utf-8')):
                    session['loggedin'] = True
                    session['user_email'] = account['email']
                    session['user_id'] = account['id']
                    session.permanent = True
                    logging.info(f"User {email} logged in successfully. Session: {dict(session)}")
                    return jsonify({
                        'success': True,
                        'message': 'Login successful',
                        'user': {'email': account['email'], 'id': account['id']}
                    }), 200
                else:
                    logging.warning(f"Invalid password for {email}")
                    return jsonify({'success': False, 'message': 'Invalid credentials'}), 401
            else:
                logging.warning(f"Email {email} not found")
                return jsonify({'success': False, 'message': 'Invalid credentials'}), 401
        except Exception as e:
            logging.error(f"Unexpected error during login: {str(e)}")
            return jsonify({'success': False, 'message': f'Unexpected error: {str(e)}'}), 500

    @app.route('/check-auth', methods=['GET'])
    @app.route('/api/auth/check-auth', methods=['GET'])
    def check_auth():
        try:
            logging.debug(f"Checking auth with session: {dict(session)}")
            if 'loggedin' in session and 'user_id' in session:
                conn = get_db_connection()
                cursor = conn.cursor(dictionary=True)
                cursor.execute("SELECT email, first_name FROM login_details WHERE id = %s", (session['user_id'],))
                user = cursor.fetchone()
                cursor.close()
                if user:
                    logging.info(f"User {session.get('user_email')} is authenticated")
                    return jsonify({
                        'success': True,
                        'user': {
                            'email': user['email'],
                            'id': session['user_id'],
                            'first_name': user['first_name']
                        }
                    })
                else:
                    logging.warning("User not found in database")  
                    session.clear()
                    return jsonify({'success': False, 'message': 'User not found'}), 401
            logging.warning("User not authenticated")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        except Exception as e:
            logging.error(f"Error in check-auth endpoint: {str(e)}")
            return jsonify({'success': False, 'message': f'Server error: {str(e)}'}), 500

    @app.route('/register', methods=['POST'])
    @app.route('/api/auth/register', methods=['POST'])
    def register():
        first_name = request.form.get('first_name')
        last_name = request.form.get('last_name')
        email = request.form.get('email')
        mobile = request.form.get('mobile')
        password = request.form.get('password')
        confirm_password = request.form.get('confirm_password')

        if not all([first_name, last_name, email, mobile, password, confirm_password]):
            return jsonify({'success': False, 'message': 'All fields are required'}), 400
        if password != confirm_password:
            return jsonify({'success': False, 'message': 'Passwords do not match'}), 400

        hashed_password = bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
        try:
            conn = get_db_connection()
            cursor = conn.cursor()
            cursor.execute("""
                INSERT INTO login_details (first_name, last_name, email, mobile, password)
                VALUES (%s, %s, %s, %s, %s)
            """, (first_name, last_name, email, mobile, hashed_password))
            user_id = cursor.lastrowid
            conn.commit()
            cursor.close()
            session['loggedin'] = True
            session['user_email'] = email
            session['user_id'] = user_id
            return jsonify({
                'success': True,
                'message': 'Registration successful',
                'user': {'email': email, 'id': user_id}
            }), 200
        except mysql.connector.Error as e:
            logging.error(f"Database error during registration: {str(e)}")
            return jsonify({'success': False, 'message': f'Registration error: {str(e)}'}), 500

    @app.route('/logout', methods=['POST'])
    @app.route('/api/auth/logout', methods=['POST'])
    def logout():
        logging.info(f"User {session.get('user_email', 'unknown')} logged out")
        session.clear()
        return jsonify({'success': True, 'message': 'Logged out successfully'})

    # Template routes
    @app.route('/templates', methods=['GET'])
    @app.route('/api/templates', methods=['GET'])
    def get_templates():
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /templates: session missing")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("""
                SELECT template_id, template_name, created_at, status
                FROM excel_templates
                WHERE user_id = %s AND status = 'ACTIVE'
                ORDER BY created_at DESC
                LIMIT 100
            """, (session['user_id'],))
            templates = cursor.fetchall()
            cursor.close()
            logging.info(f"Fetched {len(templates)} templates for user {session['user_id']}")
            return jsonify({'success': True, 'templates': templates})
        except mysql.connector.Error as e:
            logging.error(f'Error fetching templates: {str(e)}')
            return jsonify({'success': False, 'message': f'Error fetching templates: {str(e)}'}), 500
        except Exception as e:
            logging.error(f'Unexpected error fetching templates: {str(e)}')
            return jsonify({'success': False, 'message': f'Unexpected error: {str(e)}'}), 500

    # Rule Configuration routes
    @app.route('/rule-configurations', methods=['GET'])
    @app.route('/api/validation/rule-configurations', methods=['GET'])
    def get_rule_configurations():
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning(f"Unauthorized access to /rule-configurations: session={dict(session)}")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            user_id = session['user_id']
            logging.debug(f"Fetching rule configurations for user_id: {user_id}")

            # Main query to fetch templates with configured rules
            cursor.execute("""
                SELECT 
                    t.template_id, 
                    t.template_name, 
                    t.created_at, 
                    COUNT(cvr.column_validation_id) as rule_count
                FROM excel_templates t
                LEFT JOIN template_columns tc ON t.template_id = tc.template_id
                LEFT JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                WHERE t.user_id = %s AND t.status = 'ACTIVE' AND t.is_corrected = FALSE
                GROUP BY t.template_id, t.template_name, t.created_at
                HAVING rule_count > 0
                ORDER BY t.created_at DESC
                LIMIT 100
            """, (user_id,))
            templates = cursor.fetchall()
            logging.debug(f"Fetched rule-configured templates: {templates}")

            cursor.close()

            if not templates:
                logging.info(f"No templates with rules found for user_id: {user_id}")
            else:
                logging.info(f"Found {len(templates)} templates with rules for user_id: {user_id}")

            return jsonify({'success': True, 'templates': templates})
        except mysql.connector.Error as e:
            logging.error(f"Database error fetching rule configurations: {str(e)}")
            return jsonify({'success': False, 'message': f"Database error: {str(e)}"}), 500
        except Exception as e:
            logging.error(f"Unexpected error fetching rule configurations: {str(e)}")
            return jsonify({'success': False, 'message': f"Unexpected error: {str(e)}"}), 500

    # File upload route
    @app.route('/upload', methods=['POST'])
    @app.route('/api/templates/upload', methods=['POST'])
    @app.route('/api/upload', methods=['POST'])  # Additional common path
    def upload():
        logging.info(f"Upload endpoint called: {request.endpoint}, method: {request.method}")
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /upload: session missing")
            return jsonify({'error': 'Not logged in'}), 401
        if 'file' not in request.files:
            logging.warning("No file provided in upload request")
            return jsonify({'error': 'No file uploaded'}), 400
        file = request.files['file']
        if file.filename == '':
            logging.warning("No file selected in upload request")
            return jsonify({'error': 'No file selected'}), 400
        
        file_path = os.path.join(app.config['UPLOAD_FOLDER'], file.filename)
        try:
            file.save(file_path)
            logging.info(f"File saved: {file_path}")
        except Exception as e:
            logging.error(f"Failed to save file {file.filename}: {str(e)}")
            return jsonify({'error': f'Failed to save file: {str(e)}'}), 500

        try:
            # Read the file to get sheets and headers
            if file.filename.endswith('.xlsx') or file.filename.endswith('.xls'):
                xl = pd.ExcelFile(file_path)
                sheets = {sheet_name: pd.read_excel(file_path, sheet_name=sheet_name, header=None) 
                         for sheet_name in xl.sheet_names}
            elif file.filename.endswith(('.txt', '.csv', '.dat')):
                df = pd.read_csv(file_path, header=None, encoding='utf-8')
                sheets = {'Sheet1': df}
            else:
                logging.error("Unsupported file type")
                return jsonify({'error': 'Unsupported file type'}), 400
            
            logging.debug(f"Sheets extracted: {list(sheets.keys())}")
        except Exception as e:
            logging.error(f"Failed to read file {file_path}: {str(e)}")
            return jsonify({'error': f'Failed to read file: {str(e)}'}), 400

        try:
            sheet_names = list(sheets.keys())
            if not sheet_names:
                logging.error("No sheets found in the file")
                return jsonify({'error': 'No sheets found in the file'}), 400
            sheet_name = sheet_names[0]
            df = sheets[sheet_name]
            
            # Find header row
            header_row = 0
            for i in range(min(len(df), 10)):
                row = df.iloc[i].dropna()
                if not row.empty and all(isinstance(x, str) for x in row if pd.notna(x)):
                    header_row = i
                    break
                    
            headers = df.iloc[header_row].tolist()
            logging.debug(f"Headers extracted: {headers}")
            
            if not headers or all(not h for h in headers):
                logging.error("No valid headers found in file")
                return jsonify({'error': 'No valid headers found in the file'}), 400
        except Exception as e:
            logging.error(f"Error processing file {file.filename}: {str(e)}")
            return jsonify({'error': f'Error processing file: {str(e)}'}), 400

        # Clear existing session data
        for key in ['df', 'header_row', 'headers', 'sheet_name', 'current_step', 'selected_headers', 'validations', 'error_cell_locations', 'data_rows', 'corrected_file_path']:
            session.pop(key, None)

        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)

            # Check if template exists
            cursor.execute("""
                SELECT template_id, headers, sheet_name
                FROM excel_templates
                WHERE template_name = %s AND user_id = %s AND status = 'ACTIVE'
                ORDER BY created_at DESC
            """, (file.filename, session['user_id']))
            existing_templates = cursor.fetchall()
            logging.info(f"Found {len(existing_templates)} existing templates with name {file.filename}")

            template_id = None
            has_existing_rules = False
            validations = {}
            selected_headers = []

            # Check for matching template
            matching_template = None
            for template in existing_templates:
                stored_headers = json.loads(template['headers']) if template['headers'] else []
                stored_sheet_name = template['sheet_name']
                if stored_headers == headers and stored_sheet_name == sheet_name:
                    matching_template = template
                    break

            if matching_template:
                template_id = matching_template['template_id']
                # Check for existing rules
                cursor.execute("""
                    SELECT tc.column_name, vrt.rule_name
                    FROM template_columns tc
                    JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                    JOIN validation_rule_types vrt ON cvr.rule_type_id = vrt.rule_type_id
                    WHERE tc.template_id = %s AND tc.is_selected = TRUE
                """, (template_id,))
                rules_data = cursor.fetchall()
                for row in rules_data:
                    column_name = row['column_name']
                    rule_name = row['rule_name']
                    if column_name not in validations:
                        validations[column_name] = []
                    validations[column_name].append(rule_name)
                    if column_name not in selected_headers:
                        selected_headers.append(column_name)
                has_existing_rules = len(validations) > 0
            else:
                # New template
                cursor.execute("""
                    INSERT INTO excel_templates (template_name, user_id, sheet_name, headers, is_corrected)
                    VALUES (%s, %s, %s, %s, %s)
                """, (file.filename, session['user_id'], sheet_name, json.dumps(headers), False))
                template_id = cursor.lastrowid
                column_data = [(template_id, header, i + 1, False) for i, header in enumerate(headers)]
                cursor.executemany("""
                    INSERT INTO template_columns (template_id, column_name, column_position, is_selected)
                    VALUES (%s, %s, %s, %s)
                """, column_data)

            conn.commit()
            cursor.close()

            # Store session data
            session['file_path'] = file_path
            session['template_id'] = template_id
            session['df'] = df.to_json()
            session['header_row'] = header_row
            session['headers'] = headers
            session['sheet_name'] = sheet_name
            session['current_step'] = 1 if not has_existing_rules else 3
            session['validations'] = validations
            session['selected_headers'] = selected_headers
            session['has_existing_rules'] = has_existing_rules

            logging.info(f"Upload processed: template_id={template_id}, filename={file.filename}, has_existing_rules={has_existing_rules}")

            return jsonify({
                'success': True,
                'sheets': {sheet_name: {'headers': headers}},
                'file_name': file.filename,
                'template_id': template_id,
                'has_existing_rules': has_existing_rules,
                'sheet_name': sheet_name,
                'skip_to_step_3': has_existing_rules
            })
        except mysql.connector.Error as e:
            logging.error(f'Error saving template: {str(e)}')
            return jsonify({'error': f'Error saving template: {str(e)}'}), 500
        except Exception as e:
            logging.error(f'Unexpected error saving template: {str(e)}')
            return jsonify({'error': f'Unexpected error: {str(e)}'}), 500

    # Multi-step workflow endpoints
    @app.route('/step/1', methods=['GET', 'POST'])
    @app.route('/api/step/1', methods=['GET', 'POST'])
    def step_one():
        if 'loggedin' not in session:
            return jsonify({'error': 'Not logged in'}), 401
        
        if request.method == 'POST':
            try:
                headers = request.form.getlist('headers')
                new_header_row = request.form.get('new_header_row')
                logging.debug(f"Step 1 submitted: headers={headers}, new_header_row={new_header_row}")
                
                if not headers:
                    logging.error("No headers provided in step 1")
                    return jsonify({'success': False, 'message': 'No headers provided'}), 400
                    
                if 'template_id' not in session:
                    logging.error("Session missing template_id")
                    return jsonify({'success': False, 'message': 'Session data missing'}), 400

                template_id = session['template_id']
                
                # Get the dataframe from session for auto-detection
                df_json = session.get('df')
                if df_json:
                    df = pd.read_json(StringIO(df_json))
                    session_headers = session.get('headers', [])
                    df.columns = session_headers
                    header_row = session.get('header_row', 0)
                    df = df.iloc[header_row + 1:].reset_index(drop=True)
                    
                    # Auto-detect rules for selected headers
                    validations = assign_default_rules_to_columns(df, headers)
                    session['validations'] = validations
                    logging.debug(f"Auto-assigned rules: {validations}")
                else:
                    validations = {}

                session['selected_headers'] = headers
                session['current_step'] = 2

                # Mark selected headers in the database
                conn = get_db_connection()
                cursor = conn.cursor()
                cursor.execute("UPDATE template_columns SET is_selected = FALSE WHERE template_id = %s", (template_id,))
                for header in headers:
                    cursor.execute("""
                        UPDATE template_columns
                        SET is_selected = TRUE
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    
                    # Get column_id and add auto-detected rules
                    cursor.execute("""
                        SELECT column_id FROM template_columns
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    result = cursor.fetchone()
                    if result:
                        column_id = result[0]
                        for rule_name in validations.get(header, []):
                            cursor.execute("""
                                SELECT rule_type_id FROM validation_rule_types
                                WHERE rule_name = %s AND is_custom = FALSE
                            """, (rule_name,))
                            rule_result = cursor.fetchone()
                            if rule_result:
                                rule_type_id = rule_result[0]
                                cursor.execute("""
                                    INSERT IGNORE INTO column_validation_rules (column_id, rule_type_id, rule_config)
                                    VALUES (%s, %s, %s)
                                """, (column_id, rule_type_id, '{}'))
                
                conn.commit()
                cursor.close()

                logging.info(f"Step 1 completed: headers={headers}, auto-assigned rules={validations}")
                return jsonify({'success': True, 'headers': headers, 'validations': validations})
            except Exception as e:
                logging.error(f"Error in step 1: {str(e)}")
                return jsonify({'success': False, 'message': str(e)}), 500
        
        # GET request - return current headers
        headers = session.get('headers', [])
        return jsonify({'headers': headers})

    @app.route('/step/2', methods=['GET', 'POST'])
    @app.route('/api/step/2', methods=['GET', 'POST'])
    def step_two():
        if 'loggedin' not in session:
            return jsonify({'error': 'Not logged in'}), 401
            
        if request.method == 'POST':
            try:
                action = request.form.get('action', 'save')
                validations = {}
                for key, values in request.form.lists():
                    if key.startswith('validations_'):
                        header = key.replace('validations_', '')
                        validations[header] = values
                        
                logging.debug(f"Step 2 submitted: action={action}, validations={validations}")
                
                template_id = session.get('template_id')
                if not template_id:
                    return jsonify({'success': False, 'message': 'Session data missing'}), 400

                # Save validations to database
                conn = get_db_connection()
                cursor = conn.cursor()
                
                # Clear existing rules
                cursor.execute("""
                    DELETE FROM column_validation_rules
                    WHERE column_id IN (
                        SELECT column_id FROM template_columns WHERE template_id = %s
                    )
                """, (template_id,))
                
                # Add new rules
                for header, rules in validations.items():
                    cursor.execute("""
                        SELECT column_id FROM template_columns
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    result = cursor.fetchone()
                    if not result:
                        continue
                    column_id = result[0]
                    
                    for rule_name in rules:
                        cursor.execute("""
                            SELECT rule_type_id FROM validation_rule_types
                            WHERE rule_name = %s
                        """, (rule_name,))
                        result = cursor.fetchone()
                        if result:
                            rule_type_id = result[0]
                            cursor.execute("""
                                INSERT IGNORE INTO column_validation_rules (column_id, rule_type_id, rule_config)
                                VALUES (%s, %s, %s)
                            """, (column_id, rule_type_id, '{}'))
                
                conn.commit()
                cursor.close()

                session['validations'] = validations
                session['current_step'] = 3 if action == 'review' else 2
                
                logging.info(f"Step 2 completed: action={action}, validations={validations}")
                return jsonify({'success': True, 'message': 'Step 2 completed successfully'})
            except Exception as e:
                logging.error(f"Error in step 2: {str(e)}")
                return jsonify({'success': False, 'message': str(e)}), 500
        
        # GET request
        selected_headers = session.get('selected_headers', [])
        return jsonify({'selected_headers': selected_headers})

    # Rules endpoint
    @app.route('/rules', methods=['GET'])
    @app.route('/api/rules', methods=['GET'])
    def get_rules():
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            
            cursor.execute("""
                SELECT rule_type_id AS rule_id, rule_name, description, parameters, is_custom, 
                       column_name, template_id, source_format, target_format, data_type, is_active
                FROM validation_rule_types
            """)
            rules = cursor.fetchall()
            cursor.close()
            
            logging.info(f"Returning {len(rules)} rules from getRules endpoint")
            return jsonify({'success': True, 'rules': rules})
        except mysql.connector.Error as e:
            logging.error(f"Database error fetching rules: {str(e)}")
            return jsonify({'success': False, 'message': str(e)}), 500
        except Exception as e:
            logging.error(f"Unexpected error fetching rules: {str(e)}")
            return jsonify({'success': False, 'message': str(e)}), 500

    # Template details endpoint
    @app.route('/template/<int:template_id>/<sheet_name>', methods=['GET'])
    @app.route('/api/template/<int:template_id>/<sheet_name>', methods=['GET'])
    def get_template(template_id, sheet_name):
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /template: session missing")
            return jsonify({'error': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("""
                SELECT template_name, sheet_name, headers
                FROM excel_templates
                WHERE template_id = %s AND user_id = %s AND status = 'ACTIVE'
            """, (template_id, session['user_id']))
            template_record = cursor.fetchone()
            
            if not template_record:
                logging.error(f"Template not found for template_id: {template_id}, user_id: {session['user_id']}")
                cursor.close()
                return jsonify({'error': 'Template not found'}), 404

            headers = json.loads(template_record['headers']) if template_record['headers'] else []
            stored_sheet_name = template_record['sheet_name'] or sheet_name
            file_path = os.path.join(app.config['UPLOAD_FOLDER'], template_record['template_name'])
            
            cursor.execute("""
                SELECT COUNT(*) as rule_count
                FROM template_columns tc
                JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                WHERE tc.template_id = %s AND tc.is_selected = TRUE
            """, (template_id,))
            rule_count = cursor.fetchone()['rule_count']
            has_existing_rules = rule_count > 0
            
            cursor.close()
            
            return jsonify({
                'success': True,
                'sheets': {stored_sheet_name: {'headers': headers}},
                'file_name': template_record['template_name'],
                'file_path': file_path,
                'sheet_name': stored_sheet_name,
                'has_existing_rules': has_existing_rules
            })
        except mysql.connector.Error as e:
            logging.error(f"Database error in get_template: {str(e)}")
            return jsonify({'error': f'Database error: {str(e)}'}), 500
        except Exception as e:
            logging.error(f"Unexpected error in get_template: {str(e)}")
            return jsonify({'error': f'Unexpected error: {str(e)}'}), 500

    # Debug route to show all registered routes
    @app.route('/debug/routes', methods=['GET'])
    def list_routes():
        routes = []
        for rule in app.url_map.iter_rules():
            routes.append({
                'endpoint': rule.endpoint,
                'methods': list(rule.methods),
                'rule': rule.rule
            })
        return jsonify(routes)

    # 404 handler to debug missing routes
    @app.errorhandler(404)
    def not_found_handler(error):
        logging.error(f"404 Error: {request.method} {request.url} not found")
        logging.error(f"Available routes: {[rule.rule for rule in app.url_map.iter_rules()]}")
        return jsonify({
            'error': 'Endpoint not found', 
            'method': request.method,
            'url': request.url,
            'path': request.path
        }), 404

    return app

def initialize_app_data():
    """Initialize database and create default data"""
    try:
        logging.info("Initializing database schema...")
        init_db()
        
        logging.info("Creating admin user...")
        create_admin_user()
        
        logging.info("Creating default validation rules...")
        create_default_validation_rules()
        
        logging.info("Application initialization completed successfully")
    except Exception as e:
        logging.error(f"Failed to initialize application: {e}")
        raise

DB_CONFIG = {
    'host': os.getenv('MYSQL_HOST', 'localhost'),
    'user': os.getenv('MYSQL_USER', 'root'),
    'password': os.getenv('MYSQL_PASSWORD', 'Keansa@2024'),
    'database': os.getenv('MYSQL_DATABASE', 'data_validation_2'),
}

def get_db_connection():
    if 'db' not in g:
        try:
            conn = mysql.connector.connect(
                host=DB_CONFIG['host'],
                user=DB_CONFIG['user'],
                password=DB_CONFIG['password']
            )
            cursor = conn.cursor()
            cursor.execute(f"CREATE DATABASE IF NOT EXISTS {DB_CONFIG['database']}")
            cursor.close()
            conn.close()
            g.db = mysql.connector.connect(**DB_CONFIG)
            logging.info("Database connection established successfully")
        except mysql.connector.Error as err:
            if err.errno == errorcode.ER_ACCESS_DENIED_ERROR:
                logging.error("Database connection failed: Access denied for user - check username/password")
            elif err.errno == errorcode.ER_BAD_DB_ERROR:
                logging.error("Database connection failed: Database does not exist")
            else:
                logging.error(f"Database connection failed: {err}")
            raise Exception(f"Failed to connect to database: {str(err)}")
    return g.db

def close_db(error):
    db = g.pop('db', None)
    if db is not None:
        db.close()

def init_db():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        tables = [
            """
            CREATE TABLE IF NOT EXISTS login_details (
                id INT AUTO_INCREMENT PRIMARY KEY,
                first_name VARCHAR(100),
                last_name VARCHAR(100),
                email VARCHAR(255) UNIQUE,
                mobile VARCHAR(10),
                password VARCHAR(255)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS excel_templates (
                template_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_name VARCHAR(255) NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
                user_id INT NOT NULL,
                sheet_name VARCHAR(255),
                headers JSON,
                status ENUM('ACTIVE', 'INACTIVE') DEFAULT 'ACTIVE',
                is_corrected BOOLEAN DEFAULT FALSE,
                remote_file_path VARCHAR(512),
                FOREIGN KEY (user_id) REFERENCES login_details(id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS template_columns (
                column_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_id BIGINT NOT NULL,
                column_name VARCHAR(255) NOT NULL,
                column_position INT NOT NULL,
                is_validation_enabled BOOLEAN DEFAULT FALSE,
                is_selected BOOLEAN DEFAULT FALSE,
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE,
                UNIQUE (template_id, column_name)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_rule_types (
                rule_type_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                rule_name VARCHAR(255) NOT NULL,
                description TEXT,
                parameters TEXT,
                is_active BOOLEAN DEFAULT TRUE,
                is_custom BOOLEAN DEFAULT FALSE,
                column_name VARCHAR(255),
                template_id BIGINT,
                data_type VARCHAR(50),
                source_format VARCHAR(50),
                target_format VARCHAR(50),
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS column_validation_rules (
                column_validation_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                column_id BIGINT NOT NULL,
                rule_type_id BIGINT NOT NULL,
                rule_config JSON,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (column_id) REFERENCES template_columns(column_id) ON DELETE CASCADE,
                FOREIGN KEY (rule_type_id) REFERENCES validation_rule_types(rule_type_id) ON DELETE RESTRICT,
                UNIQUE (column_id, rule_type_id)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_history (
                history_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_id BIGINT NOT NULL,
                template_name VARCHAR(255) NOT NULL,
                error_count INT NOT NULL,
                corrected_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                corrected_file_path VARCHAR(512) NOT NULL,
                user_id INT NOT NULL,
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE,
                FOREIGN KEY (user_id) REFERENCES login_details(id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_corrections (
                correction_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                history_id BIGINT NOT NULL,
                row_index INT NOT NULL,
                column_name VARCHAR(255) NOT NULL,
                original_value TEXT,
                corrected_value TEXT,
                rule_failed VARCHAR(255) DEFAULT NULL,
                FOREIGN KEY (history_id) REFERENCES validation_history(history_id) ON DELETE CASCADE
            )
            """
        ]
        for table_sql in tables:
            cursor.execute(table_sql)
        
        # Add missing columns if they don't exist
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'source_format'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN source_format VARCHAR(50)")
            logging.info("Added source_format column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'target_format'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN target_format VARCHAR(50)")
            logging.info("Added target_format column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'data_type'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN data_type VARCHAR(50)")
            logging.info("Added data_type column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM excel_templates LIKE 'remote_file_path'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE excel_templates ADD COLUMN remote_file_path VARCHAR(512)")
            logging.info("Added remote_file_path column to excel_templates table")
            
        cursor.execute("SHOW COLUMNS FROM template_columns LIKE 'is_selected'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE template_columns ADD COLUMN is_selected BOOLEAN DEFAULT FALSE")
            logging.info("Added is_selected column to template_columns table")
            
        conn.commit()
        cursor.close()
        logging.info("Database tables initialized")
    except Exception as e:
        logging.error(f"Failed to initialize database: {str(e)}")
        raise

def create_admin_user():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        admin_password = bcrypt.hashpw('admin'.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
        cursor.execute("""
            INSERT IGNORE INTO login_details (first_name, last_name, email, mobile, password)
            VALUES (%s, %s, %s, %s, %s)
        """, ('Admin', 'User', 'admin@example.com', '1234567890', admin_password))
        conn.commit()
        cursor.close()
        logging.info("Admin user created or already exists")
    except Exception as e:
        logging.error(f"Failed to create admin user: {str(e)}")
        raise

def create_default_validation_rules():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        default_rules = [
            ("Required", "Ensures the field is not null", '{"allow_null": false}', None, None, None),
            ("Int", "Validates integer format", '{"format": "integer"}', None, None, "Int"),
            ("Float", "Validates number format (integer or decimal)", '{"format": "float"}', None, None, "Float"),
            ("Text", "Allows text with quotes and parentheses", '{"allow_special": false}', None, None, "Text"),
            ("Email", "Validates email format", '{"regex": "^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\\\.[a-zA-Z0-9-.]+$"}', None, None, "Email"),
            ("Date(DD-MM-YYYY)", "Validates date format DD-MM-YYYY", '{"format": "%d-%m-%Y"}', "DD-MM-YYYY", None, "Date"),
            ("Boolean", "Validates boolean format (true/false or 0/1)", '{"format": "boolean"}', None, None, "Boolean"),
            ("Alphanumeric", "Validates alphanumeric format", '{"format": "alphanumeric"}', None, None, "Alphanumeric")
        ]
        cursor.executemany("""
            INSERT IGNORE INTO validation_rule_types (rule_name, description, parameters, is_custom, source_format, target_format, data_type)
            VALUES (%s, %s, %s, %s, %s, %s, %s)
        """, [(name, desc, params, False, source, target, dtype) for name, desc, params, source, target, dtype in default_rules])
        conn.commit()
        cursor.close()
        logging.info("Default validation rules ensured successfully")
    except Exception as e:
        logging.error(f"Failed to ensure default validation rules: {str(e)}")
        raise

if __name__ == '__main__':
    try:
        # Create the application using factory pattern
        app = create_app()
        
        # Initialize database and default data within app context
        with app.app_context():
            initialize_app_data()
        
        # Get port from environment or use default
        port = int(os.getenv('PORT', 5000))
        
        # Start the application server
        logging.info("Starting Flask server...")
        app.run(debug=True, host='0.0.0.0', port=port)
        
    except Exception as e:
        logging.error(f"Failed to start application: {e}")
        raise
).all():
        return "Float"
    
    # Alphanumeric detection
    if non_null.str.match(r'^[a-zA-Z0-9]+

def create_app():
    """Application factory pattern for different environments"""
    # Set the path to the frontend dist folder
    current_dir = os.path.dirname(os.path.abspath(__file__))
    frontend_dist_path = os.path.join(current_dir, '..', '..', 'Keansa-Ai-Suite2025may-frontend11', 'dist')
    frontend_dist_path = os.path.abspath(frontend_dist_path)
    
    # Create Flask application instance
    app = Flask(__name__, static_folder=frontend_dist_path, static_url_path='')
    CORS(app, supports_credentials=True, origins=["http://localhost:3000", "http://localhost:8080", "http://localhost:5000", "*"])

    app.secret_key = os.urandom(24).hex()
    app.config['SESSION_TYPE'] = 'filesystem'
    app.config['SESSION_FILE_DIR'] = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'sessions')
    app.config['SESSION_COOKIE_SAMESITE'] = 'Lax'
    app.config['SESSION_COOKIE_HTTPONLY'] = True
    app.config['SESSION_COOKIE_SECURE'] = False
    app.config['PERMANENT_SESSION_LIFETIME'] = 86400  # 24 hours
    app.config['UPLOAD_FOLDER'] = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'uploads')
    Session(app)

    # Ensure directories exist
    try:
        os.makedirs(app.config['UPLOAD_FOLDER'], exist_ok=True)
        os.makedirs(app.config['SESSION_FILE_DIR'], exist_ok=True)
    except OSError as e:
        logging.error(f"Failed to create directories: {e}")

    # Register cleanup handlers
    app.teardown_appcontext(close_db)
    
    # Register all routes directly in create_app
    
    # Static file serving for React frontend
    @app.route('/', defaults={'path': ''})
    @app.route('/<path:path>')
    def serve(path):
        if path and os.path.exists(os.path.join(app.static_folder, path)):
            return app.send_static_file(path)
        return app.send_static_file('index.html')

    # Health check endpoint
    @app.route('/health', methods=['GET'])
    def health_check():
        return jsonify({
            'status': 'healthy',
            'timestamp': datetime.now().isoformat(),
            'version': '2.0.0'
        })

    # Authentication endpoint - both old and new paths
    @app.route('/authenticate', methods=['POST'])
    @app.route('/api/auth/authenticate', methods=['POST'])
    def authenticate():
        try:
            email = request.form.get('username') or request.form.get('email')
            password = request.form.get('password')
            logging.debug(f"Login attempt: email={email}, password={'*' * len(password) if password else 'None'}")
            
            if not email or not password:
                logging.warning(f"Login failed: Email or password missing")
                return jsonify({'success': False, 'message': 'Email and password are required'}), 400

            # Check for admin login
            if email == "admin" and password == "admin":
                session['loggedin'] = True
                session['user_email'] = "admin@example.com"
                session['user_id'] = 1
                session.permanent = True
                logging.info(f"Admin login successful. Session: {dict(session)}")
                return jsonify({'success': True, 'message': 'Login successful', 'user': {'email': 'admin@example.com', 'id': 1}}), 200

            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("SELECT * FROM login_details WHERE LOWER(email) = LOWER(%s)", (email.lower(),))
            account = cursor.fetchone()
            cursor.close()
            
            if account:
                if bcrypt.checkpw(password.encode('utf-8'), account['password'].encode('utf-8')):
                    session['loggedin'] = True
                    session['user_email'] = account['email']
                    session['user_id'] = account['id']
                    session.permanent = True
                    logging.info(f"User {email} logged in successfully. Session: {dict(session)}")
                    return jsonify({
                        'success': True,
                        'message': 'Login successful',
                        'user': {'email': account['email'], 'id': account['id']}
                    }), 200
                else:
                    logging.warning(f"Invalid password for {email}")
                    return jsonify({'success': False, 'message': 'Invalid credentials'}), 401
            else:
                logging.warning(f"Email {email} not found")
                return jsonify({'success': False, 'message': 'Invalid credentials'}), 401
        except Exception as e:
            logging.error(f"Unexpected error during login: {str(e)}")
            return jsonify({'success': False, 'message': f'Unexpected error: {str(e)}'}), 500

    @app.route('/check-auth', methods=['GET'])
    @app.route('/api/auth/check-auth', methods=['GET'])
    def check_auth():
        try:
            logging.debug(f"Checking auth with session: {dict(session)}")
            if 'loggedin' in session and 'user_id' in session:
                conn = get_db_connection()
                cursor = conn.cursor(dictionary=True)
                cursor.execute("SELECT email, first_name FROM login_details WHERE id = %s", (session['user_id'],))
                user = cursor.fetchone()
                cursor.close()
                if user:
                    logging.info(f"User {session.get('user_email')} is authenticated")
                    return jsonify({
                        'success': True,
                        'user': {
                            'email': user['email'],
                            'id': session['user_id'],
                            'first_name': user['first_name']
                        }
                    })
                else:
                    logging.warning("User not found in database")  
                    session.clear()
                    return jsonify({'success': False, 'message': 'User not found'}), 401
            logging.warning("User not authenticated")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        except Exception as e:
            logging.error(f"Error in check-auth endpoint: {str(e)}")
            return jsonify({'success': False, 'message': f'Server error: {str(e)}'}), 500

    @app.route('/register', methods=['POST'])
    @app.route('/api/auth/register', methods=['POST'])
    def register():
        first_name = request.form.get('first_name')
        last_name = request.form.get('last_name')
        email = request.form.get('email')
        mobile = request.form.get('mobile')
        password = request.form.get('password')
        confirm_password = request.form.get('confirm_password')

        if not all([first_name, last_name, email, mobile, password, confirm_password]):
            return jsonify({'success': False, 'message': 'All fields are required'}), 400
        if password != confirm_password:
            return jsonify({'success': False, 'message': 'Passwords do not match'}), 400

        hashed_password = bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
        try:
            conn = get_db_connection()
            cursor = conn.cursor()
            cursor.execute("""
                INSERT INTO login_details (first_name, last_name, email, mobile, password)
                VALUES (%s, %s, %s, %s, %s)
            """, (first_name, last_name, email, mobile, hashed_password))
            user_id = cursor.lastrowid
            conn.commit()
            cursor.close()
            session['loggedin'] = True
            session['user_email'] = email
            session['user_id'] = user_id
            return jsonify({
                'success': True,
                'message': 'Registration successful',
                'user': {'email': email, 'id': user_id}
            }), 200
        except mysql.connector.Error as e:
            logging.error(f"Database error during registration: {str(e)}")
            return jsonify({'success': False, 'message': f'Registration error: {str(e)}'}), 500

    @app.route('/logout', methods=['POST'])
    @app.route('/api/auth/logout', methods=['POST'])
    def logout():
        logging.info(f"User {session.get('user_email', 'unknown')} logged out")
        session.clear()
        return jsonify({'success': True, 'message': 'Logged out successfully'})

    # Template routes
    @app.route('/templates', methods=['GET'])
    @app.route('/api/templates', methods=['GET'])
    def get_templates():
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /templates: session missing")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("""
                SELECT template_id, template_name, created_at, status
                FROM excel_templates
                WHERE user_id = %s AND status = 'ACTIVE'
                ORDER BY created_at DESC
                LIMIT 100
            """, (session['user_id'],))
            templates = cursor.fetchall()
            cursor.close()
            logging.info(f"Fetched {len(templates)} templates for user {session['user_id']}")
            return jsonify({'success': True, 'templates': templates})
        except mysql.connector.Error as e:
            logging.error(f'Error fetching templates: {str(e)}')
            return jsonify({'success': False, 'message': f'Error fetching templates: {str(e)}'}), 500
        except Exception as e:
            logging.error(f'Unexpected error fetching templates: {str(e)}')
            return jsonify({'success': False, 'message': f'Unexpected error: {str(e)}'}), 500

    # Rule Configuration routes
    @app.route('/rule-configurations', methods=['GET'])
    @app.route('/api/validation/rule-configurations', methods=['GET'])
    def get_rule_configurations():
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning(f"Unauthorized access to /rule-configurations: session={dict(session)}")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            user_id = session['user_id']
            logging.debug(f"Fetching rule configurations for user_id: {user_id}")

            # Main query to fetch templates with configured rules
            cursor.execute("""
                SELECT 
                    t.template_id, 
                    t.template_name, 
                    t.created_at, 
                    COUNT(cvr.column_validation_id) as rule_count
                FROM excel_templates t
                LEFT JOIN template_columns tc ON t.template_id = tc.template_id
                LEFT JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                WHERE t.user_id = %s AND t.status = 'ACTIVE' AND t.is_corrected = FALSE
                GROUP BY t.template_id, t.template_name, t.created_at
                HAVING rule_count > 0
                ORDER BY t.created_at DESC
                LIMIT 100
            """, (user_id,))
            templates = cursor.fetchall()
            logging.debug(f"Fetched rule-configured templates: {templates}")

            cursor.close()

            if not templates:
                logging.info(f"No templates with rules found for user_id: {user_id}")
            else:
                logging.info(f"Found {len(templates)} templates with rules for user_id: {user_id}")

            return jsonify({'success': True, 'templates': templates})
        except mysql.connector.Error as e:
            logging.error(f"Database error fetching rule configurations: {str(e)}")
            return jsonify({'success': False, 'message': f"Database error: {str(e)}"}), 500
        except Exception as e:
            logging.error(f"Unexpected error fetching rule configurations: {str(e)}")
            return jsonify({'success': False, 'message': f"Unexpected error: {str(e)}"}), 500

    # File upload route
    @app.route('/upload', methods=['POST'])
    @app.route('/api/templates/upload', methods=['POST'])
    @app.route('/api/upload', methods=['POST'])  # Additional common path
    def upload():
        logging.info(f"Upload endpoint called: {request.endpoint}, method: {request.method}")
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /upload: session missing")
            return jsonify({'error': 'Not logged in'}), 401
        if 'file' not in request.files:
            logging.warning("No file provided in upload request")
            return jsonify({'error': 'No file uploaded'}), 400
        file = request.files['file']
        if file.filename == '':
            logging.warning("No file selected in upload request")
            return jsonify({'error': 'No file selected'}), 400
        
        file_path = os.path.join(app.config['UPLOAD_FOLDER'], file.filename)
        try:
            file.save(file_path)
            logging.info(f"File saved: {file_path}")
        except Exception as e:
            logging.error(f"Failed to save file {file.filename}: {str(e)}")
            return jsonify({'error': f'Failed to save file: {str(e)}'}), 500

        try:
            # Read the file to get sheets and headers
            if file.filename.endswith('.xlsx') or file.filename.endswith('.xls'):
                xl = pd.ExcelFile(file_path)
                sheets = {sheet_name: pd.read_excel(file_path, sheet_name=sheet_name, header=None) 
                         for sheet_name in xl.sheet_names}
            elif file.filename.endswith(('.txt', '.csv', '.dat')):
                df = pd.read_csv(file_path, header=None, encoding='utf-8')
                sheets = {'Sheet1': df}
            else:
                logging.error("Unsupported file type")
                return jsonify({'error': 'Unsupported file type'}), 400
            
            logging.debug(f"Sheets extracted: {list(sheets.keys())}")
        except Exception as e:
            logging.error(f"Failed to read file {file_path}: {str(e)}")
            return jsonify({'error': f'Failed to read file: {str(e)}'}), 400

        try:
            sheet_names = list(sheets.keys())
            if not sheet_names:
                logging.error("No sheets found in the file")
                return jsonify({'error': 'No sheets found in the file'}), 400
            sheet_name = sheet_names[0]
            df = sheets[sheet_name]
            
            # Find header row
            header_row = 0
            for i in range(min(len(df), 10)):
                row = df.iloc[i].dropna()
                if not row.empty and all(isinstance(x, str) for x in row if pd.notna(x)):
                    header_row = i
                    break
                    
            headers = df.iloc[header_row].tolist()
            logging.debug(f"Headers extracted: {headers}")
            
            if not headers or all(not h for h in headers):
                logging.error("No valid headers found in file")
                return jsonify({'error': 'No valid headers found in the file'}), 400
        except Exception as e:
            logging.error(f"Error processing file {file.filename}: {str(e)}")
            return jsonify({'error': f'Error processing file: {str(e)}'}), 400

        # Clear existing session data
        for key in ['df', 'header_row', 'headers', 'sheet_name', 'current_step', 'selected_headers', 'validations', 'error_cell_locations', 'data_rows', 'corrected_file_path']:
            session.pop(key, None)

        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)

            # Check if template exists
            cursor.execute("""
                SELECT template_id, headers, sheet_name
                FROM excel_templates
                WHERE template_name = %s AND user_id = %s AND status = 'ACTIVE'
                ORDER BY created_at DESC
            """, (file.filename, session['user_id']))
            existing_templates = cursor.fetchall()
            logging.info(f"Found {len(existing_templates)} existing templates with name {file.filename}")

            template_id = None
            has_existing_rules = False
            validations = {}
            selected_headers = []

            # Check for matching template
            matching_template = None
            for template in existing_templates:
                stored_headers = json.loads(template['headers']) if template['headers'] else []
                stored_sheet_name = template['sheet_name']
                if stored_headers == headers and stored_sheet_name == sheet_name:
                    matching_template = template
                    break

            if matching_template:
                template_id = matching_template['template_id']
                # Check for existing rules
                cursor.execute("""
                    SELECT tc.column_name, vrt.rule_name
                    FROM template_columns tc
                    JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                    JOIN validation_rule_types vrt ON cvr.rule_type_id = vrt.rule_type_id
                    WHERE tc.template_id = %s AND tc.is_selected = TRUE
                """, (template_id,))
                rules_data = cursor.fetchall()
                for row in rules_data:
                    column_name = row['column_name']
                    rule_name = row['rule_name']
                    if column_name not in validations:
                        validations[column_name] = []
                    validations[column_name].append(rule_name)
                    if column_name not in selected_headers:
                        selected_headers.append(column_name)
                has_existing_rules = len(validations) > 0
            else:
                # New template
                cursor.execute("""
                    INSERT INTO excel_templates (template_name, user_id, sheet_name, headers, is_corrected)
                    VALUES (%s, %s, %s, %s, %s)
                """, (file.filename, session['user_id'], sheet_name, json.dumps(headers), False))
                template_id = cursor.lastrowid
                column_data = [(template_id, header, i + 1, False) for i, header in enumerate(headers)]
                cursor.executemany("""
                    INSERT INTO template_columns (template_id, column_name, column_position, is_selected)
                    VALUES (%s, %s, %s, %s)
                """, column_data)

            conn.commit()
            cursor.close()

            # Store session data
            session['file_path'] = file_path
            session['template_id'] = template_id
            session['df'] = df.to_json()
            session['header_row'] = header_row
            session['headers'] = headers
            session['sheet_name'] = sheet_name
            session['current_step'] = 1 if not has_existing_rules else 3
            session['validations'] = validations
            session['selected_headers'] = selected_headers
            session['has_existing_rules'] = has_existing_rules

            logging.info(f"Upload processed: template_id={template_id}, filename={file.filename}, has_existing_rules={has_existing_rules}")

            return jsonify({
                'success': True,
                'sheets': {sheet_name: {'headers': headers}},
                'file_name': file.filename,
                'template_id': template_id,
                'has_existing_rules': has_existing_rules,
                'sheet_name': sheet_name,
                'skip_to_step_3': has_existing_rules
            })
        except mysql.connector.Error as e:
            logging.error(f'Error saving template: {str(e)}')
            return jsonify({'error': f'Error saving template: {str(e)}'}), 500
        except Exception as e:
            logging.error(f'Unexpected error saving template: {str(e)}')
            return jsonify({'error': f'Unexpected error: {str(e)}'}), 500

    # Multi-step workflow endpoints
    @app.route('/step/1', methods=['GET', 'POST'])
    @app.route('/api/step/1', methods=['GET', 'POST'])
    def step_one():
        if 'loggedin' not in session:
            return jsonify({'error': 'Not logged in'}), 401
        
        if request.method == 'POST':
            try:
                headers = request.form.getlist('headers')
                new_header_row = request.form.get('new_header_row')
                logging.debug(f"Step 1 submitted: headers={headers}, new_header_row={new_header_row}")
                
                if not headers:
                    logging.error("No headers provided in step 1")
                    return jsonify({'success': False, 'message': 'No headers provided'}), 400
                    
                if 'template_id' not in session:
                    logging.error("Session missing template_id")
                    return jsonify({'success': False, 'message': 'Session data missing'}), 400

                template_id = session['template_id']
                
                # Get the dataframe from session for auto-detection
                df_json = session.get('df')
                if df_json:
                    df = pd.read_json(StringIO(df_json))
                    session_headers = session.get('headers', [])
                    df.columns = session_headers
                    header_row = session.get('header_row', 0)
                    df = df.iloc[header_row + 1:].reset_index(drop=True)
                    
                    # Auto-detect rules for selected headers
                    validations = assign_default_rules_to_columns(df, headers)
                    session['validations'] = validations
                    logging.debug(f"Auto-assigned rules: {validations}")
                else:
                    validations = {}

                session['selected_headers'] = headers
                session['current_step'] = 2

                # Mark selected headers in the database
                conn = get_db_connection()
                cursor = conn.cursor()
                cursor.execute("UPDATE template_columns SET is_selected = FALSE WHERE template_id = %s", (template_id,))
                for header in headers:
                    cursor.execute("""
                        UPDATE template_columns
                        SET is_selected = TRUE
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    
                    # Get column_id and add auto-detected rules
                    cursor.execute("""
                        SELECT column_id FROM template_columns
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    result = cursor.fetchone()
                    if result:
                        column_id = result[0]
                        for rule_name in validations.get(header, []):
                            cursor.execute("""
                                SELECT rule_type_id FROM validation_rule_types
                                WHERE rule_name = %s AND is_custom = FALSE
                            """, (rule_name,))
                            rule_result = cursor.fetchone()
                            if rule_result:
                                rule_type_id = rule_result[0]
                                cursor.execute("""
                                    INSERT IGNORE INTO column_validation_rules (column_id, rule_type_id, rule_config)
                                    VALUES (%s, %s, %s)
                                """, (column_id, rule_type_id, '{}'))
                
                conn.commit()
                cursor.close()

                logging.info(f"Step 1 completed: headers={headers}, auto-assigned rules={validations}")
                return jsonify({'success': True, 'headers': headers, 'validations': validations})
            except Exception as e:
                logging.error(f"Error in step 1: {str(e)}")
                return jsonify({'success': False, 'message': str(e)}), 500
        
        # GET request - return current headers
        headers = session.get('headers', [])
        return jsonify({'headers': headers})

    @app.route('/step/2', methods=['GET', 'POST'])
    @app.route('/api/step/2', methods=['GET', 'POST'])
    def step_two():
        if 'loggedin' not in session:
            return jsonify({'error': 'Not logged in'}), 401
            
        if request.method == 'POST':
            try:
                action = request.form.get('action', 'save')
                validations = {}
                for key, values in request.form.lists():
                    if key.startswith('validations_'):
                        header = key.replace('validations_', '')
                        validations[header] = values
                        
                logging.debug(f"Step 2 submitted: action={action}, validations={validations}")
                
                template_id = session.get('template_id')
                if not template_id:
                    return jsonify({'success': False, 'message': 'Session data missing'}), 400

                # Save validations to database
                conn = get_db_connection()
                cursor = conn.cursor()
                
                # Clear existing rules
                cursor.execute("""
                    DELETE FROM column_validation_rules
                    WHERE column_id IN (
                        SELECT column_id FROM template_columns WHERE template_id = %s
                    )
                """, (template_id,))
                
                # Add new rules
                for header, rules in validations.items():
                    cursor.execute("""
                        SELECT column_id FROM template_columns
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    result = cursor.fetchone()
                    if not result:
                        continue
                    column_id = result[0]
                    
                    for rule_name in rules:
                        cursor.execute("""
                            SELECT rule_type_id FROM validation_rule_types
                            WHERE rule_name = %s
                        """, (rule_name,))
                        result = cursor.fetchone()
                        if result:
                            rule_type_id = result[0]
                            cursor.execute("""
                                INSERT IGNORE INTO column_validation_rules (column_id, rule_type_id, rule_config)
                                VALUES (%s, %s, %s)
                            """, (column_id, rule_type_id, '{}'))
                
                conn.commit()
                cursor.close()

                session['validations'] = validations
                session['current_step'] = 3 if action == 'review' else 2
                
                logging.info(f"Step 2 completed: action={action}, validations={validations}")
                return jsonify({'success': True, 'message': 'Step 2 completed successfully'})
            except Exception as e:
                logging.error(f"Error in step 2: {str(e)}")
                return jsonify({'success': False, 'message': str(e)}), 500
        
        # GET request
        selected_headers = session.get('selected_headers', [])
        return jsonify({'selected_headers': selected_headers})

    # Rules endpoint
    @app.route('/rules', methods=['GET'])
    @app.route('/api/rules', methods=['GET'])
    def get_rules():
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            
            cursor.execute("""
                SELECT rule_type_id AS rule_id, rule_name, description, parameters, is_custom, 
                       column_name, template_id, source_format, target_format, data_type, is_active
                FROM validation_rule_types
            """)
            rules = cursor.fetchall()
            cursor.close()
            
            logging.info(f"Returning {len(rules)} rules from getRules endpoint")
            return jsonify({'success': True, 'rules': rules})
        except mysql.connector.Error as e:
            logging.error(f"Database error fetching rules: {str(e)}")
            return jsonify({'success': False, 'message': str(e)}), 500
        except Exception as e:
            logging.error(f"Unexpected error fetching rules: {str(e)}")
            return jsonify({'success': False, 'message': str(e)}), 500

    # Template details endpoint
    @app.route('/template/<int:template_id>/<sheet_name>', methods=['GET'])
    @app.route('/api/template/<int:template_id>/<sheet_name>', methods=['GET'])
    def get_template(template_id, sheet_name):
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /template: session missing")
            return jsonify({'error': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("""
                SELECT template_name, sheet_name, headers
                FROM excel_templates
                WHERE template_id = %s AND user_id = %s AND status = 'ACTIVE'
            """, (template_id, session['user_id']))
            template_record = cursor.fetchone()
            
            if not template_record:
                logging.error(f"Template not found for template_id: {template_id}, user_id: {session['user_id']}")
                cursor.close()
                return jsonify({'error': 'Template not found'}), 404

            headers = json.loads(template_record['headers']) if template_record['headers'] else []
            stored_sheet_name = template_record['sheet_name'] or sheet_name
            file_path = os.path.join(app.config['UPLOAD_FOLDER'], template_record['template_name'])
            
            cursor.execute("""
                SELECT COUNT(*) as rule_count
                FROM template_columns tc
                JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                WHERE tc.template_id = %s AND tc.is_selected = TRUE
            """, (template_id,))
            rule_count = cursor.fetchone()['rule_count']
            has_existing_rules = rule_count > 0
            
            cursor.close()
            
            return jsonify({
                'success': True,
                'sheets': {stored_sheet_name: {'headers': headers}},
                'file_name': template_record['template_name'],
                'file_path': file_path,
                'sheet_name': stored_sheet_name,
                'has_existing_rules': has_existing_rules
            })
        except mysql.connector.Error as e:
            logging.error(f"Database error in get_template: {str(e)}")
            return jsonify({'error': f'Database error: {str(e)}'}), 500
        except Exception as e:
            logging.error(f"Unexpected error in get_template: {str(e)}")
            return jsonify({'error': f'Unexpected error: {str(e)}'}), 500

    # Debug route to show all registered routes
    @app.route('/debug/routes', methods=['GET'])
    def list_routes():
        routes = []
        for rule in app.url_map.iter_rules():
            routes.append({
                'endpoint': rule.endpoint,
                'methods': list(rule.methods),
                'rule': rule.rule
            })
        return jsonify(routes)

    # 404 handler to debug missing routes
    @app.errorhandler(404)
    def not_found_handler(error):
        logging.error(f"404 Error: {request.method} {request.url} not found")
        logging.error(f"Available routes: {[rule.rule for rule in app.url_map.iter_rules()]}")
        return jsonify({
            'error': 'Endpoint not found', 
            'method': request.method,
            'url': request.url,
            'path': request.path
        }), 404

    return app

def initialize_app_data():
    """Initialize database and create default data"""
    try:
        logging.info("Initializing database schema...")
        init_db()
        
        logging.info("Creating admin user...")
        create_admin_user()
        
        logging.info("Creating default validation rules...")
        create_default_validation_rules()
        
        logging.info("Application initialization completed successfully")
    except Exception as e:
        logging.error(f"Failed to initialize application: {e}")
        raise

DB_CONFIG = {
    'host': os.getenv('MYSQL_HOST', 'localhost'),
    'user': os.getenv('MYSQL_USER', 'root'),
    'password': os.getenv('MYSQL_PASSWORD', 'Keansa@2024'),
    'database': os.getenv('MYSQL_DATABASE', 'data_validation_2'),
}

def get_db_connection():
    if 'db' not in g:
        try:
            conn = mysql.connector.connect(
                host=DB_CONFIG['host'],
                user=DB_CONFIG['user'],
                password=DB_CONFIG['password']
            )
            cursor = conn.cursor()
            cursor.execute(f"CREATE DATABASE IF NOT EXISTS {DB_CONFIG['database']}")
            cursor.close()
            conn.close()
            g.db = mysql.connector.connect(**DB_CONFIG)
            logging.info("Database connection established successfully")
        except mysql.connector.Error as err:
            if err.errno == errorcode.ER_ACCESS_DENIED_ERROR:
                logging.error("Database connection failed: Access denied for user - check username/password")
            elif err.errno == errorcode.ER_BAD_DB_ERROR:
                logging.error("Database connection failed: Database does not exist")
            else:
                logging.error(f"Database connection failed: {err}")
            raise Exception(f"Failed to connect to database: {str(err)}")
    return g.db

def close_db(error):
    db = g.pop('db', None)
    if db is not None:
        db.close()

def init_db():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        tables = [
            """
            CREATE TABLE IF NOT EXISTS login_details (
                id INT AUTO_INCREMENT PRIMARY KEY,
                first_name VARCHAR(100),
                last_name VARCHAR(100),
                email VARCHAR(255) UNIQUE,
                mobile VARCHAR(10),
                password VARCHAR(255)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS excel_templates (
                template_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_name VARCHAR(255) NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
                user_id INT NOT NULL,
                sheet_name VARCHAR(255),
                headers JSON,
                status ENUM('ACTIVE', 'INACTIVE') DEFAULT 'ACTIVE',
                is_corrected BOOLEAN DEFAULT FALSE,
                remote_file_path VARCHAR(512),
                FOREIGN KEY (user_id) REFERENCES login_details(id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS template_columns (
                column_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_id BIGINT NOT NULL,
                column_name VARCHAR(255) NOT NULL,
                column_position INT NOT NULL,
                is_validation_enabled BOOLEAN DEFAULT FALSE,
                is_selected BOOLEAN DEFAULT FALSE,
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE,
                UNIQUE (template_id, column_name)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_rule_types (
                rule_type_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                rule_name VARCHAR(255) NOT NULL,
                description TEXT,
                parameters TEXT,
                is_active BOOLEAN DEFAULT TRUE,
                is_custom BOOLEAN DEFAULT FALSE,
                column_name VARCHAR(255),
                template_id BIGINT,
                data_type VARCHAR(50),
                source_format VARCHAR(50),
                target_format VARCHAR(50),
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS column_validation_rules (
                column_validation_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                column_id BIGINT NOT NULL,
                rule_type_id BIGINT NOT NULL,
                rule_config JSON,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (column_id) REFERENCES template_columns(column_id) ON DELETE CASCADE,
                FOREIGN KEY (rule_type_id) REFERENCES validation_rule_types(rule_type_id) ON DELETE RESTRICT,
                UNIQUE (column_id, rule_type_id)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_history (
                history_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_id BIGINT NOT NULL,
                template_name VARCHAR(255) NOT NULL,
                error_count INT NOT NULL,
                corrected_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                corrected_file_path VARCHAR(512) NOT NULL,
                user_id INT NOT NULL,
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE,
                FOREIGN KEY (user_id) REFERENCES login_details(id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_corrections (
                correction_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                history_id BIGINT NOT NULL,
                row_index INT NOT NULL,
                column_name VARCHAR(255) NOT NULL,
                original_value TEXT,
                corrected_value TEXT,
                rule_failed VARCHAR(255) DEFAULT NULL,
                FOREIGN KEY (history_id) REFERENCES validation_history(history_id) ON DELETE CASCADE
            )
            """
        ]
        for table_sql in tables:
            cursor.execute(table_sql)
        
        # Add missing columns if they don't exist
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'source_format'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN source_format VARCHAR(50)")
            logging.info("Added source_format column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'target_format'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN target_format VARCHAR(50)")
            logging.info("Added target_format column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'data_type'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN data_type VARCHAR(50)")
            logging.info("Added data_type column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM excel_templates LIKE 'remote_file_path'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE excel_templates ADD COLUMN remote_file_path VARCHAR(512)")
            logging.info("Added remote_file_path column to excel_templates table")
            
        cursor.execute("SHOW COLUMNS FROM template_columns LIKE 'is_selected'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE template_columns ADD COLUMN is_selected BOOLEAN DEFAULT FALSE")
            logging.info("Added is_selected column to template_columns table")
            
        conn.commit()
        cursor.close()
        logging.info("Database tables initialized")
    except Exception as e:
        logging.error(f"Failed to initialize database: {str(e)}")
        raise

def create_admin_user():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        admin_password = bcrypt.hashpw('admin'.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
        cursor.execute("""
            INSERT IGNORE INTO login_details (first_name, last_name, email, mobile, password)
            VALUES (%s, %s, %s, %s, %s)
        """, ('Admin', 'User', 'admin@example.com', '1234567890', admin_password))
        conn.commit()
        cursor.close()
        logging.info("Admin user created or already exists")
    except Exception as e:
        logging.error(f"Failed to create admin user: {str(e)}")
        raise

def create_default_validation_rules():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        default_rules = [
            ("Required", "Ensures the field is not null", '{"allow_null": false}', None, None, None),
            ("Int", "Validates integer format", '{"format": "integer"}', None, None, "Int"),
            ("Float", "Validates number format (integer or decimal)", '{"format": "float"}', None, None, "Float"),
            ("Text", "Allows text with quotes and parentheses", '{"allow_special": false}', None, None, "Text"),
            ("Email", "Validates email format", '{"regex": "^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\\\.[a-zA-Z0-9-.]+$"}', None, None, "Email"),
            ("Date(DD-MM-YYYY)", "Validates date format DD-MM-YYYY", '{"format": "%d-%m-%Y"}', "DD-MM-YYYY", None, "Date"),
            ("Boolean", "Validates boolean format (true/false or 0/1)", '{"format": "boolean"}', None, None, "Boolean"),
            ("Alphanumeric", "Validates alphanumeric format", '{"format": "alphanumeric"}', None, None, "Alphanumeric")
        ]
        cursor.executemany("""
            INSERT IGNORE INTO validation_rule_types (rule_name, description, parameters, is_custom, source_format, target_format, data_type)
            VALUES (%s, %s, %s, %s, %s, %s, %s)
        """, [(name, desc, params, False, source, target, dtype) for name, desc, params, source, target, dtype in default_rules])
        conn.commit()
        cursor.close()
        logging.info("Default validation rules ensured successfully")
    except Exception as e:
        logging.error(f"Failed to ensure default validation rules: {str(e)}")
        raise

if __name__ == '__main__':
    try:
        # Create the application using factory pattern
        app = create_app()
        
        # Initialize database and default data within app context
        with app.app_context():
            initialize_app_data()
        
        # Get port from environment or use default
        port = int(os.getenv('PORT', 5000))
        
        # Start the application server
        logging.info("Starting Flask server...")
        app.run(debug=True, host='0.0.0.0', port=port)
        
    except Exception as e:
        logging.error(f"Failed to start application: {e}")
        raise
).all():
        return "Alphanumeric"
    
    return "Text"

def assign_default_rules_to_columns(df, headers):
    """Intelligently assign validation rules based on column content"""
    assignments = {}
    
    for col in headers:
        if col not in df.columns:
            logging.warning(f"Column {col} not found in dataframe")
            continue
            
        col_type = detect_column_type(df[col])
        rules = ["Required"]  # Default rule for all columns
        
        # Special handling for optional columns
        if not any(col.lower().startswith(prefix) for prefix in
                  ["name", "address", "phone", "username", "status", "period"]):
            rules.append(col_type)
        else:
            rules.append("Text")  # Optional text fields
        
        assignments[col] = rules
    
    return assignments

def create_app():
    """Application factory pattern for different environments"""
    # Set the path to the frontend dist folder
    current_dir = os.path.dirname(os.path.abspath(__file__))
    frontend_dist_path = os.path.join(current_dir, '..', '..', 'Keansa-Ai-Suite2025may-frontend11', 'dist')
    frontend_dist_path = os.path.abspath(frontend_dist_path)
    
    # Create Flask application instance
    app = Flask(__name__, static_folder=frontend_dist_path, static_url_path='')
    CORS(app, supports_credentials=True, origins=["http://localhost:3000", "http://localhost:8080", "http://localhost:5000", "*"])

    app.secret_key = os.urandom(24).hex()
    app.config['SESSION_TYPE'] = 'filesystem'
    app.config['SESSION_FILE_DIR'] = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'sessions')
    app.config['SESSION_COOKIE_SAMESITE'] = 'Lax'
    app.config['SESSION_COOKIE_HTTPONLY'] = True
    app.config['SESSION_COOKIE_SECURE'] = False
    app.config['PERMANENT_SESSION_LIFETIME'] = 86400  # 24 hours
    app.config['UPLOAD_FOLDER'] = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'uploads')
    Session(app)

    # Ensure directories exist
    try:
        os.makedirs(app.config['UPLOAD_FOLDER'], exist_ok=True)
        os.makedirs(app.config['SESSION_FILE_DIR'], exist_ok=True)
    except OSError as e:
        logging.error(f"Failed to create directories: {e}")

    # Register cleanup handlers
    app.teardown_appcontext(close_db)
    
    # Register all routes directly in create_app
    
    # Static file serving for React frontend
    @app.route('/', defaults={'path': ''})
    @app.route('/<path:path>')
    def serve(path):
        if path and os.path.exists(os.path.join(app.static_folder, path)):
            return app.send_static_file(path)
        return app.send_static_file('index.html')

    # Health check endpoint
    @app.route('/health', methods=['GET'])
    def health_check():
        return jsonify({
            'status': 'healthy',
            'timestamp': datetime.now().isoformat(),
            'version': '2.0.0'
        })

    # Authentication endpoint - both old and new paths
    @app.route('/authenticate', methods=['POST'])
    @app.route('/api/auth/authenticate', methods=['POST'])
    def authenticate():
        try:
            email = request.form.get('username') or request.form.get('email')
            password = request.form.get('password')
            logging.debug(f"Login attempt: email={email}, password={'*' * len(password) if password else 'None'}")
            
            if not email or not password:
                logging.warning(f"Login failed: Email or password missing")
                return jsonify({'success': False, 'message': 'Email and password are required'}), 400

            # Check for admin login
            if email == "admin" and password == "admin":
                session['loggedin'] = True
                session['user_email'] = "admin@example.com"
                session['user_id'] = 1
                session.permanent = True
                logging.info(f"Admin login successful. Session: {dict(session)}")
                return jsonify({'success': True, 'message': 'Login successful', 'user': {'email': 'admin@example.com', 'id': 1}}), 200

            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("SELECT * FROM login_details WHERE LOWER(email) = LOWER(%s)", (email.lower(),))
            account = cursor.fetchone()
            cursor.close()
            
            if account:
                if bcrypt.checkpw(password.encode('utf-8'), account['password'].encode('utf-8')):
                    session['loggedin'] = True
                    session['user_email'] = account['email']
                    session['user_id'] = account['id']
                    session.permanent = True
                    logging.info(f"User {email} logged in successfully. Session: {dict(session)}")
                    return jsonify({
                        'success': True,
                        'message': 'Login successful',
                        'user': {'email': account['email'], 'id': account['id']}
                    }), 200
                else:
                    logging.warning(f"Invalid password for {email}")
                    return jsonify({'success': False, 'message': 'Invalid credentials'}), 401
            else:
                logging.warning(f"Email {email} not found")
                return jsonify({'success': False, 'message': 'Invalid credentials'}), 401
        except Exception as e:
            logging.error(f"Unexpected error during login: {str(e)}")
            return jsonify({'success': False, 'message': f'Unexpected error: {str(e)}'}), 500

    @app.route('/check-auth', methods=['GET'])
    @app.route('/api/auth/check-auth', methods=['GET'])
    def check_auth():
        try:
            logging.debug(f"Checking auth with session: {dict(session)}")
            if 'loggedin' in session and 'user_id' in session:
                conn = get_db_connection()
                cursor = conn.cursor(dictionary=True)
                cursor.execute("SELECT email, first_name FROM login_details WHERE id = %s", (session['user_id'],))
                user = cursor.fetchone()
                cursor.close()
                if user:
                    logging.info(f"User {session.get('user_email')} is authenticated")
                    return jsonify({
                        'success': True,
                        'user': {
                            'email': user['email'],
                            'id': session['user_id'],
                            'first_name': user['first_name']
                        }
                    })
                else:
                    logging.warning("User not found in database")  
                    session.clear()
                    return jsonify({'success': False, 'message': 'User not found'}), 401
            logging.warning("User not authenticated")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        except Exception as e:
            logging.error(f"Error in check-auth endpoint: {str(e)}")
            return jsonify({'success': False, 'message': f'Server error: {str(e)}'}), 500

    @app.route('/register', methods=['POST'])
    @app.route('/api/auth/register', methods=['POST'])
    def register():
        first_name = request.form.get('first_name')
        last_name = request.form.get('last_name')
        email = request.form.get('email')
        mobile = request.form.get('mobile')
        password = request.form.get('password')
        confirm_password = request.form.get('confirm_password')

        if not all([first_name, last_name, email, mobile, password, confirm_password]):
            return jsonify({'success': False, 'message': 'All fields are required'}), 400
        if password != confirm_password:
            return jsonify({'success': False, 'message': 'Passwords do not match'}), 400

        hashed_password = bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
        try:
            conn = get_db_connection()
            cursor = conn.cursor()
            cursor.execute("""
                INSERT INTO login_details (first_name, last_name, email, mobile, password)
                VALUES (%s, %s, %s, %s, %s)
            """, (first_name, last_name, email, mobile, hashed_password))
            user_id = cursor.lastrowid
            conn.commit()
            cursor.close()
            session['loggedin'] = True
            session['user_email'] = email
            session['user_id'] = user_id
            return jsonify({
                'success': True,
                'message': 'Registration successful',
                'user': {'email': email, 'id': user_id}
            }), 200
        except mysql.connector.Error as e:
            logging.error(f"Database error during registration: {str(e)}")
            return jsonify({'success': False, 'message': f'Registration error: {str(e)}'}), 500

    @app.route('/logout', methods=['POST'])
    @app.route('/api/auth/logout', methods=['POST'])
    def logout():
        logging.info(f"User {session.get('user_email', 'unknown')} logged out")
        session.clear()
        return jsonify({'success': True, 'message': 'Logged out successfully'})

    # Template routes
    @app.route('/templates', methods=['GET'])
    @app.route('/api/templates', methods=['GET'])
    def get_templates():
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /templates: session missing")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("""
                SELECT template_id, template_name, created_at, status
                FROM excel_templates
                WHERE user_id = %s AND status = 'ACTIVE'
                ORDER BY created_at DESC
                LIMIT 100
            """, (session['user_id'],))
            templates = cursor.fetchall()
            cursor.close()
            logging.info(f"Fetched {len(templates)} templates for user {session['user_id']}")
            return jsonify({'success': True, 'templates': templates})
        except mysql.connector.Error as e:
            logging.error(f'Error fetching templates: {str(e)}')
            return jsonify({'success': False, 'message': f'Error fetching templates: {str(e)}'}), 500
        except Exception as e:
            logging.error(f'Unexpected error fetching templates: {str(e)}')
            return jsonify({'success': False, 'message': f'Unexpected error: {str(e)}'}), 500

    # Rule Configuration routes
    @app.route('/rule-configurations', methods=['GET'])
    @app.route('/api/validation/rule-configurations', methods=['GET'])
    def get_rule_configurations():
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning(f"Unauthorized access to /rule-configurations: session={dict(session)}")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            user_id = session['user_id']
            logging.debug(f"Fetching rule configurations for user_id: {user_id}")

            # Main query to fetch templates with configured rules
            cursor.execute("""
                SELECT 
                    t.template_id, 
                    t.template_name, 
                    t.created_at, 
                    COUNT(cvr.column_validation_id) as rule_count
                FROM excel_templates t
                LEFT JOIN template_columns tc ON t.template_id = tc.template_id
                LEFT JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                WHERE t.user_id = %s AND t.status = 'ACTIVE' AND t.is_corrected = FALSE
                GROUP BY t.template_id, t.template_name, t.created_at
                HAVING rule_count > 0
                ORDER BY t.created_at DESC
                LIMIT 100
            """, (user_id,))
            templates = cursor.fetchall()
            logging.debug(f"Fetched rule-configured templates: {templates}")

            cursor.close()

            if not templates:
                logging.info(f"No templates with rules found for user_id: {user_id}")
            else:
                logging.info(f"Found {len(templates)} templates with rules for user_id: {user_id}")

            return jsonify({'success': True, 'templates': templates})
        except mysql.connector.Error as e:
            logging.error(f"Database error fetching rule configurations: {str(e)}")
            return jsonify({'success': False, 'message': f"Database error: {str(e)}"}), 500
        except Exception as e:
            logging.error(f"Unexpected error fetching rule configurations: {str(e)}")
            return jsonify({'success': False, 'message': f"Unexpected error: {str(e)}"}), 500

    # File upload route
    @app.route('/upload', methods=['POST'])
    @app.route('/api/templates/upload', methods=['POST'])
    @app.route('/api/upload', methods=['POST'])  # Additional common path
    def upload():
        logging.info(f"Upload endpoint called: {request.endpoint}, method: {request.method}")
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /upload: session missing")
            return jsonify({'error': 'Not logged in'}), 401
        if 'file' not in request.files:
            logging.warning("No file provided in upload request")
            return jsonify({'error': 'No file uploaded'}), 400
        file = request.files['file']
        if file.filename == '':
            logging.warning("No file selected in upload request")
            return jsonify({'error': 'No file selected'}), 400
        
        file_path = os.path.join(app.config['UPLOAD_FOLDER'], file.filename)
        try:
            file.save(file_path)
            logging.info(f"File saved: {file_path}")
        except Exception as e:
            logging.error(f"Failed to save file {file.filename}: {str(e)}")
            return jsonify({'error': f'Failed to save file: {str(e)}'}), 500

        try:
            # Read the file to get sheets and headers
            if file.filename.endswith('.xlsx') or file.filename.endswith('.xls'):
                xl = pd.ExcelFile(file_path)
                sheets = {sheet_name: pd.read_excel(file_path, sheet_name=sheet_name, header=None) 
                         for sheet_name in xl.sheet_names}
            elif file.filename.endswith(('.txt', '.csv', '.dat')):
                df = pd.read_csv(file_path, header=None, encoding='utf-8')
                sheets = {'Sheet1': df}
            else:
                logging.error("Unsupported file type")
                return jsonify({'error': 'Unsupported file type'}), 400
            
            logging.debug(f"Sheets extracted: {list(sheets.keys())}")
        except Exception as e:
            logging.error(f"Failed to read file {file_path}: {str(e)}")
            return jsonify({'error': f'Failed to read file: {str(e)}'}), 400

        try:
            sheet_names = list(sheets.keys())
            if not sheet_names:
                logging.error("No sheets found in the file")
                return jsonify({'error': 'No sheets found in the file'}), 400
            sheet_name = sheet_names[0]
            df = sheets[sheet_name]
            
            # Find header row
            header_row = 0
            for i in range(min(len(df), 10)):
                row = df.iloc[i].dropna()
                if not row.empty and all(isinstance(x, str) for x in row if pd.notna(x)):
                    header_row = i
                    break
                    
            headers = df.iloc[header_row].tolist()
            logging.debug(f"Headers extracted: {headers}")
            
            if not headers or all(not h for h in headers):
                logging.error("No valid headers found in file")
                return jsonify({'error': 'No valid headers found in the file'}), 400
        except Exception as e:
            logging.error(f"Error processing file {file.filename}: {str(e)}")
            return jsonify({'error': f'Error processing file: {str(e)}'}), 400

        # Clear existing session data
        for key in ['df', 'header_row', 'headers', 'sheet_name', 'current_step', 'selected_headers', 'validations', 'error_cell_locations', 'data_rows', 'corrected_file_path']:
            session.pop(key, None)

        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)

            # Check if template exists
            cursor.execute("""
                SELECT template_id, headers, sheet_name
                FROM excel_templates
                WHERE template_name = %s AND user_id = %s AND status = 'ACTIVE'
                ORDER BY created_at DESC
            """, (file.filename, session['user_id']))
            existing_templates = cursor.fetchall()
            logging.info(f"Found {len(existing_templates)} existing templates with name {file.filename}")

            template_id = None
            has_existing_rules = False
            validations = {}
            selected_headers = []

            # Check for matching template
            matching_template = None
            for template in existing_templates:
                stored_headers = json.loads(template['headers']) if template['headers'] else []
                stored_sheet_name = template['sheet_name']
                if stored_headers == headers and stored_sheet_name == sheet_name:
                    matching_template = template
                    break

            if matching_template:
                template_id = matching_template['template_id']
                # Check for existing rules
                cursor.execute("""
                    SELECT tc.column_name, vrt.rule_name
                    FROM template_columns tc
                    JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                    JOIN validation_rule_types vrt ON cvr.rule_type_id = vrt.rule_type_id
                    WHERE tc.template_id = %s AND tc.is_selected = TRUE
                """, (template_id,))
                rules_data = cursor.fetchall()
                for row in rules_data:
                    column_name = row['column_name']
                    rule_name = row['rule_name']
                    if column_name not in validations:
                        validations[column_name] = []
                    validations[column_name].append(rule_name)
                    if column_name not in selected_headers:
                        selected_headers.append(column_name)
                has_existing_rules = len(validations) > 0
            else:
                # New template
                cursor.execute("""
                    INSERT INTO excel_templates (template_name, user_id, sheet_name, headers, is_corrected)
                    VALUES (%s, %s, %s, %s, %s)
                """, (file.filename, session['user_id'], sheet_name, json.dumps(headers), False))
                template_id = cursor.lastrowid
                column_data = [(template_id, header, i + 1, False) for i, header in enumerate(headers)]
                cursor.executemany("""
                    INSERT INTO template_columns (template_id, column_name, column_position, is_selected)
                    VALUES (%s, %s, %s, %s)
                """, column_data)

            conn.commit()
            cursor.close()

            # Store session data
            session['file_path'] = file_path
            session['template_id'] = template_id
            session['df'] = df.to_json()
            session['header_row'] = header_row
            session['headers'] = headers
            session['sheet_name'] = sheet_name
            session['current_step'] = 1 if not has_existing_rules else 3
            session['validations'] = validations
            session['selected_headers'] = selected_headers
            session['has_existing_rules'] = has_existing_rules

            logging.info(f"Upload processed: template_id={template_id}, filename={file.filename}, has_existing_rules={has_existing_rules}")

            return jsonify({
                'success': True,
                'sheets': {sheet_name: {'headers': headers}},
                'file_name': file.filename,
                'template_id': template_id,
                'has_existing_rules': has_existing_rules,
                'sheet_name': sheet_name,
                'skip_to_step_3': has_existing_rules
            })
        except mysql.connector.Error as e:
            logging.error(f'Error saving template: {str(e)}')
            return jsonify({'error': f'Error saving template: {str(e)}'}), 500
        except Exception as e:
            logging.error(f'Unexpected error saving template: {str(e)}')
            return jsonify({'error': f'Unexpected error: {str(e)}'}), 500

    # Multi-step workflow endpoints
    @app.route('/step/1', methods=['GET', 'POST'])
    @app.route('/api/step/1', methods=['GET', 'POST'])
    def step_one():
        if 'loggedin' not in session:
            return jsonify({'error': 'Not logged in'}), 401
        
        if request.method == 'POST':
            try:
                headers = request.form.getlist('headers')
                new_header_row = request.form.get('new_header_row')
                logging.debug(f"Step 1 submitted: headers={headers}, new_header_row={new_header_row}")
                
                if not headers:
                    logging.error("No headers provided in step 1")
                    return jsonify({'success': False, 'message': 'No headers provided'}), 400
                    
                if 'template_id' not in session:
                    logging.error("Session missing template_id")
                    return jsonify({'success': False, 'message': 'Session data missing'}), 400

                template_id = session['template_id']
                
                # Get the dataframe from session for auto-detection
                df_json = session.get('df')
                if df_json:
                    df = pd.read_json(StringIO(df_json))
                    session_headers = session.get('headers', [])
                    df.columns = session_headers
                    header_row = session.get('header_row', 0)
                    df = df.iloc[header_row + 1:].reset_index(drop=True)
                    
                    # Auto-detect rules for selected headers
                    validations = assign_default_rules_to_columns(df, headers)
                    session['validations'] = validations
                    logging.debug(f"Auto-assigned rules: {validations}")
                else:
                    validations = {}

                session['selected_headers'] = headers
                session['current_step'] = 2

                # Mark selected headers in the database
                conn = get_db_connection()
                cursor = conn.cursor()
                cursor.execute("UPDATE template_columns SET is_selected = FALSE WHERE template_id = %s", (template_id,))
                for header in headers:
                    cursor.execute("""
                        UPDATE template_columns
                        SET is_selected = TRUE
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    
                    # Get column_id and add auto-detected rules
                    cursor.execute("""
                        SELECT column_id FROM template_columns
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    result = cursor.fetchone()
                    if result:
                        column_id = result[0]
                        for rule_name in validations.get(header, []):
                            cursor.execute("""
                                SELECT rule_type_id FROM validation_rule_types
                                WHERE rule_name = %s AND is_custom = FALSE
                            """, (rule_name,))
                            rule_result = cursor.fetchone()
                            if rule_result:
                                rule_type_id = rule_result[0]
                                cursor.execute("""
                                    INSERT IGNORE INTO column_validation_rules (column_id, rule_type_id, rule_config)
                                    VALUES (%s, %s, %s)
                                """, (column_id, rule_type_id, '{}'))
                
                conn.commit()
                cursor.close()

                logging.info(f"Step 1 completed: headers={headers}, auto-assigned rules={validations}")
                return jsonify({'success': True, 'headers': headers, 'validations': validations})
            except Exception as e:
                logging.error(f"Error in step 1: {str(e)}")
                return jsonify({'success': False, 'message': str(e)}), 500
        
        # GET request - return current headers
        headers = session.get('headers', [])
        return jsonify({'headers': headers})

    @app.route('/step/2', methods=['GET', 'POST'])
    @app.route('/api/step/2', methods=['GET', 'POST'])
    def step_two():
        if 'loggedin' not in session:
            return jsonify({'error': 'Not logged in'}), 401
            
        if request.method == 'POST':
            try:
                action = request.form.get('action', 'save')
                validations = {}
                for key, values in request.form.lists():
                    if key.startswith('validations_'):
                        header = key.replace('validations_', '')
                        validations[header] = values
                        
                logging.debug(f"Step 2 submitted: action={action}, validations={validations}")
                
                template_id = session.get('template_id')
                if not template_id:
                    return jsonify({'success': False, 'message': 'Session data missing'}), 400

                # Save validations to database
                conn = get_db_connection()
                cursor = conn.cursor()
                
                # Clear existing rules
                cursor.execute("""
                    DELETE FROM column_validation_rules
                    WHERE column_id IN (
                        SELECT column_id FROM template_columns WHERE template_id = %s
                    )
                """, (template_id,))
                
                # Add new rules
                for header, rules in validations.items():
                    cursor.execute("""
                        SELECT column_id FROM template_columns
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    result = cursor.fetchone()
                    if not result:
                        continue
                    column_id = result[0]
                    
                    for rule_name in rules:
                        cursor.execute("""
                            SELECT rule_type_id FROM validation_rule_types
                            WHERE rule_name = %s
                        """, (rule_name,))
                        result = cursor.fetchone()
                        if result:
                            rule_type_id = result[0]
                            cursor.execute("""
                                INSERT IGNORE INTO column_validation_rules (column_id, rule_type_id, rule_config)
                                VALUES (%s, %s, %s)
                            """, (column_id, rule_type_id, '{}'))
                
                conn.commit()
                cursor.close()

                session['validations'] = validations
                session['current_step'] = 3 if action == 'review' else 2
                
                logging.info(f"Step 2 completed: action={action}, validations={validations}")
                return jsonify({'success': True, 'message': 'Step 2 completed successfully'})
            except Exception as e:
                logging.error(f"Error in step 2: {str(e)}")
                return jsonify({'success': False, 'message': str(e)}), 500
        
        # GET request
        selected_headers = session.get('selected_headers', [])
        return jsonify({'selected_headers': selected_headers})

    # Rules endpoint
    @app.route('/rules', methods=['GET'])
    @app.route('/api/rules', methods=['GET'])
    def get_rules():
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            
            cursor.execute("""
                SELECT rule_type_id AS rule_id, rule_name, description, parameters, is_custom, 
                       column_name, template_id, source_format, target_format, data_type, is_active
                FROM validation_rule_types
            """)
            rules = cursor.fetchall()
            cursor.close()
            
            logging.info(f"Returning {len(rules)} rules from getRules endpoint")
            return jsonify({'success': True, 'rules': rules})
        except mysql.connector.Error as e:
            logging.error(f"Database error fetching rules: {str(e)}")
            return jsonify({'success': False, 'message': str(e)}), 500
        except Exception as e:
            logging.error(f"Unexpected error fetching rules: {str(e)}")
            return jsonify({'success': False, 'message': str(e)}), 500

    # Template details endpoint
    @app.route('/template/<int:template_id>/<sheet_name>', methods=['GET'])
    @app.route('/api/template/<int:template_id>/<sheet_name>', methods=['GET'])
    def get_template(template_id, sheet_name):
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /template: session missing")
            return jsonify({'error': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("""
                SELECT template_name, sheet_name, headers
                FROM excel_templates
                WHERE template_id = %s AND user_id = %s AND status = 'ACTIVE'
            """, (template_id, session['user_id']))
            template_record = cursor.fetchone()
            
            if not template_record:
                logging.error(f"Template not found for template_id: {template_id}, user_id: {session['user_id']}")
                cursor.close()
                return jsonify({'error': 'Template not found'}), 404

            headers = json.loads(template_record['headers']) if template_record['headers'] else []
            stored_sheet_name = template_record['sheet_name'] or sheet_name
            file_path = os.path.join(app.config['UPLOAD_FOLDER'], template_record['template_name'])
            
            cursor.execute("""
                SELECT COUNT(*) as rule_count
                FROM template_columns tc
                JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                WHERE tc.template_id = %s AND tc.is_selected = TRUE
            """, (template_id,))
            rule_count = cursor.fetchone()['rule_count']
            has_existing_rules = rule_count > 0
            
            cursor.close()
            
            return jsonify({
                'success': True,
                'sheets': {stored_sheet_name: {'headers': headers}},
                'file_name': template_record['template_name'],
                'file_path': file_path,
                'sheet_name': stored_sheet_name,
                'has_existing_rules': has_existing_rules
            })
        except mysql.connector.Error as e:
            logging.error(f"Database error in get_template: {str(e)}")
            return jsonify({'error': f'Database error: {str(e)}'}), 500
        except Exception as e:
            logging.error(f"Unexpected error in get_template: {str(e)}")
            return jsonify({'error': f'Unexpected error: {str(e)}'}), 500

    # Debug route to show all registered routes
    @app.route('/debug/routes', methods=['GET'])
    def list_routes():
        routes = []
        for rule in app.url_map.iter_rules():
            routes.append({
                'endpoint': rule.endpoint,
                'methods': list(rule.methods),
                'rule': rule.rule
            })
        return jsonify(routes)

    # 404 handler to debug missing routes
    @app.errorhandler(404)
    def not_found_handler(error):
        logging.error(f"404 Error: {request.method} {request.url} not found")
        logging.error(f"Available routes: {[rule.rule for rule in app.url_map.iter_rules()]}")
        return jsonify({
            'error': 'Endpoint not found', 
            'method': request.method,
            'url': request.url,
            'path': request.path
        }), 404

    return app

def initialize_app_data():
    """Initialize database and create default data"""
    try:
        logging.info("Initializing database schema...")
        init_db()
        
        logging.info("Creating admin user...")
        create_admin_user()
        
        logging.info("Creating default validation rules...")
        create_default_validation_rules()
        
        logging.info("Application initialization completed successfully")
    except Exception as e:
        logging.error(f"Failed to initialize application: {e}")
        raise

DB_CONFIG = {
    'host': os.getenv('MYSQL_HOST', 'localhost'),
    'user': os.getenv('MYSQL_USER', 'root'),
    'password': os.getenv('MYSQL_PASSWORD', 'Keansa@2024'),
    'database': os.getenv('MYSQL_DATABASE', 'data_validation_2'),
}

def get_db_connection():
    if 'db' not in g:
        try:
            conn = mysql.connector.connect(
                host=DB_CONFIG['host'],
                user=DB_CONFIG['user'],
                password=DB_CONFIG['password']
            )
            cursor = conn.cursor()
            cursor.execute(f"CREATE DATABASE IF NOT EXISTS {DB_CONFIG['database']}")
            cursor.close()
            conn.close()
            g.db = mysql.connector.connect(**DB_CONFIG)
            logging.info("Database connection established successfully")
        except mysql.connector.Error as err:
            if err.errno == errorcode.ER_ACCESS_DENIED_ERROR:
                logging.error("Database connection failed: Access denied for user - check username/password")
            elif err.errno == errorcode.ER_BAD_DB_ERROR:
                logging.error("Database connection failed: Database does not exist")
            else:
                logging.error(f"Database connection failed: {err}")
            raise Exception(f"Failed to connect to database: {str(err)}")
    return g.db

def close_db(error):
    db = g.pop('db', None)
    if db is not None:
        db.close()

def init_db():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        tables = [
            """
            CREATE TABLE IF NOT EXISTS login_details (
                id INT AUTO_INCREMENT PRIMARY KEY,
                first_name VARCHAR(100),
                last_name VARCHAR(100),
                email VARCHAR(255) UNIQUE,
                mobile VARCHAR(10),
                password VARCHAR(255)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS excel_templates (
                template_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_name VARCHAR(255) NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
                user_id INT NOT NULL,
                sheet_name VARCHAR(255),
                headers JSON,
                status ENUM('ACTIVE', 'INACTIVE') DEFAULT 'ACTIVE',
                is_corrected BOOLEAN DEFAULT FALSE,
                remote_file_path VARCHAR(512),
                FOREIGN KEY (user_id) REFERENCES login_details(id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS template_columns (
                column_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_id BIGINT NOT NULL,
                column_name VARCHAR(255) NOT NULL,
                column_position INT NOT NULL,
                is_validation_enabled BOOLEAN DEFAULT FALSE,
                is_selected BOOLEAN DEFAULT FALSE,
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE,
                UNIQUE (template_id, column_name)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_rule_types (
                rule_type_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                rule_name VARCHAR(255) NOT NULL,
                description TEXT,
                parameters TEXT,
                is_active BOOLEAN DEFAULT TRUE,
                is_custom BOOLEAN DEFAULT FALSE,
                column_name VARCHAR(255),
                template_id BIGINT,
                data_type VARCHAR(50),
                source_format VARCHAR(50),
                target_format VARCHAR(50),
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS column_validation_rules (
                column_validation_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                column_id BIGINT NOT NULL,
                rule_type_id BIGINT NOT NULL,
                rule_config JSON,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (column_id) REFERENCES template_columns(column_id) ON DELETE CASCADE,
                FOREIGN KEY (rule_type_id) REFERENCES validation_rule_types(rule_type_id) ON DELETE RESTRICT,
                UNIQUE (column_id, rule_type_id)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_history (
                history_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_id BIGINT NOT NULL,
                template_name VARCHAR(255) NOT NULL,
                error_count INT NOT NULL,
                corrected_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                corrected_file_path VARCHAR(512) NOT NULL,
                user_id INT NOT NULL,
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE,
                FOREIGN KEY (user_id) REFERENCES login_details(id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_corrections (
                correction_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                history_id BIGINT NOT NULL,
                row_index INT NOT NULL,
                column_name VARCHAR(255) NOT NULL,
                original_value TEXT,
                corrected_value TEXT,
                rule_failed VARCHAR(255) DEFAULT NULL,
                FOREIGN KEY (history_id) REFERENCES validation_history(history_id) ON DELETE CASCADE
            )
            """
        ]
        for table_sql in tables:
            cursor.execute(table_sql)
        
        # Add missing columns if they don't exist
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'source_format'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN source_format VARCHAR(50)")
            logging.info("Added source_format column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'target_format'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN target_format VARCHAR(50)")
            logging.info("Added target_format column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'data_type'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN data_type VARCHAR(50)")
            logging.info("Added data_type column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM excel_templates LIKE 'remote_file_path'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE excel_templates ADD COLUMN remote_file_path VARCHAR(512)")
            logging.info("Added remote_file_path column to excel_templates table")
            
        cursor.execute("SHOW COLUMNS FROM template_columns LIKE 'is_selected'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE template_columns ADD COLUMN is_selected BOOLEAN DEFAULT FALSE")
            logging.info("Added is_selected column to template_columns table")
            
        conn.commit()
        cursor.close()
        logging.info("Database tables initialized")
    except Exception as e:
        logging.error(f"Failed to initialize database: {str(e)}")
        raise

def create_admin_user():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        admin_password = bcrypt.hashpw('admin'.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
        cursor.execute("""
            INSERT IGNORE INTO login_details (first_name, last_name, email, mobile, password)
            VALUES (%s, %s, %s, %s, %s)
        """, ('Admin', 'User', 'admin@example.com', '1234567890', admin_password))
        conn.commit()
        cursor.close()
        logging.info("Admin user created or already exists")
    except Exception as e:
        logging.error(f"Failed to create admin user: {str(e)}")
        raise

def create_default_validation_rules():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        default_rules = [
            ("Required", "Ensures the field is not null", '{"allow_null": false}', None, None, None),
            ("Int", "Validates integer format", '{"format": "integer"}', None, None, "Int"),
            ("Float", "Validates number format (integer or decimal)", '{"format": "float"}', None, None, "Float"),
            ("Text", "Allows text with quotes and parentheses", '{"allow_special": false}', None, None, "Text"),
            ("Email", "Validates email format", '{"regex": "^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\\\.[a-zA-Z0-9-.]+$"}', None, None, "Email"),
            ("Date(DD-MM-YYYY)", "Validates date format DD-MM-YYYY", '{"format": "%d-%m-%Y"}', "DD-MM-YYYY", None, "Date"),
            ("Boolean", "Validates boolean format (true/false or 0/1)", '{"format": "boolean"}', None, None, "Boolean"),
            ("Alphanumeric", "Validates alphanumeric format", '{"format": "alphanumeric"}', None, None, "Alphanumeric")
        ]
        cursor.executemany("""
            INSERT IGNORE INTO validation_rule_types (rule_name, description, parameters, is_custom, source_format, target_format, data_type)
            VALUES (%s, %s, %s, %s, %s, %s, %s)
        """, [(name, desc, params, False, source, target, dtype) for name, desc, params, source, target, dtype in default_rules])
        conn.commit()
        cursor.close()
        logging.info("Default validation rules ensured successfully")
    except Exception as e:
        logging.error(f"Failed to ensure default validation rules: {str(e)}")
        raise

if __name__ == '__main__':
    try:
        # Create the application using factory pattern
        app = create_app()
        
        # Initialize database and default data within app context
        with app.app_context():
            initialize_app_data()
        
        # Get port from environment or use default
        port = int(os.getenv('PORT', 5000))
        
        # Start the application server
        logging.info("Starting Flask server...")
        app.run(debug=True, host='0.0.0.0', port=port)
        
    except Exception as e:
        logging.error(f"Failed to start application: {e}")
        raise
).any():
        return "Email"

def create_app():
    """Application factory pattern for different environments"""
    # Set the path to the frontend dist folder
    current_dir = os.path.dirname(os.path.abspath(__file__))
    frontend_dist_path = os.path.join(current_dir, '..', '..', 'Keansa-Ai-Suite2025may-frontend11', 'dist')
    frontend_dist_path = os.path.abspath(frontend_dist_path)
    
    # Create Flask application instance
    app = Flask(__name__, static_folder=frontend_dist_path, static_url_path='')
    CORS(app, supports_credentials=True, origins=["http://localhost:3000", "http://localhost:8080", "http://localhost:5000", "*"])

    app.secret_key = os.urandom(24).hex()
    app.config['SESSION_TYPE'] = 'filesystem'
    app.config['SESSION_FILE_DIR'] = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'sessions')
    app.config['SESSION_COOKIE_SAMESITE'] = 'Lax'
    app.config['SESSION_COOKIE_HTTPONLY'] = True
    app.config['SESSION_COOKIE_SECURE'] = False
    app.config['PERMANENT_SESSION_LIFETIME'] = 86400  # 24 hours
    app.config['UPLOAD_FOLDER'] = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'uploads')
    Session(app)

    # Ensure directories exist
    try:
        os.makedirs(app.config['UPLOAD_FOLDER'], exist_ok=True)
        os.makedirs(app.config['SESSION_FILE_DIR'], exist_ok=True)
    except OSError as e:
        logging.error(f"Failed to create directories: {e}")

    # Register cleanup handlers
    app.teardown_appcontext(close_db)
    
    # Register all routes directly in create_app
    
    # Static file serving for React frontend
    @app.route('/', defaults={'path': ''})
    @app.route('/<path:path>')
    def serve(path):
        if path and os.path.exists(os.path.join(app.static_folder, path)):
            return app.send_static_file(path)
        return app.send_static_file('index.html')

    # Health check endpoint
    @app.route('/health', methods=['GET'])
    def health_check():
        return jsonify({
            'status': 'healthy',
            'timestamp': datetime.now().isoformat(),
            'version': '2.0.0'
        })

    # Authentication endpoint - both old and new paths
    @app.route('/authenticate', methods=['POST'])
    @app.route('/api/auth/authenticate', methods=['POST'])
    def authenticate():
        try:
            email = request.form.get('username') or request.form.get('email')
            password = request.form.get('password')
            logging.debug(f"Login attempt: email={email}, password={'*' * len(password) if password else 'None'}")
            
            if not email or not password:
                logging.warning(f"Login failed: Email or password missing")
                return jsonify({'success': False, 'message': 'Email and password are required'}), 400

            # Check for admin login
            if email == "admin" and password == "admin":
                session['loggedin'] = True
                session['user_email'] = "admin@example.com"
                session['user_id'] = 1
                session.permanent = True
                logging.info(f"Admin login successful. Session: {dict(session)}")
                return jsonify({'success': True, 'message': 'Login successful', 'user': {'email': 'admin@example.com', 'id': 1}}), 200

            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("SELECT * FROM login_details WHERE LOWER(email) = LOWER(%s)", (email.lower(),))
            account = cursor.fetchone()
            cursor.close()
            
            if account:
                if bcrypt.checkpw(password.encode('utf-8'), account['password'].encode('utf-8')):
                    session['loggedin'] = True
                    session['user_email'] = account['email']
                    session['user_id'] = account['id']
                    session.permanent = True
                    logging.info(f"User {email} logged in successfully. Session: {dict(session)}")
                    return jsonify({
                        'success': True,
                        'message': 'Login successful',
                        'user': {'email': account['email'], 'id': account['id']}
                    }), 200
                else:
                    logging.warning(f"Invalid password for {email}")
                    return jsonify({'success': False, 'message': 'Invalid credentials'}), 401
            else:
                logging.warning(f"Email {email} not found")
                return jsonify({'success': False, 'message': 'Invalid credentials'}), 401
        except Exception as e:
            logging.error(f"Unexpected error during login: {str(e)}")
            return jsonify({'success': False, 'message': f'Unexpected error: {str(e)}'}), 500

    @app.route('/check-auth', methods=['GET'])
    @app.route('/api/auth/check-auth', methods=['GET'])
    def check_auth():
        try:
            logging.debug(f"Checking auth with session: {dict(session)}")
            if 'loggedin' in session and 'user_id' in session:
                conn = get_db_connection()
                cursor = conn.cursor(dictionary=True)
                cursor.execute("SELECT email, first_name FROM login_details WHERE id = %s", (session['user_id'],))
                user = cursor.fetchone()
                cursor.close()
                if user:
                    logging.info(f"User {session.get('user_email')} is authenticated")
                    return jsonify({
                        'success': True,
                        'user': {
                            'email': user['email'],
                            'id': session['user_id'],
                            'first_name': user['first_name']
                        }
                    })
                else:
                    logging.warning("User not found in database")  
                    session.clear()
                    return jsonify({'success': False, 'message': 'User not found'}), 401
            logging.warning("User not authenticated")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        except Exception as e:
            logging.error(f"Error in check-auth endpoint: {str(e)}")
            return jsonify({'success': False, 'message': f'Server error: {str(e)}'}), 500

    @app.route('/register', methods=['POST'])
    @app.route('/api/auth/register', methods=['POST'])
    def register():
        first_name = request.form.get('first_name')
        last_name = request.form.get('last_name')
        email = request.form.get('email')
        mobile = request.form.get('mobile')
        password = request.form.get('password')
        confirm_password = request.form.get('confirm_password')

        if not all([first_name, last_name, email, mobile, password, confirm_password]):
            return jsonify({'success': False, 'message': 'All fields are required'}), 400
        if password != confirm_password:
            return jsonify({'success': False, 'message': 'Passwords do not match'}), 400

        hashed_password = bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
        try:
            conn = get_db_connection()
            cursor = conn.cursor()
            cursor.execute("""
                INSERT INTO login_details (first_name, last_name, email, mobile, password)
                VALUES (%s, %s, %s, %s, %s)
            """, (first_name, last_name, email, mobile, hashed_password))
            user_id = cursor.lastrowid
            conn.commit()
            cursor.close()
            session['loggedin'] = True
            session['user_email'] = email
            session['user_id'] = user_id
            return jsonify({
                'success': True,
                'message': 'Registration successful',
                'user': {'email': email, 'id': user_id}
            }), 200
        except mysql.connector.Error as e:
            logging.error(f"Database error during registration: {str(e)}")
            return jsonify({'success': False, 'message': f'Registration error: {str(e)}'}), 500

    @app.route('/logout', methods=['POST'])
    @app.route('/api/auth/logout', methods=['POST'])
    def logout():
        logging.info(f"User {session.get('user_email', 'unknown')} logged out")
        session.clear()
        return jsonify({'success': True, 'message': 'Logged out successfully'})

    # Template routes
    @app.route('/templates', methods=['GET'])
    @app.route('/api/templates', methods=['GET'])
    def get_templates():
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /templates: session missing")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("""
                SELECT template_id, template_name, created_at, status
                FROM excel_templates
                WHERE user_id = %s AND status = 'ACTIVE'
                ORDER BY created_at DESC
                LIMIT 100
            """, (session['user_id'],))
            templates = cursor.fetchall()
            cursor.close()
            logging.info(f"Fetched {len(templates)} templates for user {session['user_id']}")
            return jsonify({'success': True, 'templates': templates})
        except mysql.connector.Error as e:
            logging.error(f'Error fetching templates: {str(e)}')
            return jsonify({'success': False, 'message': f'Error fetching templates: {str(e)}'}), 500
        except Exception as e:
            logging.error(f'Unexpected error fetching templates: {str(e)}')
            return jsonify({'success': False, 'message': f'Unexpected error: {str(e)}'}), 500

    # Rule Configuration routes
    @app.route('/rule-configurations', methods=['GET'])
    @app.route('/api/validation/rule-configurations', methods=['GET'])
    def get_rule_configurations():
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning(f"Unauthorized access to /rule-configurations: session={dict(session)}")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            user_id = session['user_id']
            logging.debug(f"Fetching rule configurations for user_id: {user_id}")

            # Main query to fetch templates with configured rules
            cursor.execute("""
                SELECT 
                    t.template_id, 
                    t.template_name, 
                    t.created_at, 
                    COUNT(cvr.column_validation_id) as rule_count
                FROM excel_templates t
                LEFT JOIN template_columns tc ON t.template_id = tc.template_id
                LEFT JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                WHERE t.user_id = %s AND t.status = 'ACTIVE' AND t.is_corrected = FALSE
                GROUP BY t.template_id, t.template_name, t.created_at
                HAVING rule_count > 0
                ORDER BY t.created_at DESC
                LIMIT 100
            """, (user_id,))
            templates = cursor.fetchall()
            logging.debug(f"Fetched rule-configured templates: {templates}")

            cursor.close()

            if not templates:
                logging.info(f"No templates with rules found for user_id: {user_id}")
            else:
                logging.info(f"Found {len(templates)} templates with rules for user_id: {user_id}")

            return jsonify({'success': True, 'templates': templates})
        except mysql.connector.Error as e:
            logging.error(f"Database error fetching rule configurations: {str(e)}")
            return jsonify({'success': False, 'message': f"Database error: {str(e)}"}), 500
        except Exception as e:
            logging.error(f"Unexpected error fetching rule configurations: {str(e)}")
            return jsonify({'success': False, 'message': f"Unexpected error: {str(e)}"}), 500

    # File upload route
    @app.route('/upload', methods=['POST'])
    @app.route('/api/templates/upload', methods=['POST'])
    @app.route('/api/upload', methods=['POST'])  # Additional common path
    def upload():
        logging.info(f"Upload endpoint called: {request.endpoint}, method: {request.method}")
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /upload: session missing")
            return jsonify({'error': 'Not logged in'}), 401
        if 'file' not in request.files:
            logging.warning("No file provided in upload request")
            return jsonify({'error': 'No file uploaded'}), 400
        file = request.files['file']
        if file.filename == '':
            logging.warning("No file selected in upload request")
            return jsonify({'error': 'No file selected'}), 400
        
        file_path = os.path.join(app.config['UPLOAD_FOLDER'], file.filename)
        try:
            file.save(file_path)
            logging.info(f"File saved: {file_path}")
        except Exception as e:
            logging.error(f"Failed to save file {file.filename}: {str(e)}")
            return jsonify({'error': f'Failed to save file: {str(e)}'}), 500

        try:
            # Read the file to get sheets and headers
            if file.filename.endswith('.xlsx') or file.filename.endswith('.xls'):
                xl = pd.ExcelFile(file_path)
                sheets = {sheet_name: pd.read_excel(file_path, sheet_name=sheet_name, header=None) 
                         for sheet_name in xl.sheet_names}
            elif file.filename.endswith(('.txt', '.csv', '.dat')):
                df = pd.read_csv(file_path, header=None, encoding='utf-8')
                sheets = {'Sheet1': df}
            else:
                logging.error("Unsupported file type")
                return jsonify({'error': 'Unsupported file type'}), 400
            
            logging.debug(f"Sheets extracted: {list(sheets.keys())}")
        except Exception as e:
            logging.error(f"Failed to read file {file_path}: {str(e)}")
            return jsonify({'error': f'Failed to read file: {str(e)}'}), 400

        try:
            sheet_names = list(sheets.keys())
            if not sheet_names:
                logging.error("No sheets found in the file")
                return jsonify({'error': 'No sheets found in the file'}), 400
            sheet_name = sheet_names[0]
            df = sheets[sheet_name]
            
            # Find header row
            header_row = 0
            for i in range(min(len(df), 10)):
                row = df.iloc[i].dropna()
                if not row.empty and all(isinstance(x, str) for x in row if pd.notna(x)):
                    header_row = i
                    break
                    
            headers = df.iloc[header_row].tolist()
            logging.debug(f"Headers extracted: {headers}")
            
            if not headers or all(not h for h in headers):
                logging.error("No valid headers found in file")
                return jsonify({'error': 'No valid headers found in the file'}), 400
        except Exception as e:
            logging.error(f"Error processing file {file.filename}: {str(e)}")
            return jsonify({'error': f'Error processing file: {str(e)}'}), 400

        # Clear existing session data
        for key in ['df', 'header_row', 'headers', 'sheet_name', 'current_step', 'selected_headers', 'validations', 'error_cell_locations', 'data_rows', 'corrected_file_path']:
            session.pop(key, None)

        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)

            # Check if template exists
            cursor.execute("""
                SELECT template_id, headers, sheet_name
                FROM excel_templates
                WHERE template_name = %s AND user_id = %s AND status = 'ACTIVE'
                ORDER BY created_at DESC
            """, (file.filename, session['user_id']))
            existing_templates = cursor.fetchall()
            logging.info(f"Found {len(existing_templates)} existing templates with name {file.filename}")

            template_id = None
            has_existing_rules = False
            validations = {}
            selected_headers = []

            # Check for matching template
            matching_template = None
            for template in existing_templates:
                stored_headers = json.loads(template['headers']) if template['headers'] else []
                stored_sheet_name = template['sheet_name']
                if stored_headers == headers and stored_sheet_name == sheet_name:
                    matching_template = template
                    break

            if matching_template:
                template_id = matching_template['template_id']
                # Check for existing rules
                cursor.execute("""
                    SELECT tc.column_name, vrt.rule_name
                    FROM template_columns tc
                    JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                    JOIN validation_rule_types vrt ON cvr.rule_type_id = vrt.rule_type_id
                    WHERE tc.template_id = %s AND tc.is_selected = TRUE
                """, (template_id,))
                rules_data = cursor.fetchall()
                for row in rules_data:
                    column_name = row['column_name']
                    rule_name = row['rule_name']
                    if column_name not in validations:
                        validations[column_name] = []
                    validations[column_name].append(rule_name)
                    if column_name not in selected_headers:
                        selected_headers.append(column_name)
                has_existing_rules = len(validations) > 0
            else:
                # New template
                cursor.execute("""
                    INSERT INTO excel_templates (template_name, user_id, sheet_name, headers, is_corrected)
                    VALUES (%s, %s, %s, %s, %s)
                """, (file.filename, session['user_id'], sheet_name, json.dumps(headers), False))
                template_id = cursor.lastrowid
                column_data = [(template_id, header, i + 1, False) for i, header in enumerate(headers)]
                cursor.executemany("""
                    INSERT INTO template_columns (template_id, column_name, column_position, is_selected)
                    VALUES (%s, %s, %s, %s)
                """, column_data)

            conn.commit()
            cursor.close()

            # Store session data
            session['file_path'] = file_path
            session['template_id'] = template_id
            session['df'] = df.to_json()
            session['header_row'] = header_row
            session['headers'] = headers
            session['sheet_name'] = sheet_name
            session['current_step'] = 1 if not has_existing_rules else 3
            session['validations'] = validations
            session['selected_headers'] = selected_headers
            session['has_existing_rules'] = has_existing_rules

            logging.info(f"Upload processed: template_id={template_id}, filename={file.filename}, has_existing_rules={has_existing_rules}")

            return jsonify({
                'success': True,
                'sheets': {sheet_name: {'headers': headers}},
                'file_name': file.filename,
                'template_id': template_id,
                'has_existing_rules': has_existing_rules,
                'sheet_name': sheet_name,
                'skip_to_step_3': has_existing_rules
            })
        except mysql.connector.Error as e:
            logging.error(f'Error saving template: {str(e)}')
            return jsonify({'error': f'Error saving template: {str(e)}'}), 500
        except Exception as e:
            logging.error(f'Unexpected error saving template: {str(e)}')
            return jsonify({'error': f'Unexpected error: {str(e)}'}), 500

    # Multi-step workflow endpoints
    @app.route('/step/1', methods=['GET', 'POST'])
    @app.route('/api/step/1', methods=['GET', 'POST'])
    def step_one():
        if 'loggedin' not in session:
            return jsonify({'error': 'Not logged in'}), 401
        
        if request.method == 'POST':
            try:
                headers = request.form.getlist('headers')
                new_header_row = request.form.get('new_header_row')
                logging.debug(f"Step 1 submitted: headers={headers}, new_header_row={new_header_row}")
                
                if not headers:
                    logging.error("No headers provided in step 1")
                    return jsonify({'success': False, 'message': 'No headers provided'}), 400
                    
                if 'template_id' not in session:
                    logging.error("Session missing template_id")
                    return jsonify({'success': False, 'message': 'Session data missing'}), 400

                template_id = session['template_id']
                
                # Get the dataframe from session for auto-detection
                df_json = session.get('df')
                if df_json:
                    df = pd.read_json(StringIO(df_json))
                    session_headers = session.get('headers', [])
                    df.columns = session_headers
                    header_row = session.get('header_row', 0)
                    df = df.iloc[header_row + 1:].reset_index(drop=True)
                    
                    # Auto-detect rules for selected headers
                    validations = assign_default_rules_to_columns(df, headers)
                    session['validations'] = validations
                    logging.debug(f"Auto-assigned rules: {validations}")
                else:
                    validations = {}

                session['selected_headers'] = headers
                session['current_step'] = 2

                # Mark selected headers in the database
                conn = get_db_connection()
                cursor = conn.cursor()
                cursor.execute("UPDATE template_columns SET is_selected = FALSE WHERE template_id = %s", (template_id,))
                for header in headers:
                    cursor.execute("""
                        UPDATE template_columns
                        SET is_selected = TRUE
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    
                    # Get column_id and add auto-detected rules
                    cursor.execute("""
                        SELECT column_id FROM template_columns
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    result = cursor.fetchone()
                    if result:
                        column_id = result[0]
                        for rule_name in validations.get(header, []):
                            cursor.execute("""
                                SELECT rule_type_id FROM validation_rule_types
                                WHERE rule_name = %s AND is_custom = FALSE
                            """, (rule_name,))
                            rule_result = cursor.fetchone()
                            if rule_result:
                                rule_type_id = rule_result[0]
                                cursor.execute("""
                                    INSERT IGNORE INTO column_validation_rules (column_id, rule_type_id, rule_config)
                                    VALUES (%s, %s, %s)
                                """, (column_id, rule_type_id, '{}'))
                
                conn.commit()
                cursor.close()

                logging.info(f"Step 1 completed: headers={headers}, auto-assigned rules={validations}")
                return jsonify({'success': True, 'headers': headers, 'validations': validations})
            except Exception as e:
                logging.error(f"Error in step 1: {str(e)}")
                return jsonify({'success': False, 'message': str(e)}), 500
        
        # GET request - return current headers
        headers = session.get('headers', [])
        return jsonify({'headers': headers})

    @app.route('/step/2', methods=['GET', 'POST'])
    @app.route('/api/step/2', methods=['GET', 'POST'])
    def step_two():
        if 'loggedin' not in session:
            return jsonify({'error': 'Not logged in'}), 401
            
        if request.method == 'POST':
            try:
                action = request.form.get('action', 'save')
                validations = {}
                for key, values in request.form.lists():
                    if key.startswith('validations_'):
                        header = key.replace('validations_', '')
                        validations[header] = values
                        
                logging.debug(f"Step 2 submitted: action={action}, validations={validations}")
                
                template_id = session.get('template_id')
                if not template_id:
                    return jsonify({'success': False, 'message': 'Session data missing'}), 400

                # Save validations to database
                conn = get_db_connection()
                cursor = conn.cursor()
                
                # Clear existing rules
                cursor.execute("""
                    DELETE FROM column_validation_rules
                    WHERE column_id IN (
                        SELECT column_id FROM template_columns WHERE template_id = %s
                    )
                """, (template_id,))
                
                # Add new rules
                for header, rules in validations.items():
                    cursor.execute("""
                        SELECT column_id FROM template_columns
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    result = cursor.fetchone()
                    if not result:
                        continue
                    column_id = result[0]
                    
                    for rule_name in rules:
                        cursor.execute("""
                            SELECT rule_type_id FROM validation_rule_types
                            WHERE rule_name = %s
                        """, (rule_name,))
                        result = cursor.fetchone()
                        if result:
                            rule_type_id = result[0]
                            cursor.execute("""
                                INSERT IGNORE INTO column_validation_rules (column_id, rule_type_id, rule_config)
                                VALUES (%s, %s, %s)
                            """, (column_id, rule_type_id, '{}'))
                
                conn.commit()
                cursor.close()

                session['validations'] = validations
                session['current_step'] = 3 if action == 'review' else 2
                
                logging.info(f"Step 2 completed: action={action}, validations={validations}")
                return jsonify({'success': True, 'message': 'Step 2 completed successfully'})
            except Exception as e:
                logging.error(f"Error in step 2: {str(e)}")
                return jsonify({'success': False, 'message': str(e)}), 500
        
        # GET request
        selected_headers = session.get('selected_headers', [])
        return jsonify({'selected_headers': selected_headers})

    # Rules endpoint
    @app.route('/rules', methods=['GET'])
    @app.route('/api/rules', methods=['GET'])
    def get_rules():
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            
            cursor.execute("""
                SELECT rule_type_id AS rule_id, rule_name, description, parameters, is_custom, 
                       column_name, template_id, source_format, target_format, data_type, is_active
                FROM validation_rule_types
            """)
            rules = cursor.fetchall()
            cursor.close()
            
            logging.info(f"Returning {len(rules)} rules from getRules endpoint")
            return jsonify({'success': True, 'rules': rules})
        except mysql.connector.Error as e:
            logging.error(f"Database error fetching rules: {str(e)}")
            return jsonify({'success': False, 'message': str(e)}), 500
        except Exception as e:
            logging.error(f"Unexpected error fetching rules: {str(e)}")
            return jsonify({'success': False, 'message': str(e)}), 500

    # Template details endpoint
    @app.route('/template/<int:template_id>/<sheet_name>', methods=['GET'])
    @app.route('/api/template/<int:template_id>/<sheet_name>', methods=['GET'])
    def get_template(template_id, sheet_name):
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /template: session missing")
            return jsonify({'error': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("""
                SELECT template_name, sheet_name, headers
                FROM excel_templates
                WHERE template_id = %s AND user_id = %s AND status = 'ACTIVE'
            """, (template_id, session['user_id']))
            template_record = cursor.fetchone()
            
            if not template_record:
                logging.error(f"Template not found for template_id: {template_id}, user_id: {session['user_id']}")
                cursor.close()
                return jsonify({'error': 'Template not found'}), 404

            headers = json.loads(template_record['headers']) if template_record['headers'] else []
            stored_sheet_name = template_record['sheet_name'] or sheet_name
            file_path = os.path.join(app.config['UPLOAD_FOLDER'], template_record['template_name'])
            
            cursor.execute("""
                SELECT COUNT(*) as rule_count
                FROM template_columns tc
                JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                WHERE tc.template_id = %s AND tc.is_selected = TRUE
            """, (template_id,))
            rule_count = cursor.fetchone()['rule_count']
            has_existing_rules = rule_count > 0
            
            cursor.close()
            
            return jsonify({
                'success': True,
                'sheets': {stored_sheet_name: {'headers': headers}},
                'file_name': template_record['template_name'],
                'file_path': file_path,
                'sheet_name': stored_sheet_name,
                'has_existing_rules': has_existing_rules
            })
        except mysql.connector.Error as e:
            logging.error(f"Database error in get_template: {str(e)}")
            return jsonify({'error': f'Database error: {str(e)}'}), 500
        except Exception as e:
            logging.error(f"Unexpected error in get_template: {str(e)}")
            return jsonify({'error': f'Unexpected error: {str(e)}'}), 500

    # Debug route to show all registered routes
    @app.route('/debug/routes', methods=['GET'])
    def list_routes():
        routes = []
        for rule in app.url_map.iter_rules():
            routes.append({
                'endpoint': rule.endpoint,
                'methods': list(rule.methods),
                'rule': rule.rule
            })
        return jsonify(routes)

    # 404 handler to debug missing routes
    @app.errorhandler(404)
    def not_found_handler(error):
        logging.error(f"404 Error: {request.method} {request.url} not found")
        logging.error(f"Available routes: {[rule.rule for rule in app.url_map.iter_rules()]}")
        return jsonify({
            'error': 'Endpoint not found', 
            'method': request.method,
            'url': request.url,
            'path': request.path
        }), 404

    return app

def initialize_app_data():
    """Initialize database and create default data"""
    try:
        logging.info("Initializing database schema...")
        init_db()
        
        logging.info("Creating admin user...")
        create_admin_user()
        
        logging.info("Creating default validation rules...")
        create_default_validation_rules()
        
        logging.info("Application initialization completed successfully")
    except Exception as e:
        logging.error(f"Failed to initialize application: {e}")
        raise

DB_CONFIG = {
    'host': os.getenv('MYSQL_HOST', 'localhost'),
    'user': os.getenv('MYSQL_USER', 'root'),
    'password': os.getenv('MYSQL_PASSWORD', 'Keansa@2024'),
    'database': os.getenv('MYSQL_DATABASE', 'data_validation_2'),
}

def get_db_connection():
    if 'db' not in g:
        try:
            conn = mysql.connector.connect(
                host=DB_CONFIG['host'],
                user=DB_CONFIG['user'],
                password=DB_CONFIG['password']
            )
            cursor = conn.cursor()
            cursor.execute(f"CREATE DATABASE IF NOT EXISTS {DB_CONFIG['database']}")
            cursor.close()
            conn.close()
            g.db = mysql.connector.connect(**DB_CONFIG)
            logging.info("Database connection established successfully")
        except mysql.connector.Error as err:
            if err.errno == errorcode.ER_ACCESS_DENIED_ERROR:
                logging.error("Database connection failed: Access denied for user - check username/password")
            elif err.errno == errorcode.ER_BAD_DB_ERROR:
                logging.error("Database connection failed: Database does not exist")
            else:
                logging.error(f"Database connection failed: {err}")
            raise Exception(f"Failed to connect to database: {str(err)}")
    return g.db

def close_db(error):
    db = g.pop('db', None)
    if db is not None:
        db.close()

def init_db():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        tables = [
            """
            CREATE TABLE IF NOT EXISTS login_details (
                id INT AUTO_INCREMENT PRIMARY KEY,
                first_name VARCHAR(100),
                last_name VARCHAR(100),
                email VARCHAR(255) UNIQUE,
                mobile VARCHAR(10),
                password VARCHAR(255)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS excel_templates (
                template_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_name VARCHAR(255) NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
                user_id INT NOT NULL,
                sheet_name VARCHAR(255),
                headers JSON,
                status ENUM('ACTIVE', 'INACTIVE') DEFAULT 'ACTIVE',
                is_corrected BOOLEAN DEFAULT FALSE,
                remote_file_path VARCHAR(512),
                FOREIGN KEY (user_id) REFERENCES login_details(id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS template_columns (
                column_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_id BIGINT NOT NULL,
                column_name VARCHAR(255) NOT NULL,
                column_position INT NOT NULL,
                is_validation_enabled BOOLEAN DEFAULT FALSE,
                is_selected BOOLEAN DEFAULT FALSE,
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE,
                UNIQUE (template_id, column_name)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_rule_types (
                rule_type_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                rule_name VARCHAR(255) NOT NULL,
                description TEXT,
                parameters TEXT,
                is_active BOOLEAN DEFAULT TRUE,
                is_custom BOOLEAN DEFAULT FALSE,
                column_name VARCHAR(255),
                template_id BIGINT,
                data_type VARCHAR(50),
                source_format VARCHAR(50),
                target_format VARCHAR(50),
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS column_validation_rules (
                column_validation_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                column_id BIGINT NOT NULL,
                rule_type_id BIGINT NOT NULL,
                rule_config JSON,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (column_id) REFERENCES template_columns(column_id) ON DELETE CASCADE,
                FOREIGN KEY (rule_type_id) REFERENCES validation_rule_types(rule_type_id) ON DELETE RESTRICT,
                UNIQUE (column_id, rule_type_id)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_history (
                history_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_id BIGINT NOT NULL,
                template_name VARCHAR(255) NOT NULL,
                error_count INT NOT NULL,
                corrected_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                corrected_file_path VARCHAR(512) NOT NULL,
                user_id INT NOT NULL,
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE,
                FOREIGN KEY (user_id) REFERENCES login_details(id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_corrections (
                correction_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                history_id BIGINT NOT NULL,
                row_index INT NOT NULL,
                column_name VARCHAR(255) NOT NULL,
                original_value TEXT,
                corrected_value TEXT,
                rule_failed VARCHAR(255) DEFAULT NULL,
                FOREIGN KEY (history_id) REFERENCES validation_history(history_id) ON DELETE CASCADE
            )
            """
        ]
        for table_sql in tables:
            cursor.execute(table_sql)
        
        # Add missing columns if they don't exist
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'source_format'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN source_format VARCHAR(50)")
            logging.info("Added source_format column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'target_format'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN target_format VARCHAR(50)")
            logging.info("Added target_format column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'data_type'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN data_type VARCHAR(50)")
            logging.info("Added data_type column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM excel_templates LIKE 'remote_file_path'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE excel_templates ADD COLUMN remote_file_path VARCHAR(512)")
            logging.info("Added remote_file_path column to excel_templates table")
            
        cursor.execute("SHOW COLUMNS FROM template_columns LIKE 'is_selected'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE template_columns ADD COLUMN is_selected BOOLEAN DEFAULT FALSE")
            logging.info("Added is_selected column to template_columns table")
            
        conn.commit()
        cursor.close()
        logging.info("Database tables initialized")
    except Exception as e:
        logging.error(f"Failed to initialize database: {str(e)}")
        raise

def create_admin_user():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        admin_password = bcrypt.hashpw('admin'.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
        cursor.execute("""
            INSERT IGNORE INTO login_details (first_name, last_name, email, mobile, password)
            VALUES (%s, %s, %s, %s, %s)
        """, ('Admin', 'User', 'admin@example.com', '1234567890', admin_password))
        conn.commit()
        cursor.close()
        logging.info("Admin user created or already exists")
    except Exception as e:
        logging.error(f"Failed to create admin user: {str(e)}")
        raise

def create_default_validation_rules():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        default_rules = [
            ("Required", "Ensures the field is not null", '{"allow_null": false}', None, None, None),
            ("Int", "Validates integer format", '{"format": "integer"}', None, None, "Int"),
            ("Float", "Validates number format (integer or decimal)", '{"format": "float"}', None, None, "Float"),
            ("Text", "Allows text with quotes and parentheses", '{"allow_special": false}', None, None, "Text"),
            ("Email", "Validates email format", '{"regex": "^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\\\.[a-zA-Z0-9-.]+$"}', None, None, "Email"),
            ("Date(DD-MM-YYYY)", "Validates date format DD-MM-YYYY", '{"format": "%d-%m-%Y"}', "DD-MM-YYYY", None, "Date"),
            ("Boolean", "Validates boolean format (true/false or 0/1)", '{"format": "boolean"}', None, None, "Boolean"),
            ("Alphanumeric", "Validates alphanumeric format", '{"format": "alphanumeric"}', None, None, "Alphanumeric")
        ]
        cursor.executemany("""
            INSERT IGNORE INTO validation_rule_types (rule_name, description, parameters, is_custom, source_format, target_format, data_type)
            VALUES (%s, %s, %s, %s, %s, %s, %s)
        """, [(name, desc, params, False, source, target, dtype) for name, desc, params, source, target, dtype in default_rules])
        conn.commit()
        cursor.close()
        logging.info("Default validation rules ensured successfully")
    except Exception as e:
        logging.error(f"Failed to ensure default validation rules: {str(e)}")
        raise

if __name__ == '__main__':
    try:
        # Create the application using factory pattern
        app = create_app()
        
        # Initialize database and default data within app context
        with app.app_context():
            initialize_app_data()
        
        # Get port from environment or use default
        port = int(os.getenv('PORT', 5000))
        
        # Start the application server
        logging.info("Starting Flask server...")
        app.run(debug=True, host='0.0.0.0', port=port)
        
    except Exception as e:
        logging.error(f"Failed to start application: {e}")
        raise
).all():
        return "Email"
    
    # Date pattern detection
    try:
        pd.to_datetime(non_null, format="%d-%m-%Y")
        return "Date"
    except Exception:
        try:
            pd.to_datetime(non_null, format="%Y-%m-%d")
            return "Date"
        except Exception:
            pass
    
    # Boolean detection
    if non_null.str.lower().isin(['true', 'false', '0', '1']).all():
        return "Boolean"
    
    # Numeric detection
    if non_null.str.match(r'^-?\d+

def create_app():
    """Application factory pattern for different environments"""
    # Set the path to the frontend dist folder
    current_dir = os.path.dirname(os.path.abspath(__file__))
    frontend_dist_path = os.path.join(current_dir, '..', '..', 'Keansa-Ai-Suite2025may-frontend11', 'dist')
    frontend_dist_path = os.path.abspath(frontend_dist_path)
    
    # Create Flask application instance
    app = Flask(__name__, static_folder=frontend_dist_path, static_url_path='')
    CORS(app, supports_credentials=True, origins=["http://localhost:3000", "http://localhost:8080", "http://localhost:5000", "*"])

    app.secret_key = os.urandom(24).hex()
    app.config['SESSION_TYPE'] = 'filesystem'
    app.config['SESSION_FILE_DIR'] = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'sessions')
    app.config['SESSION_COOKIE_SAMESITE'] = 'Lax'
    app.config['SESSION_COOKIE_HTTPONLY'] = True
    app.config['SESSION_COOKIE_SECURE'] = False
    app.config['PERMANENT_SESSION_LIFETIME'] = 86400  # 24 hours
    app.config['UPLOAD_FOLDER'] = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'uploads')
    Session(app)

    # Ensure directories exist
    try:
        os.makedirs(app.config['UPLOAD_FOLDER'], exist_ok=True)
        os.makedirs(app.config['SESSION_FILE_DIR'], exist_ok=True)
    except OSError as e:
        logging.error(f"Failed to create directories: {e}")

    # Register cleanup handlers
    app.teardown_appcontext(close_db)
    
    # Register all routes directly in create_app
    
    # Static file serving for React frontend
    @app.route('/', defaults={'path': ''})
    @app.route('/<path:path>')
    def serve(path):
        if path and os.path.exists(os.path.join(app.static_folder, path)):
            return app.send_static_file(path)
        return app.send_static_file('index.html')

    # Health check endpoint
    @app.route('/health', methods=['GET'])
    def health_check():
        return jsonify({
            'status': 'healthy',
            'timestamp': datetime.now().isoformat(),
            'version': '2.0.0'
        })

    # Authentication endpoint - both old and new paths
    @app.route('/authenticate', methods=['POST'])
    @app.route('/api/auth/authenticate', methods=['POST'])
    def authenticate():
        try:
            email = request.form.get('username') or request.form.get('email')
            password = request.form.get('password')
            logging.debug(f"Login attempt: email={email}, password={'*' * len(password) if password else 'None'}")
            
            if not email or not password:
                logging.warning(f"Login failed: Email or password missing")
                return jsonify({'success': False, 'message': 'Email and password are required'}), 400

            # Check for admin login
            if email == "admin" and password == "admin":
                session['loggedin'] = True
                session['user_email'] = "admin@example.com"
                session['user_id'] = 1
                session.permanent = True
                logging.info(f"Admin login successful. Session: {dict(session)}")
                return jsonify({'success': True, 'message': 'Login successful', 'user': {'email': 'admin@example.com', 'id': 1}}), 200

            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("SELECT * FROM login_details WHERE LOWER(email) = LOWER(%s)", (email.lower(),))
            account = cursor.fetchone()
            cursor.close()
            
            if account:
                if bcrypt.checkpw(password.encode('utf-8'), account['password'].encode('utf-8')):
                    session['loggedin'] = True
                    session['user_email'] = account['email']
                    session['user_id'] = account['id']
                    session.permanent = True
                    logging.info(f"User {email} logged in successfully. Session: {dict(session)}")
                    return jsonify({
                        'success': True,
                        'message': 'Login successful',
                        'user': {'email': account['email'], 'id': account['id']}
                    }), 200
                else:
                    logging.warning(f"Invalid password for {email}")
                    return jsonify({'success': False, 'message': 'Invalid credentials'}), 401
            else:
                logging.warning(f"Email {email} not found")
                return jsonify({'success': False, 'message': 'Invalid credentials'}), 401
        except Exception as e:
            logging.error(f"Unexpected error during login: {str(e)}")
            return jsonify({'success': False, 'message': f'Unexpected error: {str(e)}'}), 500

    @app.route('/check-auth', methods=['GET'])
    @app.route('/api/auth/check-auth', methods=['GET'])
    def check_auth():
        try:
            logging.debug(f"Checking auth with session: {dict(session)}")
            if 'loggedin' in session and 'user_id' in session:
                conn = get_db_connection()
                cursor = conn.cursor(dictionary=True)
                cursor.execute("SELECT email, first_name FROM login_details WHERE id = %s", (session['user_id'],))
                user = cursor.fetchone()
                cursor.close()
                if user:
                    logging.info(f"User {session.get('user_email')} is authenticated")
                    return jsonify({
                        'success': True,
                        'user': {
                            'email': user['email'],
                            'id': session['user_id'],
                            'first_name': user['first_name']
                        }
                    })
                else:
                    logging.warning("User not found in database")  
                    session.clear()
                    return jsonify({'success': False, 'message': 'User not found'}), 401
            logging.warning("User not authenticated")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        except Exception as e:
            logging.error(f"Error in check-auth endpoint: {str(e)}")
            return jsonify({'success': False, 'message': f'Server error: {str(e)}'}), 500

    @app.route('/register', methods=['POST'])
    @app.route('/api/auth/register', methods=['POST'])
    def register():
        first_name = request.form.get('first_name')
        last_name = request.form.get('last_name')
        email = request.form.get('email')
        mobile = request.form.get('mobile')
        password = request.form.get('password')
        confirm_password = request.form.get('confirm_password')

        if not all([first_name, last_name, email, mobile, password, confirm_password]):
            return jsonify({'success': False, 'message': 'All fields are required'}), 400
        if password != confirm_password:
            return jsonify({'success': False, 'message': 'Passwords do not match'}), 400

        hashed_password = bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
        try:
            conn = get_db_connection()
            cursor = conn.cursor()
            cursor.execute("""
                INSERT INTO login_details (first_name, last_name, email, mobile, password)
                VALUES (%s, %s, %s, %s, %s)
            """, (first_name, last_name, email, mobile, hashed_password))
            user_id = cursor.lastrowid
            conn.commit()
            cursor.close()
            session['loggedin'] = True
            session['user_email'] = email
            session['user_id'] = user_id
            return jsonify({
                'success': True,
                'message': 'Registration successful',
                'user': {'email': email, 'id': user_id}
            }), 200
        except mysql.connector.Error as e:
            logging.error(f"Database error during registration: {str(e)}")
            return jsonify({'success': False, 'message': f'Registration error: {str(e)}'}), 500

    @app.route('/logout', methods=['POST'])
    @app.route('/api/auth/logout', methods=['POST'])
    def logout():
        logging.info(f"User {session.get('user_email', 'unknown')} logged out")
        session.clear()
        return jsonify({'success': True, 'message': 'Logged out successfully'})

    # Template routes
    @app.route('/templates', methods=['GET'])
    @app.route('/api/templates', methods=['GET'])
    def get_templates():
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /templates: session missing")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("""
                SELECT template_id, template_name, created_at, status
                FROM excel_templates
                WHERE user_id = %s AND status = 'ACTIVE'
                ORDER BY created_at DESC
                LIMIT 100
            """, (session['user_id'],))
            templates = cursor.fetchall()
            cursor.close()
            logging.info(f"Fetched {len(templates)} templates for user {session['user_id']}")
            return jsonify({'success': True, 'templates': templates})
        except mysql.connector.Error as e:
            logging.error(f'Error fetching templates: {str(e)}')
            return jsonify({'success': False, 'message': f'Error fetching templates: {str(e)}'}), 500
        except Exception as e:
            logging.error(f'Unexpected error fetching templates: {str(e)}')
            return jsonify({'success': False, 'message': f'Unexpected error: {str(e)}'}), 500

    # Rule Configuration routes
    @app.route('/rule-configurations', methods=['GET'])
    @app.route('/api/validation/rule-configurations', methods=['GET'])
    def get_rule_configurations():
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning(f"Unauthorized access to /rule-configurations: session={dict(session)}")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            user_id = session['user_id']
            logging.debug(f"Fetching rule configurations for user_id: {user_id}")

            # Main query to fetch templates with configured rules
            cursor.execute("""
                SELECT 
                    t.template_id, 
                    t.template_name, 
                    t.created_at, 
                    COUNT(cvr.column_validation_id) as rule_count
                FROM excel_templates t
                LEFT JOIN template_columns tc ON t.template_id = tc.template_id
                LEFT JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                WHERE t.user_id = %s AND t.status = 'ACTIVE' AND t.is_corrected = FALSE
                GROUP BY t.template_id, t.template_name, t.created_at
                HAVING rule_count > 0
                ORDER BY t.created_at DESC
                LIMIT 100
            """, (user_id,))
            templates = cursor.fetchall()
            logging.debug(f"Fetched rule-configured templates: {templates}")

            cursor.close()

            if not templates:
                logging.info(f"No templates with rules found for user_id: {user_id}")
            else:
                logging.info(f"Found {len(templates)} templates with rules for user_id: {user_id}")

            return jsonify({'success': True, 'templates': templates})
        except mysql.connector.Error as e:
            logging.error(f"Database error fetching rule configurations: {str(e)}")
            return jsonify({'success': False, 'message': f"Database error: {str(e)}"}), 500
        except Exception as e:
            logging.error(f"Unexpected error fetching rule configurations: {str(e)}")
            return jsonify({'success': False, 'message': f"Unexpected error: {str(e)}"}), 500

    # File upload route
    @app.route('/upload', methods=['POST'])
    @app.route('/api/templates/upload', methods=['POST'])
    @app.route('/api/upload', methods=['POST'])  # Additional common path
    def upload():
        logging.info(f"Upload endpoint called: {request.endpoint}, method: {request.method}")
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /upload: session missing")
            return jsonify({'error': 'Not logged in'}), 401
        if 'file' not in request.files:
            logging.warning("No file provided in upload request")
            return jsonify({'error': 'No file uploaded'}), 400
        file = request.files['file']
        if file.filename == '':
            logging.warning("No file selected in upload request")
            return jsonify({'error': 'No file selected'}), 400
        
        file_path = os.path.join(app.config['UPLOAD_FOLDER'], file.filename)
        try:
            file.save(file_path)
            logging.info(f"File saved: {file_path}")
        except Exception as e:
            logging.error(f"Failed to save file {file.filename}: {str(e)}")
            return jsonify({'error': f'Failed to save file: {str(e)}'}), 500

        try:
            # Read the file to get sheets and headers
            if file.filename.endswith('.xlsx') or file.filename.endswith('.xls'):
                xl = pd.ExcelFile(file_path)
                sheets = {sheet_name: pd.read_excel(file_path, sheet_name=sheet_name, header=None) 
                         for sheet_name in xl.sheet_names}
            elif file.filename.endswith(('.txt', '.csv', '.dat')):
                df = pd.read_csv(file_path, header=None, encoding='utf-8')
                sheets = {'Sheet1': df}
            else:
                logging.error("Unsupported file type")
                return jsonify({'error': 'Unsupported file type'}), 400
            
            logging.debug(f"Sheets extracted: {list(sheets.keys())}")
        except Exception as e:
            logging.error(f"Failed to read file {file_path}: {str(e)}")
            return jsonify({'error': f'Failed to read file: {str(e)}'}), 400

        try:
            sheet_names = list(sheets.keys())
            if not sheet_names:
                logging.error("No sheets found in the file")
                return jsonify({'error': 'No sheets found in the file'}), 400
            sheet_name = sheet_names[0]
            df = sheets[sheet_name]
            
            # Find header row
            header_row = 0
            for i in range(min(len(df), 10)):
                row = df.iloc[i].dropna()
                if not row.empty and all(isinstance(x, str) for x in row if pd.notna(x)):
                    header_row = i
                    break
                    
            headers = df.iloc[header_row].tolist()
            logging.debug(f"Headers extracted: {headers}")
            
            if not headers or all(not h for h in headers):
                logging.error("No valid headers found in file")
                return jsonify({'error': 'No valid headers found in the file'}), 400
        except Exception as e:
            logging.error(f"Error processing file {file.filename}: {str(e)}")
            return jsonify({'error': f'Error processing file: {str(e)}'}), 400

        # Clear existing session data
        for key in ['df', 'header_row', 'headers', 'sheet_name', 'current_step', 'selected_headers', 'validations', 'error_cell_locations', 'data_rows', 'corrected_file_path']:
            session.pop(key, None)

        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)

            # Check if template exists
            cursor.execute("""
                SELECT template_id, headers, sheet_name
                FROM excel_templates
                WHERE template_name = %s AND user_id = %s AND status = 'ACTIVE'
                ORDER BY created_at DESC
            """, (file.filename, session['user_id']))
            existing_templates = cursor.fetchall()
            logging.info(f"Found {len(existing_templates)} existing templates with name {file.filename}")

            template_id = None
            has_existing_rules = False
            validations = {}
            selected_headers = []

            # Check for matching template
            matching_template = None
            for template in existing_templates:
                stored_headers = json.loads(template['headers']) if template['headers'] else []
                stored_sheet_name = template['sheet_name']
                if stored_headers == headers and stored_sheet_name == sheet_name:
                    matching_template = template
                    break

            if matching_template:
                template_id = matching_template['template_id']
                # Check for existing rules
                cursor.execute("""
                    SELECT tc.column_name, vrt.rule_name
                    FROM template_columns tc
                    JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                    JOIN validation_rule_types vrt ON cvr.rule_type_id = vrt.rule_type_id
                    WHERE tc.template_id = %s AND tc.is_selected = TRUE
                """, (template_id,))
                rules_data = cursor.fetchall()
                for row in rules_data:
                    column_name = row['column_name']
                    rule_name = row['rule_name']
                    if column_name not in validations:
                        validations[column_name] = []
                    validations[column_name].append(rule_name)
                    if column_name not in selected_headers:
                        selected_headers.append(column_name)
                has_existing_rules = len(validations) > 0
            else:
                # New template
                cursor.execute("""
                    INSERT INTO excel_templates (template_name, user_id, sheet_name, headers, is_corrected)
                    VALUES (%s, %s, %s, %s, %s)
                """, (file.filename, session['user_id'], sheet_name, json.dumps(headers), False))
                template_id = cursor.lastrowid
                column_data = [(template_id, header, i + 1, False) for i, header in enumerate(headers)]
                cursor.executemany("""
                    INSERT INTO template_columns (template_id, column_name, column_position, is_selected)
                    VALUES (%s, %s, %s, %s)
                """, column_data)

            conn.commit()
            cursor.close()

            # Store session data
            session['file_path'] = file_path
            session['template_id'] = template_id
            session['df'] = df.to_json()
            session['header_row'] = header_row
            session['headers'] = headers
            session['sheet_name'] = sheet_name
            session['current_step'] = 1 if not has_existing_rules else 3
            session['validations'] = validations
            session['selected_headers'] = selected_headers
            session['has_existing_rules'] = has_existing_rules

            logging.info(f"Upload processed: template_id={template_id}, filename={file.filename}, has_existing_rules={has_existing_rules}")

            return jsonify({
                'success': True,
                'sheets': {sheet_name: {'headers': headers}},
                'file_name': file.filename,
                'template_id': template_id,
                'has_existing_rules': has_existing_rules,
                'sheet_name': sheet_name,
                'skip_to_step_3': has_existing_rules
            })
        except mysql.connector.Error as e:
            logging.error(f'Error saving template: {str(e)}')
            return jsonify({'error': f'Error saving template: {str(e)}'}), 500
        except Exception as e:
            logging.error(f'Unexpected error saving template: {str(e)}')
            return jsonify({'error': f'Unexpected error: {str(e)}'}), 500

    # Multi-step workflow endpoints
    @app.route('/step/1', methods=['GET', 'POST'])
    @app.route('/api/step/1', methods=['GET', 'POST'])
    def step_one():
        if 'loggedin' not in session:
            return jsonify({'error': 'Not logged in'}), 401
        
        if request.method == 'POST':
            try:
                headers = request.form.getlist('headers')
                new_header_row = request.form.get('new_header_row')
                logging.debug(f"Step 1 submitted: headers={headers}, new_header_row={new_header_row}")
                
                if not headers:
                    logging.error("No headers provided in step 1")
                    return jsonify({'success': False, 'message': 'No headers provided'}), 400
                    
                if 'template_id' not in session:
                    logging.error("Session missing template_id")
                    return jsonify({'success': False, 'message': 'Session data missing'}), 400

                template_id = session['template_id']
                
                # Get the dataframe from session for auto-detection
                df_json = session.get('df')
                if df_json:
                    df = pd.read_json(StringIO(df_json))
                    session_headers = session.get('headers', [])
                    df.columns = session_headers
                    header_row = session.get('header_row', 0)
                    df = df.iloc[header_row + 1:].reset_index(drop=True)
                    
                    # Auto-detect rules for selected headers
                    validations = assign_default_rules_to_columns(df, headers)
                    session['validations'] = validations
                    logging.debug(f"Auto-assigned rules: {validations}")
                else:
                    validations = {}

                session['selected_headers'] = headers
                session['current_step'] = 2

                # Mark selected headers in the database
                conn = get_db_connection()
                cursor = conn.cursor()
                cursor.execute("UPDATE template_columns SET is_selected = FALSE WHERE template_id = %s", (template_id,))
                for header in headers:
                    cursor.execute("""
                        UPDATE template_columns
                        SET is_selected = TRUE
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    
                    # Get column_id and add auto-detected rules
                    cursor.execute("""
                        SELECT column_id FROM template_columns
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    result = cursor.fetchone()
                    if result:
                        column_id = result[0]
                        for rule_name in validations.get(header, []):
                            cursor.execute("""
                                SELECT rule_type_id FROM validation_rule_types
                                WHERE rule_name = %s AND is_custom = FALSE
                            """, (rule_name,))
                            rule_result = cursor.fetchone()
                            if rule_result:
                                rule_type_id = rule_result[0]
                                cursor.execute("""
                                    INSERT IGNORE INTO column_validation_rules (column_id, rule_type_id, rule_config)
                                    VALUES (%s, %s, %s)
                                """, (column_id, rule_type_id, '{}'))
                
                conn.commit()
                cursor.close()

                logging.info(f"Step 1 completed: headers={headers}, auto-assigned rules={validations}")
                return jsonify({'success': True, 'headers': headers, 'validations': validations})
            except Exception as e:
                logging.error(f"Error in step 1: {str(e)}")
                return jsonify({'success': False, 'message': str(e)}), 500
        
        # GET request - return current headers
        headers = session.get('headers', [])
        return jsonify({'headers': headers})

    @app.route('/step/2', methods=['GET', 'POST'])
    @app.route('/api/step/2', methods=['GET', 'POST'])
    def step_two():
        if 'loggedin' not in session:
            return jsonify({'error': 'Not logged in'}), 401
            
        if request.method == 'POST':
            try:
                action = request.form.get('action', 'save')
                validations = {}
                for key, values in request.form.lists():
                    if key.startswith('validations_'):
                        header = key.replace('validations_', '')
                        validations[header] = values
                        
                logging.debug(f"Step 2 submitted: action={action}, validations={validations}")
                
                template_id = session.get('template_id')
                if not template_id:
                    return jsonify({'success': False, 'message': 'Session data missing'}), 400

                # Save validations to database
                conn = get_db_connection()
                cursor = conn.cursor()
                
                # Clear existing rules
                cursor.execute("""
                    DELETE FROM column_validation_rules
                    WHERE column_id IN (
                        SELECT column_id FROM template_columns WHERE template_id = %s
                    )
                """, (template_id,))
                
                # Add new rules
                for header, rules in validations.items():
                    cursor.execute("""
                        SELECT column_id FROM template_columns
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    result = cursor.fetchone()
                    if not result:
                        continue
                    column_id = result[0]
                    
                    for rule_name in rules:
                        cursor.execute("""
                            SELECT rule_type_id FROM validation_rule_types
                            WHERE rule_name = %s
                        """, (rule_name,))
                        result = cursor.fetchone()
                        if result:
                            rule_type_id = result[0]
                            cursor.execute("""
                                INSERT IGNORE INTO column_validation_rules (column_id, rule_type_id, rule_config)
                                VALUES (%s, %s, %s)
                            """, (column_id, rule_type_id, '{}'))
                
                conn.commit()
                cursor.close()

                session['validations'] = validations
                session['current_step'] = 3 if action == 'review' else 2
                
                logging.info(f"Step 2 completed: action={action}, validations={validations}")
                return jsonify({'success': True, 'message': 'Step 2 completed successfully'})
            except Exception as e:
                logging.error(f"Error in step 2: {str(e)}")
                return jsonify({'success': False, 'message': str(e)}), 500
        
        # GET request
        selected_headers = session.get('selected_headers', [])
        return jsonify({'selected_headers': selected_headers})

    # Rules endpoint
    @app.route('/rules', methods=['GET'])
    @app.route('/api/rules', methods=['GET'])
    def get_rules():
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            
            cursor.execute("""
                SELECT rule_type_id AS rule_id, rule_name, description, parameters, is_custom, 
                       column_name, template_id, source_format, target_format, data_type, is_active
                FROM validation_rule_types
            """)
            rules = cursor.fetchall()
            cursor.close()
            
            logging.info(f"Returning {len(rules)} rules from getRules endpoint")
            return jsonify({'success': True, 'rules': rules})
        except mysql.connector.Error as e:
            logging.error(f"Database error fetching rules: {str(e)}")
            return jsonify({'success': False, 'message': str(e)}), 500
        except Exception as e:
            logging.error(f"Unexpected error fetching rules: {str(e)}")
            return jsonify({'success': False, 'message': str(e)}), 500

    # Template details endpoint
    @app.route('/template/<int:template_id>/<sheet_name>', methods=['GET'])
    @app.route('/api/template/<int:template_id>/<sheet_name>', methods=['GET'])
    def get_template(template_id, sheet_name):
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /template: session missing")
            return jsonify({'error': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("""
                SELECT template_name, sheet_name, headers
                FROM excel_templates
                WHERE template_id = %s AND user_id = %s AND status = 'ACTIVE'
            """, (template_id, session['user_id']))
            template_record = cursor.fetchone()
            
            if not template_record:
                logging.error(f"Template not found for template_id: {template_id}, user_id: {session['user_id']}")
                cursor.close()
                return jsonify({'error': 'Template not found'}), 404

            headers = json.loads(template_record['headers']) if template_record['headers'] else []
            stored_sheet_name = template_record['sheet_name'] or sheet_name
            file_path = os.path.join(app.config['UPLOAD_FOLDER'], template_record['template_name'])
            
            cursor.execute("""
                SELECT COUNT(*) as rule_count
                FROM template_columns tc
                JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                WHERE tc.template_id = %s AND tc.is_selected = TRUE
            """, (template_id,))
            rule_count = cursor.fetchone()['rule_count']
            has_existing_rules = rule_count > 0
            
            cursor.close()
            
            return jsonify({
                'success': True,
                'sheets': {stored_sheet_name: {'headers': headers}},
                'file_name': template_record['template_name'],
                'file_path': file_path,
                'sheet_name': stored_sheet_name,
                'has_existing_rules': has_existing_rules
            })
        except mysql.connector.Error as e:
            logging.error(f"Database error in get_template: {str(e)}")
            return jsonify({'error': f'Database error: {str(e)}'}), 500
        except Exception as e:
            logging.error(f"Unexpected error in get_template: {str(e)}")
            return jsonify({'error': f'Unexpected error: {str(e)}'}), 500

    # Debug route to show all registered routes
    @app.route('/debug/routes', methods=['GET'])
    def list_routes():
        routes = []
        for rule in app.url_map.iter_rules():
            routes.append({
                'endpoint': rule.endpoint,
                'methods': list(rule.methods),
                'rule': rule.rule
            })
        return jsonify(routes)

    # 404 handler to debug missing routes
    @app.errorhandler(404)
    def not_found_handler(error):
        logging.error(f"404 Error: {request.method} {request.url} not found")
        logging.error(f"Available routes: {[rule.rule for rule in app.url_map.iter_rules()]}")
        return jsonify({
            'error': 'Endpoint not found', 
            'method': request.method,
            'url': request.url,
            'path': request.path
        }), 404

    return app

def initialize_app_data():
    """Initialize database and create default data"""
    try:
        logging.info("Initializing database schema...")
        init_db()
        
        logging.info("Creating admin user...")
        create_admin_user()
        
        logging.info("Creating default validation rules...")
        create_default_validation_rules()
        
        logging.info("Application initialization completed successfully")
    except Exception as e:
        logging.error(f"Failed to initialize application: {e}")
        raise

DB_CONFIG = {
    'host': os.getenv('MYSQL_HOST', 'localhost'),
    'user': os.getenv('MYSQL_USER', 'root'),
    'password': os.getenv('MYSQL_PASSWORD', 'Keansa@2024'),
    'database': os.getenv('MYSQL_DATABASE', 'data_validation_2'),
}

def get_db_connection():
    if 'db' not in g:
        try:
            conn = mysql.connector.connect(
                host=DB_CONFIG['host'],
                user=DB_CONFIG['user'],
                password=DB_CONFIG['password']
            )
            cursor = conn.cursor()
            cursor.execute(f"CREATE DATABASE IF NOT EXISTS {DB_CONFIG['database']}")
            cursor.close()
            conn.close()
            g.db = mysql.connector.connect(**DB_CONFIG)
            logging.info("Database connection established successfully")
        except mysql.connector.Error as err:
            if err.errno == errorcode.ER_ACCESS_DENIED_ERROR:
                logging.error("Database connection failed: Access denied for user - check username/password")
            elif err.errno == errorcode.ER_BAD_DB_ERROR:
                logging.error("Database connection failed: Database does not exist")
            else:
                logging.error(f"Database connection failed: {err}")
            raise Exception(f"Failed to connect to database: {str(err)}")
    return g.db

def close_db(error):
    db = g.pop('db', None)
    if db is not None:
        db.close()

def init_db():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        tables = [
            """
            CREATE TABLE IF NOT EXISTS login_details (
                id INT AUTO_INCREMENT PRIMARY KEY,
                first_name VARCHAR(100),
                last_name VARCHAR(100),
                email VARCHAR(255) UNIQUE,
                mobile VARCHAR(10),
                password VARCHAR(255)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS excel_templates (
                template_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_name VARCHAR(255) NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
                user_id INT NOT NULL,
                sheet_name VARCHAR(255),
                headers JSON,
                status ENUM('ACTIVE', 'INACTIVE') DEFAULT 'ACTIVE',
                is_corrected BOOLEAN DEFAULT FALSE,
                remote_file_path VARCHAR(512),
                FOREIGN KEY (user_id) REFERENCES login_details(id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS template_columns (
                column_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_id BIGINT NOT NULL,
                column_name VARCHAR(255) NOT NULL,
                column_position INT NOT NULL,
                is_validation_enabled BOOLEAN DEFAULT FALSE,
                is_selected BOOLEAN DEFAULT FALSE,
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE,
                UNIQUE (template_id, column_name)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_rule_types (
                rule_type_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                rule_name VARCHAR(255) NOT NULL,
                description TEXT,
                parameters TEXT,
                is_active BOOLEAN DEFAULT TRUE,
                is_custom BOOLEAN DEFAULT FALSE,
                column_name VARCHAR(255),
                template_id BIGINT,
                data_type VARCHAR(50),
                source_format VARCHAR(50),
                target_format VARCHAR(50),
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS column_validation_rules (
                column_validation_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                column_id BIGINT NOT NULL,
                rule_type_id BIGINT NOT NULL,
                rule_config JSON,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (column_id) REFERENCES template_columns(column_id) ON DELETE CASCADE,
                FOREIGN KEY (rule_type_id) REFERENCES validation_rule_types(rule_type_id) ON DELETE RESTRICT,
                UNIQUE (column_id, rule_type_id)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_history (
                history_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_id BIGINT NOT NULL,
                template_name VARCHAR(255) NOT NULL,
                error_count INT NOT NULL,
                corrected_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                corrected_file_path VARCHAR(512) NOT NULL,
                user_id INT NOT NULL,
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE,
                FOREIGN KEY (user_id) REFERENCES login_details(id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_corrections (
                correction_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                history_id BIGINT NOT NULL,
                row_index INT NOT NULL,
                column_name VARCHAR(255) NOT NULL,
                original_value TEXT,
                corrected_value TEXT,
                rule_failed VARCHAR(255) DEFAULT NULL,
                FOREIGN KEY (history_id) REFERENCES validation_history(history_id) ON DELETE CASCADE
            )
            """
        ]
        for table_sql in tables:
            cursor.execute(table_sql)
        
        # Add missing columns if they don't exist
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'source_format'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN source_format VARCHAR(50)")
            logging.info("Added source_format column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'target_format'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN target_format VARCHAR(50)")
            logging.info("Added target_format column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'data_type'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN data_type VARCHAR(50)")
            logging.info("Added data_type column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM excel_templates LIKE 'remote_file_path'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE excel_templates ADD COLUMN remote_file_path VARCHAR(512)")
            logging.info("Added remote_file_path column to excel_templates table")
            
        cursor.execute("SHOW COLUMNS FROM template_columns LIKE 'is_selected'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE template_columns ADD COLUMN is_selected BOOLEAN DEFAULT FALSE")
            logging.info("Added is_selected column to template_columns table")
            
        conn.commit()
        cursor.close()
        logging.info("Database tables initialized")
    except Exception as e:
        logging.error(f"Failed to initialize database: {str(e)}")
        raise

def create_admin_user():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        admin_password = bcrypt.hashpw('admin'.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
        cursor.execute("""
            INSERT IGNORE INTO login_details (first_name, last_name, email, mobile, password)
            VALUES (%s, %s, %s, %s, %s)
        """, ('Admin', 'User', 'admin@example.com', '1234567890', admin_password))
        conn.commit()
        cursor.close()
        logging.info("Admin user created or already exists")
    except Exception as e:
        logging.error(f"Failed to create admin user: {str(e)}")
        raise

def create_default_validation_rules():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        default_rules = [
            ("Required", "Ensures the field is not null", '{"allow_null": false}', None, None, None),
            ("Int", "Validates integer format", '{"format": "integer"}', None, None, "Int"),
            ("Float", "Validates number format (integer or decimal)", '{"format": "float"}', None, None, "Float"),
            ("Text", "Allows text with quotes and parentheses", '{"allow_special": false}', None, None, "Text"),
            ("Email", "Validates email format", '{"regex": "^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\\\.[a-zA-Z0-9-.]+$"}', None, None, "Email"),
            ("Date(DD-MM-YYYY)", "Validates date format DD-MM-YYYY", '{"format": "%d-%m-%Y"}', "DD-MM-YYYY", None, "Date"),
            ("Boolean", "Validates boolean format (true/false or 0/1)", '{"format": "boolean"}', None, None, "Boolean"),
            ("Alphanumeric", "Validates alphanumeric format", '{"format": "alphanumeric"}', None, None, "Alphanumeric")
        ]
        cursor.executemany("""
            INSERT IGNORE INTO validation_rule_types (rule_name, description, parameters, is_custom, source_format, target_format, data_type)
            VALUES (%s, %s, %s, %s, %s, %s, %s)
        """, [(name, desc, params, False, source, target, dtype) for name, desc, params, source, target, dtype in default_rules])
        conn.commit()
        cursor.close()
        logging.info("Default validation rules ensured successfully")
    except Exception as e:
        logging.error(f"Failed to ensure default validation rules: {str(e)}")
        raise

if __name__ == '__main__':
    try:
        # Create the application using factory pattern
        app = create_app()
        
        # Initialize database and default data within app context
        with app.app_context():
            initialize_app_data()
        
        # Get port from environment or use default
        port = int(os.getenv('PORT', 5000))
        
        # Start the application server
        logging.info("Starting Flask server...")
        app.run(debug=True, host='0.0.0.0', port=port)
        
    except Exception as e:
        logging.error(f"Failed to start application: {e}")
        raise
).all():
        return "Int"
    
    if non_null.str.match(r'^-?\d+(\.\d+)?

def create_app():
    """Application factory pattern for different environments"""
    # Set the path to the frontend dist folder
    current_dir = os.path.dirname(os.path.abspath(__file__))
    frontend_dist_path = os.path.join(current_dir, '..', '..', 'Keansa-Ai-Suite2025may-frontend11', 'dist')
    frontend_dist_path = os.path.abspath(frontend_dist_path)
    
    # Create Flask application instance
    app = Flask(__name__, static_folder=frontend_dist_path, static_url_path='')
    CORS(app, supports_credentials=True, origins=["http://localhost:3000", "http://localhost:8080", "http://localhost:5000", "*"])

    app.secret_key = os.urandom(24).hex()
    app.config['SESSION_TYPE'] = 'filesystem'
    app.config['SESSION_FILE_DIR'] = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'sessions')
    app.config['SESSION_COOKIE_SAMESITE'] = 'Lax'
    app.config['SESSION_COOKIE_HTTPONLY'] = True
    app.config['SESSION_COOKIE_SECURE'] = False
    app.config['PERMANENT_SESSION_LIFETIME'] = 86400  # 24 hours
    app.config['UPLOAD_FOLDER'] = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'uploads')
    Session(app)

    # Ensure directories exist
    try:
        os.makedirs(app.config['UPLOAD_FOLDER'], exist_ok=True)
        os.makedirs(app.config['SESSION_FILE_DIR'], exist_ok=True)
    except OSError as e:
        logging.error(f"Failed to create directories: {e}")

    # Register cleanup handlers
    app.teardown_appcontext(close_db)
    
    # Register all routes directly in create_app
    
    # Static file serving for React frontend
    @app.route('/', defaults={'path': ''})
    @app.route('/<path:path>')
    def serve(path):
        if path and os.path.exists(os.path.join(app.static_folder, path)):
            return app.send_static_file(path)
        return app.send_static_file('index.html')

    # Health check endpoint
    @app.route('/health', methods=['GET'])
    def health_check():
        return jsonify({
            'status': 'healthy',
            'timestamp': datetime.now().isoformat(),
            'version': '2.0.0'
        })

    # Authentication endpoint - both old and new paths
    @app.route('/authenticate', methods=['POST'])
    @app.route('/api/auth/authenticate', methods=['POST'])
    def authenticate():
        try:
            email = request.form.get('username') or request.form.get('email')
            password = request.form.get('password')
            logging.debug(f"Login attempt: email={email}, password={'*' * len(password) if password else 'None'}")
            
            if not email or not password:
                logging.warning(f"Login failed: Email or password missing")
                return jsonify({'success': False, 'message': 'Email and password are required'}), 400

            # Check for admin login
            if email == "admin" and password == "admin":
                session['loggedin'] = True
                session['user_email'] = "admin@example.com"
                session['user_id'] = 1
                session.permanent = True
                logging.info(f"Admin login successful. Session: {dict(session)}")
                return jsonify({'success': True, 'message': 'Login successful', 'user': {'email': 'admin@example.com', 'id': 1}}), 200

            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("SELECT * FROM login_details WHERE LOWER(email) = LOWER(%s)", (email.lower(),))
            account = cursor.fetchone()
            cursor.close()
            
            if account:
                if bcrypt.checkpw(password.encode('utf-8'), account['password'].encode('utf-8')):
                    session['loggedin'] = True
                    session['user_email'] = account['email']
                    session['user_id'] = account['id']
                    session.permanent = True
                    logging.info(f"User {email} logged in successfully. Session: {dict(session)}")
                    return jsonify({
                        'success': True,
                        'message': 'Login successful',
                        'user': {'email': account['email'], 'id': account['id']}
                    }), 200
                else:
                    logging.warning(f"Invalid password for {email}")
                    return jsonify({'success': False, 'message': 'Invalid credentials'}), 401
            else:
                logging.warning(f"Email {email} not found")
                return jsonify({'success': False, 'message': 'Invalid credentials'}), 401
        except Exception as e:
            logging.error(f"Unexpected error during login: {str(e)}")
            return jsonify({'success': False, 'message': f'Unexpected error: {str(e)}'}), 500

    @app.route('/check-auth', methods=['GET'])
    @app.route('/api/auth/check-auth', methods=['GET'])
    def check_auth():
        try:
            logging.debug(f"Checking auth with session: {dict(session)}")
            if 'loggedin' in session and 'user_id' in session:
                conn = get_db_connection()
                cursor = conn.cursor(dictionary=True)
                cursor.execute("SELECT email, first_name FROM login_details WHERE id = %s", (session['user_id'],))
                user = cursor.fetchone()
                cursor.close()
                if user:
                    logging.info(f"User {session.get('user_email')} is authenticated")
                    return jsonify({
                        'success': True,
                        'user': {
                            'email': user['email'],
                            'id': session['user_id'],
                            'first_name': user['first_name']
                        }
                    })
                else:
                    logging.warning("User not found in database")  
                    session.clear()
                    return jsonify({'success': False, 'message': 'User not found'}), 401
            logging.warning("User not authenticated")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        except Exception as e:
            logging.error(f"Error in check-auth endpoint: {str(e)}")
            return jsonify({'success': False, 'message': f'Server error: {str(e)}'}), 500

    @app.route('/register', methods=['POST'])
    @app.route('/api/auth/register', methods=['POST'])
    def register():
        first_name = request.form.get('first_name')
        last_name = request.form.get('last_name')
        email = request.form.get('email')
        mobile = request.form.get('mobile')
        password = request.form.get('password')
        confirm_password = request.form.get('confirm_password')

        if not all([first_name, last_name, email, mobile, password, confirm_password]):
            return jsonify({'success': False, 'message': 'All fields are required'}), 400
        if password != confirm_password:
            return jsonify({'success': False, 'message': 'Passwords do not match'}), 400

        hashed_password = bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
        try:
            conn = get_db_connection()
            cursor = conn.cursor()
            cursor.execute("""
                INSERT INTO login_details (first_name, last_name, email, mobile, password)
                VALUES (%s, %s, %s, %s, %s)
            """, (first_name, last_name, email, mobile, hashed_password))
            user_id = cursor.lastrowid
            conn.commit()
            cursor.close()
            session['loggedin'] = True
            session['user_email'] = email
            session['user_id'] = user_id
            return jsonify({
                'success': True,
                'message': 'Registration successful',
                'user': {'email': email, 'id': user_id}
            }), 200
        except mysql.connector.Error as e:
            logging.error(f"Database error during registration: {str(e)}")
            return jsonify({'success': False, 'message': f'Registration error: {str(e)}'}), 500

    @app.route('/logout', methods=['POST'])
    @app.route('/api/auth/logout', methods=['POST'])
    def logout():
        logging.info(f"User {session.get('user_email', 'unknown')} logged out")
        session.clear()
        return jsonify({'success': True, 'message': 'Logged out successfully'})

    # Template routes
    @app.route('/templates', methods=['GET'])
    @app.route('/api/templates', methods=['GET'])
    def get_templates():
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /templates: session missing")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("""
                SELECT template_id, template_name, created_at, status
                FROM excel_templates
                WHERE user_id = %s AND status = 'ACTIVE'
                ORDER BY created_at DESC
                LIMIT 100
            """, (session['user_id'],))
            templates = cursor.fetchall()
            cursor.close()
            logging.info(f"Fetched {len(templates)} templates for user {session['user_id']}")
            return jsonify({'success': True, 'templates': templates})
        except mysql.connector.Error as e:
            logging.error(f'Error fetching templates: {str(e)}')
            return jsonify({'success': False, 'message': f'Error fetching templates: {str(e)}'}), 500
        except Exception as e:
            logging.error(f'Unexpected error fetching templates: {str(e)}')
            return jsonify({'success': False, 'message': f'Unexpected error: {str(e)}'}), 500

    # Rule Configuration routes
    @app.route('/rule-configurations', methods=['GET'])
    @app.route('/api/validation/rule-configurations', methods=['GET'])
    def get_rule_configurations():
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning(f"Unauthorized access to /rule-configurations: session={dict(session)}")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            user_id = session['user_id']
            logging.debug(f"Fetching rule configurations for user_id: {user_id}")

            # Main query to fetch templates with configured rules
            cursor.execute("""
                SELECT 
                    t.template_id, 
                    t.template_name, 
                    t.created_at, 
                    COUNT(cvr.column_validation_id) as rule_count
                FROM excel_templates t
                LEFT JOIN template_columns tc ON t.template_id = tc.template_id
                LEFT JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                WHERE t.user_id = %s AND t.status = 'ACTIVE' AND t.is_corrected = FALSE
                GROUP BY t.template_id, t.template_name, t.created_at
                HAVING rule_count > 0
                ORDER BY t.created_at DESC
                LIMIT 100
            """, (user_id,))
            templates = cursor.fetchall()
            logging.debug(f"Fetched rule-configured templates: {templates}")

            cursor.close()

            if not templates:
                logging.info(f"No templates with rules found for user_id: {user_id}")
            else:
                logging.info(f"Found {len(templates)} templates with rules for user_id: {user_id}")

            return jsonify({'success': True, 'templates': templates})
        except mysql.connector.Error as e:
            logging.error(f"Database error fetching rule configurations: {str(e)}")
            return jsonify({'success': False, 'message': f"Database error: {str(e)}"}), 500
        except Exception as e:
            logging.error(f"Unexpected error fetching rule configurations: {str(e)}")
            return jsonify({'success': False, 'message': f"Unexpected error: {str(e)}"}), 500

    # File upload route
    @app.route('/upload', methods=['POST'])
    @app.route('/api/templates/upload', methods=['POST'])
    @app.route('/api/upload', methods=['POST'])  # Additional common path
    def upload():
        logging.info(f"Upload endpoint called: {request.endpoint}, method: {request.method}")
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /upload: session missing")
            return jsonify({'error': 'Not logged in'}), 401
        if 'file' not in request.files:
            logging.warning("No file provided in upload request")
            return jsonify({'error': 'No file uploaded'}), 400
        file = request.files['file']
        if file.filename == '':
            logging.warning("No file selected in upload request")
            return jsonify({'error': 'No file selected'}), 400
        
        file_path = os.path.join(app.config['UPLOAD_FOLDER'], file.filename)
        try:
            file.save(file_path)
            logging.info(f"File saved: {file_path}")
        except Exception as e:
            logging.error(f"Failed to save file {file.filename}: {str(e)}")
            return jsonify({'error': f'Failed to save file: {str(e)}'}), 500

        try:
            # Read the file to get sheets and headers
            if file.filename.endswith('.xlsx') or file.filename.endswith('.xls'):
                xl = pd.ExcelFile(file_path)
                sheets = {sheet_name: pd.read_excel(file_path, sheet_name=sheet_name, header=None) 
                         for sheet_name in xl.sheet_names}
            elif file.filename.endswith(('.txt', '.csv', '.dat')):
                df = pd.read_csv(file_path, header=None, encoding='utf-8')
                sheets = {'Sheet1': df}
            else:
                logging.error("Unsupported file type")
                return jsonify({'error': 'Unsupported file type'}), 400
            
            logging.debug(f"Sheets extracted: {list(sheets.keys())}")
        except Exception as e:
            logging.error(f"Failed to read file {file_path}: {str(e)}")
            return jsonify({'error': f'Failed to read file: {str(e)}'}), 400

        try:
            sheet_names = list(sheets.keys())
            if not sheet_names:
                logging.error("No sheets found in the file")
                return jsonify({'error': 'No sheets found in the file'}), 400
            sheet_name = sheet_names[0]
            df = sheets[sheet_name]
            
            # Find header row
            header_row = 0
            for i in range(min(len(df), 10)):
                row = df.iloc[i].dropna()
                if not row.empty and all(isinstance(x, str) for x in row if pd.notna(x)):
                    header_row = i
                    break
                    
            headers = df.iloc[header_row].tolist()
            logging.debug(f"Headers extracted: {headers}")
            
            if not headers or all(not h for h in headers):
                logging.error("No valid headers found in file")
                return jsonify({'error': 'No valid headers found in the file'}), 400
        except Exception as e:
            logging.error(f"Error processing file {file.filename}: {str(e)}")
            return jsonify({'error': f'Error processing file: {str(e)}'}), 400

        # Clear existing session data
        for key in ['df', 'header_row', 'headers', 'sheet_name', 'current_step', 'selected_headers', 'validations', 'error_cell_locations', 'data_rows', 'corrected_file_path']:
            session.pop(key, None)

        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)

            # Check if template exists
            cursor.execute("""
                SELECT template_id, headers, sheet_name
                FROM excel_templates
                WHERE template_name = %s AND user_id = %s AND status = 'ACTIVE'
                ORDER BY created_at DESC
            """, (file.filename, session['user_id']))
            existing_templates = cursor.fetchall()
            logging.info(f"Found {len(existing_templates)} existing templates with name {file.filename}")

            template_id = None
            has_existing_rules = False
            validations = {}
            selected_headers = []

            # Check for matching template
            matching_template = None
            for template in existing_templates:
                stored_headers = json.loads(template['headers']) if template['headers'] else []
                stored_sheet_name = template['sheet_name']
                if stored_headers == headers and stored_sheet_name == sheet_name:
                    matching_template = template
                    break

            if matching_template:
                template_id = matching_template['template_id']
                # Check for existing rules
                cursor.execute("""
                    SELECT tc.column_name, vrt.rule_name
                    FROM template_columns tc
                    JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                    JOIN validation_rule_types vrt ON cvr.rule_type_id = vrt.rule_type_id
                    WHERE tc.template_id = %s AND tc.is_selected = TRUE
                """, (template_id,))
                rules_data = cursor.fetchall()
                for row in rules_data:
                    column_name = row['column_name']
                    rule_name = row['rule_name']
                    if column_name not in validations:
                        validations[column_name] = []
                    validations[column_name].append(rule_name)
                    if column_name not in selected_headers:
                        selected_headers.append(column_name)
                has_existing_rules = len(validations) > 0
            else:
                # New template
                cursor.execute("""
                    INSERT INTO excel_templates (template_name, user_id, sheet_name, headers, is_corrected)
                    VALUES (%s, %s, %s, %s, %s)
                """, (file.filename, session['user_id'], sheet_name, json.dumps(headers), False))
                template_id = cursor.lastrowid
                column_data = [(template_id, header, i + 1, False) for i, header in enumerate(headers)]
                cursor.executemany("""
                    INSERT INTO template_columns (template_id, column_name, column_position, is_selected)
                    VALUES (%s, %s, %s, %s)
                """, column_data)

            conn.commit()
            cursor.close()

            # Store session data
            session['file_path'] = file_path
            session['template_id'] = template_id
            session['df'] = df.to_json()
            session['header_row'] = header_row
            session['headers'] = headers
            session['sheet_name'] = sheet_name
            session['current_step'] = 1 if not has_existing_rules else 3
            session['validations'] = validations
            session['selected_headers'] = selected_headers
            session['has_existing_rules'] = has_existing_rules

            logging.info(f"Upload processed: template_id={template_id}, filename={file.filename}, has_existing_rules={has_existing_rules}")

            return jsonify({
                'success': True,
                'sheets': {sheet_name: {'headers': headers}},
                'file_name': file.filename,
                'template_id': template_id,
                'has_existing_rules': has_existing_rules,
                'sheet_name': sheet_name,
                'skip_to_step_3': has_existing_rules
            })
        except mysql.connector.Error as e:
            logging.error(f'Error saving template: {str(e)}')
            return jsonify({'error': f'Error saving template: {str(e)}'}), 500
        except Exception as e:
            logging.error(f'Unexpected error saving template: {str(e)}')
            return jsonify({'error': f'Unexpected error: {str(e)}'}), 500

    # Multi-step workflow endpoints
    @app.route('/step/1', methods=['GET', 'POST'])
    @app.route('/api/step/1', methods=['GET', 'POST'])
    def step_one():
        if 'loggedin' not in session:
            return jsonify({'error': 'Not logged in'}), 401
        
        if request.method == 'POST':
            try:
                headers = request.form.getlist('headers')
                new_header_row = request.form.get('new_header_row')
                logging.debug(f"Step 1 submitted: headers={headers}, new_header_row={new_header_row}")
                
                if not headers:
                    logging.error("No headers provided in step 1")
                    return jsonify({'success': False, 'message': 'No headers provided'}), 400
                    
                if 'template_id' not in session:
                    logging.error("Session missing template_id")
                    return jsonify({'success': False, 'message': 'Session data missing'}), 400

                template_id = session['template_id']
                
                # Get the dataframe from session for auto-detection
                df_json = session.get('df')
                if df_json:
                    df = pd.read_json(StringIO(df_json))
                    session_headers = session.get('headers', [])
                    df.columns = session_headers
                    header_row = session.get('header_row', 0)
                    df = df.iloc[header_row + 1:].reset_index(drop=True)
                    
                    # Auto-detect rules for selected headers
                    validations = assign_default_rules_to_columns(df, headers)
                    session['validations'] = validations
                    logging.debug(f"Auto-assigned rules: {validations}")
                else:
                    validations = {}

                session['selected_headers'] = headers
                session['current_step'] = 2

                # Mark selected headers in the database
                conn = get_db_connection()
                cursor = conn.cursor()
                cursor.execute("UPDATE template_columns SET is_selected = FALSE WHERE template_id = %s", (template_id,))
                for header in headers:
                    cursor.execute("""
                        UPDATE template_columns
                        SET is_selected = TRUE
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    
                    # Get column_id and add auto-detected rules
                    cursor.execute("""
                        SELECT column_id FROM template_columns
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    result = cursor.fetchone()
                    if result:
                        column_id = result[0]
                        for rule_name in validations.get(header, []):
                            cursor.execute("""
                                SELECT rule_type_id FROM validation_rule_types
                                WHERE rule_name = %s AND is_custom = FALSE
                            """, (rule_name,))
                            rule_result = cursor.fetchone()
                            if rule_result:
                                rule_type_id = rule_result[0]
                                cursor.execute("""
                                    INSERT IGNORE INTO column_validation_rules (column_id, rule_type_id, rule_config)
                                    VALUES (%s, %s, %s)
                                """, (column_id, rule_type_id, '{}'))
                
                conn.commit()
                cursor.close()

                logging.info(f"Step 1 completed: headers={headers}, auto-assigned rules={validations}")
                return jsonify({'success': True, 'headers': headers, 'validations': validations})
            except Exception as e:
                logging.error(f"Error in step 1: {str(e)}")
                return jsonify({'success': False, 'message': str(e)}), 500
        
        # GET request - return current headers
        headers = session.get('headers', [])
        return jsonify({'headers': headers})

    @app.route('/step/2', methods=['GET', 'POST'])
    @app.route('/api/step/2', methods=['GET', 'POST'])
    def step_two():
        if 'loggedin' not in session:
            return jsonify({'error': 'Not logged in'}), 401
            
        if request.method == 'POST':
            try:
                action = request.form.get('action', 'save')
                validations = {}
                for key, values in request.form.lists():
                    if key.startswith('validations_'):
                        header = key.replace('validations_', '')
                        validations[header] = values
                        
                logging.debug(f"Step 2 submitted: action={action}, validations={validations}")
                
                template_id = session.get('template_id')
                if not template_id:
                    return jsonify({'success': False, 'message': 'Session data missing'}), 400

                # Save validations to database
                conn = get_db_connection()
                cursor = conn.cursor()
                
                # Clear existing rules
                cursor.execute("""
                    DELETE FROM column_validation_rules
                    WHERE column_id IN (
                        SELECT column_id FROM template_columns WHERE template_id = %s
                    )
                """, (template_id,))
                
                # Add new rules
                for header, rules in validations.items():
                    cursor.execute("""
                        SELECT column_id FROM template_columns
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    result = cursor.fetchone()
                    if not result:
                        continue
                    column_id = result[0]
                    
                    for rule_name in rules:
                        cursor.execute("""
                            SELECT rule_type_id FROM validation_rule_types
                            WHERE rule_name = %s
                        """, (rule_name,))
                        result = cursor.fetchone()
                        if result:
                            rule_type_id = result[0]
                            cursor.execute("""
                                INSERT IGNORE INTO column_validation_rules (column_id, rule_type_id, rule_config)
                                VALUES (%s, %s, %s)
                            """, (column_id, rule_type_id, '{}'))
                
                conn.commit()
                cursor.close()

                session['validations'] = validations
                session['current_step'] = 3 if action == 'review' else 2
                
                logging.info(f"Step 2 completed: action={action}, validations={validations}")
                return jsonify({'success': True, 'message': 'Step 2 completed successfully'})
            except Exception as e:
                logging.error(f"Error in step 2: {str(e)}")
                return jsonify({'success': False, 'message': str(e)}), 500
        
        # GET request
        selected_headers = session.get('selected_headers', [])
        return jsonify({'selected_headers': selected_headers})

    # Rules endpoint
    @app.route('/rules', methods=['GET'])
    @app.route('/api/rules', methods=['GET'])
    def get_rules():
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            
            cursor.execute("""
                SELECT rule_type_id AS rule_id, rule_name, description, parameters, is_custom, 
                       column_name, template_id, source_format, target_format, data_type, is_active
                FROM validation_rule_types
            """)
            rules = cursor.fetchall()
            cursor.close()
            
            logging.info(f"Returning {len(rules)} rules from getRules endpoint")
            return jsonify({'success': True, 'rules': rules})
        except mysql.connector.Error as e:
            logging.error(f"Database error fetching rules: {str(e)}")
            return jsonify({'success': False, 'message': str(e)}), 500
        except Exception as e:
            logging.error(f"Unexpected error fetching rules: {str(e)}")
            return jsonify({'success': False, 'message': str(e)}), 500

    # Template details endpoint
    @app.route('/template/<int:template_id>/<sheet_name>', methods=['GET'])
    @app.route('/api/template/<int:template_id>/<sheet_name>', methods=['GET'])
    def get_template(template_id, sheet_name):
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /template: session missing")
            return jsonify({'error': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("""
                SELECT template_name, sheet_name, headers
                FROM excel_templates
                WHERE template_id = %s AND user_id = %s AND status = 'ACTIVE'
            """, (template_id, session['user_id']))
            template_record = cursor.fetchone()
            
            if not template_record:
                logging.error(f"Template not found for template_id: {template_id}, user_id: {session['user_id']}")
                cursor.close()
                return jsonify({'error': 'Template not found'}), 404

            headers = json.loads(template_record['headers']) if template_record['headers'] else []
            stored_sheet_name = template_record['sheet_name'] or sheet_name
            file_path = os.path.join(app.config['UPLOAD_FOLDER'], template_record['template_name'])
            
            cursor.execute("""
                SELECT COUNT(*) as rule_count
                FROM template_columns tc
                JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                WHERE tc.template_id = %s AND tc.is_selected = TRUE
            """, (template_id,))
            rule_count = cursor.fetchone()['rule_count']
            has_existing_rules = rule_count > 0
            
            cursor.close()
            
            return jsonify({
                'success': True,
                'sheets': {stored_sheet_name: {'headers': headers}},
                'file_name': template_record['template_name'],
                'file_path': file_path,
                'sheet_name': stored_sheet_name,
                'has_existing_rules': has_existing_rules
            })
        except mysql.connector.Error as e:
            logging.error(f"Database error in get_template: {str(e)}")
            return jsonify({'error': f'Database error: {str(e)}'}), 500
        except Exception as e:
            logging.error(f"Unexpected error in get_template: {str(e)}")
            return jsonify({'error': f'Unexpected error: {str(e)}'}), 500

    # Debug route to show all registered routes
    @app.route('/debug/routes', methods=['GET'])
    def list_routes():
        routes = []
        for rule in app.url_map.iter_rules():
            routes.append({
                'endpoint': rule.endpoint,
                'methods': list(rule.methods),
                'rule': rule.rule
            })
        return jsonify(routes)

    # 404 handler to debug missing routes
    @app.errorhandler(404)
    def not_found_handler(error):
        logging.error(f"404 Error: {request.method} {request.url} not found")
        logging.error(f"Available routes: {[rule.rule for rule in app.url_map.iter_rules()]}")
        return jsonify({
            'error': 'Endpoint not found', 
            'method': request.method,
            'url': request.url,
            'path': request.path
        }), 404

    return app

def initialize_app_data():
    """Initialize database and create default data"""
    try:
        logging.info("Initializing database schema...")
        init_db()
        
        logging.info("Creating admin user...")
        create_admin_user()
        
        logging.info("Creating default validation rules...")
        create_default_validation_rules()
        
        logging.info("Application initialization completed successfully")
    except Exception as e:
        logging.error(f"Failed to initialize application: {e}")
        raise

DB_CONFIG = {
    'host': os.getenv('MYSQL_HOST', 'localhost'),
    'user': os.getenv('MYSQL_USER', 'root'),
    'password': os.getenv('MYSQL_PASSWORD', 'Keansa@2024'),
    'database': os.getenv('MYSQL_DATABASE', 'data_validation_2'),
}

def get_db_connection():
    if 'db' not in g:
        try:
            conn = mysql.connector.connect(
                host=DB_CONFIG['host'],
                user=DB_CONFIG['user'],
                password=DB_CONFIG['password']
            )
            cursor = conn.cursor()
            cursor.execute(f"CREATE DATABASE IF NOT EXISTS {DB_CONFIG['database']}")
            cursor.close()
            conn.close()
            g.db = mysql.connector.connect(**DB_CONFIG)
            logging.info("Database connection established successfully")
        except mysql.connector.Error as err:
            if err.errno == errorcode.ER_ACCESS_DENIED_ERROR:
                logging.error("Database connection failed: Access denied for user - check username/password")
            elif err.errno == errorcode.ER_BAD_DB_ERROR:
                logging.error("Database connection failed: Database does not exist")
            else:
                logging.error(f"Database connection failed: {err}")
            raise Exception(f"Failed to connect to database: {str(err)}")
    return g.db

def close_db(error):
    db = g.pop('db', None)
    if db is not None:
        db.close()

def init_db():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        tables = [
            """
            CREATE TABLE IF NOT EXISTS login_details (
                id INT AUTO_INCREMENT PRIMARY KEY,
                first_name VARCHAR(100),
                last_name VARCHAR(100),
                email VARCHAR(255) UNIQUE,
                mobile VARCHAR(10),
                password VARCHAR(255)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS excel_templates (
                template_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_name VARCHAR(255) NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
                user_id INT NOT NULL,
                sheet_name VARCHAR(255),
                headers JSON,
                status ENUM('ACTIVE', 'INACTIVE') DEFAULT 'ACTIVE',
                is_corrected BOOLEAN DEFAULT FALSE,
                remote_file_path VARCHAR(512),
                FOREIGN KEY (user_id) REFERENCES login_details(id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS template_columns (
                column_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_id BIGINT NOT NULL,
                column_name VARCHAR(255) NOT NULL,
                column_position INT NOT NULL,
                is_validation_enabled BOOLEAN DEFAULT FALSE,
                is_selected BOOLEAN DEFAULT FALSE,
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE,
                UNIQUE (template_id, column_name)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_rule_types (
                rule_type_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                rule_name VARCHAR(255) NOT NULL,
                description TEXT,
                parameters TEXT,
                is_active BOOLEAN DEFAULT TRUE,
                is_custom BOOLEAN DEFAULT FALSE,
                column_name VARCHAR(255),
                template_id BIGINT,
                data_type VARCHAR(50),
                source_format VARCHAR(50),
                target_format VARCHAR(50),
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS column_validation_rules (
                column_validation_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                column_id BIGINT NOT NULL,
                rule_type_id BIGINT NOT NULL,
                rule_config JSON,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (column_id) REFERENCES template_columns(column_id) ON DELETE CASCADE,
                FOREIGN KEY (rule_type_id) REFERENCES validation_rule_types(rule_type_id) ON DELETE RESTRICT,
                UNIQUE (column_id, rule_type_id)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_history (
                history_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_id BIGINT NOT NULL,
                template_name VARCHAR(255) NOT NULL,
                error_count INT NOT NULL,
                corrected_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                corrected_file_path VARCHAR(512) NOT NULL,
                user_id INT NOT NULL,
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE,
                FOREIGN KEY (user_id) REFERENCES login_details(id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_corrections (
                correction_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                history_id BIGINT NOT NULL,
                row_index INT NOT NULL,
                column_name VARCHAR(255) NOT NULL,
                original_value TEXT,
                corrected_value TEXT,
                rule_failed VARCHAR(255) DEFAULT NULL,
                FOREIGN KEY (history_id) REFERENCES validation_history(history_id) ON DELETE CASCADE
            )
            """
        ]
        for table_sql in tables:
            cursor.execute(table_sql)
        
        # Add missing columns if they don't exist
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'source_format'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN source_format VARCHAR(50)")
            logging.info("Added source_format column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'target_format'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN target_format VARCHAR(50)")
            logging.info("Added target_format column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'data_type'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN data_type VARCHAR(50)")
            logging.info("Added data_type column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM excel_templates LIKE 'remote_file_path'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE excel_templates ADD COLUMN remote_file_path VARCHAR(512)")
            logging.info("Added remote_file_path column to excel_templates table")
            
        cursor.execute("SHOW COLUMNS FROM template_columns LIKE 'is_selected'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE template_columns ADD COLUMN is_selected BOOLEAN DEFAULT FALSE")
            logging.info("Added is_selected column to template_columns table")
            
        conn.commit()
        cursor.close()
        logging.info("Database tables initialized")
    except Exception as e:
        logging.error(f"Failed to initialize database: {str(e)}")
        raise

def create_admin_user():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        admin_password = bcrypt.hashpw('admin'.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
        cursor.execute("""
            INSERT IGNORE INTO login_details (first_name, last_name, email, mobile, password)
            VALUES (%s, %s, %s, %s, %s)
        """, ('Admin', 'User', 'admin@example.com', '1234567890', admin_password))
        conn.commit()
        cursor.close()
        logging.info("Admin user created or already exists")
    except Exception as e:
        logging.error(f"Failed to create admin user: {str(e)}")
        raise

def create_default_validation_rules():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        default_rules = [
            ("Required", "Ensures the field is not null", '{"allow_null": false}', None, None, None),
            ("Int", "Validates integer format", '{"format": "integer"}', None, None, "Int"),
            ("Float", "Validates number format (integer or decimal)", '{"format": "float"}', None, None, "Float"),
            ("Text", "Allows text with quotes and parentheses", '{"allow_special": false}', None, None, "Text"),
            ("Email", "Validates email format", '{"regex": "^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\\\.[a-zA-Z0-9-.]+$"}', None, None, "Email"),
            ("Date(DD-MM-YYYY)", "Validates date format DD-MM-YYYY", '{"format": "%d-%m-%Y"}', "DD-MM-YYYY", None, "Date"),
            ("Boolean", "Validates boolean format (true/false or 0/1)", '{"format": "boolean"}', None, None, "Boolean"),
            ("Alphanumeric", "Validates alphanumeric format", '{"format": "alphanumeric"}', None, None, "Alphanumeric")
        ]
        cursor.executemany("""
            INSERT IGNORE INTO validation_rule_types (rule_name, description, parameters, is_custom, source_format, target_format, data_type)
            VALUES (%s, %s, %s, %s, %s, %s, %s)
        """, [(name, desc, params, False, source, target, dtype) for name, desc, params, source, target, dtype in default_rules])
        conn.commit()
        cursor.close()
        logging.info("Default validation rules ensured successfully")
    except Exception as e:
        logging.error(f"Failed to ensure default validation rules: {str(e)}")
        raise

if __name__ == '__main__':
    try:
        # Create the application using factory pattern
        app = create_app()
        
        # Initialize database and default data within app context
        with app.app_context():
            initialize_app_data()
        
        # Get port from environment or use default
        port = int(os.getenv('PORT', 5000))
        
        # Start the application server
        logging.info("Starting Flask server...")
        app.run(debug=True, host='0.0.0.0', port=port)
        
    except Exception as e:
        logging.error(f"Failed to start application: {e}")
        raise
).all():
        return "Float"
    
    # Alphanumeric detection
    if non_null.str.match(r'^[a-zA-Z0-9]+

def create_app():
    """Application factory pattern for different environments"""
    # Set the path to the frontend dist folder
    current_dir = os.path.dirname(os.path.abspath(__file__))
    frontend_dist_path = os.path.join(current_dir, '..', '..', 'Keansa-Ai-Suite2025may-frontend11', 'dist')
    frontend_dist_path = os.path.abspath(frontend_dist_path)
    
    # Create Flask application instance
    app = Flask(__name__, static_folder=frontend_dist_path, static_url_path='')
    CORS(app, supports_credentials=True, origins=["http://localhost:3000", "http://localhost:8080", "http://localhost:5000", "*"])

    app.secret_key = os.urandom(24).hex()
    app.config['SESSION_TYPE'] = 'filesystem'
    app.config['SESSION_FILE_DIR'] = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'sessions')
    app.config['SESSION_COOKIE_SAMESITE'] = 'Lax'
    app.config['SESSION_COOKIE_HTTPONLY'] = True
    app.config['SESSION_COOKIE_SECURE'] = False
    app.config['PERMANENT_SESSION_LIFETIME'] = 86400  # 24 hours
    app.config['UPLOAD_FOLDER'] = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'uploads')
    Session(app)

    # Ensure directories exist
    try:
        os.makedirs(app.config['UPLOAD_FOLDER'], exist_ok=True)
        os.makedirs(app.config['SESSION_FILE_DIR'], exist_ok=True)
    except OSError as e:
        logging.error(f"Failed to create directories: {e}")

    # Register cleanup handlers
    app.teardown_appcontext(close_db)
    
    # Register all routes directly in create_app
    
    # Static file serving for React frontend
    @app.route('/', defaults={'path': ''})
    @app.route('/<path:path>')
    def serve(path):
        if path and os.path.exists(os.path.join(app.static_folder, path)):
            return app.send_static_file(path)
        return app.send_static_file('index.html')

    # Health check endpoint
    @app.route('/health', methods=['GET'])
    def health_check():
        return jsonify({
            'status': 'healthy',
            'timestamp': datetime.now().isoformat(),
            'version': '2.0.0'
        })

    # Authentication endpoint - both old and new paths
    @app.route('/authenticate', methods=['POST'])
    @app.route('/api/auth/authenticate', methods=['POST'])
    def authenticate():
        try:
            email = request.form.get('username') or request.form.get('email')
            password = request.form.get('password')
            logging.debug(f"Login attempt: email={email}, password={'*' * len(password) if password else 'None'}")
            
            if not email or not password:
                logging.warning(f"Login failed: Email or password missing")
                return jsonify({'success': False, 'message': 'Email and password are required'}), 400

            # Check for admin login
            if email == "admin" and password == "admin":
                session['loggedin'] = True
                session['user_email'] = "admin@example.com"
                session['user_id'] = 1
                session.permanent = True
                logging.info(f"Admin login successful. Session: {dict(session)}")
                return jsonify({'success': True, 'message': 'Login successful', 'user': {'email': 'admin@example.com', 'id': 1}}), 200

            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("SELECT * FROM login_details WHERE LOWER(email) = LOWER(%s)", (email.lower(),))
            account = cursor.fetchone()
            cursor.close()
            
            if account:
                if bcrypt.checkpw(password.encode('utf-8'), account['password'].encode('utf-8')):
                    session['loggedin'] = True
                    session['user_email'] = account['email']
                    session['user_id'] = account['id']
                    session.permanent = True
                    logging.info(f"User {email} logged in successfully. Session: {dict(session)}")
                    return jsonify({
                        'success': True,
                        'message': 'Login successful',
                        'user': {'email': account['email'], 'id': account['id']}
                    }), 200
                else:
                    logging.warning(f"Invalid password for {email}")
                    return jsonify({'success': False, 'message': 'Invalid credentials'}), 401
            else:
                logging.warning(f"Email {email} not found")
                return jsonify({'success': False, 'message': 'Invalid credentials'}), 401
        except Exception as e:
            logging.error(f"Unexpected error during login: {str(e)}")
            return jsonify({'success': False, 'message': f'Unexpected error: {str(e)}'}), 500

    @app.route('/check-auth', methods=['GET'])
    @app.route('/api/auth/check-auth', methods=['GET'])
    def check_auth():
        try:
            logging.debug(f"Checking auth with session: {dict(session)}")
            if 'loggedin' in session and 'user_id' in session:
                conn = get_db_connection()
                cursor = conn.cursor(dictionary=True)
                cursor.execute("SELECT email, first_name FROM login_details WHERE id = %s", (session['user_id'],))
                user = cursor.fetchone()
                cursor.close()
                if user:
                    logging.info(f"User {session.get('user_email')} is authenticated")
                    return jsonify({
                        'success': True,
                        'user': {
                            'email': user['email'],
                            'id': session['user_id'],
                            'first_name': user['first_name']
                        }
                    })
                else:
                    logging.warning("User not found in database")  
                    session.clear()
                    return jsonify({'success': False, 'message': 'User not found'}), 401
            logging.warning("User not authenticated")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        except Exception as e:
            logging.error(f"Error in check-auth endpoint: {str(e)}")
            return jsonify({'success': False, 'message': f'Server error: {str(e)}'}), 500

    @app.route('/register', methods=['POST'])
    @app.route('/api/auth/register', methods=['POST'])
    def register():
        first_name = request.form.get('first_name')
        last_name = request.form.get('last_name')
        email = request.form.get('email')
        mobile = request.form.get('mobile')
        password = request.form.get('password')
        confirm_password = request.form.get('confirm_password')

        if not all([first_name, last_name, email, mobile, password, confirm_password]):
            return jsonify({'success': False, 'message': 'All fields are required'}), 400
        if password != confirm_password:
            return jsonify({'success': False, 'message': 'Passwords do not match'}), 400

        hashed_password = bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
        try:
            conn = get_db_connection()
            cursor = conn.cursor()
            cursor.execute("""
                INSERT INTO login_details (first_name, last_name, email, mobile, password)
                VALUES (%s, %s, %s, %s, %s)
            """, (first_name, last_name, email, mobile, hashed_password))
            user_id = cursor.lastrowid
            conn.commit()
            cursor.close()
            session['loggedin'] = True
            session['user_email'] = email
            session['user_id'] = user_id
            return jsonify({
                'success': True,
                'message': 'Registration successful',
                'user': {'email': email, 'id': user_id}
            }), 200
        except mysql.connector.Error as e:
            logging.error(f"Database error during registration: {str(e)}")
            return jsonify({'success': False, 'message': f'Registration error: {str(e)}'}), 500

    @app.route('/logout', methods=['POST'])
    @app.route('/api/auth/logout', methods=['POST'])
    def logout():
        logging.info(f"User {session.get('user_email', 'unknown')} logged out")
        session.clear()
        return jsonify({'success': True, 'message': 'Logged out successfully'})

    # Template routes
    @app.route('/templates', methods=['GET'])
    @app.route('/api/templates', methods=['GET'])
    def get_templates():
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /templates: session missing")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("""
                SELECT template_id, template_name, created_at, status
                FROM excel_templates
                WHERE user_id = %s AND status = 'ACTIVE'
                ORDER BY created_at DESC
                LIMIT 100
            """, (session['user_id'],))
            templates = cursor.fetchall()
            cursor.close()
            logging.info(f"Fetched {len(templates)} templates for user {session['user_id']}")
            return jsonify({'success': True, 'templates': templates})
        except mysql.connector.Error as e:
            logging.error(f'Error fetching templates: {str(e)}')
            return jsonify({'success': False, 'message': f'Error fetching templates: {str(e)}'}), 500
        except Exception as e:
            logging.error(f'Unexpected error fetching templates: {str(e)}')
            return jsonify({'success': False, 'message': f'Unexpected error: {str(e)}'}), 500

    # Rule Configuration routes
    @app.route('/rule-configurations', methods=['GET'])
    @app.route('/api/validation/rule-configurations', methods=['GET'])
    def get_rule_configurations():
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning(f"Unauthorized access to /rule-configurations: session={dict(session)}")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            user_id = session['user_id']
            logging.debug(f"Fetching rule configurations for user_id: {user_id}")

            # Main query to fetch templates with configured rules
            cursor.execute("""
                SELECT 
                    t.template_id, 
                    t.template_name, 
                    t.created_at, 
                    COUNT(cvr.column_validation_id) as rule_count
                FROM excel_templates t
                LEFT JOIN template_columns tc ON t.template_id = tc.template_id
                LEFT JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                WHERE t.user_id = %s AND t.status = 'ACTIVE' AND t.is_corrected = FALSE
                GROUP BY t.template_id, t.template_name, t.created_at
                HAVING rule_count > 0
                ORDER BY t.created_at DESC
                LIMIT 100
            """, (user_id,))
            templates = cursor.fetchall()
            logging.debug(f"Fetched rule-configured templates: {templates}")

            cursor.close()

            if not templates:
                logging.info(f"No templates with rules found for user_id: {user_id}")
            else:
                logging.info(f"Found {len(templates)} templates with rules for user_id: {user_id}")

            return jsonify({'success': True, 'templates': templates})
        except mysql.connector.Error as e:
            logging.error(f"Database error fetching rule configurations: {str(e)}")
            return jsonify({'success': False, 'message': f"Database error: {str(e)}"}), 500
        except Exception as e:
            logging.error(f"Unexpected error fetching rule configurations: {str(e)}")
            return jsonify({'success': False, 'message': f"Unexpected error: {str(e)}"}), 500

    # File upload route
    @app.route('/upload', methods=['POST'])
    @app.route('/api/templates/upload', methods=['POST'])
    @app.route('/api/upload', methods=['POST'])  # Additional common path
    def upload():
        logging.info(f"Upload endpoint called: {request.endpoint}, method: {request.method}")
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /upload: session missing")
            return jsonify({'error': 'Not logged in'}), 401
        if 'file' not in request.files:
            logging.warning("No file provided in upload request")
            return jsonify({'error': 'No file uploaded'}), 400
        file = request.files['file']
        if file.filename == '':
            logging.warning("No file selected in upload request")
            return jsonify({'error': 'No file selected'}), 400
        
        file_path = os.path.join(app.config['UPLOAD_FOLDER'], file.filename)
        try:
            file.save(file_path)
            logging.info(f"File saved: {file_path}")
        except Exception as e:
            logging.error(f"Failed to save file {file.filename}: {str(e)}")
            return jsonify({'error': f'Failed to save file: {str(e)}'}), 500

        try:
            # Read the file to get sheets and headers
            if file.filename.endswith('.xlsx') or file.filename.endswith('.xls'):
                xl = pd.ExcelFile(file_path)
                sheets = {sheet_name: pd.read_excel(file_path, sheet_name=sheet_name, header=None) 
                         for sheet_name in xl.sheet_names}
            elif file.filename.endswith(('.txt', '.csv', '.dat')):
                df = pd.read_csv(file_path, header=None, encoding='utf-8')
                sheets = {'Sheet1': df}
            else:
                logging.error("Unsupported file type")
                return jsonify({'error': 'Unsupported file type'}), 400
            
            logging.debug(f"Sheets extracted: {list(sheets.keys())}")
        except Exception as e:
            logging.error(f"Failed to read file {file_path}: {str(e)}")
            return jsonify({'error': f'Failed to read file: {str(e)}'}), 400

        try:
            sheet_names = list(sheets.keys())
            if not sheet_names:
                logging.error("No sheets found in the file")
                return jsonify({'error': 'No sheets found in the file'}), 400
            sheet_name = sheet_names[0]
            df = sheets[sheet_name]
            
            # Find header row
            header_row = 0
            for i in range(min(len(df), 10)):
                row = df.iloc[i].dropna()
                if not row.empty and all(isinstance(x, str) for x in row if pd.notna(x)):
                    header_row = i
                    break
                    
            headers = df.iloc[header_row].tolist()
            logging.debug(f"Headers extracted: {headers}")
            
            if not headers or all(not h for h in headers):
                logging.error("No valid headers found in file")
                return jsonify({'error': 'No valid headers found in the file'}), 400
        except Exception as e:
            logging.error(f"Error processing file {file.filename}: {str(e)}")
            return jsonify({'error': f'Error processing file: {str(e)}'}), 400

        # Clear existing session data
        for key in ['df', 'header_row', 'headers', 'sheet_name', 'current_step', 'selected_headers', 'validations', 'error_cell_locations', 'data_rows', 'corrected_file_path']:
            session.pop(key, None)

        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)

            # Check if template exists
            cursor.execute("""
                SELECT template_id, headers, sheet_name
                FROM excel_templates
                WHERE template_name = %s AND user_id = %s AND status = 'ACTIVE'
                ORDER BY created_at DESC
            """, (file.filename, session['user_id']))
            existing_templates = cursor.fetchall()
            logging.info(f"Found {len(existing_templates)} existing templates with name {file.filename}")

            template_id = None
            has_existing_rules = False
            validations = {}
            selected_headers = []

            # Check for matching template
            matching_template = None
            for template in existing_templates:
                stored_headers = json.loads(template['headers']) if template['headers'] else []
                stored_sheet_name = template['sheet_name']
                if stored_headers == headers and stored_sheet_name == sheet_name:
                    matching_template = template
                    break

            if matching_template:
                template_id = matching_template['template_id']
                # Check for existing rules
                cursor.execute("""
                    SELECT tc.column_name, vrt.rule_name
                    FROM template_columns tc
                    JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                    JOIN validation_rule_types vrt ON cvr.rule_type_id = vrt.rule_type_id
                    WHERE tc.template_id = %s AND tc.is_selected = TRUE
                """, (template_id,))
                rules_data = cursor.fetchall()
                for row in rules_data:
                    column_name = row['column_name']
                    rule_name = row['rule_name']
                    if column_name not in validations:
                        validations[column_name] = []
                    validations[column_name].append(rule_name)
                    if column_name not in selected_headers:
                        selected_headers.append(column_name)
                has_existing_rules = len(validations) > 0
            else:
                # New template
                cursor.execute("""
                    INSERT INTO excel_templates (template_name, user_id, sheet_name, headers, is_corrected)
                    VALUES (%s, %s, %s, %s, %s)
                """, (file.filename, session['user_id'], sheet_name, json.dumps(headers), False))
                template_id = cursor.lastrowid
                column_data = [(template_id, header, i + 1, False) for i, header in enumerate(headers)]
                cursor.executemany("""
                    INSERT INTO template_columns (template_id, column_name, column_position, is_selected)
                    VALUES (%s, %s, %s, %s)
                """, column_data)

            conn.commit()
            cursor.close()

            # Store session data
            session['file_path'] = file_path
            session['template_id'] = template_id
            session['df'] = df.to_json()
            session['header_row'] = header_row
            session['headers'] = headers
            session['sheet_name'] = sheet_name
            session['current_step'] = 1 if not has_existing_rules else 3
            session['validations'] = validations
            session['selected_headers'] = selected_headers
            session['has_existing_rules'] = has_existing_rules

            logging.info(f"Upload processed: template_id={template_id}, filename={file.filename}, has_existing_rules={has_existing_rules}")

            return jsonify({
                'success': True,
                'sheets': {sheet_name: {'headers': headers}},
                'file_name': file.filename,
                'template_id': template_id,
                'has_existing_rules': has_existing_rules,
                'sheet_name': sheet_name,
                'skip_to_step_3': has_existing_rules
            })
        except mysql.connector.Error as e:
            logging.error(f'Error saving template: {str(e)}')
            return jsonify({'error': f'Error saving template: {str(e)}'}), 500
        except Exception as e:
            logging.error(f'Unexpected error saving template: {str(e)}')
            return jsonify({'error': f'Unexpected error: {str(e)}'}), 500

    # Multi-step workflow endpoints
    @app.route('/step/1', methods=['GET', 'POST'])
    @app.route('/api/step/1', methods=['GET', 'POST'])
    def step_one():
        if 'loggedin' not in session:
            return jsonify({'error': 'Not logged in'}), 401
        
        if request.method == 'POST':
            try:
                headers = request.form.getlist('headers')
                new_header_row = request.form.get('new_header_row')
                logging.debug(f"Step 1 submitted: headers={headers}, new_header_row={new_header_row}")
                
                if not headers:
                    logging.error("No headers provided in step 1")
                    return jsonify({'success': False, 'message': 'No headers provided'}), 400
                    
                if 'template_id' not in session:
                    logging.error("Session missing template_id")
                    return jsonify({'success': False, 'message': 'Session data missing'}), 400

                template_id = session['template_id']
                
                # Get the dataframe from session for auto-detection
                df_json = session.get('df')
                if df_json:
                    df = pd.read_json(StringIO(df_json))
                    session_headers = session.get('headers', [])
                    df.columns = session_headers
                    header_row = session.get('header_row', 0)
                    df = df.iloc[header_row + 1:].reset_index(drop=True)
                    
                    # Auto-detect rules for selected headers
                    validations = assign_default_rules_to_columns(df, headers)
                    session['validations'] = validations
                    logging.debug(f"Auto-assigned rules: {validations}")
                else:
                    validations = {}

                session['selected_headers'] = headers
                session['current_step'] = 2

                # Mark selected headers in the database
                conn = get_db_connection()
                cursor = conn.cursor()
                cursor.execute("UPDATE template_columns SET is_selected = FALSE WHERE template_id = %s", (template_id,))
                for header in headers:
                    cursor.execute("""
                        UPDATE template_columns
                        SET is_selected = TRUE
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    
                    # Get column_id and add auto-detected rules
                    cursor.execute("""
                        SELECT column_id FROM template_columns
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    result = cursor.fetchone()
                    if result:
                        column_id = result[0]
                        for rule_name in validations.get(header, []):
                            cursor.execute("""
                                SELECT rule_type_id FROM validation_rule_types
                                WHERE rule_name = %s AND is_custom = FALSE
                            """, (rule_name,))
                            rule_result = cursor.fetchone()
                            if rule_result:
                                rule_type_id = rule_result[0]
                                cursor.execute("""
                                    INSERT IGNORE INTO column_validation_rules (column_id, rule_type_id, rule_config)
                                    VALUES (%s, %s, %s)
                                """, (column_id, rule_type_id, '{}'))
                
                conn.commit()
                cursor.close()

                logging.info(f"Step 1 completed: headers={headers}, auto-assigned rules={validations}")
                return jsonify({'success': True, 'headers': headers, 'validations': validations})
            except Exception as e:
                logging.error(f"Error in step 1: {str(e)}")
                return jsonify({'success': False, 'message': str(e)}), 500
        
        # GET request - return current headers
        headers = session.get('headers', [])
        return jsonify({'headers': headers})

    @app.route('/step/2', methods=['GET', 'POST'])
    @app.route('/api/step/2', methods=['GET', 'POST'])
    def step_two():
        if 'loggedin' not in session:
            return jsonify({'error': 'Not logged in'}), 401
            
        if request.method == 'POST':
            try:
                action = request.form.get('action', 'save')
                validations = {}
                for key, values in request.form.lists():
                    if key.startswith('validations_'):
                        header = key.replace('validations_', '')
                        validations[header] = values
                        
                logging.debug(f"Step 2 submitted: action={action}, validations={validations}")
                
                template_id = session.get('template_id')
                if not template_id:
                    return jsonify({'success': False, 'message': 'Session data missing'}), 400

                # Save validations to database
                conn = get_db_connection()
                cursor = conn.cursor()
                
                # Clear existing rules
                cursor.execute("""
                    DELETE FROM column_validation_rules
                    WHERE column_id IN (
                        SELECT column_id FROM template_columns WHERE template_id = %s
                    )
                """, (template_id,))
                
                # Add new rules
                for header, rules in validations.items():
                    cursor.execute("""
                        SELECT column_id FROM template_columns
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    result = cursor.fetchone()
                    if not result:
                        continue
                    column_id = result[0]
                    
                    for rule_name in rules:
                        cursor.execute("""
                            SELECT rule_type_id FROM validation_rule_types
                            WHERE rule_name = %s
                        """, (rule_name,))
                        result = cursor.fetchone()
                        if result:
                            rule_type_id = result[0]
                            cursor.execute("""
                                INSERT IGNORE INTO column_validation_rules (column_id, rule_type_id, rule_config)
                                VALUES (%s, %s, %s)
                            """, (column_id, rule_type_id, '{}'))
                
                conn.commit()
                cursor.close()

                session['validations'] = validations
                session['current_step'] = 3 if action == 'review' else 2
                
                logging.info(f"Step 2 completed: action={action}, validations={validations}")
                return jsonify({'success': True, 'message': 'Step 2 completed successfully'})
            except Exception as e:
                logging.error(f"Error in step 2: {str(e)}")
                return jsonify({'success': False, 'message': str(e)}), 500
        
        # GET request
        selected_headers = session.get('selected_headers', [])
        return jsonify({'selected_headers': selected_headers})

    # Rules endpoint
    @app.route('/rules', methods=['GET'])
    @app.route('/api/rules', methods=['GET'])
    def get_rules():
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            
            cursor.execute("""
                SELECT rule_type_id AS rule_id, rule_name, description, parameters, is_custom, 
                       column_name, template_id, source_format, target_format, data_type, is_active
                FROM validation_rule_types
            """)
            rules = cursor.fetchall()
            cursor.close()
            
            logging.info(f"Returning {len(rules)} rules from getRules endpoint")
            return jsonify({'success': True, 'rules': rules})
        except mysql.connector.Error as e:
            logging.error(f"Database error fetching rules: {str(e)}")
            return jsonify({'success': False, 'message': str(e)}), 500
        except Exception as e:
            logging.error(f"Unexpected error fetching rules: {str(e)}")
            return jsonify({'success': False, 'message': str(e)}), 500

    # Template details endpoint
    @app.route('/template/<int:template_id>/<sheet_name>', methods=['GET'])
    @app.route('/api/template/<int:template_id>/<sheet_name>', methods=['GET'])
    def get_template(template_id, sheet_name):
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /template: session missing")
            return jsonify({'error': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("""
                SELECT template_name, sheet_name, headers
                FROM excel_templates
                WHERE template_id = %s AND user_id = %s AND status = 'ACTIVE'
            """, (template_id, session['user_id']))
            template_record = cursor.fetchone()
            
            if not template_record:
                logging.error(f"Template not found for template_id: {template_id}, user_id: {session['user_id']}")
                cursor.close()
                return jsonify({'error': 'Template not found'}), 404

            headers = json.loads(template_record['headers']) if template_record['headers'] else []
            stored_sheet_name = template_record['sheet_name'] or sheet_name
            file_path = os.path.join(app.config['UPLOAD_FOLDER'], template_record['template_name'])
            
            cursor.execute("""
                SELECT COUNT(*) as rule_count
                FROM template_columns tc
                JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                WHERE tc.template_id = %s AND tc.is_selected = TRUE
            """, (template_id,))
            rule_count = cursor.fetchone()['rule_count']
            has_existing_rules = rule_count > 0
            
            cursor.close()
            
            return jsonify({
                'success': True,
                'sheets': {stored_sheet_name: {'headers': headers}},
                'file_name': template_record['template_name'],
                'file_path': file_path,
                'sheet_name': stored_sheet_name,
                'has_existing_rules': has_existing_rules
            })
        except mysql.connector.Error as e:
            logging.error(f"Database error in get_template: {str(e)}")
            return jsonify({'error': f'Database error: {str(e)}'}), 500
        except Exception as e:
            logging.error(f"Unexpected error in get_template: {str(e)}")
            return jsonify({'error': f'Unexpected error: {str(e)}'}), 500

    # Debug route to show all registered routes
    @app.route('/debug/routes', methods=['GET'])
    def list_routes():
        routes = []
        for rule in app.url_map.iter_rules():
            routes.append({
                'endpoint': rule.endpoint,
                'methods': list(rule.methods),
                'rule': rule.rule
            })
        return jsonify(routes)

    # 404 handler to debug missing routes
    @app.errorhandler(404)
    def not_found_handler(error):
        logging.error(f"404 Error: {request.method} {request.url} not found")
        logging.error(f"Available routes: {[rule.rule for rule in app.url_map.iter_rules()]}")
        return jsonify({
            'error': 'Endpoint not found', 
            'method': request.method,
            'url': request.url,
            'path': request.path
        }), 404

    return app

def initialize_app_data():
    """Initialize database and create default data"""
    try:
        logging.info("Initializing database schema...")
        init_db()
        
        logging.info("Creating admin user...")
        create_admin_user()
        
        logging.info("Creating default validation rules...")
        create_default_validation_rules()
        
        logging.info("Application initialization completed successfully")
    except Exception as e:
        logging.error(f"Failed to initialize application: {e}")
        raise

DB_CONFIG = {
    'host': os.getenv('MYSQL_HOST', 'localhost'),
    'user': os.getenv('MYSQL_USER', 'root'),
    'password': os.getenv('MYSQL_PASSWORD', 'Keansa@2024'),
    'database': os.getenv('MYSQL_DATABASE', 'data_validation_2'),
}

def get_db_connection():
    if 'db' not in g:
        try:
            conn = mysql.connector.connect(
                host=DB_CONFIG['host'],
                user=DB_CONFIG['user'],
                password=DB_CONFIG['password']
            )
            cursor = conn.cursor()
            cursor.execute(f"CREATE DATABASE IF NOT EXISTS {DB_CONFIG['database']}")
            cursor.close()
            conn.close()
            g.db = mysql.connector.connect(**DB_CONFIG)
            logging.info("Database connection established successfully")
        except mysql.connector.Error as err:
            if err.errno == errorcode.ER_ACCESS_DENIED_ERROR:
                logging.error("Database connection failed: Access denied for user - check username/password")
            elif err.errno == errorcode.ER_BAD_DB_ERROR:
                logging.error("Database connection failed: Database does not exist")
            else:
                logging.error(f"Database connection failed: {err}")
            raise Exception(f"Failed to connect to database: {str(err)}")
    return g.db

def close_db(error):
    db = g.pop('db', None)
    if db is not None:
        db.close()

def init_db():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        tables = [
            """
            CREATE TABLE IF NOT EXISTS login_details (
                id INT AUTO_INCREMENT PRIMARY KEY,
                first_name VARCHAR(100),
                last_name VARCHAR(100),
                email VARCHAR(255) UNIQUE,
                mobile VARCHAR(10),
                password VARCHAR(255)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS excel_templates (
                template_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_name VARCHAR(255) NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
                user_id INT NOT NULL,
                sheet_name VARCHAR(255),
                headers JSON,
                status ENUM('ACTIVE', 'INACTIVE') DEFAULT 'ACTIVE',
                is_corrected BOOLEAN DEFAULT FALSE,
                remote_file_path VARCHAR(512),
                FOREIGN KEY (user_id) REFERENCES login_details(id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS template_columns (
                column_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_id BIGINT NOT NULL,
                column_name VARCHAR(255) NOT NULL,
                column_position INT NOT NULL,
                is_validation_enabled BOOLEAN DEFAULT FALSE,
                is_selected BOOLEAN DEFAULT FALSE,
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE,
                UNIQUE (template_id, column_name)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_rule_types (
                rule_type_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                rule_name VARCHAR(255) NOT NULL,
                description TEXT,
                parameters TEXT,
                is_active BOOLEAN DEFAULT TRUE,
                is_custom BOOLEAN DEFAULT FALSE,
                column_name VARCHAR(255),
                template_id BIGINT,
                data_type VARCHAR(50),
                source_format VARCHAR(50),
                target_format VARCHAR(50),
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS column_validation_rules (
                column_validation_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                column_id BIGINT NOT NULL,
                rule_type_id BIGINT NOT NULL,
                rule_config JSON,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (column_id) REFERENCES template_columns(column_id) ON DELETE CASCADE,
                FOREIGN KEY (rule_type_id) REFERENCES validation_rule_types(rule_type_id) ON DELETE RESTRICT,
                UNIQUE (column_id, rule_type_id)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_history (
                history_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_id BIGINT NOT NULL,
                template_name VARCHAR(255) NOT NULL,
                error_count INT NOT NULL,
                corrected_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                corrected_file_path VARCHAR(512) NOT NULL,
                user_id INT NOT NULL,
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE,
                FOREIGN KEY (user_id) REFERENCES login_details(id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_corrections (
                correction_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                history_id BIGINT NOT NULL,
                row_index INT NOT NULL,
                column_name VARCHAR(255) NOT NULL,
                original_value TEXT,
                corrected_value TEXT,
                rule_failed VARCHAR(255) DEFAULT NULL,
                FOREIGN KEY (history_id) REFERENCES validation_history(history_id) ON DELETE CASCADE
            )
            """
        ]
        for table_sql in tables:
            cursor.execute(table_sql)
        
        # Add missing columns if they don't exist
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'source_format'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN source_format VARCHAR(50)")
            logging.info("Added source_format column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'target_format'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN target_format VARCHAR(50)")
            logging.info("Added target_format column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'data_type'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN data_type VARCHAR(50)")
            logging.info("Added data_type column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM excel_templates LIKE 'remote_file_path'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE excel_templates ADD COLUMN remote_file_path VARCHAR(512)")
            logging.info("Added remote_file_path column to excel_templates table")
            
        cursor.execute("SHOW COLUMNS FROM template_columns LIKE 'is_selected'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE template_columns ADD COLUMN is_selected BOOLEAN DEFAULT FALSE")
            logging.info("Added is_selected column to template_columns table")
            
        conn.commit()
        cursor.close()
        logging.info("Database tables initialized")
    except Exception as e:
        logging.error(f"Failed to initialize database: {str(e)}")
        raise

def create_admin_user():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        admin_password = bcrypt.hashpw('admin'.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
        cursor.execute("""
            INSERT IGNORE INTO login_details (first_name, last_name, email, mobile, password)
            VALUES (%s, %s, %s, %s, %s)
        """, ('Admin', 'User', 'admin@example.com', '1234567890', admin_password))
        conn.commit()
        cursor.close()
        logging.info("Admin user created or already exists")
    except Exception as e:
        logging.error(f"Failed to create admin user: {str(e)}")
        raise

def create_default_validation_rules():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        default_rules = [
            ("Required", "Ensures the field is not null", '{"allow_null": false}', None, None, None),
            ("Int", "Validates integer format", '{"format": "integer"}', None, None, "Int"),
            ("Float", "Validates number format (integer or decimal)", '{"format": "float"}', None, None, "Float"),
            ("Text", "Allows text with quotes and parentheses", '{"allow_special": false}', None, None, "Text"),
            ("Email", "Validates email format", '{"regex": "^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\\\.[a-zA-Z0-9-.]+$"}', None, None, "Email"),
            ("Date(DD-MM-YYYY)", "Validates date format DD-MM-YYYY", '{"format": "%d-%m-%Y"}', "DD-MM-YYYY", None, "Date"),
            ("Boolean", "Validates boolean format (true/false or 0/1)", '{"format": "boolean"}', None, None, "Boolean"),
            ("Alphanumeric", "Validates alphanumeric format", '{"format": "alphanumeric"}', None, None, "Alphanumeric")
        ]
        cursor.executemany("""
            INSERT IGNORE INTO validation_rule_types (rule_name, description, parameters, is_custom, source_format, target_format, data_type)
            VALUES (%s, %s, %s, %s, %s, %s, %s)
        """, [(name, desc, params, False, source, target, dtype) for name, desc, params, source, target, dtype in default_rules])
        conn.commit()
        cursor.close()
        logging.info("Default validation rules ensured successfully")
    except Exception as e:
        logging.error(f"Failed to ensure default validation rules: {str(e)}")
        raise

if __name__ == '__main__':
    try:
        # Create the application using factory pattern
        app = create_app()
        
        # Initialize database and default data within app context
        with app.app_context():
            initialize_app_data()
        
        # Get port from environment or use default
        port = int(os.getenv('PORT', 5000))
        
        # Start the application server
        logging.info("Starting Flask server...")
        app.run(debug=True, host='0.0.0.0', port=port)
        
    except Exception as e:
        logging.error(f"Failed to start application: {e}")
        raise
).all():
        return "Alphanumeric"
    
    return "Text"

def assign_default_rules_to_columns(df, headers):
    """Intelligently assign validation rules based on column content"""
    assignments = {}
    
    for col in headers:
        if col not in df.columns:
            logging.warning(f"Column {col} not found in dataframe")
            continue
            
        col_type = detect_column_type(df[col])
        rules = ["Required"]  # Default rule for all columns
        
        # Special handling for optional columns
        if not any(col.lower().startswith(prefix) for prefix in
                  ["name", "address", "phone", "username", "status", "period"]):
            rules.append(col_type)
        else:
            rules.append("Text")  # Optional text fields
        
        assignments[col] = rules
    
    return assignments

def create_app():
    """Application factory pattern for different environments"""
    # Set the path to the frontend dist folder
    current_dir = os.path.dirname(os.path.abspath(__file__))
    frontend_dist_path = os.path.join(current_dir, '..', '..', 'Keansa-Ai-Suite2025may-frontend11', 'dist')
    frontend_dist_path = os.path.abspath(frontend_dist_path)
    
    # Create Flask application instance
    app = Flask(__name__, static_folder=frontend_dist_path, static_url_path='')
    CORS(app, supports_credentials=True, origins=["http://localhost:3000", "http://localhost:8080", "http://localhost:5000", "*"])

    app.secret_key = os.urandom(24).hex()
    app.config['SESSION_TYPE'] = 'filesystem'
    app.config['SESSION_FILE_DIR'] = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'sessions')
    app.config['SESSION_COOKIE_SAMESITE'] = 'Lax'
    app.config['SESSION_COOKIE_HTTPONLY'] = True
    app.config['SESSION_COOKIE_SECURE'] = False
    app.config['PERMANENT_SESSION_LIFETIME'] = 86400  # 24 hours
    app.config['UPLOAD_FOLDER'] = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'uploads')
    Session(app)

    # Ensure directories exist
    try:
        os.makedirs(app.config['UPLOAD_FOLDER'], exist_ok=True)
        os.makedirs(app.config['SESSION_FILE_DIR'], exist_ok=True)
    except OSError as e:
        logging.error(f"Failed to create directories: {e}")

    # Register cleanup handlers
    app.teardown_appcontext(close_db)
    
    # Register all routes directly in create_app
    
    # Static file serving for React frontend
    @app.route('/', defaults={'path': ''})
    @app.route('/<path:path>')
    def serve(path):
        if path and os.path.exists(os.path.join(app.static_folder, path)):
            return app.send_static_file(path)
        return app.send_static_file('index.html')

    # Health check endpoint
    @app.route('/health', methods=['GET'])
    def health_check():
        return jsonify({
            'status': 'healthy',
            'timestamp': datetime.now().isoformat(),
            'version': '2.0.0'
        })

    # Authentication endpoint - both old and new paths
    @app.route('/authenticate', methods=['POST'])
    @app.route('/api/auth/authenticate', methods=['POST'])
    def authenticate():
        try:
            email = request.form.get('username') or request.form.get('email')
            password = request.form.get('password')
            logging.debug(f"Login attempt: email={email}, password={'*' * len(password) if password else 'None'}")
            
            if not email or not password:
                logging.warning(f"Login failed: Email or password missing")
                return jsonify({'success': False, 'message': 'Email and password are required'}), 400

            # Check for admin login
            if email == "admin" and password == "admin":
                session['loggedin'] = True
                session['user_email'] = "admin@example.com"
                session['user_id'] = 1
                session.permanent = True
                logging.info(f"Admin login successful. Session: {dict(session)}")
                return jsonify({'success': True, 'message': 'Login successful', 'user': {'email': 'admin@example.com', 'id': 1}}), 200

            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("SELECT * FROM login_details WHERE LOWER(email) = LOWER(%s)", (email.lower(),))
            account = cursor.fetchone()
            cursor.close()
            
            if account:
                if bcrypt.checkpw(password.encode('utf-8'), account['password'].encode('utf-8')):
                    session['loggedin'] = True
                    session['user_email'] = account['email']
                    session['user_id'] = account['id']
                    session.permanent = True
                    logging.info(f"User {email} logged in successfully. Session: {dict(session)}")
                    return jsonify({
                        'success': True,
                        'message': 'Login successful',
                        'user': {'email': account['email'], 'id': account['id']}
                    }), 200
                else:
                    logging.warning(f"Invalid password for {email}")
                    return jsonify({'success': False, 'message': 'Invalid credentials'}), 401
            else:
                logging.warning(f"Email {email} not found")
                return jsonify({'success': False, 'message': 'Invalid credentials'}), 401
        except Exception as e:
            logging.error(f"Unexpected error during login: {str(e)}")
            return jsonify({'success': False, 'message': f'Unexpected error: {str(e)}'}), 500

    @app.route('/check-auth', methods=['GET'])
    @app.route('/api/auth/check-auth', methods=['GET'])
    def check_auth():
        try:
            logging.debug(f"Checking auth with session: {dict(session)}")
            if 'loggedin' in session and 'user_id' in session:
                conn = get_db_connection()
                cursor = conn.cursor(dictionary=True)
                cursor.execute("SELECT email, first_name FROM login_details WHERE id = %s", (session['user_id'],))
                user = cursor.fetchone()
                cursor.close()
                if user:
                    logging.info(f"User {session.get('user_email')} is authenticated")
                    return jsonify({
                        'success': True,
                        'user': {
                            'email': user['email'],
                            'id': session['user_id'],
                            'first_name': user['first_name']
                        }
                    })
                else:
                    logging.warning("User not found in database")  
                    session.clear()
                    return jsonify({'success': False, 'message': 'User not found'}), 401
            logging.warning("User not authenticated")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        except Exception as e:
            logging.error(f"Error in check-auth endpoint: {str(e)}")
            return jsonify({'success': False, 'message': f'Server error: {str(e)}'}), 500

    @app.route('/register', methods=['POST'])
    @app.route('/api/auth/register', methods=['POST'])
    def register():
        first_name = request.form.get('first_name')
        last_name = request.form.get('last_name')
        email = request.form.get('email')
        mobile = request.form.get('mobile')
        password = request.form.get('password')
        confirm_password = request.form.get('confirm_password')

        if not all([first_name, last_name, email, mobile, password, confirm_password]):
            return jsonify({'success': False, 'message': 'All fields are required'}), 400
        if password != confirm_password:
            return jsonify({'success': False, 'message': 'Passwords do not match'}), 400

        hashed_password = bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
        try:
            conn = get_db_connection()
            cursor = conn.cursor()
            cursor.execute("""
                INSERT INTO login_details (first_name, last_name, email, mobile, password)
                VALUES (%s, %s, %s, %s, %s)
            """, (first_name, last_name, email, mobile, hashed_password))
            user_id = cursor.lastrowid
            conn.commit()
            cursor.close()
            session['loggedin'] = True
            session['user_email'] = email
            session['user_id'] = user_id
            return jsonify({
                'success': True,
                'message': 'Registration successful',
                'user': {'email': email, 'id': user_id}
            }), 200
        except mysql.connector.Error as e:
            logging.error(f"Database error during registration: {str(e)}")
            return jsonify({'success': False, 'message': f'Registration error: {str(e)}'}), 500

    @app.route('/logout', methods=['POST'])
    @app.route('/api/auth/logout', methods=['POST'])
    def logout():
        logging.info(f"User {session.get('user_email', 'unknown')} logged out")
        session.clear()
        return jsonify({'success': True, 'message': 'Logged out successfully'})

    # Template routes
    @app.route('/templates', methods=['GET'])
    @app.route('/api/templates', methods=['GET'])
    def get_templates():
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /templates: session missing")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("""
                SELECT template_id, template_name, created_at, status
                FROM excel_templates
                WHERE user_id = %s AND status = 'ACTIVE'
                ORDER BY created_at DESC
                LIMIT 100
            """, (session['user_id'],))
            templates = cursor.fetchall()
            cursor.close()
            logging.info(f"Fetched {len(templates)} templates for user {session['user_id']}")
            return jsonify({'success': True, 'templates': templates})
        except mysql.connector.Error as e:
            logging.error(f'Error fetching templates: {str(e)}')
            return jsonify({'success': False, 'message': f'Error fetching templates: {str(e)}'}), 500
        except Exception as e:
            logging.error(f'Unexpected error fetching templates: {str(e)}')
            return jsonify({'success': False, 'message': f'Unexpected error: {str(e)}'}), 500

    # Rule Configuration routes
    @app.route('/rule-configurations', methods=['GET'])
    @app.route('/api/validation/rule-configurations', methods=['GET'])
    def get_rule_configurations():
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning(f"Unauthorized access to /rule-configurations: session={dict(session)}")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            user_id = session['user_id']
            logging.debug(f"Fetching rule configurations for user_id: {user_id}")

            # Main query to fetch templates with configured rules
            cursor.execute("""
                SELECT 
                    t.template_id, 
                    t.template_name, 
                    t.created_at, 
                    COUNT(cvr.column_validation_id) as rule_count
                FROM excel_templates t
                LEFT JOIN template_columns tc ON t.template_id = tc.template_id
                LEFT JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                WHERE t.user_id = %s AND t.status = 'ACTIVE' AND t.is_corrected = FALSE
                GROUP BY t.template_id, t.template_name, t.created_at
                HAVING rule_count > 0
                ORDER BY t.created_at DESC
                LIMIT 100
            """, (user_id,))
            templates = cursor.fetchall()
            logging.debug(f"Fetched rule-configured templates: {templates}")

            cursor.close()

            if not templates:
                logging.info(f"No templates with rules found for user_id: {user_id}")
            else:
                logging.info(f"Found {len(templates)} templates with rules for user_id: {user_id}")

            return jsonify({'success': True, 'templates': templates})
        except mysql.connector.Error as e:
            logging.error(f"Database error fetching rule configurations: {str(e)}")
            return jsonify({'success': False, 'message': f"Database error: {str(e)}"}), 500
        except Exception as e:
            logging.error(f"Unexpected error fetching rule configurations: {str(e)}")
            return jsonify({'success': False, 'message': f"Unexpected error: {str(e)}"}), 500

    # File upload route
    @app.route('/upload', methods=['POST'])
    @app.route('/api/templates/upload', methods=['POST'])
    @app.route('/api/upload', methods=['POST'])  # Additional common path
    def upload():
        logging.info(f"Upload endpoint called: {request.endpoint}, method: {request.method}")
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /upload: session missing")
            return jsonify({'error': 'Not logged in'}), 401
        if 'file' not in request.files:
            logging.warning("No file provided in upload request")
            return jsonify({'error': 'No file uploaded'}), 400
        file = request.files['file']
        if file.filename == '':
            logging.warning("No file selected in upload request")
            return jsonify({'error': 'No file selected'}), 400
        
        file_path = os.path.join(app.config['UPLOAD_FOLDER'], file.filename)
        try:
            file.save(file_path)
            logging.info(f"File saved: {file_path}")
        except Exception as e:
            logging.error(f"Failed to save file {file.filename}: {str(e)}")
            return jsonify({'error': f'Failed to save file: {str(e)}'}), 500

        try:
            # Read the file to get sheets and headers
            if file.filename.endswith('.xlsx') or file.filename.endswith('.xls'):
                xl = pd.ExcelFile(file_path)
                sheets = {sheet_name: pd.read_excel(file_path, sheet_name=sheet_name, header=None) 
                         for sheet_name in xl.sheet_names}
            elif file.filename.endswith(('.txt', '.csv', '.dat')):
                df = pd.read_csv(file_path, header=None, encoding='utf-8')
                sheets = {'Sheet1': df}
            else:
                logging.error("Unsupported file type")
                return jsonify({'error': 'Unsupported file type'}), 400
            
            logging.debug(f"Sheets extracted: {list(sheets.keys())}")
        except Exception as e:
            logging.error(f"Failed to read file {file_path}: {str(e)}")
            return jsonify({'error': f'Failed to read file: {str(e)}'}), 400

        try:
            sheet_names = list(sheets.keys())
            if not sheet_names:
                logging.error("No sheets found in the file")
                return jsonify({'error': 'No sheets found in the file'}), 400
            sheet_name = sheet_names[0]
            df = sheets[sheet_name]
            
            # Find header row
            header_row = 0
            for i in range(min(len(df), 10)):
                row = df.iloc[i].dropna()
                if not row.empty and all(isinstance(x, str) for x in row if pd.notna(x)):
                    header_row = i
                    break
                    
            headers = df.iloc[header_row].tolist()
            logging.debug(f"Headers extracted: {headers}")
            
            if not headers or all(not h for h in headers):
                logging.error("No valid headers found in file")
                return jsonify({'error': 'No valid headers found in the file'}), 400
        except Exception as e:
            logging.error(f"Error processing file {file.filename}: {str(e)}")
            return jsonify({'error': f'Error processing file: {str(e)}'}), 400

        # Clear existing session data
        for key in ['df', 'header_row', 'headers', 'sheet_name', 'current_step', 'selected_headers', 'validations', 'error_cell_locations', 'data_rows', 'corrected_file_path']:
            session.pop(key, None)

        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)

            # Check if template exists
            cursor.execute("""
                SELECT template_id, headers, sheet_name
                FROM excel_templates
                WHERE template_name = %s AND user_id = %s AND status = 'ACTIVE'
                ORDER BY created_at DESC
            """, (file.filename, session['user_id']))
            existing_templates = cursor.fetchall()
            logging.info(f"Found {len(existing_templates)} existing templates with name {file.filename}")

            template_id = None
            has_existing_rules = False
            validations = {}
            selected_headers = []

            # Check for matching template
            matching_template = None
            for template in existing_templates:
                stored_headers = json.loads(template['headers']) if template['headers'] else []
                stored_sheet_name = template['sheet_name']
                if stored_headers == headers and stored_sheet_name == sheet_name:
                    matching_template = template
                    break

            if matching_template:
                template_id = matching_template['template_id']
                # Check for existing rules
                cursor.execute("""
                    SELECT tc.column_name, vrt.rule_name
                    FROM template_columns tc
                    JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                    JOIN validation_rule_types vrt ON cvr.rule_type_id = vrt.rule_type_id
                    WHERE tc.template_id = %s AND tc.is_selected = TRUE
                """, (template_id,))
                rules_data = cursor.fetchall()
                for row in rules_data:
                    column_name = row['column_name']
                    rule_name = row['rule_name']
                    if column_name not in validations:
                        validations[column_name] = []
                    validations[column_name].append(rule_name)
                    if column_name not in selected_headers:
                        selected_headers.append(column_name)
                has_existing_rules = len(validations) > 0
            else:
                # New template
                cursor.execute("""
                    INSERT INTO excel_templates (template_name, user_id, sheet_name, headers, is_corrected)
                    VALUES (%s, %s, %s, %s, %s)
                """, (file.filename, session['user_id'], sheet_name, json.dumps(headers), False))
                template_id = cursor.lastrowid
                column_data = [(template_id, header, i + 1, False) for i, header in enumerate(headers)]
                cursor.executemany("""
                    INSERT INTO template_columns (template_id, column_name, column_position, is_selected)
                    VALUES (%s, %s, %s, %s)
                """, column_data)

            conn.commit()
            cursor.close()

            # Store session data
            session['file_path'] = file_path
            session['template_id'] = template_id
            session['df'] = df.to_json()
            session['header_row'] = header_row
            session['headers'] = headers
            session['sheet_name'] = sheet_name
            session['current_step'] = 1 if not has_existing_rules else 3
            session['validations'] = validations
            session['selected_headers'] = selected_headers
            session['has_existing_rules'] = has_existing_rules

            logging.info(f"Upload processed: template_id={template_id}, filename={file.filename}, has_existing_rules={has_existing_rules}")

            return jsonify({
                'success': True,
                'sheets': {sheet_name: {'headers': headers}},
                'file_name': file.filename,
                'template_id': template_id,
                'has_existing_rules': has_existing_rules,
                'sheet_name': sheet_name,
                'skip_to_step_3': has_existing_rules
            })
        except mysql.connector.Error as e:
            logging.error(f'Error saving template: {str(e)}')
            return jsonify({'error': f'Error saving template: {str(e)}'}), 500
        except Exception as e:
            logging.error(f'Unexpected error saving template: {str(e)}')
            return jsonify({'error': f'Unexpected error: {str(e)}'}), 500

    # Multi-step workflow endpoints
    @app.route('/step/1', methods=['GET', 'POST'])
    @app.route('/api/step/1', methods=['GET', 'POST'])
    def step_one():
        if 'loggedin' not in session:
            return jsonify({'error': 'Not logged in'}), 401
        
        if request.method == 'POST':
            try:
                headers = request.form.getlist('headers')
                new_header_row = request.form.get('new_header_row')
                logging.debug(f"Step 1 submitted: headers={headers}, new_header_row={new_header_row}")
                
                if not headers:
                    logging.error("No headers provided in step 1")
                    return jsonify({'success': False, 'message': 'No headers provided'}), 400
                    
                if 'template_id' not in session:
                    logging.error("Session missing template_id")
                    return jsonify({'success': False, 'message': 'Session data missing'}), 400

                template_id = session['template_id']
                
                # Get the dataframe from session for auto-detection
                df_json = session.get('df')
                if df_json:
                    df = pd.read_json(StringIO(df_json))
                    session_headers = session.get('headers', [])
                    df.columns = session_headers
                    header_row = session.get('header_row', 0)
                    df = df.iloc[header_row + 1:].reset_index(drop=True)
                    
                    # Auto-detect rules for selected headers
                    validations = assign_default_rules_to_columns(df, headers)
                    session['validations'] = validations
                    logging.debug(f"Auto-assigned rules: {validations}")
                else:
                    validations = {}

                session['selected_headers'] = headers
                session['current_step'] = 2

                # Mark selected headers in the database
                conn = get_db_connection()
                cursor = conn.cursor()
                cursor.execute("UPDATE template_columns SET is_selected = FALSE WHERE template_id = %s", (template_id,))
                for header in headers:
                    cursor.execute("""
                        UPDATE template_columns
                        SET is_selected = TRUE
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    
                    # Get column_id and add auto-detected rules
                    cursor.execute("""
                        SELECT column_id FROM template_columns
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    result = cursor.fetchone()
                    if result:
                        column_id = result[0]
                        for rule_name in validations.get(header, []):
                            cursor.execute("""
                                SELECT rule_type_id FROM validation_rule_types
                                WHERE rule_name = %s AND is_custom = FALSE
                            """, (rule_name,))
                            rule_result = cursor.fetchone()
                            if rule_result:
                                rule_type_id = rule_result[0]
                                cursor.execute("""
                                    INSERT IGNORE INTO column_validation_rules (column_id, rule_type_id, rule_config)
                                    VALUES (%s, %s, %s)
                                """, (column_id, rule_type_id, '{}'))
                
                conn.commit()
                cursor.close()

                logging.info(f"Step 1 completed: headers={headers}, auto-assigned rules={validations}")
                return jsonify({'success': True, 'headers': headers, 'validations': validations})
            except Exception as e:
                logging.error(f"Error in step 1: {str(e)}")
                return jsonify({'success': False, 'message': str(e)}), 500
        
        # GET request - return current headers
        headers = session.get('headers', [])
        return jsonify({'headers': headers})

    @app.route('/step/2', methods=['GET', 'POST'])
    @app.route('/api/step/2', methods=['GET', 'POST'])
    def step_two():
        if 'loggedin' not in session:
            return jsonify({'error': 'Not logged in'}), 401
            
        if request.method == 'POST':
            try:
                action = request.form.get('action', 'save')
                validations = {}
                for key, values in request.form.lists():
                    if key.startswith('validations_'):
                        header = key.replace('validations_', '')
                        validations[header] = values
                        
                logging.debug(f"Step 2 submitted: action={action}, validations={validations}")
                
                template_id = session.get('template_id')
                if not template_id:
                    return jsonify({'success': False, 'message': 'Session data missing'}), 400

                # Save validations to database
                conn = get_db_connection()
                cursor = conn.cursor()
                
                # Clear existing rules
                cursor.execute("""
                    DELETE FROM column_validation_rules
                    WHERE column_id IN (
                        SELECT column_id FROM template_columns WHERE template_id = %s
                    )
                """, (template_id,))
                
                # Add new rules
                for header, rules in validations.items():
                    cursor.execute("""
                        SELECT column_id FROM template_columns
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    result = cursor.fetchone()
                    if not result:
                        continue
                    column_id = result[0]
                    
                    for rule_name in rules:
                        cursor.execute("""
                            SELECT rule_type_id FROM validation_rule_types
                            WHERE rule_name = %s
                        """, (rule_name,))
                        result = cursor.fetchone()
                        if result:
                            rule_type_id = result[0]
                            cursor.execute("""
                                INSERT IGNORE INTO column_validation_rules (column_id, rule_type_id, rule_config)
                                VALUES (%s, %s, %s)
                            """, (column_id, rule_type_id, '{}'))
                
                conn.commit()
                cursor.close()

                session['validations'] = validations
                session['current_step'] = 3 if action == 'review' else 2
                
                logging.info(f"Step 2 completed: action={action}, validations={validations}")
                return jsonify({'success': True, 'message': 'Step 2 completed successfully'})
            except Exception as e:
                logging.error(f"Error in step 2: {str(e)}")
                return jsonify({'success': False, 'message': str(e)}), 500
        
        # GET request
        selected_headers = session.get('selected_headers', [])
        return jsonify({'selected_headers': selected_headers})

    # Rules endpoint
    @app.route('/rules', methods=['GET'])
    @app.route('/api/rules', methods=['GET'])
    def get_rules():
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            
            cursor.execute("""
                SELECT rule_type_id AS rule_id, rule_name, description, parameters, is_custom, 
                       column_name, template_id, source_format, target_format, data_type, is_active
                FROM validation_rule_types
            """)
            rules = cursor.fetchall()
            cursor.close()
            
            logging.info(f"Returning {len(rules)} rules from getRules endpoint")
            return jsonify({'success': True, 'rules': rules})
        except mysql.connector.Error as e:
            logging.error(f"Database error fetching rules: {str(e)}")
            return jsonify({'success': False, 'message': str(e)}), 500
        except Exception as e:
            logging.error(f"Unexpected error fetching rules: {str(e)}")
            return jsonify({'success': False, 'message': str(e)}), 500

    # Template details endpoint
    @app.route('/template/<int:template_id>/<sheet_name>', methods=['GET'])
    @app.route('/api/template/<int:template_id>/<sheet_name>', methods=['GET'])
    def get_template(template_id, sheet_name):
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /template: session missing")
            return jsonify({'error': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("""
                SELECT template_name, sheet_name, headers
                FROM excel_templates
                WHERE template_id = %s AND user_id = %s AND status = 'ACTIVE'
            """, (template_id, session['user_id']))
            template_record = cursor.fetchone()
            
            if not template_record:
                logging.error(f"Template not found for template_id: {template_id}, user_id: {session['user_id']}")
                cursor.close()
                return jsonify({'error': 'Template not found'}), 404

            headers = json.loads(template_record['headers']) if template_record['headers'] else []
            stored_sheet_name = template_record['sheet_name'] or sheet_name
            file_path = os.path.join(app.config['UPLOAD_FOLDER'], template_record['template_name'])
            
            cursor.execute("""
                SELECT COUNT(*) as rule_count
                FROM template_columns tc
                JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                WHERE tc.template_id = %s AND tc.is_selected = TRUE
            """, (template_id,))
            rule_count = cursor.fetchone()['rule_count']
            has_existing_rules = rule_count > 0
            
            cursor.close()
            
            return jsonify({
                'success': True,
                'sheets': {stored_sheet_name: {'headers': headers}},
                'file_name': template_record['template_name'],
                'file_path': file_path,
                'sheet_name': stored_sheet_name,
                'has_existing_rules': has_existing_rules
            })
        except mysql.connector.Error as e:
            logging.error(f"Database error in get_template: {str(e)}")
            return jsonify({'error': f'Database error: {str(e)}'}), 500
        except Exception as e:
            logging.error(f"Unexpected error in get_template: {str(e)}")
            return jsonify({'error': f'Unexpected error: {str(e)}'}), 500

    # Debug route to show all registered routes
    @app.route('/debug/routes', methods=['GET'])
    def list_routes():
        routes = []
        for rule in app.url_map.iter_rules():
            routes.append({
                'endpoint': rule.endpoint,
                'methods': list(rule.methods),
                'rule': rule.rule
            })
        return jsonify(routes)

    # 404 handler to debug missing routes
    @app.errorhandler(404)
    def not_found_handler(error):
        logging.error(f"404 Error: {request.method} {request.url} not found")
        logging.error(f"Available routes: {[rule.rule for rule in app.url_map.iter_rules()]}")
        return jsonify({
            'error': 'Endpoint not found', 
            'method': request.method,
            'url': request.url,
            'path': request.path
        }), 404

    return app

def initialize_app_data():
    """Initialize database and create default data"""
    try:
        logging.info("Initializing database schema...")
        init_db()
        
        logging.info("Creating admin user...")
        create_admin_user()
        
        logging.info("Creating default validation rules...")
        create_default_validation_rules()
        
        logging.info("Application initialization completed successfully")
    except Exception as e:
        logging.error(f"Failed to initialize application: {e}")
        raise

DB_CONFIG = {
    'host': os.getenv('MYSQL_HOST', 'localhost'),
    'user': os.getenv('MYSQL_USER', 'root'),
    'password': os.getenv('MYSQL_PASSWORD', 'Keansa@2024'),
    'database': os.getenv('MYSQL_DATABASE', 'data_validation_2'),
}

def get_db_connection():
    if 'db' not in g:
        try:
            conn = mysql.connector.connect(
                host=DB_CONFIG['host'],
                user=DB_CONFIG['user'],
                password=DB_CONFIG['password']
            )
            cursor = conn.cursor()
            cursor.execute(f"CREATE DATABASE IF NOT EXISTS {DB_CONFIG['database']}")
            cursor.close()
            conn.close()
            g.db = mysql.connector.connect(**DB_CONFIG)
            logging.info("Database connection established successfully")
        except mysql.connector.Error as err:
            if err.errno == errorcode.ER_ACCESS_DENIED_ERROR:
                logging.error("Database connection failed: Access denied for user - check username/password")
            elif err.errno == errorcode.ER_BAD_DB_ERROR:
                logging.error("Database connection failed: Database does not exist")
            else:
                logging.error(f"Database connection failed: {err}")
            raise Exception(f"Failed to connect to database: {str(err)}")
    return g.db

def close_db(error):
    db = g.pop('db', None)
    if db is not None:
        db.close()

def init_db():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        tables = [
            """
            CREATE TABLE IF NOT EXISTS login_details (
                id INT AUTO_INCREMENT PRIMARY KEY,
                first_name VARCHAR(100),
                last_name VARCHAR(100),
                email VARCHAR(255) UNIQUE,
                mobile VARCHAR(10),
                password VARCHAR(255)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS excel_templates (
                template_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_name VARCHAR(255) NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
                user_id INT NOT NULL,
                sheet_name VARCHAR(255),
                headers JSON,
                status ENUM('ACTIVE', 'INACTIVE') DEFAULT 'ACTIVE',
                is_corrected BOOLEAN DEFAULT FALSE,
                remote_file_path VARCHAR(512),
                FOREIGN KEY (user_id) REFERENCES login_details(id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS template_columns (
                column_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_id BIGINT NOT NULL,
                column_name VARCHAR(255) NOT NULL,
                column_position INT NOT NULL,
                is_validation_enabled BOOLEAN DEFAULT FALSE,
                is_selected BOOLEAN DEFAULT FALSE,
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE,
                UNIQUE (template_id, column_name)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_rule_types (
                rule_type_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                rule_name VARCHAR(255) NOT NULL,
                description TEXT,
                parameters TEXT,
                is_active BOOLEAN DEFAULT TRUE,
                is_custom BOOLEAN DEFAULT FALSE,
                column_name VARCHAR(255),
                template_id BIGINT,
                data_type VARCHAR(50),
                source_format VARCHAR(50),
                target_format VARCHAR(50),
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS column_validation_rules (
                column_validation_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                column_id BIGINT NOT NULL,
                rule_type_id BIGINT NOT NULL,
                rule_config JSON,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (column_id) REFERENCES template_columns(column_id) ON DELETE CASCADE,
                FOREIGN KEY (rule_type_id) REFERENCES validation_rule_types(rule_type_id) ON DELETE RESTRICT,
                UNIQUE (column_id, rule_type_id)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_history (
                history_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_id BIGINT NOT NULL,
                template_name VARCHAR(255) NOT NULL,
                error_count INT NOT NULL,
                corrected_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                corrected_file_path VARCHAR(512) NOT NULL,
                user_id INT NOT NULL,
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE,
                FOREIGN KEY (user_id) REFERENCES login_details(id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_corrections (
                correction_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                history_id BIGINT NOT NULL,
                row_index INT NOT NULL,
                column_name VARCHAR(255) NOT NULL,
                original_value TEXT,
                corrected_value TEXT,
                rule_failed VARCHAR(255) DEFAULT NULL,
                FOREIGN KEY (history_id) REFERENCES validation_history(history_id) ON DELETE CASCADE
            )
            """
        ]
        for table_sql in tables:
            cursor.execute(table_sql)
        
        # Add missing columns if they don't exist
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'source_format'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN source_format VARCHAR(50)")
            logging.info("Added source_format column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'target_format'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN target_format VARCHAR(50)")
            logging.info("Added target_format column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'data_type'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN data_type VARCHAR(50)")
            logging.info("Added data_type column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM excel_templates LIKE 'remote_file_path'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE excel_templates ADD COLUMN remote_file_path VARCHAR(512)")
            logging.info("Added remote_file_path column to excel_templates table")
            
        cursor.execute("SHOW COLUMNS FROM template_columns LIKE 'is_selected'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE template_columns ADD COLUMN is_selected BOOLEAN DEFAULT FALSE")
            logging.info("Added is_selected column to template_columns table")
            
        conn.commit()
        cursor.close()
        logging.info("Database tables initialized")
    except Exception as e:
        logging.error(f"Failed to initialize database: {str(e)}")
        raise

def create_admin_user():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        admin_password = bcrypt.hashpw('admin'.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
        cursor.execute("""
            INSERT IGNORE INTO login_details (first_name, last_name, email, mobile, password)
            VALUES (%s, %s, %s, %s, %s)
        """, ('Admin', 'User', 'admin@example.com', '1234567890', admin_password))
        conn.commit()
        cursor.close()
        logging.info("Admin user created or already exists")
    except Exception as e:
        logging.error(f"Failed to create admin user: {str(e)}")
        raise

def create_default_validation_rules():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        default_rules = [
            ("Required", "Ensures the field is not null", '{"allow_null": false}', None, None, None),
            ("Int", "Validates integer format", '{"format": "integer"}', None, None, "Int"),
            ("Float", "Validates number format (integer or decimal)", '{"format": "float"}', None, None, "Float"),
            ("Text", "Allows text with quotes and parentheses", '{"allow_special": false}', None, None, "Text"),
            ("Email", "Validates email format", '{"regex": "^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\\\.[a-zA-Z0-9-.]+$"}', None, None, "Email"),
            ("Date(DD-MM-YYYY)", "Validates date format DD-MM-YYYY", '{"format": "%d-%m-%Y"}', "DD-MM-YYYY", None, "Date"),
            ("Boolean", "Validates boolean format (true/false or 0/1)", '{"format": "boolean"}', None, None, "Boolean"),
            ("Alphanumeric", "Validates alphanumeric format", '{"format": "alphanumeric"}', None, None, "Alphanumeric")
        ]
        cursor.executemany("""
            INSERT IGNORE INTO validation_rule_types (rule_name, description, parameters, is_custom, source_format, target_format, data_type)
            VALUES (%s, %s, %s, %s, %s, %s, %s)
        """, [(name, desc, params, False, source, target, dtype) for name, desc, params, source, target, dtype in default_rules])
        conn.commit()
        cursor.close()
        logging.info("Default validation rules ensured successfully")
    except Exception as e:
        logging.error(f"Failed to ensure default validation rules: {str(e)}")
        raise

if __name__ == '__main__':
    try:
        # Create the application using factory pattern
        app = create_app()
        
        # Initialize database and default data within app context
        with app.app_context():
            initialize_app_data()
        
        # Get port from environment or use default
        port = int(os.getenv('PORT', 5000))
        
        # Start the application server
        logging.info("Starting Flask server...")
        app.run(debug=True, host='0.0.0.0', port=port)
        
    except Exception as e:
        logging.error(f"Failed to start application: {e}")
        raise
).all():
        return "Int"
    
    if non_null.str.match(r'^-?\d+(\.\d+)?

def create_app():
    """Application factory pattern for different environments"""
    # Set the path to the frontend dist folder
    current_dir = os.path.dirname(os.path.abspath(__file__))
    frontend_dist_path = os.path.join(current_dir, '..', '..', 'Keansa-Ai-Suite2025may-frontend11', 'dist')
    frontend_dist_path = os.path.abspath(frontend_dist_path)
    
    # Create Flask application instance
    app = Flask(__name__, static_folder=frontend_dist_path, static_url_path='')
    CORS(app, supports_credentials=True, origins=["http://localhost:3000", "http://localhost:8080", "http://localhost:5000", "*"])

    app.secret_key = os.urandom(24).hex()
    app.config['SESSION_TYPE'] = 'filesystem'
    app.config['SESSION_FILE_DIR'] = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'sessions')
    app.config['SESSION_COOKIE_SAMESITE'] = 'Lax'
    app.config['SESSION_COOKIE_HTTPONLY'] = True
    app.config['SESSION_COOKIE_SECURE'] = False
    app.config['PERMANENT_SESSION_LIFETIME'] = 86400  # 24 hours
    app.config['UPLOAD_FOLDER'] = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'uploads')
    Session(app)

    # Ensure directories exist
    try:
        os.makedirs(app.config['UPLOAD_FOLDER'], exist_ok=True)
        os.makedirs(app.config['SESSION_FILE_DIR'], exist_ok=True)
    except OSError as e:
        logging.error(f"Failed to create directories: {e}")

    # Register cleanup handlers
    app.teardown_appcontext(close_db)
    
    # Register all routes directly in create_app
    
    # Static file serving for React frontend
    @app.route('/', defaults={'path': ''})
    @app.route('/<path:path>')
    def serve(path):
        if path and os.path.exists(os.path.join(app.static_folder, path)):
            return app.send_static_file(path)
        return app.send_static_file('index.html')

    # Health check endpoint
    @app.route('/health', methods=['GET'])
    def health_check():
        return jsonify({
            'status': 'healthy',
            'timestamp': datetime.now().isoformat(),
            'version': '2.0.0'
        })

    # Authentication endpoint - both old and new paths
    @app.route('/authenticate', methods=['POST'])
    @app.route('/api/auth/authenticate', methods=['POST'])
    def authenticate():
        try:
            email = request.form.get('username') or request.form.get('email')
            password = request.form.get('password')
            logging.debug(f"Login attempt: email={email}, password={'*' * len(password) if password else 'None'}")
            
            if not email or not password:
                logging.warning(f"Login failed: Email or password missing")
                return jsonify({'success': False, 'message': 'Email and password are required'}), 400

            # Check for admin login
            if email == "admin" and password == "admin":
                session['loggedin'] = True
                session['user_email'] = "admin@example.com"
                session['user_id'] = 1
                session.permanent = True
                logging.info(f"Admin login successful. Session: {dict(session)}")
                return jsonify({'success': True, 'message': 'Login successful', 'user': {'email': 'admin@example.com', 'id': 1}}), 200

            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("SELECT * FROM login_details WHERE LOWER(email) = LOWER(%s)", (email.lower(),))
            account = cursor.fetchone()
            cursor.close()
            
            if account:
                if bcrypt.checkpw(password.encode('utf-8'), account['password'].encode('utf-8')):
                    session['loggedin'] = True
                    session['user_email'] = account['email']
                    session['user_id'] = account['id']
                    session.permanent = True
                    logging.info(f"User {email} logged in successfully. Session: {dict(session)}")
                    return jsonify({
                        'success': True,
                        'message': 'Login successful',
                        'user': {'email': account['email'], 'id': account['id']}
                    }), 200
                else:
                    logging.warning(f"Invalid password for {email}")
                    return jsonify({'success': False, 'message': 'Invalid credentials'}), 401
            else:
                logging.warning(f"Email {email} not found")
                return jsonify({'success': False, 'message': 'Invalid credentials'}), 401
        except Exception as e:
            logging.error(f"Unexpected error during login: {str(e)}")
            return jsonify({'success': False, 'message': f'Unexpected error: {str(e)}'}), 500

    @app.route('/check-auth', methods=['GET'])
    @app.route('/api/auth/check-auth', methods=['GET'])
    def check_auth():
        try:
            logging.debug(f"Checking auth with session: {dict(session)}")
            if 'loggedin' in session and 'user_id' in session:
                conn = get_db_connection()
                cursor = conn.cursor(dictionary=True)
                cursor.execute("SELECT email, first_name FROM login_details WHERE id = %s", (session['user_id'],))
                user = cursor.fetchone()
                cursor.close()
                if user:
                    logging.info(f"User {session.get('user_email')} is authenticated")
                    return jsonify({
                        'success': True,
                        'user': {
                            'email': user['email'],
                            'id': session['user_id'],
                            'first_name': user['first_name']
                        }
                    })
                else:
                    logging.warning("User not found in database")  
                    session.clear()
                    return jsonify({'success': False, 'message': 'User not found'}), 401
            logging.warning("User not authenticated")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        except Exception as e:
            logging.error(f"Error in check-auth endpoint: {str(e)}")
            return jsonify({'success': False, 'message': f'Server error: {str(e)}'}), 500

    @app.route('/register', methods=['POST'])
    @app.route('/api/auth/register', methods=['POST'])
    def register():
        first_name = request.form.get('first_name')
        last_name = request.form.get('last_name')
        email = request.form.get('email')
        mobile = request.form.get('mobile')
        password = request.form.get('password')
        confirm_password = request.form.get('confirm_password')

        if not all([first_name, last_name, email, mobile, password, confirm_password]):
            return jsonify({'success': False, 'message': 'All fields are required'}), 400
        if password != confirm_password:
            return jsonify({'success': False, 'message': 'Passwords do not match'}), 400

        hashed_password = bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
        try:
            conn = get_db_connection()
            cursor = conn.cursor()
            cursor.execute("""
                INSERT INTO login_details (first_name, last_name, email, mobile, password)
                VALUES (%s, %s, %s, %s, %s)
            """, (first_name, last_name, email, mobile, hashed_password))
            user_id = cursor.lastrowid
            conn.commit()
            cursor.close()
            session['loggedin'] = True
            session['user_email'] = email
            session['user_id'] = user_id
            return jsonify({
                'success': True,
                'message': 'Registration successful',
                'user': {'email': email, 'id': user_id}
            }), 200
        except mysql.connector.Error as e:
            logging.error(f"Database error during registration: {str(e)}")
            return jsonify({'success': False, 'message': f'Registration error: {str(e)}'}), 500

    @app.route('/logout', methods=['POST'])
    @app.route('/api/auth/logout', methods=['POST'])
    def logout():
        logging.info(f"User {session.get('user_email', 'unknown')} logged out")
        session.clear()
        return jsonify({'success': True, 'message': 'Logged out successfully'})

    # Template routes
    @app.route('/templates', methods=['GET'])
    @app.route('/api/templates', methods=['GET'])
    def get_templates():
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /templates: session missing")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("""
                SELECT template_id, template_name, created_at, status
                FROM excel_templates
                WHERE user_id = %s AND status = 'ACTIVE'
                ORDER BY created_at DESC
                LIMIT 100
            """, (session['user_id'],))
            templates = cursor.fetchall()
            cursor.close()
            logging.info(f"Fetched {len(templates)} templates for user {session['user_id']}")
            return jsonify({'success': True, 'templates': templates})
        except mysql.connector.Error as e:
            logging.error(f'Error fetching templates: {str(e)}')
            return jsonify({'success': False, 'message': f'Error fetching templates: {str(e)}'}), 500
        except Exception as e:
            logging.error(f'Unexpected error fetching templates: {str(e)}')
            return jsonify({'success': False, 'message': f'Unexpected error: {str(e)}'}), 500

    # Rule Configuration routes
    @app.route('/rule-configurations', methods=['GET'])
    @app.route('/api/validation/rule-configurations', methods=['GET'])
    def get_rule_configurations():
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning(f"Unauthorized access to /rule-configurations: session={dict(session)}")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            user_id = session['user_id']
            logging.debug(f"Fetching rule configurations for user_id: {user_id}")

            # Main query to fetch templates with configured rules
            cursor.execute("""
                SELECT 
                    t.template_id, 
                    t.template_name, 
                    t.created_at, 
                    COUNT(cvr.column_validation_id) as rule_count
                FROM excel_templates t
                LEFT JOIN template_columns tc ON t.template_id = tc.template_id
                LEFT JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                WHERE t.user_id = %s AND t.status = 'ACTIVE' AND t.is_corrected = FALSE
                GROUP BY t.template_id, t.template_name, t.created_at
                HAVING rule_count > 0
                ORDER BY t.created_at DESC
                LIMIT 100
            """, (user_id,))
            templates = cursor.fetchall()
            logging.debug(f"Fetched rule-configured templates: {templates}")

            cursor.close()

            if not templates:
                logging.info(f"No templates with rules found for user_id: {user_id}")
            else:
                logging.info(f"Found {len(templates)} templates with rules for user_id: {user_id}")

            return jsonify({'success': True, 'templates': templates})
        except mysql.connector.Error as e:
            logging.error(f"Database error fetching rule configurations: {str(e)}")
            return jsonify({'success': False, 'message': f"Database error: {str(e)}"}), 500
        except Exception as e:
            logging.error(f"Unexpected error fetching rule configurations: {str(e)}")
            return jsonify({'success': False, 'message': f"Unexpected error: {str(e)}"}), 500

    # File upload route
    @app.route('/upload', methods=['POST'])
    @app.route('/api/templates/upload', methods=['POST'])
    @app.route('/api/upload', methods=['POST'])  # Additional common path
    def upload():
        logging.info(f"Upload endpoint called: {request.endpoint}, method: {request.method}")
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /upload: session missing")
            return jsonify({'error': 'Not logged in'}), 401
        if 'file' not in request.files:
            logging.warning("No file provided in upload request")
            return jsonify({'error': 'No file uploaded'}), 400
        file = request.files['file']
        if file.filename == '':
            logging.warning("No file selected in upload request")
            return jsonify({'error': 'No file selected'}), 400
        
        file_path = os.path.join(app.config['UPLOAD_FOLDER'], file.filename)
        try:
            file.save(file_path)
            logging.info(f"File saved: {file_path}")
        except Exception as e:
            logging.error(f"Failed to save file {file.filename}: {str(e)}")
            return jsonify({'error': f'Failed to save file: {str(e)}'}), 500

        try:
            # Read the file to get sheets and headers
            if file.filename.endswith('.xlsx') or file.filename.endswith('.xls'):
                xl = pd.ExcelFile(file_path)
                sheets = {sheet_name: pd.read_excel(file_path, sheet_name=sheet_name, header=None) 
                         for sheet_name in xl.sheet_names}
            elif file.filename.endswith(('.txt', '.csv', '.dat')):
                df = pd.read_csv(file_path, header=None, encoding='utf-8')
                sheets = {'Sheet1': df}
            else:
                logging.error("Unsupported file type")
                return jsonify({'error': 'Unsupported file type'}), 400
            
            logging.debug(f"Sheets extracted: {list(sheets.keys())}")
        except Exception as e:
            logging.error(f"Failed to read file {file_path}: {str(e)}")
            return jsonify({'error': f'Failed to read file: {str(e)}'}), 400

        try:
            sheet_names = list(sheets.keys())
            if not sheet_names:
                logging.error("No sheets found in the file")
                return jsonify({'error': 'No sheets found in the file'}), 400
            sheet_name = sheet_names[0]
            df = sheets[sheet_name]
            
            # Find header row
            header_row = 0
            for i in range(min(len(df), 10)):
                row = df.iloc[i].dropna()
                if not row.empty and all(isinstance(x, str) for x in row if pd.notna(x)):
                    header_row = i
                    break
                    
            headers = df.iloc[header_row].tolist()
            logging.debug(f"Headers extracted: {headers}")
            
            if not headers or all(not h for h in headers):
                logging.error("No valid headers found in file")
                return jsonify({'error': 'No valid headers found in the file'}), 400
        except Exception as e:
            logging.error(f"Error processing file {file.filename}: {str(e)}")
            return jsonify({'error': f'Error processing file: {str(e)}'}), 400

        # Clear existing session data
        for key in ['df', 'header_row', 'headers', 'sheet_name', 'current_step', 'selected_headers', 'validations', 'error_cell_locations', 'data_rows', 'corrected_file_path']:
            session.pop(key, None)

        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)

            # Check if template exists
            cursor.execute("""
                SELECT template_id, headers, sheet_name
                FROM excel_templates
                WHERE template_name = %s AND user_id = %s AND status = 'ACTIVE'
                ORDER BY created_at DESC
            """, (file.filename, session['user_id']))
            existing_templates = cursor.fetchall()
            logging.info(f"Found {len(existing_templates)} existing templates with name {file.filename}")

            template_id = None
            has_existing_rules = False
            validations = {}
            selected_headers = []

            # Check for matching template
            matching_template = None
            for template in existing_templates:
                stored_headers = json.loads(template['headers']) if template['headers'] else []
                stored_sheet_name = template['sheet_name']
                if stored_headers == headers and stored_sheet_name == sheet_name:
                    matching_template = template
                    break

            if matching_template:
                template_id = matching_template['template_id']
                # Check for existing rules
                cursor.execute("""
                    SELECT tc.column_name, vrt.rule_name
                    FROM template_columns tc
                    JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                    JOIN validation_rule_types vrt ON cvr.rule_type_id = vrt.rule_type_id
                    WHERE tc.template_id = %s AND tc.is_selected = TRUE
                """, (template_id,))
                rules_data = cursor.fetchall()
                for row in rules_data:
                    column_name = row['column_name']
                    rule_name = row['rule_name']
                    if column_name not in validations:
                        validations[column_name] = []
                    validations[column_name].append(rule_name)
                    if column_name not in selected_headers:
                        selected_headers.append(column_name)
                has_existing_rules = len(validations) > 0
            else:
                # New template
                cursor.execute("""
                    INSERT INTO excel_templates (template_name, user_id, sheet_name, headers, is_corrected)
                    VALUES (%s, %s, %s, %s, %s)
                """, (file.filename, session['user_id'], sheet_name, json.dumps(headers), False))
                template_id = cursor.lastrowid
                column_data = [(template_id, header, i + 1, False) for i, header in enumerate(headers)]
                cursor.executemany("""
                    INSERT INTO template_columns (template_id, column_name, column_position, is_selected)
                    VALUES (%s, %s, %s, %s)
                """, column_data)

            conn.commit()
            cursor.close()

            # Store session data
            session['file_path'] = file_path
            session['template_id'] = template_id
            session['df'] = df.to_json()
            session['header_row'] = header_row
            session['headers'] = headers
            session['sheet_name'] = sheet_name
            session['current_step'] = 1 if not has_existing_rules else 3
            session['validations'] = validations
            session['selected_headers'] = selected_headers
            session['has_existing_rules'] = has_existing_rules

            logging.info(f"Upload processed: template_id={template_id}, filename={file.filename}, has_existing_rules={has_existing_rules}")

            return jsonify({
                'success': True,
                'sheets': {sheet_name: {'headers': headers}},
                'file_name': file.filename,
                'template_id': template_id,
                'has_existing_rules': has_existing_rules,
                'sheet_name': sheet_name,
                'skip_to_step_3': has_existing_rules
            })
        except mysql.connector.Error as e:
            logging.error(f'Error saving template: {str(e)}')
            return jsonify({'error': f'Error saving template: {str(e)}'}), 500
        except Exception as e:
            logging.error(f'Unexpected error saving template: {str(e)}')
            return jsonify({'error': f'Unexpected error: {str(e)}'}), 500

    # Multi-step workflow endpoints
    @app.route('/step/1', methods=['GET', 'POST'])
    @app.route('/api/step/1', methods=['GET', 'POST'])
    def step_one():
        if 'loggedin' not in session:
            return jsonify({'error': 'Not logged in'}), 401
        
        if request.method == 'POST':
            try:
                headers = request.form.getlist('headers')
                new_header_row = request.form.get('new_header_row')
                logging.debug(f"Step 1 submitted: headers={headers}, new_header_row={new_header_row}")
                
                if not headers:
                    logging.error("No headers provided in step 1")
                    return jsonify({'success': False, 'message': 'No headers provided'}), 400
                    
                if 'template_id' not in session:
                    logging.error("Session missing template_id")
                    return jsonify({'success': False, 'message': 'Session data missing'}), 400

                template_id = session['template_id']
                
                # Get the dataframe from session for auto-detection
                df_json = session.get('df')
                if df_json:
                    df = pd.read_json(StringIO(df_json))
                    session_headers = session.get('headers', [])
                    df.columns = session_headers
                    header_row = session.get('header_row', 0)
                    df = df.iloc[header_row + 1:].reset_index(drop=True)
                    
                    # Auto-detect rules for selected headers
                    validations = assign_default_rules_to_columns(df, headers)
                    session['validations'] = validations
                    logging.debug(f"Auto-assigned rules: {validations}")
                else:
                    validations = {}

                session['selected_headers'] = headers
                session['current_step'] = 2

                # Mark selected headers in the database
                conn = get_db_connection()
                cursor = conn.cursor()
                cursor.execute("UPDATE template_columns SET is_selected = FALSE WHERE template_id = %s", (template_id,))
                for header in headers:
                    cursor.execute("""
                        UPDATE template_columns
                        SET is_selected = TRUE
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    
                    # Get column_id and add auto-detected rules
                    cursor.execute("""
                        SELECT column_id FROM template_columns
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    result = cursor.fetchone()
                    if result:
                        column_id = result[0]
                        for rule_name in validations.get(header, []):
                            cursor.execute("""
                                SELECT rule_type_id FROM validation_rule_types
                                WHERE rule_name = %s AND is_custom = FALSE
                            """, (rule_name,))
                            rule_result = cursor.fetchone()
                            if rule_result:
                                rule_type_id = rule_result[0]
                                cursor.execute("""
                                    INSERT IGNORE INTO column_validation_rules (column_id, rule_type_id, rule_config)
                                    VALUES (%s, %s, %s)
                                """, (column_id, rule_type_id, '{}'))
                
                conn.commit()
                cursor.close()

                logging.info(f"Step 1 completed: headers={headers}, auto-assigned rules={validations}")
                return jsonify({'success': True, 'headers': headers, 'validations': validations})
            except Exception as e:
                logging.error(f"Error in step 1: {str(e)}")
                return jsonify({'success': False, 'message': str(e)}), 500
        
        # GET request - return current headers
        headers = session.get('headers', [])
        return jsonify({'headers': headers})

    @app.route('/step/2', methods=['GET', 'POST'])
    @app.route('/api/step/2', methods=['GET', 'POST'])
    def step_two():
        if 'loggedin' not in session:
            return jsonify({'error': 'Not logged in'}), 401
            
        if request.method == 'POST':
            try:
                action = request.form.get('action', 'save')
                validations = {}
                for key, values in request.form.lists():
                    if key.startswith('validations_'):
                        header = key.replace('validations_', '')
                        validations[header] = values
                        
                logging.debug(f"Step 2 submitted: action={action}, validations={validations}")
                
                template_id = session.get('template_id')
                if not template_id:
                    return jsonify({'success': False, 'message': 'Session data missing'}), 400

                # Save validations to database
                conn = get_db_connection()
                cursor = conn.cursor()
                
                # Clear existing rules
                cursor.execute("""
                    DELETE FROM column_validation_rules
                    WHERE column_id IN (
                        SELECT column_id FROM template_columns WHERE template_id = %s
                    )
                """, (template_id,))
                
                # Add new rules
                for header, rules in validations.items():
                    cursor.execute("""
                        SELECT column_id FROM template_columns
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    result = cursor.fetchone()
                    if not result:
                        continue
                    column_id = result[0]
                    
                    for rule_name in rules:
                        cursor.execute("""
                            SELECT rule_type_id FROM validation_rule_types
                            WHERE rule_name = %s
                        """, (rule_name,))
                        result = cursor.fetchone()
                        if result:
                            rule_type_id = result[0]
                            cursor.execute("""
                                INSERT IGNORE INTO column_validation_rules (column_id, rule_type_id, rule_config)
                                VALUES (%s, %s, %s)
                            """, (column_id, rule_type_id, '{}'))
                
                conn.commit()
                cursor.close()

                session['validations'] = validations
                session['current_step'] = 3 if action == 'review' else 2
                
                logging.info(f"Step 2 completed: action={action}, validations={validations}")
                return jsonify({'success': True, 'message': 'Step 2 completed successfully'})
            except Exception as e:
                logging.error(f"Error in step 2: {str(e)}")
                return jsonify({'success': False, 'message': str(e)}), 500
        
        # GET request
        selected_headers = session.get('selected_headers', [])
        return jsonify({'selected_headers': selected_headers})

    # Rules endpoint
    @app.route('/rules', methods=['GET'])
    @app.route('/api/rules', methods=['GET'])
    def get_rules():
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            
            cursor.execute("""
                SELECT rule_type_id AS rule_id, rule_name, description, parameters, is_custom, 
                       column_name, template_id, source_format, target_format, data_type, is_active
                FROM validation_rule_types
            """)
            rules = cursor.fetchall()
            cursor.close()
            
            logging.info(f"Returning {len(rules)} rules from getRules endpoint")
            return jsonify({'success': True, 'rules': rules})
        except mysql.connector.Error as e:
            logging.error(f"Database error fetching rules: {str(e)}")
            return jsonify({'success': False, 'message': str(e)}), 500
        except Exception as e:
            logging.error(f"Unexpected error fetching rules: {str(e)}")
            return jsonify({'success': False, 'message': str(e)}), 500

    # Template details endpoint
    @app.route('/template/<int:template_id>/<sheet_name>', methods=['GET'])
    @app.route('/api/template/<int:template_id>/<sheet_name>', methods=['GET'])
    def get_template(template_id, sheet_name):
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /template: session missing")
            return jsonify({'error': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("""
                SELECT template_name, sheet_name, headers
                FROM excel_templates
                WHERE template_id = %s AND user_id = %s AND status = 'ACTIVE'
            """, (template_id, session['user_id']))
            template_record = cursor.fetchone()
            
            if not template_record:
                logging.error(f"Template not found for template_id: {template_id}, user_id: {session['user_id']}")
                cursor.close()
                return jsonify({'error': 'Template not found'}), 404

            headers = json.loads(template_record['headers']) if template_record['headers'] else []
            stored_sheet_name = template_record['sheet_name'] or sheet_name
            file_path = os.path.join(app.config['UPLOAD_FOLDER'], template_record['template_name'])
            
            cursor.execute("""
                SELECT COUNT(*) as rule_count
                FROM template_columns tc
                JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                WHERE tc.template_id = %s AND tc.is_selected = TRUE
            """, (template_id,))
            rule_count = cursor.fetchone()['rule_count']
            has_existing_rules = rule_count > 0
            
            cursor.close()
            
            return jsonify({
                'success': True,
                'sheets': {stored_sheet_name: {'headers': headers}},
                'file_name': template_record['template_name'],
                'file_path': file_path,
                'sheet_name': stored_sheet_name,
                'has_existing_rules': has_existing_rules
            })
        except mysql.connector.Error as e:
            logging.error(f"Database error in get_template: {str(e)}")
            return jsonify({'error': f'Database error: {str(e)}'}), 500
        except Exception as e:
            logging.error(f"Unexpected error in get_template: {str(e)}")
            return jsonify({'error': f'Unexpected error: {str(e)}'}), 500

    # Debug route to show all registered routes
    @app.route('/debug/routes', methods=['GET'])
    def list_routes():
        routes = []
        for rule in app.url_map.iter_rules():
            routes.append({
                'endpoint': rule.endpoint,
                'methods': list(rule.methods),
                'rule': rule.rule
            })
        return jsonify(routes)

    # 404 handler to debug missing routes
    @app.errorhandler(404)
    def not_found_handler(error):
        logging.error(f"404 Error: {request.method} {request.url} not found")
        logging.error(f"Available routes: {[rule.rule for rule in app.url_map.iter_rules()]}")
        return jsonify({
            'error': 'Endpoint not found', 
            'method': request.method,
            'url': request.url,
            'path': request.path
        }), 404

    return app

def initialize_app_data():
    """Initialize database and create default data"""
    try:
        logging.info("Initializing database schema...")
        init_db()
        
        logging.info("Creating admin user...")
        create_admin_user()
        
        logging.info("Creating default validation rules...")
        create_default_validation_rules()
        
        logging.info("Application initialization completed successfully")
    except Exception as e:
        logging.error(f"Failed to initialize application: {e}")
        raise

DB_CONFIG = {
    'host': os.getenv('MYSQL_HOST', 'localhost'),
    'user': os.getenv('MYSQL_USER', 'root'),
    'password': os.getenv('MYSQL_PASSWORD', 'Keansa@2024'),
    'database': os.getenv('MYSQL_DATABASE', 'data_validation_2'),
}

def get_db_connection():
    if 'db' not in g:
        try:
            conn = mysql.connector.connect(
                host=DB_CONFIG['host'],
                user=DB_CONFIG['user'],
                password=DB_CONFIG['password']
            )
            cursor = conn.cursor()
            cursor.execute(f"CREATE DATABASE IF NOT EXISTS {DB_CONFIG['database']}")
            cursor.close()
            conn.close()
            g.db = mysql.connector.connect(**DB_CONFIG)
            logging.info("Database connection established successfully")
        except mysql.connector.Error as err:
            if err.errno == errorcode.ER_ACCESS_DENIED_ERROR:
                logging.error("Database connection failed: Access denied for user - check username/password")
            elif err.errno == errorcode.ER_BAD_DB_ERROR:
                logging.error("Database connection failed: Database does not exist")
            else:
                logging.error(f"Database connection failed: {err}")
            raise Exception(f"Failed to connect to database: {str(err)}")
    return g.db

def close_db(error):
    db = g.pop('db', None)
    if db is not None:
        db.close()

def init_db():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        tables = [
            """
            CREATE TABLE IF NOT EXISTS login_details (
                id INT AUTO_INCREMENT PRIMARY KEY,
                first_name VARCHAR(100),
                last_name VARCHAR(100),
                email VARCHAR(255) UNIQUE,
                mobile VARCHAR(10),
                password VARCHAR(255)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS excel_templates (
                template_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_name VARCHAR(255) NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
                user_id INT NOT NULL,
                sheet_name VARCHAR(255),
                headers JSON,
                status ENUM('ACTIVE', 'INACTIVE') DEFAULT 'ACTIVE',
                is_corrected BOOLEAN DEFAULT FALSE,
                remote_file_path VARCHAR(512),
                FOREIGN KEY (user_id) REFERENCES login_details(id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS template_columns (
                column_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_id BIGINT NOT NULL,
                column_name VARCHAR(255) NOT NULL,
                column_position INT NOT NULL,
                is_validation_enabled BOOLEAN DEFAULT FALSE,
                is_selected BOOLEAN DEFAULT FALSE,
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE,
                UNIQUE (template_id, column_name)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_rule_types (
                rule_type_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                rule_name VARCHAR(255) NOT NULL,
                description TEXT,
                parameters TEXT,
                is_active BOOLEAN DEFAULT TRUE,
                is_custom BOOLEAN DEFAULT FALSE,
                column_name VARCHAR(255),
                template_id BIGINT,
                data_type VARCHAR(50),
                source_format VARCHAR(50),
                target_format VARCHAR(50),
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS column_validation_rules (
                column_validation_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                column_id BIGINT NOT NULL,
                rule_type_id BIGINT NOT NULL,
                rule_config JSON,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (column_id) REFERENCES template_columns(column_id) ON DELETE CASCADE,
                FOREIGN KEY (rule_type_id) REFERENCES validation_rule_types(rule_type_id) ON DELETE RESTRICT,
                UNIQUE (column_id, rule_type_id)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_history (
                history_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_id BIGINT NOT NULL,
                template_name VARCHAR(255) NOT NULL,
                error_count INT NOT NULL,
                corrected_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                corrected_file_path VARCHAR(512) NOT NULL,
                user_id INT NOT NULL,
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE,
                FOREIGN KEY (user_id) REFERENCES login_details(id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_corrections (
                correction_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                history_id BIGINT NOT NULL,
                row_index INT NOT NULL,
                column_name VARCHAR(255) NOT NULL,
                original_value TEXT,
                corrected_value TEXT,
                rule_failed VARCHAR(255) DEFAULT NULL,
                FOREIGN KEY (history_id) REFERENCES validation_history(history_id) ON DELETE CASCADE
            )
            """
        ]
        for table_sql in tables:
            cursor.execute(table_sql)
        
        # Add missing columns if they don't exist
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'source_format'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN source_format VARCHAR(50)")
            logging.info("Added source_format column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'target_format'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN target_format VARCHAR(50)")
            logging.info("Added target_format column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'data_type'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN data_type VARCHAR(50)")
            logging.info("Added data_type column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM excel_templates LIKE 'remote_file_path'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE excel_templates ADD COLUMN remote_file_path VARCHAR(512)")
            logging.info("Added remote_file_path column to excel_templates table")
            
        cursor.execute("SHOW COLUMNS FROM template_columns LIKE 'is_selected'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE template_columns ADD COLUMN is_selected BOOLEAN DEFAULT FALSE")
            logging.info("Added is_selected column to template_columns table")
            
        conn.commit()
        cursor.close()
        logging.info("Database tables initialized")
    except Exception as e:
        logging.error(f"Failed to initialize database: {str(e)}")
        raise

def create_admin_user():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        admin_password = bcrypt.hashpw('admin'.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
        cursor.execute("""
            INSERT IGNORE INTO login_details (first_name, last_name, email, mobile, password)
            VALUES (%s, %s, %s, %s, %s)
        """, ('Admin', 'User', 'admin@example.com', '1234567890', admin_password))
        conn.commit()
        cursor.close()
        logging.info("Admin user created or already exists")
    except Exception as e:
        logging.error(f"Failed to create admin user: {str(e)}")
        raise

def create_default_validation_rules():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        default_rules = [
            ("Required", "Ensures the field is not null", '{"allow_null": false}', None, None, None),
            ("Int", "Validates integer format", '{"format": "integer"}', None, None, "Int"),
            ("Float", "Validates number format (integer or decimal)", '{"format": "float"}', None, None, "Float"),
            ("Text", "Allows text with quotes and parentheses", '{"allow_special": false}', None, None, "Text"),
            ("Email", "Validates email format", '{"regex": "^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\\\.[a-zA-Z0-9-.]+$"}', None, None, "Email"),
            ("Date(DD-MM-YYYY)", "Validates date format DD-MM-YYYY", '{"format": "%d-%m-%Y"}', "DD-MM-YYYY", None, "Date"),
            ("Boolean", "Validates boolean format (true/false or 0/1)", '{"format": "boolean"}', None, None, "Boolean"),
            ("Alphanumeric", "Validates alphanumeric format", '{"format": "alphanumeric"}', None, None, "Alphanumeric")
        ]
        cursor.executemany("""
            INSERT IGNORE INTO validation_rule_types (rule_name, description, parameters, is_custom, source_format, target_format, data_type)
            VALUES (%s, %s, %s, %s, %s, %s, %s)
        """, [(name, desc, params, False, source, target, dtype) for name, desc, params, source, target, dtype in default_rules])
        conn.commit()
        cursor.close()
        logging.info("Default validation rules ensured successfully")
    except Exception as e:
        logging.error(f"Failed to ensure default validation rules: {str(e)}")
        raise

if __name__ == '__main__':
    try:
        # Create the application using factory pattern
        app = create_app()
        
        # Initialize database and default data within app context
        with app.app_context():
            initialize_app_data()
        
        # Get port from environment or use default
        port = int(os.getenv('PORT', 5000))
        
        # Start the application server
        logging.info("Starting Flask server...")
        app.run(debug=True, host='0.0.0.0', port=port)
        
    except Exception as e:
        logging.error(f"Failed to start application: {e}")
        raise
).all():
        return "Email"
    
    # Date pattern detection
    try:
        pd.to_datetime(non_null, format="%d-%m-%Y")
        return "Date"
    except Exception:
        try:
            pd.to_datetime(non_null, format="%Y-%m-%d")
            return "Date"
        except Exception:
            pass
    
    # Boolean detection
    if non_null.str.lower().isin(['true', 'false', '0', '1']).all():
        return "Boolean"
    
    # Numeric detection
    if non_null.str.match(r'^-?\d+

def create_app():
    """Application factory pattern for different environments"""
    # Set the path to the frontend dist folder
    current_dir = os.path.dirname(os.path.abspath(__file__))
    frontend_dist_path = os.path.join(current_dir, '..', '..', 'Keansa-Ai-Suite2025may-frontend11', 'dist')
    frontend_dist_path = os.path.abspath(frontend_dist_path)
    
    # Create Flask application instance
    app = Flask(__name__, static_folder=frontend_dist_path, static_url_path='')
    CORS(app, supports_credentials=True, origins=["http://localhost:3000", "http://localhost:8080", "http://localhost:5000", "*"])

    app.secret_key = os.urandom(24).hex()
    app.config['SESSION_TYPE'] = 'filesystem'
    app.config['SESSION_FILE_DIR'] = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'sessions')
    app.config['SESSION_COOKIE_SAMESITE'] = 'Lax'
    app.config['SESSION_COOKIE_HTTPONLY'] = True
    app.config['SESSION_COOKIE_SECURE'] = False
    app.config['PERMANENT_SESSION_LIFETIME'] = 86400  # 24 hours
    app.config['UPLOAD_FOLDER'] = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'uploads')
    Session(app)

    # Ensure directories exist
    try:
        os.makedirs(app.config['UPLOAD_FOLDER'], exist_ok=True)
        os.makedirs(app.config['SESSION_FILE_DIR'], exist_ok=True)
    except OSError as e:
        logging.error(f"Failed to create directories: {e}")

    # Register cleanup handlers
    app.teardown_appcontext(close_db)
    
    # Register all routes directly in create_app
    
    # Static file serving for React frontend
    @app.route('/', defaults={'path': ''})
    @app.route('/<path:path>')
    def serve(path):
        if path and os.path.exists(os.path.join(app.static_folder, path)):
            return app.send_static_file(path)
        return app.send_static_file('index.html')

    # Health check endpoint
    @app.route('/health', methods=['GET'])
    def health_check():
        return jsonify({
            'status': 'healthy',
            'timestamp': datetime.now().isoformat(),
            'version': '2.0.0'
        })

    # Authentication endpoint - both old and new paths
    @app.route('/authenticate', methods=['POST'])
    @app.route('/api/auth/authenticate', methods=['POST'])
    def authenticate():
        try:
            email = request.form.get('username') or request.form.get('email')
            password = request.form.get('password')
            logging.debug(f"Login attempt: email={email}, password={'*' * len(password) if password else 'None'}")
            
            if not email or not password:
                logging.warning(f"Login failed: Email or password missing")
                return jsonify({'success': False, 'message': 'Email and password are required'}), 400

            # Check for admin login
            if email == "admin" and password == "admin":
                session['loggedin'] = True
                session['user_email'] = "admin@example.com"
                session['user_id'] = 1
                session.permanent = True
                logging.info(f"Admin login successful. Session: {dict(session)}")
                return jsonify({'success': True, 'message': 'Login successful', 'user': {'email': 'admin@example.com', 'id': 1}}), 200

            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("SELECT * FROM login_details WHERE LOWER(email) = LOWER(%s)", (email.lower(),))
            account = cursor.fetchone()
            cursor.close()
            
            if account:
                if bcrypt.checkpw(password.encode('utf-8'), account['password'].encode('utf-8')):
                    session['loggedin'] = True
                    session['user_email'] = account['email']
                    session['user_id'] = account['id']
                    session.permanent = True
                    logging.info(f"User {email} logged in successfully. Session: {dict(session)}")
                    return jsonify({
                        'success': True,
                        'message': 'Login successful',
                        'user': {'email': account['email'], 'id': account['id']}
                    }), 200
                else:
                    logging.warning(f"Invalid password for {email}")
                    return jsonify({'success': False, 'message': 'Invalid credentials'}), 401
            else:
                logging.warning(f"Email {email} not found")
                return jsonify({'success': False, 'message': 'Invalid credentials'}), 401
        except Exception as e:
            logging.error(f"Unexpected error during login: {str(e)}")
            return jsonify({'success': False, 'message': f'Unexpected error: {str(e)}'}), 500

    @app.route('/check-auth', methods=['GET'])
    @app.route('/api/auth/check-auth', methods=['GET'])
    def check_auth():
        try:
            logging.debug(f"Checking auth with session: {dict(session)}")
            if 'loggedin' in session and 'user_id' in session:
                conn = get_db_connection()
                cursor = conn.cursor(dictionary=True)
                cursor.execute("SELECT email, first_name FROM login_details WHERE id = %s", (session['user_id'],))
                user = cursor.fetchone()
                cursor.close()
                if user:
                    logging.info(f"User {session.get('user_email')} is authenticated")
                    return jsonify({
                        'success': True,
                        'user': {
                            'email': user['email'],
                            'id': session['user_id'],
                            'first_name': user['first_name']
                        }
                    })
                else:
                    logging.warning("User not found in database")  
                    session.clear()
                    return jsonify({'success': False, 'message': 'User not found'}), 401
            logging.warning("User not authenticated")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        except Exception as e:
            logging.error(f"Error in check-auth endpoint: {str(e)}")
            return jsonify({'success': False, 'message': f'Server error: {str(e)}'}), 500

    @app.route('/register', methods=['POST'])
    @app.route('/api/auth/register', methods=['POST'])
    def register():
        first_name = request.form.get('first_name')
        last_name = request.form.get('last_name')
        email = request.form.get('email')
        mobile = request.form.get('mobile')
        password = request.form.get('password')
        confirm_password = request.form.get('confirm_password')

        if not all([first_name, last_name, email, mobile, password, confirm_password]):
            return jsonify({'success': False, 'message': 'All fields are required'}), 400
        if password != confirm_password:
            return jsonify({'success': False, 'message': 'Passwords do not match'}), 400

        hashed_password = bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
        try:
            conn = get_db_connection()
            cursor = conn.cursor()
            cursor.execute("""
                INSERT INTO login_details (first_name, last_name, email, mobile, password)
                VALUES (%s, %s, %s, %s, %s)
            """, (first_name, last_name, email, mobile, hashed_password))
            user_id = cursor.lastrowid
            conn.commit()
            cursor.close()
            session['loggedin'] = True
            session['user_email'] = email
            session['user_id'] = user_id
            return jsonify({
                'success': True,
                'message': 'Registration successful',
                'user': {'email': email, 'id': user_id}
            }), 200
        except mysql.connector.Error as e:
            logging.error(f"Database error during registration: {str(e)}")
            return jsonify({'success': False, 'message': f'Registration error: {str(e)}'}), 500

    @app.route('/logout', methods=['POST'])
    @app.route('/api/auth/logout', methods=['POST'])
    def logout():
        logging.info(f"User {session.get('user_email', 'unknown')} logged out")
        session.clear()
        return jsonify({'success': True, 'message': 'Logged out successfully'})

    # Template routes
    @app.route('/templates', methods=['GET'])
    @app.route('/api/templates', methods=['GET'])
    def get_templates():
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /templates: session missing")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("""
                SELECT template_id, template_name, created_at, status
                FROM excel_templates
                WHERE user_id = %s AND status = 'ACTIVE'
                ORDER BY created_at DESC
                LIMIT 100
            """, (session['user_id'],))
            templates = cursor.fetchall()
            cursor.close()
            logging.info(f"Fetched {len(templates)} templates for user {session['user_id']}")
            return jsonify({'success': True, 'templates': templates})
        except mysql.connector.Error as e:
            logging.error(f'Error fetching templates: {str(e)}')
            return jsonify({'success': False, 'message': f'Error fetching templates: {str(e)}'}), 500
        except Exception as e:
            logging.error(f'Unexpected error fetching templates: {str(e)}')
            return jsonify({'success': False, 'message': f'Unexpected error: {str(e)}'}), 500

    # Rule Configuration routes
    @app.route('/rule-configurations', methods=['GET'])
    @app.route('/api/validation/rule-configurations', methods=['GET'])
    def get_rule_configurations():
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning(f"Unauthorized access to /rule-configurations: session={dict(session)}")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            user_id = session['user_id']
            logging.debug(f"Fetching rule configurations for user_id: {user_id}")

            # Main query to fetch templates with configured rules
            cursor.execute("""
                SELECT 
                    t.template_id, 
                    t.template_name, 
                    t.created_at, 
                    COUNT(cvr.column_validation_id) as rule_count
                FROM excel_templates t
                LEFT JOIN template_columns tc ON t.template_id = tc.template_id
                LEFT JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                WHERE t.user_id = %s AND t.status = 'ACTIVE' AND t.is_corrected = FALSE
                GROUP BY t.template_id, t.template_name, t.created_at
                HAVING rule_count > 0
                ORDER BY t.created_at DESC
                LIMIT 100
            """, (user_id,))
            templates = cursor.fetchall()
            logging.debug(f"Fetched rule-configured templates: {templates}")

            cursor.close()

            if not templates:
                logging.info(f"No templates with rules found for user_id: {user_id}")
            else:
                logging.info(f"Found {len(templates)} templates with rules for user_id: {user_id}")

            return jsonify({'success': True, 'templates': templates})
        except mysql.connector.Error as e:
            logging.error(f"Database error fetching rule configurations: {str(e)}")
            return jsonify({'success': False, 'message': f"Database error: {str(e)}"}), 500
        except Exception as e:
            logging.error(f"Unexpected error fetching rule configurations: {str(e)}")
            return jsonify({'success': False, 'message': f"Unexpected error: {str(e)}"}), 500

    # File upload route
    @app.route('/upload', methods=['POST'])
    @app.route('/api/templates/upload', methods=['POST'])
    @app.route('/api/upload', methods=['POST'])  # Additional common path
    def upload():
        logging.info(f"Upload endpoint called: {request.endpoint}, method: {request.method}")
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /upload: session missing")
            return jsonify({'error': 'Not logged in'}), 401
        if 'file' not in request.files:
            logging.warning("No file provided in upload request")
            return jsonify({'error': 'No file uploaded'}), 400
        file = request.files['file']
        if file.filename == '':
            logging.warning("No file selected in upload request")
            return jsonify({'error': 'No file selected'}), 400
        
        file_path = os.path.join(app.config['UPLOAD_FOLDER'], file.filename)
        try:
            file.save(file_path)
            logging.info(f"File saved: {file_path}")
        except Exception as e:
            logging.error(f"Failed to save file {file.filename}: {str(e)}")
            return jsonify({'error': f'Failed to save file: {str(e)}'}), 500

        try:
            # Read the file to get sheets and headers
            if file.filename.endswith('.xlsx') or file.filename.endswith('.xls'):
                xl = pd.ExcelFile(file_path)
                sheets = {sheet_name: pd.read_excel(file_path, sheet_name=sheet_name, header=None) 
                         for sheet_name in xl.sheet_names}
            elif file.filename.endswith(('.txt', '.csv', '.dat')):
                df = pd.read_csv(file_path, header=None, encoding='utf-8')
                sheets = {'Sheet1': df}
            else:
                logging.error("Unsupported file type")
                return jsonify({'error': 'Unsupported file type'}), 400
            
            logging.debug(f"Sheets extracted: {list(sheets.keys())}")
        except Exception as e:
            logging.error(f"Failed to read file {file_path}: {str(e)}")
            return jsonify({'error': f'Failed to read file: {str(e)}'}), 400

        try:
            sheet_names = list(sheets.keys())
            if not sheet_names:
                logging.error("No sheets found in the file")
                return jsonify({'error': 'No sheets found in the file'}), 400
            sheet_name = sheet_names[0]
            df = sheets[sheet_name]
            
            # Find header row
            header_row = 0
            for i in range(min(len(df), 10)):
                row = df.iloc[i].dropna()
                if not row.empty and all(isinstance(x, str) for x in row if pd.notna(x)):
                    header_row = i
                    break
                    
            headers = df.iloc[header_row].tolist()
            logging.debug(f"Headers extracted: {headers}")
            
            if not headers or all(not h for h in headers):
                logging.error("No valid headers found in file")
                return jsonify({'error': 'No valid headers found in the file'}), 400
        except Exception as e:
            logging.error(f"Error processing file {file.filename}: {str(e)}")
            return jsonify({'error': f'Error processing file: {str(e)}'}), 400

        # Clear existing session data
        for key in ['df', 'header_row', 'headers', 'sheet_name', 'current_step', 'selected_headers', 'validations', 'error_cell_locations', 'data_rows', 'corrected_file_path']:
            session.pop(key, None)

        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)

            # Check if template exists
            cursor.execute("""
                SELECT template_id, headers, sheet_name
                FROM excel_templates
                WHERE template_name = %s AND user_id = %s AND status = 'ACTIVE'
                ORDER BY created_at DESC
            """, (file.filename, session['user_id']))
            existing_templates = cursor.fetchall()
            logging.info(f"Found {len(existing_templates)} existing templates with name {file.filename}")

            template_id = None
            has_existing_rules = False
            validations = {}
            selected_headers = []

            # Check for matching template
            matching_template = None
            for template in existing_templates:
                stored_headers = json.loads(template['headers']) if template['headers'] else []
                stored_sheet_name = template['sheet_name']
                if stored_headers == headers and stored_sheet_name == sheet_name:
                    matching_template = template
                    break

            if matching_template:
                template_id = matching_template['template_id']
                # Check for existing rules
                cursor.execute("""
                    SELECT tc.column_name, vrt.rule_name
                    FROM template_columns tc
                    JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                    JOIN validation_rule_types vrt ON cvr.rule_type_id = vrt.rule_type_id
                    WHERE tc.template_id = %s AND tc.is_selected = TRUE
                """, (template_id,))
                rules_data = cursor.fetchall()
                for row in rules_data:
                    column_name = row['column_name']
                    rule_name = row['rule_name']
                    if column_name not in validations:
                        validations[column_name] = []
                    validations[column_name].append(rule_name)
                    if column_name not in selected_headers:
                        selected_headers.append(column_name)
                has_existing_rules = len(validations) > 0
            else:
                # New template
                cursor.execute("""
                    INSERT INTO excel_templates (template_name, user_id, sheet_name, headers, is_corrected)
                    VALUES (%s, %s, %s, %s, %s)
                """, (file.filename, session['user_id'], sheet_name, json.dumps(headers), False))
                template_id = cursor.lastrowid
                column_data = [(template_id, header, i + 1, False) for i, header in enumerate(headers)]
                cursor.executemany("""
                    INSERT INTO template_columns (template_id, column_name, column_position, is_selected)
                    VALUES (%s, %s, %s, %s)
                """, column_data)

            conn.commit()
            cursor.close()

            # Store session data
            session['file_path'] = file_path
            session['template_id'] = template_id
            session['df'] = df.to_json()
            session['header_row'] = header_row
            session['headers'] = headers
            session['sheet_name'] = sheet_name
            session['current_step'] = 1 if not has_existing_rules else 3
            session['validations'] = validations
            session['selected_headers'] = selected_headers
            session['has_existing_rules'] = has_existing_rules

            logging.info(f"Upload processed: template_id={template_id}, filename={file.filename}, has_existing_rules={has_existing_rules}")

            return jsonify({
                'success': True,
                'sheets': {sheet_name: {'headers': headers}},
                'file_name': file.filename,
                'template_id': template_id,
                'has_existing_rules': has_existing_rules,
                'sheet_name': sheet_name,
                'skip_to_step_3': has_existing_rules
            })
        except mysql.connector.Error as e:
            logging.error(f'Error saving template: {str(e)}')
            return jsonify({'error': f'Error saving template: {str(e)}'}), 500
        except Exception as e:
            logging.error(f'Unexpected error saving template: {str(e)}')
            return jsonify({'error': f'Unexpected error: {str(e)}'}), 500

    # Multi-step workflow endpoints
    @app.route('/step/1', methods=['GET', 'POST'])
    @app.route('/api/step/1', methods=['GET', 'POST'])
    def step_one():
        if 'loggedin' not in session:
            return jsonify({'error': 'Not logged in'}), 401
        
        if request.method == 'POST':
            try:
                headers = request.form.getlist('headers')
                new_header_row = request.form.get('new_header_row')
                logging.debug(f"Step 1 submitted: headers={headers}, new_header_row={new_header_row}")
                
                if not headers:
                    logging.error("No headers provided in step 1")
                    return jsonify({'success': False, 'message': 'No headers provided'}), 400
                    
                if 'template_id' not in session:
                    logging.error("Session missing template_id")
                    return jsonify({'success': False, 'message': 'Session data missing'}), 400

                template_id = session['template_id']
                
                # Get the dataframe from session for auto-detection
                df_json = session.get('df')
                if df_json:
                    df = pd.read_json(StringIO(df_json))
                    session_headers = session.get('headers', [])
                    df.columns = session_headers
                    header_row = session.get('header_row', 0)
                    df = df.iloc[header_row + 1:].reset_index(drop=True)
                    
                    # Auto-detect rules for selected headers
                    validations = assign_default_rules_to_columns(df, headers)
                    session['validations'] = validations
                    logging.debug(f"Auto-assigned rules: {validations}")
                else:
                    validations = {}

                session['selected_headers'] = headers
                session['current_step'] = 2

                # Mark selected headers in the database
                conn = get_db_connection()
                cursor = conn.cursor()
                cursor.execute("UPDATE template_columns SET is_selected = FALSE WHERE template_id = %s", (template_id,))
                for header in headers:
                    cursor.execute("""
                        UPDATE template_columns
                        SET is_selected = TRUE
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    
                    # Get column_id and add auto-detected rules
                    cursor.execute("""
                        SELECT column_id FROM template_columns
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    result = cursor.fetchone()
                    if result:
                        column_id = result[0]
                        for rule_name in validations.get(header, []):
                            cursor.execute("""
                                SELECT rule_type_id FROM validation_rule_types
                                WHERE rule_name = %s AND is_custom = FALSE
                            """, (rule_name,))
                            rule_result = cursor.fetchone()
                            if rule_result:
                                rule_type_id = rule_result[0]
                                cursor.execute("""
                                    INSERT IGNORE INTO column_validation_rules (column_id, rule_type_id, rule_config)
                                    VALUES (%s, %s, %s)
                                """, (column_id, rule_type_id, '{}'))
                
                conn.commit()
                cursor.close()

                logging.info(f"Step 1 completed: headers={headers}, auto-assigned rules={validations}")
                return jsonify({'success': True, 'headers': headers, 'validations': validations})
            except Exception as e:
                logging.error(f"Error in step 1: {str(e)}")
                return jsonify({'success': False, 'message': str(e)}), 500
        
        # GET request - return current headers
        headers = session.get('headers', [])
        return jsonify({'headers': headers})

    @app.route('/step/2', methods=['GET', 'POST'])
    @app.route('/api/step/2', methods=['GET', 'POST'])
    def step_two():
        if 'loggedin' not in session:
            return jsonify({'error': 'Not logged in'}), 401
            
        if request.method == 'POST':
            try:
                action = request.form.get('action', 'save')
                validations = {}
                for key, values in request.form.lists():
                    if key.startswith('validations_'):
                        header = key.replace('validations_', '')
                        validations[header] = values
                        
                logging.debug(f"Step 2 submitted: action={action}, validations={validations}")
                
                template_id = session.get('template_id')
                if not template_id:
                    return jsonify({'success': False, 'message': 'Session data missing'}), 400

                # Save validations to database
                conn = get_db_connection()
                cursor = conn.cursor()
                
                # Clear existing rules
                cursor.execute("""
                    DELETE FROM column_validation_rules
                    WHERE column_id IN (
                        SELECT column_id FROM template_columns WHERE template_id = %s
                    )
                """, (template_id,))
                
                # Add new rules
                for header, rules in validations.items():
                    cursor.execute("""
                        SELECT column_id FROM template_columns
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    result = cursor.fetchone()
                    if not result:
                        continue
                    column_id = result[0]
                    
                    for rule_name in rules:
                        cursor.execute("""
                            SELECT rule_type_id FROM validation_rule_types
                            WHERE rule_name = %s
                        """, (rule_name,))
                        result = cursor.fetchone()
                        if result:
                            rule_type_id = result[0]
                            cursor.execute("""
                                INSERT IGNORE INTO column_validation_rules (column_id, rule_type_id, rule_config)
                                VALUES (%s, %s, %s)
                            """, (column_id, rule_type_id, '{}'))
                
                conn.commit()
                cursor.close()

                session['validations'] = validations
                session['current_step'] = 3 if action == 'review' else 2
                
                logging.info(f"Step 2 completed: action={action}, validations={validations}")
                return jsonify({'success': True, 'message': 'Step 2 completed successfully'})
            except Exception as e:
                logging.error(f"Error in step 2: {str(e)}")
                return jsonify({'success': False, 'message': str(e)}), 500
        
        # GET request
        selected_headers = session.get('selected_headers', [])
        return jsonify({'selected_headers': selected_headers})

    # Rules endpoint
    @app.route('/rules', methods=['GET'])
    @app.route('/api/rules', methods=['GET'])
    def get_rules():
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            
            cursor.execute("""
                SELECT rule_type_id AS rule_id, rule_name, description, parameters, is_custom, 
                       column_name, template_id, source_format, target_format, data_type, is_active
                FROM validation_rule_types
            """)
            rules = cursor.fetchall()
            cursor.close()
            
            logging.info(f"Returning {len(rules)} rules from getRules endpoint")
            return jsonify({'success': True, 'rules': rules})
        except mysql.connector.Error as e:
            logging.error(f"Database error fetching rules: {str(e)}")
            return jsonify({'success': False, 'message': str(e)}), 500
        except Exception as e:
            logging.error(f"Unexpected error fetching rules: {str(e)}")
            return jsonify({'success': False, 'message': str(e)}), 500

    # Template details endpoint
    @app.route('/template/<int:template_id>/<sheet_name>', methods=['GET'])
    @app.route('/api/template/<int:template_id>/<sheet_name>', methods=['GET'])
    def get_template(template_id, sheet_name):
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /template: session missing")
            return jsonify({'error': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("""
                SELECT template_name, sheet_name, headers
                FROM excel_templates
                WHERE template_id = %s AND user_id = %s AND status = 'ACTIVE'
            """, (template_id, session['user_id']))
            template_record = cursor.fetchone()
            
            if not template_record:
                logging.error(f"Template not found for template_id: {template_id}, user_id: {session['user_id']}")
                cursor.close()
                return jsonify({'error': 'Template not found'}), 404

            headers = json.loads(template_record['headers']) if template_record['headers'] else []
            stored_sheet_name = template_record['sheet_name'] or sheet_name
            file_path = os.path.join(app.config['UPLOAD_FOLDER'], template_record['template_name'])
            
            cursor.execute("""
                SELECT COUNT(*) as rule_count
                FROM template_columns tc
                JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                WHERE tc.template_id = %s AND tc.is_selected = TRUE
            """, (template_id,))
            rule_count = cursor.fetchone()['rule_count']
            has_existing_rules = rule_count > 0
            
            cursor.close()
            
            return jsonify({
                'success': True,
                'sheets': {stored_sheet_name: {'headers': headers}},
                'file_name': template_record['template_name'],
                'file_path': file_path,
                'sheet_name': stored_sheet_name,
                'has_existing_rules': has_existing_rules
            })
        except mysql.connector.Error as e:
            logging.error(f"Database error in get_template: {str(e)}")
            return jsonify({'error': f'Database error: {str(e)}'}), 500
        except Exception as e:
            logging.error(f"Unexpected error in get_template: {str(e)}")
            return jsonify({'error': f'Unexpected error: {str(e)}'}), 500

    # Debug route to show all registered routes
    @app.route('/debug/routes', methods=['GET'])
    def list_routes():
        routes = []
        for rule in app.url_map.iter_rules():
            routes.append({
                'endpoint': rule.endpoint,
                'methods': list(rule.methods),
                'rule': rule.rule
            })
        return jsonify(routes)

    # 404 handler to debug missing routes
    @app.errorhandler(404)
    def not_found_handler(error):
        logging.error(f"404 Error: {request.method} {request.url} not found")
        logging.error(f"Available routes: {[rule.rule for rule in app.url_map.iter_rules()]}")
        return jsonify({
            'error': 'Endpoint not found', 
            'method': request.method,
            'url': request.url,
            'path': request.path
        }), 404

    return app

def initialize_app_data():
    """Initialize database and create default data"""
    try:
        logging.info("Initializing database schema...")
        init_db()
        
        logging.info("Creating admin user...")
        create_admin_user()
        
        logging.info("Creating default validation rules...")
        create_default_validation_rules()
        
        logging.info("Application initialization completed successfully")
    except Exception as e:
        logging.error(f"Failed to initialize application: {e}")
        raise

DB_CONFIG = {
    'host': os.getenv('MYSQL_HOST', 'localhost'),
    'user': os.getenv('MYSQL_USER', 'root'),
    'password': os.getenv('MYSQL_PASSWORD', 'Keansa@2024'),
    'database': os.getenv('MYSQL_DATABASE', 'data_validation_2'),
}

def get_db_connection():
    if 'db' not in g:
        try:
            conn = mysql.connector.connect(
                host=DB_CONFIG['host'],
                user=DB_CONFIG['user'],
                password=DB_CONFIG['password']
            )
            cursor = conn.cursor()
            cursor.execute(f"CREATE DATABASE IF NOT EXISTS {DB_CONFIG['database']}")
            cursor.close()
            conn.close()
            g.db = mysql.connector.connect(**DB_CONFIG)
            logging.info("Database connection established successfully")
        except mysql.connector.Error as err:
            if err.errno == errorcode.ER_ACCESS_DENIED_ERROR:
                logging.error("Database connection failed: Access denied for user - check username/password")
            elif err.errno == errorcode.ER_BAD_DB_ERROR:
                logging.error("Database connection failed: Database does not exist")
            else:
                logging.error(f"Database connection failed: {err}")
            raise Exception(f"Failed to connect to database: {str(err)}")
    return g.db

def close_db(error):
    db = g.pop('db', None)
    if db is not None:
        db.close()

def init_db():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        tables = [
            """
            CREATE TABLE IF NOT EXISTS login_details (
                id INT AUTO_INCREMENT PRIMARY KEY,
                first_name VARCHAR(100),
                last_name VARCHAR(100),
                email VARCHAR(255) UNIQUE,
                mobile VARCHAR(10),
                password VARCHAR(255)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS excel_templates (
                template_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_name VARCHAR(255) NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
                user_id INT NOT NULL,
                sheet_name VARCHAR(255),
                headers JSON,
                status ENUM('ACTIVE', 'INACTIVE') DEFAULT 'ACTIVE',
                is_corrected BOOLEAN DEFAULT FALSE,
                remote_file_path VARCHAR(512),
                FOREIGN KEY (user_id) REFERENCES login_details(id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS template_columns (
                column_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_id BIGINT NOT NULL,
                column_name VARCHAR(255) NOT NULL,
                column_position INT NOT NULL,
                is_validation_enabled BOOLEAN DEFAULT FALSE,
                is_selected BOOLEAN DEFAULT FALSE,
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE,
                UNIQUE (template_id, column_name)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_rule_types (
                rule_type_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                rule_name VARCHAR(255) NOT NULL,
                description TEXT,
                parameters TEXT,
                is_active BOOLEAN DEFAULT TRUE,
                is_custom BOOLEAN DEFAULT FALSE,
                column_name VARCHAR(255),
                template_id BIGINT,
                data_type VARCHAR(50),
                source_format VARCHAR(50),
                target_format VARCHAR(50),
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS column_validation_rules (
                column_validation_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                column_id BIGINT NOT NULL,
                rule_type_id BIGINT NOT NULL,
                rule_config JSON,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (column_id) REFERENCES template_columns(column_id) ON DELETE CASCADE,
                FOREIGN KEY (rule_type_id) REFERENCES validation_rule_types(rule_type_id) ON DELETE RESTRICT,
                UNIQUE (column_id, rule_type_id)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_history (
                history_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_id BIGINT NOT NULL,
                template_name VARCHAR(255) NOT NULL,
                error_count INT NOT NULL,
                corrected_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                corrected_file_path VARCHAR(512) NOT NULL,
                user_id INT NOT NULL,
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE,
                FOREIGN KEY (user_id) REFERENCES login_details(id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_corrections (
                correction_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                history_id BIGINT NOT NULL,
                row_index INT NOT NULL,
                column_name VARCHAR(255) NOT NULL,
                original_value TEXT,
                corrected_value TEXT,
                rule_failed VARCHAR(255) DEFAULT NULL,
                FOREIGN KEY (history_id) REFERENCES validation_history(history_id) ON DELETE CASCADE
            )
            """
        ]
        for table_sql in tables:
            cursor.execute(table_sql)
        
        # Add missing columns if they don't exist
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'source_format'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN source_format VARCHAR(50)")
            logging.info("Added source_format column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'target_format'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN target_format VARCHAR(50)")
            logging.info("Added target_format column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'data_type'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN data_type VARCHAR(50)")
            logging.info("Added data_type column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM excel_templates LIKE 'remote_file_path'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE excel_templates ADD COLUMN remote_file_path VARCHAR(512)")
            logging.info("Added remote_file_path column to excel_templates table")
            
        cursor.execute("SHOW COLUMNS FROM template_columns LIKE 'is_selected'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE template_columns ADD COLUMN is_selected BOOLEAN DEFAULT FALSE")
            logging.info("Added is_selected column to template_columns table")
            
        conn.commit()
        cursor.close()
        logging.info("Database tables initialized")
    except Exception as e:
        logging.error(f"Failed to initialize database: {str(e)}")
        raise

def create_admin_user():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        admin_password = bcrypt.hashpw('admin'.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
        cursor.execute("""
            INSERT IGNORE INTO login_details (first_name, last_name, email, mobile, password)
            VALUES (%s, %s, %s, %s, %s)
        """, ('Admin', 'User', 'admin@example.com', '1234567890', admin_password))
        conn.commit()
        cursor.close()
        logging.info("Admin user created or already exists")
    except Exception as e:
        logging.error(f"Failed to create admin user: {str(e)}")
        raise

def create_default_validation_rules():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        default_rules = [
            ("Required", "Ensures the field is not null", '{"allow_null": false}', None, None, None),
            ("Int", "Validates integer format", '{"format": "integer"}', None, None, "Int"),
            ("Float", "Validates number format (integer or decimal)", '{"format": "float"}', None, None, "Float"),
            ("Text", "Allows text with quotes and parentheses", '{"allow_special": false}', None, None, "Text"),
            ("Email", "Validates email format", '{"regex": "^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\\\.[a-zA-Z0-9-.]+$"}', None, None, "Email"),
            ("Date(DD-MM-YYYY)", "Validates date format DD-MM-YYYY", '{"format": "%d-%m-%Y"}', "DD-MM-YYYY", None, "Date"),
            ("Boolean", "Validates boolean format (true/false or 0/1)", '{"format": "boolean"}', None, None, "Boolean"),
            ("Alphanumeric", "Validates alphanumeric format", '{"format": "alphanumeric"}', None, None, "Alphanumeric")
        ]
        cursor.executemany("""
            INSERT IGNORE INTO validation_rule_types (rule_name, description, parameters, is_custom, source_format, target_format, data_type)
            VALUES (%s, %s, %s, %s, %s, %s, %s)
        """, [(name, desc, params, False, source, target, dtype) for name, desc, params, source, target, dtype in default_rules])
        conn.commit()
        cursor.close()
        logging.info("Default validation rules ensured successfully")
    except Exception as e:
        logging.error(f"Failed to ensure default validation rules: {str(e)}")
        raise

if __name__ == '__main__':
    try:
        # Create the application using factory pattern
        app = create_app()
        
        # Initialize database and default data within app context
        with app.app_context():
            initialize_app_data()
        
        # Get port from environment or use default
        port = int(os.getenv('PORT', 5000))
        
        # Start the application server
        logging.info("Starting Flask server...")
        app.run(debug=True, host='0.0.0.0', port=port)
        
    except Exception as e:
        logging.error(f"Failed to start application: {e}")
        raise
).all():
        return "Int"
    
    if non_null.str.match(r'^-?\d+(\.\d+)?

def create_app():
    """Application factory pattern for different environments"""
    # Set the path to the frontend dist folder
    current_dir = os.path.dirname(os.path.abspath(__file__))
    frontend_dist_path = os.path.join(current_dir, '..', '..', 'Keansa-Ai-Suite2025may-frontend11', 'dist')
    frontend_dist_path = os.path.abspath(frontend_dist_path)
    
    # Create Flask application instance
    app = Flask(__name__, static_folder=frontend_dist_path, static_url_path='')
    CORS(app, supports_credentials=True, origins=["http://localhost:3000", "http://localhost:8080", "http://localhost:5000", "*"])

    app.secret_key = os.urandom(24).hex()
    app.config['SESSION_TYPE'] = 'filesystem'
    app.config['SESSION_FILE_DIR'] = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'sessions')
    app.config['SESSION_COOKIE_SAMESITE'] = 'Lax'
    app.config['SESSION_COOKIE_HTTPONLY'] = True
    app.config['SESSION_COOKIE_SECURE'] = False
    app.config['PERMANENT_SESSION_LIFETIME'] = 86400  # 24 hours
    app.config['UPLOAD_FOLDER'] = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'uploads')
    Session(app)

    # Ensure directories exist
    try:
        os.makedirs(app.config['UPLOAD_FOLDER'], exist_ok=True)
        os.makedirs(app.config['SESSION_FILE_DIR'], exist_ok=True)
    except OSError as e:
        logging.error(f"Failed to create directories: {e}")

    # Register cleanup handlers
    app.teardown_appcontext(close_db)
    
    # Register all routes directly in create_app
    
    # Static file serving for React frontend
    @app.route('/', defaults={'path': ''})
    @app.route('/<path:path>')
    def serve(path):
        if path and os.path.exists(os.path.join(app.static_folder, path)):
            return app.send_static_file(path)
        return app.send_static_file('index.html')

    # Health check endpoint
    @app.route('/health', methods=['GET'])
    def health_check():
        return jsonify({
            'status': 'healthy',
            'timestamp': datetime.now().isoformat(),
            'version': '2.0.0'
        })

    # Authentication endpoint - both old and new paths
    @app.route('/authenticate', methods=['POST'])
    @app.route('/api/auth/authenticate', methods=['POST'])
    def authenticate():
        try:
            email = request.form.get('username') or request.form.get('email')
            password = request.form.get('password')
            logging.debug(f"Login attempt: email={email}, password={'*' * len(password) if password else 'None'}")
            
            if not email or not password:
                logging.warning(f"Login failed: Email or password missing")
                return jsonify({'success': False, 'message': 'Email and password are required'}), 400

            # Check for admin login
            if email == "admin" and password == "admin":
                session['loggedin'] = True
                session['user_email'] = "admin@example.com"
                session['user_id'] = 1
                session.permanent = True
                logging.info(f"Admin login successful. Session: {dict(session)}")
                return jsonify({'success': True, 'message': 'Login successful', 'user': {'email': 'admin@example.com', 'id': 1}}), 200

            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("SELECT * FROM login_details WHERE LOWER(email) = LOWER(%s)", (email.lower(),))
            account = cursor.fetchone()
            cursor.close()
            
            if account:
                if bcrypt.checkpw(password.encode('utf-8'), account['password'].encode('utf-8')):
                    session['loggedin'] = True
                    session['user_email'] = account['email']
                    session['user_id'] = account['id']
                    session.permanent = True
                    logging.info(f"User {email} logged in successfully. Session: {dict(session)}")
                    return jsonify({
                        'success': True,
                        'message': 'Login successful',
                        'user': {'email': account['email'], 'id': account['id']}
                    }), 200
                else:
                    logging.warning(f"Invalid password for {email}")
                    return jsonify({'success': False, 'message': 'Invalid credentials'}), 401
            else:
                logging.warning(f"Email {email} not found")
                return jsonify({'success': False, 'message': 'Invalid credentials'}), 401
        except Exception as e:
            logging.error(f"Unexpected error during login: {str(e)}")
            return jsonify({'success': False, 'message': f'Unexpected error: {str(e)}'}), 500

    @app.route('/check-auth', methods=['GET'])
    @app.route('/api/auth/check-auth', methods=['GET'])
    def check_auth():
        try:
            logging.debug(f"Checking auth with session: {dict(session)}")
            if 'loggedin' in session and 'user_id' in session:
                conn = get_db_connection()
                cursor = conn.cursor(dictionary=True)
                cursor.execute("SELECT email, first_name FROM login_details WHERE id = %s", (session['user_id'],))
                user = cursor.fetchone()
                cursor.close()
                if user:
                    logging.info(f"User {session.get('user_email')} is authenticated")
                    return jsonify({
                        'success': True,
                        'user': {
                            'email': user['email'],
                            'id': session['user_id'],
                            'first_name': user['first_name']
                        }
                    })
                else:
                    logging.warning("User not found in database")  
                    session.clear()
                    return jsonify({'success': False, 'message': 'User not found'}), 401
            logging.warning("User not authenticated")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        except Exception as e:
            logging.error(f"Error in check-auth endpoint: {str(e)}")
            return jsonify({'success': False, 'message': f'Server error: {str(e)}'}), 500

    @app.route('/register', methods=['POST'])
    @app.route('/api/auth/register', methods=['POST'])
    def register():
        first_name = request.form.get('first_name')
        last_name = request.form.get('last_name')
        email = request.form.get('email')
        mobile = request.form.get('mobile')
        password = request.form.get('password')
        confirm_password = request.form.get('confirm_password')

        if not all([first_name, last_name, email, mobile, password, confirm_password]):
            return jsonify({'success': False, 'message': 'All fields are required'}), 400
        if password != confirm_password:
            return jsonify({'success': False, 'message': 'Passwords do not match'}), 400

        hashed_password = bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
        try:
            conn = get_db_connection()
            cursor = conn.cursor()
            cursor.execute("""
                INSERT INTO login_details (first_name, last_name, email, mobile, password)
                VALUES (%s, %s, %s, %s, %s)
            """, (first_name, last_name, email, mobile, hashed_password))
            user_id = cursor.lastrowid
            conn.commit()
            cursor.close()
            session['loggedin'] = True
            session['user_email'] = email
            session['user_id'] = user_id
            return jsonify({
                'success': True,
                'message': 'Registration successful',
                'user': {'email': email, 'id': user_id}
            }), 200
        except mysql.connector.Error as e:
            logging.error(f"Database error during registration: {str(e)}")
            return jsonify({'success': False, 'message': f'Registration error: {str(e)}'}), 500

    @app.route('/logout', methods=['POST'])
    @app.route('/api/auth/logout', methods=['POST'])
    def logout():
        logging.info(f"User {session.get('user_email', 'unknown')} logged out")
        session.clear()
        return jsonify({'success': True, 'message': 'Logged out successfully'})

    # Template routes
    @app.route('/templates', methods=['GET'])
    @app.route('/api/templates', methods=['GET'])
    def get_templates():
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /templates: session missing")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("""
                SELECT template_id, template_name, created_at, status
                FROM excel_templates
                WHERE user_id = %s AND status = 'ACTIVE'
                ORDER BY created_at DESC
                LIMIT 100
            """, (session['user_id'],))
            templates = cursor.fetchall()
            cursor.close()
            logging.info(f"Fetched {len(templates)} templates for user {session['user_id']}")
            return jsonify({'success': True, 'templates': templates})
        except mysql.connector.Error as e:
            logging.error(f'Error fetching templates: {str(e)}')
            return jsonify({'success': False, 'message': f'Error fetching templates: {str(e)}'}), 500
        except Exception as e:
            logging.error(f'Unexpected error fetching templates: {str(e)}')
            return jsonify({'success': False, 'message': f'Unexpected error: {str(e)}'}), 500

    # Rule Configuration routes
    @app.route('/rule-configurations', methods=['GET'])
    @app.route('/api/validation/rule-configurations', methods=['GET'])
    def get_rule_configurations():
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning(f"Unauthorized access to /rule-configurations: session={dict(session)}")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            user_id = session['user_id']
            logging.debug(f"Fetching rule configurations for user_id: {user_id}")

            # Main query to fetch templates with configured rules
            cursor.execute("""
                SELECT 
                    t.template_id, 
                    t.template_name, 
                    t.created_at, 
                    COUNT(cvr.column_validation_id) as rule_count
                FROM excel_templates t
                LEFT JOIN template_columns tc ON t.template_id = tc.template_id
                LEFT JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                WHERE t.user_id = %s AND t.status = 'ACTIVE' AND t.is_corrected = FALSE
                GROUP BY t.template_id, t.template_name, t.created_at
                HAVING rule_count > 0
                ORDER BY t.created_at DESC
                LIMIT 100
            """, (user_id,))
            templates = cursor.fetchall()
            logging.debug(f"Fetched rule-configured templates: {templates}")

            cursor.close()

            if not templates:
                logging.info(f"No templates with rules found for user_id: {user_id}")
            else:
                logging.info(f"Found {len(templates)} templates with rules for user_id: {user_id}")

            return jsonify({'success': True, 'templates': templates})
        except mysql.connector.Error as e:
            logging.error(f"Database error fetching rule configurations: {str(e)}")
            return jsonify({'success': False, 'message': f"Database error: {str(e)}"}), 500
        except Exception as e:
            logging.error(f"Unexpected error fetching rule configurations: {str(e)}")
            return jsonify({'success': False, 'message': f"Unexpected error: {str(e)}"}), 500

    # File upload route
    @app.route('/upload', methods=['POST'])
    @app.route('/api/templates/upload', methods=['POST'])
    @app.route('/api/upload', methods=['POST'])  # Additional common path
    def upload():
        logging.info(f"Upload endpoint called: {request.endpoint}, method: {request.method}")
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /upload: session missing")
            return jsonify({'error': 'Not logged in'}), 401
        if 'file' not in request.files:
            logging.warning("No file provided in upload request")
            return jsonify({'error': 'No file uploaded'}), 400
        file = request.files['file']
        if file.filename == '':
            logging.warning("No file selected in upload request")
            return jsonify({'error': 'No file selected'}), 400
        
        file_path = os.path.join(app.config['UPLOAD_FOLDER'], file.filename)
        try:
            file.save(file_path)
            logging.info(f"File saved: {file_path}")
        except Exception as e:
            logging.error(f"Failed to save file {file.filename}: {str(e)}")
            return jsonify({'error': f'Failed to save file: {str(e)}'}), 500

        try:
            # Read the file to get sheets and headers
            if file.filename.endswith('.xlsx') or file.filename.endswith('.xls'):
                xl = pd.ExcelFile(file_path)
                sheets = {sheet_name: pd.read_excel(file_path, sheet_name=sheet_name, header=None) 
                         for sheet_name in xl.sheet_names}
            elif file.filename.endswith(('.txt', '.csv', '.dat')):
                df = pd.read_csv(file_path, header=None, encoding='utf-8')
                sheets = {'Sheet1': df}
            else:
                logging.error("Unsupported file type")
                return jsonify({'error': 'Unsupported file type'}), 400
            
            logging.debug(f"Sheets extracted: {list(sheets.keys())}")
        except Exception as e:
            logging.error(f"Failed to read file {file_path}: {str(e)}")
            return jsonify({'error': f'Failed to read file: {str(e)}'}), 400

        try:
            sheet_names = list(sheets.keys())
            if not sheet_names:
                logging.error("No sheets found in the file")
                return jsonify({'error': 'No sheets found in the file'}), 400
            sheet_name = sheet_names[0]
            df = sheets[sheet_name]
            
            # Find header row
            header_row = 0
            for i in range(min(len(df), 10)):
                row = df.iloc[i].dropna()
                if not row.empty and all(isinstance(x, str) for x in row if pd.notna(x)):
                    header_row = i
                    break
                    
            headers = df.iloc[header_row].tolist()
            logging.debug(f"Headers extracted: {headers}")
            
            if not headers or all(not h for h in headers):
                logging.error("No valid headers found in file")
                return jsonify({'error': 'No valid headers found in the file'}), 400
        except Exception as e:
            logging.error(f"Error processing file {file.filename}: {str(e)}")
            return jsonify({'error': f'Error processing file: {str(e)}'}), 400

        # Clear existing session data
        for key in ['df', 'header_row', 'headers', 'sheet_name', 'current_step', 'selected_headers', 'validations', 'error_cell_locations', 'data_rows', 'corrected_file_path']:
            session.pop(key, None)

        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)

            # Check if template exists
            cursor.execute("""
                SELECT template_id, headers, sheet_name
                FROM excel_templates
                WHERE template_name = %s AND user_id = %s AND status = 'ACTIVE'
                ORDER BY created_at DESC
            """, (file.filename, session['user_id']))
            existing_templates = cursor.fetchall()
            logging.info(f"Found {len(existing_templates)} existing templates with name {file.filename}")

            template_id = None
            has_existing_rules = False
            validations = {}
            selected_headers = []

            # Check for matching template
            matching_template = None
            for template in existing_templates:
                stored_headers = json.loads(template['headers']) if template['headers'] else []
                stored_sheet_name = template['sheet_name']
                if stored_headers == headers and stored_sheet_name == sheet_name:
                    matching_template = template
                    break

            if matching_template:
                template_id = matching_template['template_id']
                # Check for existing rules
                cursor.execute("""
                    SELECT tc.column_name, vrt.rule_name
                    FROM template_columns tc
                    JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                    JOIN validation_rule_types vrt ON cvr.rule_type_id = vrt.rule_type_id
                    WHERE tc.template_id = %s AND tc.is_selected = TRUE
                """, (template_id,))
                rules_data = cursor.fetchall()
                for row in rules_data:
                    column_name = row['column_name']
                    rule_name = row['rule_name']
                    if column_name not in validations:
                        validations[column_name] = []
                    validations[column_name].append(rule_name)
                    if column_name not in selected_headers:
                        selected_headers.append(column_name)
                has_existing_rules = len(validations) > 0
            else:
                # New template
                cursor.execute("""
                    INSERT INTO excel_templates (template_name, user_id, sheet_name, headers, is_corrected)
                    VALUES (%s, %s, %s, %s, %s)
                """, (file.filename, session['user_id'], sheet_name, json.dumps(headers), False))
                template_id = cursor.lastrowid
                column_data = [(template_id, header, i + 1, False) for i, header in enumerate(headers)]
                cursor.executemany("""
                    INSERT INTO template_columns (template_id, column_name, column_position, is_selected)
                    VALUES (%s, %s, %s, %s)
                """, column_data)

            conn.commit()
            cursor.close()

            # Store session data
            session['file_path'] = file_path
            session['template_id'] = template_id
            session['df'] = df.to_json()
            session['header_row'] = header_row
            session['headers'] = headers
            session['sheet_name'] = sheet_name
            session['current_step'] = 1 if not has_existing_rules else 3
            session['validations'] = validations
            session['selected_headers'] = selected_headers
            session['has_existing_rules'] = has_existing_rules

            logging.info(f"Upload processed: template_id={template_id}, filename={file.filename}, has_existing_rules={has_existing_rules}")

            return jsonify({
                'success': True,
                'sheets': {sheet_name: {'headers': headers}},
                'file_name': file.filename,
                'template_id': template_id,
                'has_existing_rules': has_existing_rules,
                'sheet_name': sheet_name,
                'skip_to_step_3': has_existing_rules
            })
        except mysql.connector.Error as e:
            logging.error(f'Error saving template: {str(e)}')
            return jsonify({'error': f'Error saving template: {str(e)}'}), 500
        except Exception as e:
            logging.error(f'Unexpected error saving template: {str(e)}')
            return jsonify({'error': f'Unexpected error: {str(e)}'}), 500

    # Multi-step workflow endpoints
    @app.route('/step/1', methods=['GET', 'POST'])
    @app.route('/api/step/1', methods=['GET', 'POST'])
    def step_one():
        if 'loggedin' not in session:
            return jsonify({'error': 'Not logged in'}), 401
        
        if request.method == 'POST':
            try:
                headers = request.form.getlist('headers')
                new_header_row = request.form.get('new_header_row')
                logging.debug(f"Step 1 submitted: headers={headers}, new_header_row={new_header_row}")
                
                if not headers:
                    logging.error("No headers provided in step 1")
                    return jsonify({'success': False, 'message': 'No headers provided'}), 400
                    
                if 'template_id' not in session:
                    logging.error("Session missing template_id")
                    return jsonify({'success': False, 'message': 'Session data missing'}), 400

                template_id = session['template_id']
                
                # Get the dataframe from session for auto-detection
                df_json = session.get('df')
                if df_json:
                    df = pd.read_json(StringIO(df_json))
                    session_headers = session.get('headers', [])
                    df.columns = session_headers
                    header_row = session.get('header_row', 0)
                    df = df.iloc[header_row + 1:].reset_index(drop=True)
                    
                    # Auto-detect rules for selected headers
                    validations = assign_default_rules_to_columns(df, headers)
                    session['validations'] = validations
                    logging.debug(f"Auto-assigned rules: {validations}")
                else:
                    validations = {}

                session['selected_headers'] = headers
                session['current_step'] = 2

                # Mark selected headers in the database
                conn = get_db_connection()
                cursor = conn.cursor()
                cursor.execute("UPDATE template_columns SET is_selected = FALSE WHERE template_id = %s", (template_id,))
                for header in headers:
                    cursor.execute("""
                        UPDATE template_columns
                        SET is_selected = TRUE
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    
                    # Get column_id and add auto-detected rules
                    cursor.execute("""
                        SELECT column_id FROM template_columns
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    result = cursor.fetchone()
                    if result:
                        column_id = result[0]
                        for rule_name in validations.get(header, []):
                            cursor.execute("""
                                SELECT rule_type_id FROM validation_rule_types
                                WHERE rule_name = %s AND is_custom = FALSE
                            """, (rule_name,))
                            rule_result = cursor.fetchone()
                            if rule_result:
                                rule_type_id = rule_result[0]
                                cursor.execute("""
                                    INSERT IGNORE INTO column_validation_rules (column_id, rule_type_id, rule_config)
                                    VALUES (%s, %s, %s)
                                """, (column_id, rule_type_id, '{}'))
                
                conn.commit()
                cursor.close()

                logging.info(f"Step 1 completed: headers={headers}, auto-assigned rules={validations}")
                return jsonify({'success': True, 'headers': headers, 'validations': validations})
            except Exception as e:
                logging.error(f"Error in step 1: {str(e)}")
                return jsonify({'success': False, 'message': str(e)}), 500
        
        # GET request - return current headers
        headers = session.get('headers', [])
        return jsonify({'headers': headers})

    @app.route('/step/2', methods=['GET', 'POST'])
    @app.route('/api/step/2', methods=['GET', 'POST'])
    def step_two():
        if 'loggedin' not in session:
            return jsonify({'error': 'Not logged in'}), 401
            
        if request.method == 'POST':
            try:
                action = request.form.get('action', 'save')
                validations = {}
                for key, values in request.form.lists():
                    if key.startswith('validations_'):
                        header = key.replace('validations_', '')
                        validations[header] = values
                        
                logging.debug(f"Step 2 submitted: action={action}, validations={validations}")
                
                template_id = session.get('template_id')
                if not template_id:
                    return jsonify({'success': False, 'message': 'Session data missing'}), 400

                # Save validations to database
                conn = get_db_connection()
                cursor = conn.cursor()
                
                # Clear existing rules
                cursor.execute("""
                    DELETE FROM column_validation_rules
                    WHERE column_id IN (
                        SELECT column_id FROM template_columns WHERE template_id = %s
                    )
                """, (template_id,))
                
                # Add new rules
                for header, rules in validations.items():
                    cursor.execute("""
                        SELECT column_id FROM template_columns
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    result = cursor.fetchone()
                    if not result:
                        continue
                    column_id = result[0]
                    
                    for rule_name in rules:
                        cursor.execute("""
                            SELECT rule_type_id FROM validation_rule_types
                            WHERE rule_name = %s
                        """, (rule_name,))
                        result = cursor.fetchone()
                        if result:
                            rule_type_id = result[0]
                            cursor.execute("""
                                INSERT IGNORE INTO column_validation_rules (column_id, rule_type_id, rule_config)
                                VALUES (%s, %s, %s)
                            """, (column_id, rule_type_id, '{}'))
                
                conn.commit()
                cursor.close()

                session['validations'] = validations
                session['current_step'] = 3 if action == 'review' else 2
                
                logging.info(f"Step 2 completed: action={action}, validations={validations}")
                return jsonify({'success': True, 'message': 'Step 2 completed successfully'})
            except Exception as e:
                logging.error(f"Error in step 2: {str(e)}")
                return jsonify({'success': False, 'message': str(e)}), 500
        
        # GET request
        selected_headers = session.get('selected_headers', [])
        return jsonify({'selected_headers': selected_headers})

    # Rules endpoint
    @app.route('/rules', methods=['GET'])
    @app.route('/api/rules', methods=['GET'])
    def get_rules():
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            
            cursor.execute("""
                SELECT rule_type_id AS rule_id, rule_name, description, parameters, is_custom, 
                       column_name, template_id, source_format, target_format, data_type, is_active
                FROM validation_rule_types
            """)
            rules = cursor.fetchall()
            cursor.close()
            
            logging.info(f"Returning {len(rules)} rules from getRules endpoint")
            return jsonify({'success': True, 'rules': rules})
        except mysql.connector.Error as e:
            logging.error(f"Database error fetching rules: {str(e)}")
            return jsonify({'success': False, 'message': str(e)}), 500
        except Exception as e:
            logging.error(f"Unexpected error fetching rules: {str(e)}")
            return jsonify({'success': False, 'message': str(e)}), 500

    # Template details endpoint
    @app.route('/template/<int:template_id>/<sheet_name>', methods=['GET'])
    @app.route('/api/template/<int:template_id>/<sheet_name>', methods=['GET'])
    def get_template(template_id, sheet_name):
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /template: session missing")
            return jsonify({'error': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("""
                SELECT template_name, sheet_name, headers
                FROM excel_templates
                WHERE template_id = %s AND user_id = %s AND status = 'ACTIVE'
            """, (template_id, session['user_id']))
            template_record = cursor.fetchone()
            
            if not template_record:
                logging.error(f"Template not found for template_id: {template_id}, user_id: {session['user_id']}")
                cursor.close()
                return jsonify({'error': 'Template not found'}), 404

            headers = json.loads(template_record['headers']) if template_record['headers'] else []
            stored_sheet_name = template_record['sheet_name'] or sheet_name
            file_path = os.path.join(app.config['UPLOAD_FOLDER'], template_record['template_name'])
            
            cursor.execute("""
                SELECT COUNT(*) as rule_count
                FROM template_columns tc
                JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                WHERE tc.template_id = %s AND tc.is_selected = TRUE
            """, (template_id,))
            rule_count = cursor.fetchone()['rule_count']
            has_existing_rules = rule_count > 0
            
            cursor.close()
            
            return jsonify({
                'success': True,
                'sheets': {stored_sheet_name: {'headers': headers}},
                'file_name': template_record['template_name'],
                'file_path': file_path,
                'sheet_name': stored_sheet_name,
                'has_existing_rules': has_existing_rules
            })
        except mysql.connector.Error as e:
            logging.error(f"Database error in get_template: {str(e)}")
            return jsonify({'error': f'Database error: {str(e)}'}), 500
        except Exception as e:
            logging.error(f"Unexpected error in get_template: {str(e)}")
            return jsonify({'error': f'Unexpected error: {str(e)}'}), 500

    # Debug route to show all registered routes
    @app.route('/debug/routes', methods=['GET'])
    def list_routes():
        routes = []
        for rule in app.url_map.iter_rules():
            routes.append({
                'endpoint': rule.endpoint,
                'methods': list(rule.methods),
                'rule': rule.rule
            })
        return jsonify(routes)

    # 404 handler to debug missing routes
    @app.errorhandler(404)
    def not_found_handler(error):
        logging.error(f"404 Error: {request.method} {request.url} not found")
        logging.error(f"Available routes: {[rule.rule for rule in app.url_map.iter_rules()]}")
        return jsonify({
            'error': 'Endpoint not found', 
            'method': request.method,
            'url': request.url,
            'path': request.path
        }), 404

    return app

def initialize_app_data():
    """Initialize database and create default data"""
    try:
        logging.info("Initializing database schema...")
        init_db()
        
        logging.info("Creating admin user...")
        create_admin_user()
        
        logging.info("Creating default validation rules...")
        create_default_validation_rules()
        
        logging.info("Application initialization completed successfully")
    except Exception as e:
        logging.error(f"Failed to initialize application: {e}")
        raise

DB_CONFIG = {
    'host': os.getenv('MYSQL_HOST', 'localhost'),
    'user': os.getenv('MYSQL_USER', 'root'),
    'password': os.getenv('MYSQL_PASSWORD', 'Keansa@2024'),
    'database': os.getenv('MYSQL_DATABASE', 'data_validation_2'),
}

def get_db_connection():
    if 'db' not in g:
        try:
            conn = mysql.connector.connect(
                host=DB_CONFIG['host'],
                user=DB_CONFIG['user'],
                password=DB_CONFIG['password']
            )
            cursor = conn.cursor()
            cursor.execute(f"CREATE DATABASE IF NOT EXISTS {DB_CONFIG['database']}")
            cursor.close()
            conn.close()
            g.db = mysql.connector.connect(**DB_CONFIG)
            logging.info("Database connection established successfully")
        except mysql.connector.Error as err:
            if err.errno == errorcode.ER_ACCESS_DENIED_ERROR:
                logging.error("Database connection failed: Access denied for user - check username/password")
            elif err.errno == errorcode.ER_BAD_DB_ERROR:
                logging.error("Database connection failed: Database does not exist")
            else:
                logging.error(f"Database connection failed: {err}")
            raise Exception(f"Failed to connect to database: {str(err)}")
    return g.db

def close_db(error):
    db = g.pop('db', None)
    if db is not None:
        db.close()

def init_db():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        tables = [
            """
            CREATE TABLE IF NOT EXISTS login_details (
                id INT AUTO_INCREMENT PRIMARY KEY,
                first_name VARCHAR(100),
                last_name VARCHAR(100),
                email VARCHAR(255) UNIQUE,
                mobile VARCHAR(10),
                password VARCHAR(255)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS excel_templates (
                template_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_name VARCHAR(255) NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
                user_id INT NOT NULL,
                sheet_name VARCHAR(255),
                headers JSON,
                status ENUM('ACTIVE', 'INACTIVE') DEFAULT 'ACTIVE',
                is_corrected BOOLEAN DEFAULT FALSE,
                remote_file_path VARCHAR(512),
                FOREIGN KEY (user_id) REFERENCES login_details(id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS template_columns (
                column_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_id BIGINT NOT NULL,
                column_name VARCHAR(255) NOT NULL,
                column_position INT NOT NULL,
                is_validation_enabled BOOLEAN DEFAULT FALSE,
                is_selected BOOLEAN DEFAULT FALSE,
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE,
                UNIQUE (template_id, column_name)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_rule_types (
                rule_type_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                rule_name VARCHAR(255) NOT NULL,
                description TEXT,
                parameters TEXT,
                is_active BOOLEAN DEFAULT TRUE,
                is_custom BOOLEAN DEFAULT FALSE,
                column_name VARCHAR(255),
                template_id BIGINT,
                data_type VARCHAR(50),
                source_format VARCHAR(50),
                target_format VARCHAR(50),
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS column_validation_rules (
                column_validation_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                column_id BIGINT NOT NULL,
                rule_type_id BIGINT NOT NULL,
                rule_config JSON,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (column_id) REFERENCES template_columns(column_id) ON DELETE CASCADE,
                FOREIGN KEY (rule_type_id) REFERENCES validation_rule_types(rule_type_id) ON DELETE RESTRICT,
                UNIQUE (column_id, rule_type_id)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_history (
                history_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_id BIGINT NOT NULL,
                template_name VARCHAR(255) NOT NULL,
                error_count INT NOT NULL,
                corrected_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                corrected_file_path VARCHAR(512) NOT NULL,
                user_id INT NOT NULL,
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE,
                FOREIGN KEY (user_id) REFERENCES login_details(id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_corrections (
                correction_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                history_id BIGINT NOT NULL,
                row_index INT NOT NULL,
                column_name VARCHAR(255) NOT NULL,
                original_value TEXT,
                corrected_value TEXT,
                rule_failed VARCHAR(255) DEFAULT NULL,
                FOREIGN KEY (history_id) REFERENCES validation_history(history_id) ON DELETE CASCADE
            )
            """
        ]
        for table_sql in tables:
            cursor.execute(table_sql)
        
        # Add missing columns if they don't exist
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'source_format'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN source_format VARCHAR(50)")
            logging.info("Added source_format column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'target_format'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN target_format VARCHAR(50)")
            logging.info("Added target_format column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'data_type'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN data_type VARCHAR(50)")
            logging.info("Added data_type column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM excel_templates LIKE 'remote_file_path'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE excel_templates ADD COLUMN remote_file_path VARCHAR(512)")
            logging.info("Added remote_file_path column to excel_templates table")
            
        cursor.execute("SHOW COLUMNS FROM template_columns LIKE 'is_selected'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE template_columns ADD COLUMN is_selected BOOLEAN DEFAULT FALSE")
            logging.info("Added is_selected column to template_columns table")
            
        conn.commit()
        cursor.close()
        logging.info("Database tables initialized")
    except Exception as e:
        logging.error(f"Failed to initialize database: {str(e)}")
        raise

def create_admin_user():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        admin_password = bcrypt.hashpw('admin'.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
        cursor.execute("""
            INSERT IGNORE INTO login_details (first_name, last_name, email, mobile, password)
            VALUES (%s, %s, %s, %s, %s)
        """, ('Admin', 'User', 'admin@example.com', '1234567890', admin_password))
        conn.commit()
        cursor.close()
        logging.info("Admin user created or already exists")
    except Exception as e:
        logging.error(f"Failed to create admin user: {str(e)}")
        raise

def create_default_validation_rules():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        default_rules = [
            ("Required", "Ensures the field is not null", '{"allow_null": false}', None, None, None),
            ("Int", "Validates integer format", '{"format": "integer"}', None, None, "Int"),
            ("Float", "Validates number format (integer or decimal)", '{"format": "float"}', None, None, "Float"),
            ("Text", "Allows text with quotes and parentheses", '{"allow_special": false}', None, None, "Text"),
            ("Email", "Validates email format", '{"regex": "^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\\\.[a-zA-Z0-9-.]+$"}', None, None, "Email"),
            ("Date(DD-MM-YYYY)", "Validates date format DD-MM-YYYY", '{"format": "%d-%m-%Y"}', "DD-MM-YYYY", None, "Date"),
            ("Boolean", "Validates boolean format (true/false or 0/1)", '{"format": "boolean"}', None, None, "Boolean"),
            ("Alphanumeric", "Validates alphanumeric format", '{"format": "alphanumeric"}', None, None, "Alphanumeric")
        ]
        cursor.executemany("""
            INSERT IGNORE INTO validation_rule_types (rule_name, description, parameters, is_custom, source_format, target_format, data_type)
            VALUES (%s, %s, %s, %s, %s, %s, %s)
        """, [(name, desc, params, False, source, target, dtype) for name, desc, params, source, target, dtype in default_rules])
        conn.commit()
        cursor.close()
        logging.info("Default validation rules ensured successfully")
    except Exception as e:
        logging.error(f"Failed to ensure default validation rules: {str(e)}")
        raise

if __name__ == '__main__':
    try:
        # Create the application using factory pattern
        app = create_app()
        
        # Initialize database and default data within app context
        with app.app_context():
            initialize_app_data()
        
        # Get port from environment or use default
        port = int(os.getenv('PORT', 5000))
        
        # Start the application server
        logging.info("Starting Flask server...")
        app.run(debug=True, host='0.0.0.0', port=port)
        
    except Exception as e:
        logging.error(f"Failed to start application: {e}")
        raise
).all():
        return "Float"
    
    # Alphanumeric detection
    if non_null.str.match(r'^[a-zA-Z0-9]+

def create_app():
    """Application factory pattern for different environments"""
    # Set the path to the frontend dist folder
    current_dir = os.path.dirname(os.path.abspath(__file__))
    frontend_dist_path = os.path.join(current_dir, '..', '..', 'Keansa-Ai-Suite2025may-frontend11', 'dist')
    frontend_dist_path = os.path.abspath(frontend_dist_path)
    
    # Create Flask application instance
    app = Flask(__name__, static_folder=frontend_dist_path, static_url_path='')
    CORS(app, supports_credentials=True, origins=["http://localhost:3000", "http://localhost:8080", "http://localhost:5000", "*"])

    app.secret_key = os.urandom(24).hex()
    app.config['SESSION_TYPE'] = 'filesystem'
    app.config['SESSION_FILE_DIR'] = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'sessions')
    app.config['SESSION_COOKIE_SAMESITE'] = 'Lax'
    app.config['SESSION_COOKIE_HTTPONLY'] = True
    app.config['SESSION_COOKIE_SECURE'] = False
    app.config['PERMANENT_SESSION_LIFETIME'] = 86400  # 24 hours
    app.config['UPLOAD_FOLDER'] = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'uploads')
    Session(app)

    # Ensure directories exist
    try:
        os.makedirs(app.config['UPLOAD_FOLDER'], exist_ok=True)
        os.makedirs(app.config['SESSION_FILE_DIR'], exist_ok=True)
    except OSError as e:
        logging.error(f"Failed to create directories: {e}")

    # Register cleanup handlers
    app.teardown_appcontext(close_db)
    
    # Register all routes directly in create_app
    
    # Static file serving for React frontend
    @app.route('/', defaults={'path': ''})
    @app.route('/<path:path>')
    def serve(path):
        if path and os.path.exists(os.path.join(app.static_folder, path)):
            return app.send_static_file(path)
        return app.send_static_file('index.html')

    # Health check endpoint
    @app.route('/health', methods=['GET'])
    def health_check():
        return jsonify({
            'status': 'healthy',
            'timestamp': datetime.now().isoformat(),
            'version': '2.0.0'
        })

    # Authentication endpoint - both old and new paths
    @app.route('/authenticate', methods=['POST'])
    @app.route('/api/auth/authenticate', methods=['POST'])
    def authenticate():
        try:
            email = request.form.get('username') or request.form.get('email')
            password = request.form.get('password')
            logging.debug(f"Login attempt: email={email}, password={'*' * len(password) if password else 'None'}")
            
            if not email or not password:
                logging.warning(f"Login failed: Email or password missing")
                return jsonify({'success': False, 'message': 'Email and password are required'}), 400

            # Check for admin login
            if email == "admin" and password == "admin":
                session['loggedin'] = True
                session['user_email'] = "admin@example.com"
                session['user_id'] = 1
                session.permanent = True
                logging.info(f"Admin login successful. Session: {dict(session)}")
                return jsonify({'success': True, 'message': 'Login successful', 'user': {'email': 'admin@example.com', 'id': 1}}), 200

            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("SELECT * FROM login_details WHERE LOWER(email) = LOWER(%s)", (email.lower(),))
            account = cursor.fetchone()
            cursor.close()
            
            if account:
                if bcrypt.checkpw(password.encode('utf-8'), account['password'].encode('utf-8')):
                    session['loggedin'] = True
                    session['user_email'] = account['email']
                    session['user_id'] = account['id']
                    session.permanent = True
                    logging.info(f"User {email} logged in successfully. Session: {dict(session)}")
                    return jsonify({
                        'success': True,
                        'message': 'Login successful',
                        'user': {'email': account['email'], 'id': account['id']}
                    }), 200
                else:
                    logging.warning(f"Invalid password for {email}")
                    return jsonify({'success': False, 'message': 'Invalid credentials'}), 401
            else:
                logging.warning(f"Email {email} not found")
                return jsonify({'success': False, 'message': 'Invalid credentials'}), 401
        except Exception as e:
            logging.error(f"Unexpected error during login: {str(e)}")
            return jsonify({'success': False, 'message': f'Unexpected error: {str(e)}'}), 500

    @app.route('/check-auth', methods=['GET'])
    @app.route('/api/auth/check-auth', methods=['GET'])
    def check_auth():
        try:
            logging.debug(f"Checking auth with session: {dict(session)}")
            if 'loggedin' in session and 'user_id' in session:
                conn = get_db_connection()
                cursor = conn.cursor(dictionary=True)
                cursor.execute("SELECT email, first_name FROM login_details WHERE id = %s", (session['user_id'],))
                user = cursor.fetchone()
                cursor.close()
                if user:
                    logging.info(f"User {session.get('user_email')} is authenticated")
                    return jsonify({
                        'success': True,
                        'user': {
                            'email': user['email'],
                            'id': session['user_id'],
                            'first_name': user['first_name']
                        }
                    })
                else:
                    logging.warning("User not found in database")  
                    session.clear()
                    return jsonify({'success': False, 'message': 'User not found'}), 401
            logging.warning("User not authenticated")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        except Exception as e:
            logging.error(f"Error in check-auth endpoint: {str(e)}")
            return jsonify({'success': False, 'message': f'Server error: {str(e)}'}), 500

    @app.route('/register', methods=['POST'])
    @app.route('/api/auth/register', methods=['POST'])
    def register():
        first_name = request.form.get('first_name')
        last_name = request.form.get('last_name')
        email = request.form.get('email')
        mobile = request.form.get('mobile')
        password = request.form.get('password')
        confirm_password = request.form.get('confirm_password')

        if not all([first_name, last_name, email, mobile, password, confirm_password]):
            return jsonify({'success': False, 'message': 'All fields are required'}), 400
        if password != confirm_password:
            return jsonify({'success': False, 'message': 'Passwords do not match'}), 400

        hashed_password = bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
        try:
            conn = get_db_connection()
            cursor = conn.cursor()
            cursor.execute("""
                INSERT INTO login_details (first_name, last_name, email, mobile, password)
                VALUES (%s, %s, %s, %s, %s)
            """, (first_name, last_name, email, mobile, hashed_password))
            user_id = cursor.lastrowid
            conn.commit()
            cursor.close()
            session['loggedin'] = True
            session['user_email'] = email
            session['user_id'] = user_id
            return jsonify({
                'success': True,
                'message': 'Registration successful',
                'user': {'email': email, 'id': user_id}
            }), 200
        except mysql.connector.Error as e:
            logging.error(f"Database error during registration: {str(e)}")
            return jsonify({'success': False, 'message': f'Registration error: {str(e)}'}), 500

    @app.route('/logout', methods=['POST'])
    @app.route('/api/auth/logout', methods=['POST'])
    def logout():
        logging.info(f"User {session.get('user_email', 'unknown')} logged out")
        session.clear()
        return jsonify({'success': True, 'message': 'Logged out successfully'})

    # Template routes
    @app.route('/templates', methods=['GET'])
    @app.route('/api/templates', methods=['GET'])
    def get_templates():
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /templates: session missing")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("""
                SELECT template_id, template_name, created_at, status
                FROM excel_templates
                WHERE user_id = %s AND status = 'ACTIVE'
                ORDER BY created_at DESC
                LIMIT 100
            """, (session['user_id'],))
            templates = cursor.fetchall()
            cursor.close()
            logging.info(f"Fetched {len(templates)} templates for user {session['user_id']}")
            return jsonify({'success': True, 'templates': templates})
        except mysql.connector.Error as e:
            logging.error(f'Error fetching templates: {str(e)}')
            return jsonify({'success': False, 'message': f'Error fetching templates: {str(e)}'}), 500
        except Exception as e:
            logging.error(f'Unexpected error fetching templates: {str(e)}')
            return jsonify({'success': False, 'message': f'Unexpected error: {str(e)}'}), 500

    # Rule Configuration routes
    @app.route('/rule-configurations', methods=['GET'])
    @app.route('/api/validation/rule-configurations', methods=['GET'])
    def get_rule_configurations():
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning(f"Unauthorized access to /rule-configurations: session={dict(session)}")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            user_id = session['user_id']
            logging.debug(f"Fetching rule configurations for user_id: {user_id}")

            # Main query to fetch templates with configured rules
            cursor.execute("""
                SELECT 
                    t.template_id, 
                    t.template_name, 
                    t.created_at, 
                    COUNT(cvr.column_validation_id) as rule_count
                FROM excel_templates t
                LEFT JOIN template_columns tc ON t.template_id = tc.template_id
                LEFT JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                WHERE t.user_id = %s AND t.status = 'ACTIVE' AND t.is_corrected = FALSE
                GROUP BY t.template_id, t.template_name, t.created_at
                HAVING rule_count > 0
                ORDER BY t.created_at DESC
                LIMIT 100
            """, (user_id,))
            templates = cursor.fetchall()
            logging.debug(f"Fetched rule-configured templates: {templates}")

            cursor.close()

            if not templates:
                logging.info(f"No templates with rules found for user_id: {user_id}")
            else:
                logging.info(f"Found {len(templates)} templates with rules for user_id: {user_id}")

            return jsonify({'success': True, 'templates': templates})
        except mysql.connector.Error as e:
            logging.error(f"Database error fetching rule configurations: {str(e)}")
            return jsonify({'success': False, 'message': f"Database error: {str(e)}"}), 500
        except Exception as e:
            logging.error(f"Unexpected error fetching rule configurations: {str(e)}")
            return jsonify({'success': False, 'message': f"Unexpected error: {str(e)}"}), 500

    # File upload route
    @app.route('/upload', methods=['POST'])
    @app.route('/api/templates/upload', methods=['POST'])
    @app.route('/api/upload', methods=['POST'])  # Additional common path
    def upload():
        logging.info(f"Upload endpoint called: {request.endpoint}, method: {request.method}")
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /upload: session missing")
            return jsonify({'error': 'Not logged in'}), 401
        if 'file' not in request.files:
            logging.warning("No file provided in upload request")
            return jsonify({'error': 'No file uploaded'}), 400
        file = request.files['file']
        if file.filename == '':
            logging.warning("No file selected in upload request")
            return jsonify({'error': 'No file selected'}), 400
        
        file_path = os.path.join(app.config['UPLOAD_FOLDER'], file.filename)
        try:
            file.save(file_path)
            logging.info(f"File saved: {file_path}")
        except Exception as e:
            logging.error(f"Failed to save file {file.filename}: {str(e)}")
            return jsonify({'error': f'Failed to save file: {str(e)}'}), 500

        try:
            # Read the file to get sheets and headers
            if file.filename.endswith('.xlsx') or file.filename.endswith('.xls'):
                xl = pd.ExcelFile(file_path)
                sheets = {sheet_name: pd.read_excel(file_path, sheet_name=sheet_name, header=None) 
                         for sheet_name in xl.sheet_names}
            elif file.filename.endswith(('.txt', '.csv', '.dat')):
                df = pd.read_csv(file_path, header=None, encoding='utf-8')
                sheets = {'Sheet1': df}
            else:
                logging.error("Unsupported file type")
                return jsonify({'error': 'Unsupported file type'}), 400
            
            logging.debug(f"Sheets extracted: {list(sheets.keys())}")
        except Exception as e:
            logging.error(f"Failed to read file {file_path}: {str(e)}")
            return jsonify({'error': f'Failed to read file: {str(e)}'}), 400

        try:
            sheet_names = list(sheets.keys())
            if not sheet_names:
                logging.error("No sheets found in the file")
                return jsonify({'error': 'No sheets found in the file'}), 400
            sheet_name = sheet_names[0]
            df = sheets[sheet_name]
            
            # Find header row
            header_row = 0
            for i in range(min(len(df), 10)):
                row = df.iloc[i].dropna()
                if not row.empty and all(isinstance(x, str) for x in row if pd.notna(x)):
                    header_row = i
                    break
                    
            headers = df.iloc[header_row].tolist()
            logging.debug(f"Headers extracted: {headers}")
            
            if not headers or all(not h for h in headers):
                logging.error("No valid headers found in file")
                return jsonify({'error': 'No valid headers found in the file'}), 400
        except Exception as e:
            logging.error(f"Error processing file {file.filename}: {str(e)}")
            return jsonify({'error': f'Error processing file: {str(e)}'}), 400

        # Clear existing session data
        for key in ['df', 'header_row', 'headers', 'sheet_name', 'current_step', 'selected_headers', 'validations', 'error_cell_locations', 'data_rows', 'corrected_file_path']:
            session.pop(key, None)

        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)

            # Check if template exists
            cursor.execute("""
                SELECT template_id, headers, sheet_name
                FROM excel_templates
                WHERE template_name = %s AND user_id = %s AND status = 'ACTIVE'
                ORDER BY created_at DESC
            """, (file.filename, session['user_id']))
            existing_templates = cursor.fetchall()
            logging.info(f"Found {len(existing_templates)} existing templates with name {file.filename}")

            template_id = None
            has_existing_rules = False
            validations = {}
            selected_headers = []

            # Check for matching template
            matching_template = None
            for template in existing_templates:
                stored_headers = json.loads(template['headers']) if template['headers'] else []
                stored_sheet_name = template['sheet_name']
                if stored_headers == headers and stored_sheet_name == sheet_name:
                    matching_template = template
                    break

            if matching_template:
                template_id = matching_template['template_id']
                # Check for existing rules
                cursor.execute("""
                    SELECT tc.column_name, vrt.rule_name
                    FROM template_columns tc
                    JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                    JOIN validation_rule_types vrt ON cvr.rule_type_id = vrt.rule_type_id
                    WHERE tc.template_id = %s AND tc.is_selected = TRUE
                """, (template_id,))
                rules_data = cursor.fetchall()
                for row in rules_data:
                    column_name = row['column_name']
                    rule_name = row['rule_name']
                    if column_name not in validations:
                        validations[column_name] = []
                    validations[column_name].append(rule_name)
                    if column_name not in selected_headers:
                        selected_headers.append(column_name)
                has_existing_rules = len(validations) > 0
            else:
                # New template
                cursor.execute("""
                    INSERT INTO excel_templates (template_name, user_id, sheet_name, headers, is_corrected)
                    VALUES (%s, %s, %s, %s, %s)
                """, (file.filename, session['user_id'], sheet_name, json.dumps(headers), False))
                template_id = cursor.lastrowid
                column_data = [(template_id, header, i + 1, False) for i, header in enumerate(headers)]
                cursor.executemany("""
                    INSERT INTO template_columns (template_id, column_name, column_position, is_selected)
                    VALUES (%s, %s, %s, %s)
                """, column_data)

            conn.commit()
            cursor.close()

            # Store session data
            session['file_path'] = file_path
            session['template_id'] = template_id
            session['df'] = df.to_json()
            session['header_row'] = header_row
            session['headers'] = headers
            session['sheet_name'] = sheet_name
            session['current_step'] = 1 if not has_existing_rules else 3
            session['validations'] = validations
            session['selected_headers'] = selected_headers
            session['has_existing_rules'] = has_existing_rules

            logging.info(f"Upload processed: template_id={template_id}, filename={file.filename}, has_existing_rules={has_existing_rules}")

            return jsonify({
                'success': True,
                'sheets': {sheet_name: {'headers': headers}},
                'file_name': file.filename,
                'template_id': template_id,
                'has_existing_rules': has_existing_rules,
                'sheet_name': sheet_name,
                'skip_to_step_3': has_existing_rules
            })
        except mysql.connector.Error as e:
            logging.error(f'Error saving template: {str(e)}')
            return jsonify({'error': f'Error saving template: {str(e)}'}), 500
        except Exception as e:
            logging.error(f'Unexpected error saving template: {str(e)}')
            return jsonify({'error': f'Unexpected error: {str(e)}'}), 500

    # Multi-step workflow endpoints
    @app.route('/step/1', methods=['GET', 'POST'])
    @app.route('/api/step/1', methods=['GET', 'POST'])
    def step_one():
        if 'loggedin' not in session:
            return jsonify({'error': 'Not logged in'}), 401
        
        if request.method == 'POST':
            try:
                headers = request.form.getlist('headers')
                new_header_row = request.form.get('new_header_row')
                logging.debug(f"Step 1 submitted: headers={headers}, new_header_row={new_header_row}")
                
                if not headers:
                    logging.error("No headers provided in step 1")
                    return jsonify({'success': False, 'message': 'No headers provided'}), 400
                    
                if 'template_id' not in session:
                    logging.error("Session missing template_id")
                    return jsonify({'success': False, 'message': 'Session data missing'}), 400

                template_id = session['template_id']
                
                # Get the dataframe from session for auto-detection
                df_json = session.get('df')
                if df_json:
                    df = pd.read_json(StringIO(df_json))
                    session_headers = session.get('headers', [])
                    df.columns = session_headers
                    header_row = session.get('header_row', 0)
                    df = df.iloc[header_row + 1:].reset_index(drop=True)
                    
                    # Auto-detect rules for selected headers
                    validations = assign_default_rules_to_columns(df, headers)
                    session['validations'] = validations
                    logging.debug(f"Auto-assigned rules: {validations}")
                else:
                    validations = {}

                session['selected_headers'] = headers
                session['current_step'] = 2

                # Mark selected headers in the database
                conn = get_db_connection()
                cursor = conn.cursor()
                cursor.execute("UPDATE template_columns SET is_selected = FALSE WHERE template_id = %s", (template_id,))
                for header in headers:
                    cursor.execute("""
                        UPDATE template_columns
                        SET is_selected = TRUE
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    
                    # Get column_id and add auto-detected rules
                    cursor.execute("""
                        SELECT column_id FROM template_columns
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    result = cursor.fetchone()
                    if result:
                        column_id = result[0]
                        for rule_name in validations.get(header, []):
                            cursor.execute("""
                                SELECT rule_type_id FROM validation_rule_types
                                WHERE rule_name = %s AND is_custom = FALSE
                            """, (rule_name,))
                            rule_result = cursor.fetchone()
                            if rule_result:
                                rule_type_id = rule_result[0]
                                cursor.execute("""
                                    INSERT IGNORE INTO column_validation_rules (column_id, rule_type_id, rule_config)
                                    VALUES (%s, %s, %s)
                                """, (column_id, rule_type_id, '{}'))
                
                conn.commit()
                cursor.close()

                logging.info(f"Step 1 completed: headers={headers}, auto-assigned rules={validations}")
                return jsonify({'success': True, 'headers': headers, 'validations': validations})
            except Exception as e:
                logging.error(f"Error in step 1: {str(e)}")
                return jsonify({'success': False, 'message': str(e)}), 500
        
        # GET request - return current headers
        headers = session.get('headers', [])
        return jsonify({'headers': headers})

    @app.route('/step/2', methods=['GET', 'POST'])
    @app.route('/api/step/2', methods=['GET', 'POST'])
    def step_two():
        if 'loggedin' not in session:
            return jsonify({'error': 'Not logged in'}), 401
            
        if request.method == 'POST':
            try:
                action = request.form.get('action', 'save')
                validations = {}
                for key, values in request.form.lists():
                    if key.startswith('validations_'):
                        header = key.replace('validations_', '')
                        validations[header] = values
                        
                logging.debug(f"Step 2 submitted: action={action}, validations={validations}")
                
                template_id = session.get('template_id')
                if not template_id:
                    return jsonify({'success': False, 'message': 'Session data missing'}), 400

                # Save validations to database
                conn = get_db_connection()
                cursor = conn.cursor()
                
                # Clear existing rules
                cursor.execute("""
                    DELETE FROM column_validation_rules
                    WHERE column_id IN (
                        SELECT column_id FROM template_columns WHERE template_id = %s
                    )
                """, (template_id,))
                
                # Add new rules
                for header, rules in validations.items():
                    cursor.execute("""
                        SELECT column_id FROM template_columns
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    result = cursor.fetchone()
                    if not result:
                        continue
                    column_id = result[0]
                    
                    for rule_name in rules:
                        cursor.execute("""
                            SELECT rule_type_id FROM validation_rule_types
                            WHERE rule_name = %s
                        """, (rule_name,))
                        result = cursor.fetchone()
                        if result:
                            rule_type_id = result[0]
                            cursor.execute("""
                                INSERT IGNORE INTO column_validation_rules (column_id, rule_type_id, rule_config)
                                VALUES (%s, %s, %s)
                            """, (column_id, rule_type_id, '{}'))
                
                conn.commit()
                cursor.close()

                session['validations'] = validations
                session['current_step'] = 3 if action == 'review' else 2
                
                logging.info(f"Step 2 completed: action={action}, validations={validations}")
                return jsonify({'success': True, 'message': 'Step 2 completed successfully'})
            except Exception as e:
                logging.error(f"Error in step 2: {str(e)}")
                return jsonify({'success': False, 'message': str(e)}), 500
        
        # GET request
        selected_headers = session.get('selected_headers', [])
        return jsonify({'selected_headers': selected_headers})

    # Rules endpoint
    @app.route('/rules', methods=['GET'])
    @app.route('/api/rules', methods=['GET'])
    def get_rules():
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            
            cursor.execute("""
                SELECT rule_type_id AS rule_id, rule_name, description, parameters, is_custom, 
                       column_name, template_id, source_format, target_format, data_type, is_active
                FROM validation_rule_types
            """)
            rules = cursor.fetchall()
            cursor.close()
            
            logging.info(f"Returning {len(rules)} rules from getRules endpoint")
            return jsonify({'success': True, 'rules': rules})
        except mysql.connector.Error as e:
            logging.error(f"Database error fetching rules: {str(e)}")
            return jsonify({'success': False, 'message': str(e)}), 500
        except Exception as e:
            logging.error(f"Unexpected error fetching rules: {str(e)}")
            return jsonify({'success': False, 'message': str(e)}), 500

    # Template details endpoint
    @app.route('/template/<int:template_id>/<sheet_name>', methods=['GET'])
    @app.route('/api/template/<int:template_id>/<sheet_name>', methods=['GET'])
    def get_template(template_id, sheet_name):
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /template: session missing")
            return jsonify({'error': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("""
                SELECT template_name, sheet_name, headers
                FROM excel_templates
                WHERE template_id = %s AND user_id = %s AND status = 'ACTIVE'
            """, (template_id, session['user_id']))
            template_record = cursor.fetchone()
            
            if not template_record:
                logging.error(f"Template not found for template_id: {template_id}, user_id: {session['user_id']}")
                cursor.close()
                return jsonify({'error': 'Template not found'}), 404

            headers = json.loads(template_record['headers']) if template_record['headers'] else []
            stored_sheet_name = template_record['sheet_name'] or sheet_name
            file_path = os.path.join(app.config['UPLOAD_FOLDER'], template_record['template_name'])
            
            cursor.execute("""
                SELECT COUNT(*) as rule_count
                FROM template_columns tc
                JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                WHERE tc.template_id = %s AND tc.is_selected = TRUE
            """, (template_id,))
            rule_count = cursor.fetchone()['rule_count']
            has_existing_rules = rule_count > 0
            
            cursor.close()
            
            return jsonify({
                'success': True,
                'sheets': {stored_sheet_name: {'headers': headers}},
                'file_name': template_record['template_name'],
                'file_path': file_path,
                'sheet_name': stored_sheet_name,
                'has_existing_rules': has_existing_rules
            })
        except mysql.connector.Error as e:
            logging.error(f"Database error in get_template: {str(e)}")
            return jsonify({'error': f'Database error: {str(e)}'}), 500
        except Exception as e:
            logging.error(f"Unexpected error in get_template: {str(e)}")
            return jsonify({'error': f'Unexpected error: {str(e)}'}), 500

    # Debug route to show all registered routes
    @app.route('/debug/routes', methods=['GET'])
    def list_routes():
        routes = []
        for rule in app.url_map.iter_rules():
            routes.append({
                'endpoint': rule.endpoint,
                'methods': list(rule.methods),
                'rule': rule.rule
            })
        return jsonify(routes)

    # 404 handler to debug missing routes
    @app.errorhandler(404)
    def not_found_handler(error):
        logging.error(f"404 Error: {request.method} {request.url} not found")
        logging.error(f"Available routes: {[rule.rule for rule in app.url_map.iter_rules()]}")
        return jsonify({
            'error': 'Endpoint not found', 
            'method': request.method,
            'url': request.url,
            'path': request.path
        }), 404

    return app

def initialize_app_data():
    """Initialize database and create default data"""
    try:
        logging.info("Initializing database schema...")
        init_db()
        
        logging.info("Creating admin user...")
        create_admin_user()
        
        logging.info("Creating default validation rules...")
        create_default_validation_rules()
        
        logging.info("Application initialization completed successfully")
    except Exception as e:
        logging.error(f"Failed to initialize application: {e}")
        raise

DB_CONFIG = {
    'host': os.getenv('MYSQL_HOST', 'localhost'),
    'user': os.getenv('MYSQL_USER', 'root'),
    'password': os.getenv('MYSQL_PASSWORD', 'Keansa@2024'),
    'database': os.getenv('MYSQL_DATABASE', 'data_validation_2'),
}

def get_db_connection():
    if 'db' not in g:
        try:
            conn = mysql.connector.connect(
                host=DB_CONFIG['host'],
                user=DB_CONFIG['user'],
                password=DB_CONFIG['password']
            )
            cursor = conn.cursor()
            cursor.execute(f"CREATE DATABASE IF NOT EXISTS {DB_CONFIG['database']}")
            cursor.close()
            conn.close()
            g.db = mysql.connector.connect(**DB_CONFIG)
            logging.info("Database connection established successfully")
        except mysql.connector.Error as err:
            if err.errno == errorcode.ER_ACCESS_DENIED_ERROR:
                logging.error("Database connection failed: Access denied for user - check username/password")
            elif err.errno == errorcode.ER_BAD_DB_ERROR:
                logging.error("Database connection failed: Database does not exist")
            else:
                logging.error(f"Database connection failed: {err}")
            raise Exception(f"Failed to connect to database: {str(err)}")
    return g.db

def close_db(error):
    db = g.pop('db', None)
    if db is not None:
        db.close()

def init_db():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        tables = [
            """
            CREATE TABLE IF NOT EXISTS login_details (
                id INT AUTO_INCREMENT PRIMARY KEY,
                first_name VARCHAR(100),
                last_name VARCHAR(100),
                email VARCHAR(255) UNIQUE,
                mobile VARCHAR(10),
                password VARCHAR(255)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS excel_templates (
                template_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_name VARCHAR(255) NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
                user_id INT NOT NULL,
                sheet_name VARCHAR(255),
                headers JSON,
                status ENUM('ACTIVE', 'INACTIVE') DEFAULT 'ACTIVE',
                is_corrected BOOLEAN DEFAULT FALSE,
                remote_file_path VARCHAR(512),
                FOREIGN KEY (user_id) REFERENCES login_details(id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS template_columns (
                column_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_id BIGINT NOT NULL,
                column_name VARCHAR(255) NOT NULL,
                column_position INT NOT NULL,
                is_validation_enabled BOOLEAN DEFAULT FALSE,
                is_selected BOOLEAN DEFAULT FALSE,
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE,
                UNIQUE (template_id, column_name)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_rule_types (
                rule_type_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                rule_name VARCHAR(255) NOT NULL,
                description TEXT,
                parameters TEXT,
                is_active BOOLEAN DEFAULT TRUE,
                is_custom BOOLEAN DEFAULT FALSE,
                column_name VARCHAR(255),
                template_id BIGINT,
                data_type VARCHAR(50),
                source_format VARCHAR(50),
                target_format VARCHAR(50),
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS column_validation_rules (
                column_validation_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                column_id BIGINT NOT NULL,
                rule_type_id BIGINT NOT NULL,
                rule_config JSON,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (column_id) REFERENCES template_columns(column_id) ON DELETE CASCADE,
                FOREIGN KEY (rule_type_id) REFERENCES validation_rule_types(rule_type_id) ON DELETE RESTRICT,
                UNIQUE (column_id, rule_type_id)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_history (
                history_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_id BIGINT NOT NULL,
                template_name VARCHAR(255) NOT NULL,
                error_count INT NOT NULL,
                corrected_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                corrected_file_path VARCHAR(512) NOT NULL,
                user_id INT NOT NULL,
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE,
                FOREIGN KEY (user_id) REFERENCES login_details(id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_corrections (
                correction_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                history_id BIGINT NOT NULL,
                row_index INT NOT NULL,
                column_name VARCHAR(255) NOT NULL,
                original_value TEXT,
                corrected_value TEXT,
                rule_failed VARCHAR(255) DEFAULT NULL,
                FOREIGN KEY (history_id) REFERENCES validation_history(history_id) ON DELETE CASCADE
            )
            """
        ]
        for table_sql in tables:
            cursor.execute(table_sql)
        
        # Add missing columns if they don't exist
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'source_format'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN source_format VARCHAR(50)")
            logging.info("Added source_format column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'target_format'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN target_format VARCHAR(50)")
            logging.info("Added target_format column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'data_type'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN data_type VARCHAR(50)")
            logging.info("Added data_type column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM excel_templates LIKE 'remote_file_path'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE excel_templates ADD COLUMN remote_file_path VARCHAR(512)")
            logging.info("Added remote_file_path column to excel_templates table")
            
        cursor.execute("SHOW COLUMNS FROM template_columns LIKE 'is_selected'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE template_columns ADD COLUMN is_selected BOOLEAN DEFAULT FALSE")
            logging.info("Added is_selected column to template_columns table")
            
        conn.commit()
        cursor.close()
        logging.info("Database tables initialized")
    except Exception as e:
        logging.error(f"Failed to initialize database: {str(e)}")
        raise

def create_admin_user():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        admin_password = bcrypt.hashpw('admin'.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
        cursor.execute("""
            INSERT IGNORE INTO login_details (first_name, last_name, email, mobile, password)
            VALUES (%s, %s, %s, %s, %s)
        """, ('Admin', 'User', 'admin@example.com', '1234567890', admin_password))
        conn.commit()
        cursor.close()
        logging.info("Admin user created or already exists")
    except Exception as e:
        logging.error(f"Failed to create admin user: {str(e)}")
        raise

def create_default_validation_rules():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        default_rules = [
            ("Required", "Ensures the field is not null", '{"allow_null": false}', None, None, None),
            ("Int", "Validates integer format", '{"format": "integer"}', None, None, "Int"),
            ("Float", "Validates number format (integer or decimal)", '{"format": "float"}', None, None, "Float"),
            ("Text", "Allows text with quotes and parentheses", '{"allow_special": false}', None, None, "Text"),
            ("Email", "Validates email format", '{"regex": "^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\\\.[a-zA-Z0-9-.]+$"}', None, None, "Email"),
            ("Date(DD-MM-YYYY)", "Validates date format DD-MM-YYYY", '{"format": "%d-%m-%Y"}', "DD-MM-YYYY", None, "Date"),
            ("Boolean", "Validates boolean format (true/false or 0/1)", '{"format": "boolean"}', None, None, "Boolean"),
            ("Alphanumeric", "Validates alphanumeric format", '{"format": "alphanumeric"}', None, None, "Alphanumeric")
        ]
        cursor.executemany("""
            INSERT IGNORE INTO validation_rule_types (rule_name, description, parameters, is_custom, source_format, target_format, data_type)
            VALUES (%s, %s, %s, %s, %s, %s, %s)
        """, [(name, desc, params, False, source, target, dtype) for name, desc, params, source, target, dtype in default_rules])
        conn.commit()
        cursor.close()
        logging.info("Default validation rules ensured successfully")
    except Exception as e:
        logging.error(f"Failed to ensure default validation rules: {str(e)}")
        raise

if __name__ == '__main__':
    try:
        # Create the application using factory pattern
        app = create_app()
        
        # Initialize database and default data within app context
        with app.app_context():
            initialize_app_data()
        
        # Get port from environment or use default
        port = int(os.getenv('PORT', 5000))
        
        # Start the application server
        logging.info("Starting Flask server...")
        app.run(debug=True, host='0.0.0.0', port=port)
        
    except Exception as e:
        logging.error(f"Failed to start application: {e}")
        raise
).all():
        return "Alphanumeric"
    
    return "Text"

def assign_default_rules_to_columns(df, headers):
    """Intelligently assign validation rules based on column content"""
    assignments = {}
    
    for col in headers:
        if col not in df.columns:
            logging.warning(f"Column {col} not found in dataframe")
            continue
            
        col_type = detect_column_type(df[col])
        rules = ["Required"]  # Default rule for all columns
        
        # Special handling for optional columns
        if not any(col.lower().startswith(prefix) for prefix in
                  ["name", "address", "phone", "username", "status", "period"]):
            rules.append(col_type)
        else:
            rules.append("Text")  # Optional text fields
        
        assignments[col] = rules
    
    return assignments

def create_app():
    """Application factory pattern for different environments"""
    # Set the path to the frontend dist folder
    current_dir = os.path.dirname(os.path.abspath(__file__))
    frontend_dist_path = os.path.join(current_dir, '..', '..', 'Keansa-Ai-Suite2025may-frontend11', 'dist')
    frontend_dist_path = os.path.abspath(frontend_dist_path)
    
    # Create Flask application instance
    app = Flask(__name__, static_folder=frontend_dist_path, static_url_path='')
    CORS(app, supports_credentials=True, origins=["http://localhost:3000", "http://localhost:8080", "http://localhost:5000", "*"])

    app.secret_key = os.urandom(24).hex()
    app.config['SESSION_TYPE'] = 'filesystem'
    app.config['SESSION_FILE_DIR'] = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'sessions')
    app.config['SESSION_COOKIE_SAMESITE'] = 'Lax'
    app.config['SESSION_COOKIE_HTTPONLY'] = True
    app.config['SESSION_COOKIE_SECURE'] = False
    app.config['PERMANENT_SESSION_LIFETIME'] = 86400  # 24 hours
    app.config['UPLOAD_FOLDER'] = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'uploads')
    Session(app)

    # Ensure directories exist
    try:
        os.makedirs(app.config['UPLOAD_FOLDER'], exist_ok=True)
        os.makedirs(app.config['SESSION_FILE_DIR'], exist_ok=True)
    except OSError as e:
        logging.error(f"Failed to create directories: {e}")

    # Register cleanup handlers
    app.teardown_appcontext(close_db)
    
    # Register all routes directly in create_app
    
    # Static file serving for React frontend
    @app.route('/', defaults={'path': ''})
    @app.route('/<path:path>')
    def serve(path):
        if path and os.path.exists(os.path.join(app.static_folder, path)):
            return app.send_static_file(path)
        return app.send_static_file('index.html')

    # Health check endpoint
    @app.route('/health', methods=['GET'])
    def health_check():
        return jsonify({
            'status': 'healthy',
            'timestamp': datetime.now().isoformat(),
            'version': '2.0.0'
        })

    # Authentication endpoint - both old and new paths
    @app.route('/authenticate', methods=['POST'])
    @app.route('/api/auth/authenticate', methods=['POST'])
    def authenticate():
        try:
            email = request.form.get('username') or request.form.get('email')
            password = request.form.get('password')
            logging.debug(f"Login attempt: email={email}, password={'*' * len(password) if password else 'None'}")
            
            if not email or not password:
                logging.warning(f"Login failed: Email or password missing")
                return jsonify({'success': False, 'message': 'Email and password are required'}), 400

            # Check for admin login
            if email == "admin" and password == "admin":
                session['loggedin'] = True
                session['user_email'] = "admin@example.com"
                session['user_id'] = 1
                session.permanent = True
                logging.info(f"Admin login successful. Session: {dict(session)}")
                return jsonify({'success': True, 'message': 'Login successful', 'user': {'email': 'admin@example.com', 'id': 1}}), 200

            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("SELECT * FROM login_details WHERE LOWER(email) = LOWER(%s)", (email.lower(),))
            account = cursor.fetchone()
            cursor.close()
            
            if account:
                if bcrypt.checkpw(password.encode('utf-8'), account['password'].encode('utf-8')):
                    session['loggedin'] = True
                    session['user_email'] = account['email']
                    session['user_id'] = account['id']
                    session.permanent = True
                    logging.info(f"User {email} logged in successfully. Session: {dict(session)}")
                    return jsonify({
                        'success': True,
                        'message': 'Login successful',
                        'user': {'email': account['email'], 'id': account['id']}
                    }), 200
                else:
                    logging.warning(f"Invalid password for {email}")
                    return jsonify({'success': False, 'message': 'Invalid credentials'}), 401
            else:
                logging.warning(f"Email {email} not found")
                return jsonify({'success': False, 'message': 'Invalid credentials'}), 401
        except Exception as e:
            logging.error(f"Unexpected error during login: {str(e)}")
            return jsonify({'success': False, 'message': f'Unexpected error: {str(e)}'}), 500

    @app.route('/check-auth', methods=['GET'])
    @app.route('/api/auth/check-auth', methods=['GET'])
    def check_auth():
        try:
            logging.debug(f"Checking auth with session: {dict(session)}")
            if 'loggedin' in session and 'user_id' in session:
                conn = get_db_connection()
                cursor = conn.cursor(dictionary=True)
                cursor.execute("SELECT email, first_name FROM login_details WHERE id = %s", (session['user_id'],))
                user = cursor.fetchone()
                cursor.close()
                if user:
                    logging.info(f"User {session.get('user_email')} is authenticated")
                    return jsonify({
                        'success': True,
                        'user': {
                            'email': user['email'],
                            'id': session['user_id'],
                            'first_name': user['first_name']
                        }
                    })
                else:
                    logging.warning("User not found in database")  
                    session.clear()
                    return jsonify({'success': False, 'message': 'User not found'}), 401
            logging.warning("User not authenticated")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        except Exception as e:
            logging.error(f"Error in check-auth endpoint: {str(e)}")
            return jsonify({'success': False, 'message': f'Server error: {str(e)}'}), 500

    @app.route('/register', methods=['POST'])
    @app.route('/api/auth/register', methods=['POST'])
    def register():
        first_name = request.form.get('first_name')
        last_name = request.form.get('last_name')
        email = request.form.get('email')
        mobile = request.form.get('mobile')
        password = request.form.get('password')
        confirm_password = request.form.get('confirm_password')

        if not all([first_name, last_name, email, mobile, password, confirm_password]):
            return jsonify({'success': False, 'message': 'All fields are required'}), 400
        if password != confirm_password:
            return jsonify({'success': False, 'message': 'Passwords do not match'}), 400

        hashed_password = bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
        try:
            conn = get_db_connection()
            cursor = conn.cursor()
            cursor.execute("""
                INSERT INTO login_details (first_name, last_name, email, mobile, password)
                VALUES (%s, %s, %s, %s, %s)
            """, (first_name, last_name, email, mobile, hashed_password))
            user_id = cursor.lastrowid
            conn.commit()
            cursor.close()
            session['loggedin'] = True
            session['user_email'] = email
            session['user_id'] = user_id
            return jsonify({
                'success': True,
                'message': 'Registration successful',
                'user': {'email': email, 'id': user_id}
            }), 200
        except mysql.connector.Error as e:
            logging.error(f"Database error during registration: {str(e)}")
            return jsonify({'success': False, 'message': f'Registration error: {str(e)}'}), 500

    @app.route('/logout', methods=['POST'])
    @app.route('/api/auth/logout', methods=['POST'])
    def logout():
        logging.info(f"User {session.get('user_email', 'unknown')} logged out")
        session.clear()
        return jsonify({'success': True, 'message': 'Logged out successfully'})

    # Template routes
    @app.route('/templates', methods=['GET'])
    @app.route('/api/templates', methods=['GET'])
    def get_templates():
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /templates: session missing")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("""
                SELECT template_id, template_name, created_at, status
                FROM excel_templates
                WHERE user_id = %s AND status = 'ACTIVE'
                ORDER BY created_at DESC
                LIMIT 100
            """, (session['user_id'],))
            templates = cursor.fetchall()
            cursor.close()
            logging.info(f"Fetched {len(templates)} templates for user {session['user_id']}")
            return jsonify({'success': True, 'templates': templates})
        except mysql.connector.Error as e:
            logging.error(f'Error fetching templates: {str(e)}')
            return jsonify({'success': False, 'message': f'Error fetching templates: {str(e)}'}), 500
        except Exception as e:
            logging.error(f'Unexpected error fetching templates: {str(e)}')
            return jsonify({'success': False, 'message': f'Unexpected error: {str(e)}'}), 500

    # Rule Configuration routes
    @app.route('/rule-configurations', methods=['GET'])
    @app.route('/api/validation/rule-configurations', methods=['GET'])
    def get_rule_configurations():
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning(f"Unauthorized access to /rule-configurations: session={dict(session)}")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            user_id = session['user_id']
            logging.debug(f"Fetching rule configurations for user_id: {user_id}")

            # Main query to fetch templates with configured rules
            cursor.execute("""
                SELECT 
                    t.template_id, 
                    t.template_name, 
                    t.created_at, 
                    COUNT(cvr.column_validation_id) as rule_count
                FROM excel_templates t
                LEFT JOIN template_columns tc ON t.template_id = tc.template_id
                LEFT JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                WHERE t.user_id = %s AND t.status = 'ACTIVE' AND t.is_corrected = FALSE
                GROUP BY t.template_id, t.template_name, t.created_at
                HAVING rule_count > 0
                ORDER BY t.created_at DESC
                LIMIT 100
            """, (user_id,))
            templates = cursor.fetchall()
            logging.debug(f"Fetched rule-configured templates: {templates}")

            cursor.close()

            if not templates:
                logging.info(f"No templates with rules found for user_id: {user_id}")
            else:
                logging.info(f"Found {len(templates)} templates with rules for user_id: {user_id}")

            return jsonify({'success': True, 'templates': templates})
        except mysql.connector.Error as e:
            logging.error(f"Database error fetching rule configurations: {str(e)}")
            return jsonify({'success': False, 'message': f"Database error: {str(e)}"}), 500
        except Exception as e:
            logging.error(f"Unexpected error fetching rule configurations: {str(e)}")
            return jsonify({'success': False, 'message': f"Unexpected error: {str(e)}"}), 500

    # File upload route
    @app.route('/upload', methods=['POST'])
    @app.route('/api/templates/upload', methods=['POST'])
    @app.route('/api/upload', methods=['POST'])  # Additional common path
    def upload():
        logging.info(f"Upload endpoint called: {request.endpoint}, method: {request.method}")
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /upload: session missing")
            return jsonify({'error': 'Not logged in'}), 401
        if 'file' not in request.files:
            logging.warning("No file provided in upload request")
            return jsonify({'error': 'No file uploaded'}), 400
        file = request.files['file']
        if file.filename == '':
            logging.warning("No file selected in upload request")
            return jsonify({'error': 'No file selected'}), 400
        
        file_path = os.path.join(app.config['UPLOAD_FOLDER'], file.filename)
        try:
            file.save(file_path)
            logging.info(f"File saved: {file_path}")
        except Exception as e:
            logging.error(f"Failed to save file {file.filename}: {str(e)}")
            return jsonify({'error': f'Failed to save file: {str(e)}'}), 500

        try:
            # Read the file to get sheets and headers
            if file.filename.endswith('.xlsx') or file.filename.endswith('.xls'):
                xl = pd.ExcelFile(file_path)
                sheets = {sheet_name: pd.read_excel(file_path, sheet_name=sheet_name, header=None) 
                         for sheet_name in xl.sheet_names}
            elif file.filename.endswith(('.txt', '.csv', '.dat')):
                df = pd.read_csv(file_path, header=None, encoding='utf-8')
                sheets = {'Sheet1': df}
            else:
                logging.error("Unsupported file type")
                return jsonify({'error': 'Unsupported file type'}), 400
            
            logging.debug(f"Sheets extracted: {list(sheets.keys())}")
        except Exception as e:
            logging.error(f"Failed to read file {file_path}: {str(e)}")
            return jsonify({'error': f'Failed to read file: {str(e)}'}), 400

        try:
            sheet_names = list(sheets.keys())
            if not sheet_names:
                logging.error("No sheets found in the file")
                return jsonify({'error': 'No sheets found in the file'}), 400
            sheet_name = sheet_names[0]
            df = sheets[sheet_name]
            
            # Find header row
            header_row = 0
            for i in range(min(len(df), 10)):
                row = df.iloc[i].dropna()
                if not row.empty and all(isinstance(x, str) for x in row if pd.notna(x)):
                    header_row = i
                    break
                    
            headers = df.iloc[header_row].tolist()
            logging.debug(f"Headers extracted: {headers}")
            
            if not headers or all(not h for h in headers):
                logging.error("No valid headers found in file")
                return jsonify({'error': 'No valid headers found in the file'}), 400
        except Exception as e:
            logging.error(f"Error processing file {file.filename}: {str(e)}")
            return jsonify({'error': f'Error processing file: {str(e)}'}), 400

        # Clear existing session data
        for key in ['df', 'header_row', 'headers', 'sheet_name', 'current_step', 'selected_headers', 'validations', 'error_cell_locations', 'data_rows', 'corrected_file_path']:
            session.pop(key, None)

        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)

            # Check if template exists
            cursor.execute("""
                SELECT template_id, headers, sheet_name
                FROM excel_templates
                WHERE template_name = %s AND user_id = %s AND status = 'ACTIVE'
                ORDER BY created_at DESC
            """, (file.filename, session['user_id']))
            existing_templates = cursor.fetchall()
            logging.info(f"Found {len(existing_templates)} existing templates with name {file.filename}")

            template_id = None
            has_existing_rules = False
            validations = {}
            selected_headers = []

            # Check for matching template
            matching_template = None
            for template in existing_templates:
                stored_headers = json.loads(template['headers']) if template['headers'] else []
                stored_sheet_name = template['sheet_name']
                if stored_headers == headers and stored_sheet_name == sheet_name:
                    matching_template = template
                    break

            if matching_template:
                template_id = matching_template['template_id']
                # Check for existing rules
                cursor.execute("""
                    SELECT tc.column_name, vrt.rule_name
                    FROM template_columns tc
                    JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                    JOIN validation_rule_types vrt ON cvr.rule_type_id = vrt.rule_type_id
                    WHERE tc.template_id = %s AND tc.is_selected = TRUE
                """, (template_id,))
                rules_data = cursor.fetchall()
                for row in rules_data:
                    column_name = row['column_name']
                    rule_name = row['rule_name']
                    if column_name not in validations:
                        validations[column_name] = []
                    validations[column_name].append(rule_name)
                    if column_name not in selected_headers:
                        selected_headers.append(column_name)
                has_existing_rules = len(validations) > 0
            else:
                # New template
                cursor.execute("""
                    INSERT INTO excel_templates (template_name, user_id, sheet_name, headers, is_corrected)
                    VALUES (%s, %s, %s, %s, %s)
                """, (file.filename, session['user_id'], sheet_name, json.dumps(headers), False))
                template_id = cursor.lastrowid
                column_data = [(template_id, header, i + 1, False) for i, header in enumerate(headers)]
                cursor.executemany("""
                    INSERT INTO template_columns (template_id, column_name, column_position, is_selected)
                    VALUES (%s, %s, %s, %s)
                """, column_data)

            conn.commit()
            cursor.close()

            # Store session data
            session['file_path'] = file_path
            session['template_id'] = template_id
            session['df'] = df.to_json()
            session['header_row'] = header_row
            session['headers'] = headers
            session['sheet_name'] = sheet_name
            session['current_step'] = 1 if not has_existing_rules else 3
            session['validations'] = validations
            session['selected_headers'] = selected_headers
            session['has_existing_rules'] = has_existing_rules

            logging.info(f"Upload processed: template_id={template_id}, filename={file.filename}, has_existing_rules={has_existing_rules}")

            return jsonify({
                'success': True,
                'sheets': {sheet_name: {'headers': headers}},
                'file_name': file.filename,
                'template_id': template_id,
                'has_existing_rules': has_existing_rules,
                'sheet_name': sheet_name,
                'skip_to_step_3': has_existing_rules
            })
        except mysql.connector.Error as e:
            logging.error(f'Error saving template: {str(e)}')
            return jsonify({'error': f'Error saving template: {str(e)}'}), 500
        except Exception as e:
            logging.error(f'Unexpected error saving template: {str(e)}')
            return jsonify({'error': f'Unexpected error: {str(e)}'}), 500

    # Multi-step workflow endpoints
    @app.route('/step/1', methods=['GET', 'POST'])
    @app.route('/api/step/1', methods=['GET', 'POST'])
    def step_one():
        if 'loggedin' not in session:
            return jsonify({'error': 'Not logged in'}), 401
        
        if request.method == 'POST':
            try:
                headers = request.form.getlist('headers')
                new_header_row = request.form.get('new_header_row')
                logging.debug(f"Step 1 submitted: headers={headers}, new_header_row={new_header_row}")
                
                if not headers:
                    logging.error("No headers provided in step 1")
                    return jsonify({'success': False, 'message': 'No headers provided'}), 400
                    
                if 'template_id' not in session:
                    logging.error("Session missing template_id")
                    return jsonify({'success': False, 'message': 'Session data missing'}), 400

                template_id = session['template_id']
                
                # Get the dataframe from session for auto-detection
                df_json = session.get('df')
                if df_json:
                    df = pd.read_json(StringIO(df_json))
                    session_headers = session.get('headers', [])
                    df.columns = session_headers
                    header_row = session.get('header_row', 0)
                    df = df.iloc[header_row + 1:].reset_index(drop=True)
                    
                    # Auto-detect rules for selected headers
                    validations = assign_default_rules_to_columns(df, headers)
                    session['validations'] = validations
                    logging.debug(f"Auto-assigned rules: {validations}")
                else:
                    validations = {}

                session['selected_headers'] = headers
                session['current_step'] = 2

                # Mark selected headers in the database
                conn = get_db_connection()
                cursor = conn.cursor()
                cursor.execute("UPDATE template_columns SET is_selected = FALSE WHERE template_id = %s", (template_id,))
                for header in headers:
                    cursor.execute("""
                        UPDATE template_columns
                        SET is_selected = TRUE
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    
                    # Get column_id and add auto-detected rules
                    cursor.execute("""
                        SELECT column_id FROM template_columns
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    result = cursor.fetchone()
                    if result:
                        column_id = result[0]
                        for rule_name in validations.get(header, []):
                            cursor.execute("""
                                SELECT rule_type_id FROM validation_rule_types
                                WHERE rule_name = %s AND is_custom = FALSE
                            """, (rule_name,))
                            rule_result = cursor.fetchone()
                            if rule_result:
                                rule_type_id = rule_result[0]
                                cursor.execute("""
                                    INSERT IGNORE INTO column_validation_rules (column_id, rule_type_id, rule_config)
                                    VALUES (%s, %s, %s)
                                """, (column_id, rule_type_id, '{}'))
                
                conn.commit()
                cursor.close()

                logging.info(f"Step 1 completed: headers={headers}, auto-assigned rules={validations}")
                return jsonify({'success': True, 'headers': headers, 'validations': validations})
            except Exception as e:
                logging.error(f"Error in step 1: {str(e)}")
                return jsonify({'success': False, 'message': str(e)}), 500
        
        # GET request - return current headers
        headers = session.get('headers', [])
        return jsonify({'headers': headers})

    @app.route('/step/2', methods=['GET', 'POST'])
    @app.route('/api/step/2', methods=['GET', 'POST'])
    def step_two():
        if 'loggedin' not in session:
            return jsonify({'error': 'Not logged in'}), 401
            
        if request.method == 'POST':
            try:
                action = request.form.get('action', 'save')
                validations = {}
                for key, values in request.form.lists():
                    if key.startswith('validations_'):
                        header = key.replace('validations_', '')
                        validations[header] = values
                        
                logging.debug(f"Step 2 submitted: action={action}, validations={validations}")
                
                template_id = session.get('template_id')
                if not template_id:
                    return jsonify({'success': False, 'message': 'Session data missing'}), 400

                # Save validations to database
                conn = get_db_connection()
                cursor = conn.cursor()
                
                # Clear existing rules
                cursor.execute("""
                    DELETE FROM column_validation_rules
                    WHERE column_id IN (
                        SELECT column_id FROM template_columns WHERE template_id = %s
                    )
                """, (template_id,))
                
                # Add new rules
                for header, rules in validations.items():
                    cursor.execute("""
                        SELECT column_id FROM template_columns
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    result = cursor.fetchone()
                    if not result:
                        continue
                    column_id = result[0]
                    
                    for rule_name in rules:
                        cursor.execute("""
                            SELECT rule_type_id FROM validation_rule_types
                            WHERE rule_name = %s
                        """, (rule_name,))
                        result = cursor.fetchone()
                        if result:
                            rule_type_id = result[0]
                            cursor.execute("""
                                INSERT IGNORE INTO column_validation_rules (column_id, rule_type_id, rule_config)
                                VALUES (%s, %s, %s)
                            """, (column_id, rule_type_id, '{}'))
                
                conn.commit()
                cursor.close()

                session['validations'] = validations
                session['current_step'] = 3 if action == 'review' else 2
                
                logging.info(f"Step 2 completed: action={action}, validations={validations}")
                return jsonify({'success': True, 'message': 'Step 2 completed successfully'})
            except Exception as e:
                logging.error(f"Error in step 2: {str(e)}")
                return jsonify({'success': False, 'message': str(e)}), 500
        
        # GET request
        selected_headers = session.get('selected_headers', [])
        return jsonify({'selected_headers': selected_headers})

    # Rules endpoint
    @app.route('/rules', methods=['GET'])
    @app.route('/api/rules', methods=['GET'])
    def get_rules():
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            
            cursor.execute("""
                SELECT rule_type_id AS rule_id, rule_name, description, parameters, is_custom, 
                       column_name, template_id, source_format, target_format, data_type, is_active
                FROM validation_rule_types
            """)
            rules = cursor.fetchall()
            cursor.close()
            
            logging.info(f"Returning {len(rules)} rules from getRules endpoint")
            return jsonify({'success': True, 'rules': rules})
        except mysql.connector.Error as e:
            logging.error(f"Database error fetching rules: {str(e)}")
            return jsonify({'success': False, 'message': str(e)}), 500
        except Exception as e:
            logging.error(f"Unexpected error fetching rules: {str(e)}")
            return jsonify({'success': False, 'message': str(e)}), 500

    # Template details endpoint
    @app.route('/template/<int:template_id>/<sheet_name>', methods=['GET'])
    @app.route('/api/template/<int:template_id>/<sheet_name>', methods=['GET'])
    def get_template(template_id, sheet_name):
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /template: session missing")
            return jsonify({'error': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("""
                SELECT template_name, sheet_name, headers
                FROM excel_templates
                WHERE template_id = %s AND user_id = %s AND status = 'ACTIVE'
            """, (template_id, session['user_id']))
            template_record = cursor.fetchone()
            
            if not template_record:
                logging.error(f"Template not found for template_id: {template_id}, user_id: {session['user_id']}")
                cursor.close()
                return jsonify({'error': 'Template not found'}), 404

            headers = json.loads(template_record['headers']) if template_record['headers'] else []
            stored_sheet_name = template_record['sheet_name'] or sheet_name
            file_path = os.path.join(app.config['UPLOAD_FOLDER'], template_record['template_name'])
            
            cursor.execute("""
                SELECT COUNT(*) as rule_count
                FROM template_columns tc
                JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                WHERE tc.template_id = %s AND tc.is_selected = TRUE
            """, (template_id,))
            rule_count = cursor.fetchone()['rule_count']
            has_existing_rules = rule_count > 0
            
            cursor.close()
            
            return jsonify({
                'success': True,
                'sheets': {stored_sheet_name: {'headers': headers}},
                'file_name': template_record['template_name'],
                'file_path': file_path,
                'sheet_name': stored_sheet_name,
                'has_existing_rules': has_existing_rules
            })
        except mysql.connector.Error as e:
            logging.error(f"Database error in get_template: {str(e)}")
            return jsonify({'error': f'Database error: {str(e)}'}), 500
        except Exception as e:
            logging.error(f"Unexpected error in get_template: {str(e)}")
            return jsonify({'error': f'Unexpected error: {str(e)}'}), 500

    # Debug route to show all registered routes
    @app.route('/debug/routes', methods=['GET'])
    def list_routes():
        routes = []
        for rule in app.url_map.iter_rules():
            routes.append({
                'endpoint': rule.endpoint,
                'methods': list(rule.methods),
                'rule': rule.rule
            })
        return jsonify(routes)

    # 404 handler to debug missing routes
    @app.errorhandler(404)
    def not_found_handler(error):
        logging.error(f"404 Error: {request.method} {request.url} not found")
        logging.error(f"Available routes: {[rule.rule for rule in app.url_map.iter_rules()]}")
        return jsonify({
            'error': 'Endpoint not found', 
            'method': request.method,
            'url': request.url,
            'path': request.path
        }), 404

    return app

def initialize_app_data():
    """Initialize database and create default data"""
    try:
        logging.info("Initializing database schema...")
        init_db()
        
        logging.info("Creating admin user...")
        create_admin_user()
        
        logging.info("Creating default validation rules...")
        create_default_validation_rules()
        
        logging.info("Application initialization completed successfully")
    except Exception as e:
        logging.error(f"Failed to initialize application: {e}")
        raise

DB_CONFIG = {
    'host': os.getenv('MYSQL_HOST', 'localhost'),
    'user': os.getenv('MYSQL_USER', 'root'),
    'password': os.getenv('MYSQL_PASSWORD', 'Keansa@2024'),
    'database': os.getenv('MYSQL_DATABASE', 'data_validation_2'),
}

def get_db_connection():
    if 'db' not in g:
        try:
            conn = mysql.connector.connect(
                host=DB_CONFIG['host'],
                user=DB_CONFIG['user'],
                password=DB_CONFIG['password']
            )
            cursor = conn.cursor()
            cursor.execute(f"CREATE DATABASE IF NOT EXISTS {DB_CONFIG['database']}")
            cursor.close()
            conn.close()
            g.db = mysql.connector.connect(**DB_CONFIG)
            logging.info("Database connection established successfully")
        except mysql.connector.Error as err:
            if err.errno == errorcode.ER_ACCESS_DENIED_ERROR:
                logging.error("Database connection failed: Access denied for user - check username/password")
            elif err.errno == errorcode.ER_BAD_DB_ERROR:
                logging.error("Database connection failed: Database does not exist")
            else:
                logging.error(f"Database connection failed: {err}")
            raise Exception(f"Failed to connect to database: {str(err)}")
    return g.db

def close_db(error):
    db = g.pop('db', None)
    if db is not None:
        db.close()

def init_db():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        tables = [
            """
            CREATE TABLE IF NOT EXISTS login_details (
                id INT AUTO_INCREMENT PRIMARY KEY,
                first_name VARCHAR(100),
                last_name VARCHAR(100),
                email VARCHAR(255) UNIQUE,
                mobile VARCHAR(10),
                password VARCHAR(255)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS excel_templates (
                template_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_name VARCHAR(255) NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
                user_id INT NOT NULL,
                sheet_name VARCHAR(255),
                headers JSON,
                status ENUM('ACTIVE', 'INACTIVE') DEFAULT 'ACTIVE',
                is_corrected BOOLEAN DEFAULT FALSE,
                remote_file_path VARCHAR(512),
                FOREIGN KEY (user_id) REFERENCES login_details(id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS template_columns (
                column_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_id BIGINT NOT NULL,
                column_name VARCHAR(255) NOT NULL,
                column_position INT NOT NULL,
                is_validation_enabled BOOLEAN DEFAULT FALSE,
                is_selected BOOLEAN DEFAULT FALSE,
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE,
                UNIQUE (template_id, column_name)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_rule_types (
                rule_type_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                rule_name VARCHAR(255) NOT NULL,
                description TEXT,
                parameters TEXT,
                is_active BOOLEAN DEFAULT TRUE,
                is_custom BOOLEAN DEFAULT FALSE,
                column_name VARCHAR(255),
                template_id BIGINT,
                data_type VARCHAR(50),
                source_format VARCHAR(50),
                target_format VARCHAR(50),
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS column_validation_rules (
                column_validation_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                column_id BIGINT NOT NULL,
                rule_type_id BIGINT NOT NULL,
                rule_config JSON,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (column_id) REFERENCES template_columns(column_id) ON DELETE CASCADE,
                FOREIGN KEY (rule_type_id) REFERENCES validation_rule_types(rule_type_id) ON DELETE RESTRICT,
                UNIQUE (column_id, rule_type_id)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_history (
                history_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_id BIGINT NOT NULL,
                template_name VARCHAR(255) NOT NULL,
                error_count INT NOT NULL,
                corrected_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                corrected_file_path VARCHAR(512) NOT NULL,
                user_id INT NOT NULL,
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE,
                FOREIGN KEY (user_id) REFERENCES login_details(id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_corrections (
                correction_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                history_id BIGINT NOT NULL,
                row_index INT NOT NULL,
                column_name VARCHAR(255) NOT NULL,
                original_value TEXT,
                corrected_value TEXT,
                rule_failed VARCHAR(255) DEFAULT NULL,
                FOREIGN KEY (history_id) REFERENCES validation_history(history_id) ON DELETE CASCADE
            )
            """
        ]
        for table_sql in tables:
            cursor.execute(table_sql)
        
        # Add missing columns if they don't exist
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'source_format'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN source_format VARCHAR(50)")
            logging.info("Added source_format column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'target_format'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN target_format VARCHAR(50)")
            logging.info("Added target_format column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'data_type'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN data_type VARCHAR(50)")
            logging.info("Added data_type column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM excel_templates LIKE 'remote_file_path'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE excel_templates ADD COLUMN remote_file_path VARCHAR(512)")
            logging.info("Added remote_file_path column to excel_templates table")
            
        cursor.execute("SHOW COLUMNS FROM template_columns LIKE 'is_selected'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE template_columns ADD COLUMN is_selected BOOLEAN DEFAULT FALSE")
            logging.info("Added is_selected column to template_columns table")
            
        conn.commit()
        cursor.close()
        logging.info("Database tables initialized")
    except Exception as e:
        logging.error(f"Failed to initialize database: {str(e)}")
        raise

def create_admin_user():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        admin_password = bcrypt.hashpw('admin'.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
        cursor.execute("""
            INSERT IGNORE INTO login_details (first_name, last_name, email, mobile, password)
            VALUES (%s, %s, %s, %s, %s)
        """, ('Admin', 'User', 'admin@example.com', '1234567890', admin_password))
        conn.commit()
        cursor.close()
        logging.info("Admin user created or already exists")
    except Exception as e:
        logging.error(f"Failed to create admin user: {str(e)}")
        raise

def create_default_validation_rules():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        default_rules = [
            ("Required", "Ensures the field is not null", '{"allow_null": false}', None, None, None),
            ("Int", "Validates integer format", '{"format": "integer"}', None, None, "Int"),
            ("Float", "Validates number format (integer or decimal)", '{"format": "float"}', None, None, "Float"),
            ("Text", "Allows text with quotes and parentheses", '{"allow_special": false}', None, None, "Text"),
            ("Email", "Validates email format", '{"regex": "^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\\\.[a-zA-Z0-9-.]+$"}', None, None, "Email"),
            ("Date(DD-MM-YYYY)", "Validates date format DD-MM-YYYY", '{"format": "%d-%m-%Y"}', "DD-MM-YYYY", None, "Date"),
            ("Boolean", "Validates boolean format (true/false or 0/1)", '{"format": "boolean"}', None, None, "Boolean"),
            ("Alphanumeric", "Validates alphanumeric format", '{"format": "alphanumeric"}', None, None, "Alphanumeric")
        ]
        cursor.executemany("""
            INSERT IGNORE INTO validation_rule_types (rule_name, description, parameters, is_custom, source_format, target_format, data_type)
            VALUES (%s, %s, %s, %s, %s, %s, %s)
        """, [(name, desc, params, False, source, target, dtype) for name, desc, params, source, target, dtype in default_rules])
        conn.commit()
        cursor.close()
        logging.info("Default validation rules ensured successfully")
    except Exception as e:
        logging.error(f"Failed to ensure default validation rules: {str(e)}")
        raise

if __name__ == '__main__':
    try:
        # Create the application using factory pattern
        app = create_app()
        
        # Initialize database and default data within app context
        with app.app_context():
            initialize_app_data()
        
        # Get port from environment or use default
        port = int(os.getenv('PORT', 5000))
        
        # Start the application server
        logging.info("Starting Flask server...")
        app.run(debug=True, host='0.0.0.0', port=port)
        
    except Exception as e:
        logging.error(f"Failed to start application: {e}")
        raise
).any():
        return "Email"

def create_app():
    """Application factory pattern for different environments"""
    # Set the path to the frontend dist folder
    current_dir = os.path.dirname(os.path.abspath(__file__))
    frontend_dist_path = os.path.join(current_dir, '..', '..', 'Keansa-Ai-Suite2025may-frontend11', 'dist')
    frontend_dist_path = os.path.abspath(frontend_dist_path)
    
    # Create Flask application instance
    app = Flask(__name__, static_folder=frontend_dist_path, static_url_path='')
    CORS(app, supports_credentials=True, origins=["http://localhost:3000", "http://localhost:8080", "http://localhost:5000", "*"])

    app.secret_key = os.urandom(24).hex()
    app.config['SESSION_TYPE'] = 'filesystem'
    app.config['SESSION_FILE_DIR'] = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'sessions')
    app.config['SESSION_COOKIE_SAMESITE'] = 'Lax'
    app.config['SESSION_COOKIE_HTTPONLY'] = True
    app.config['SESSION_COOKIE_SECURE'] = False
    app.config['PERMANENT_SESSION_LIFETIME'] = 86400  # 24 hours
    app.config['UPLOAD_FOLDER'] = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'uploads')
    Session(app)

    # Ensure directories exist
    try:
        os.makedirs(app.config['UPLOAD_FOLDER'], exist_ok=True)
        os.makedirs(app.config['SESSION_FILE_DIR'], exist_ok=True)
    except OSError as e:
        logging.error(f"Failed to create directories: {e}")

    # Register cleanup handlers
    app.teardown_appcontext(close_db)
    
    # Register all routes directly in create_app
    
    # Static file serving for React frontend
    @app.route('/', defaults={'path': ''})
    @app.route('/<path:path>')
    def serve(path):
        if path and os.path.exists(os.path.join(app.static_folder, path)):
            return app.send_static_file(path)
        return app.send_static_file('index.html')

    # Health check endpoint
    @app.route('/health', methods=['GET'])
    def health_check():
        return jsonify({
            'status': 'healthy',
            'timestamp': datetime.now().isoformat(),
            'version': '2.0.0'
        })

    # Authentication endpoint - both old and new paths
    @app.route('/authenticate', methods=['POST'])
    @app.route('/api/auth/authenticate', methods=['POST'])
    def authenticate():
        try:
            email = request.form.get('username') or request.form.get('email')
            password = request.form.get('password')
            logging.debug(f"Login attempt: email={email}, password={'*' * len(password) if password else 'None'}")
            
            if not email or not password:
                logging.warning(f"Login failed: Email or password missing")
                return jsonify({'success': False, 'message': 'Email and password are required'}), 400

            # Check for admin login
            if email == "admin" and password == "admin":
                session['loggedin'] = True
                session['user_email'] = "admin@example.com"
                session['user_id'] = 1
                session.permanent = True
                logging.info(f"Admin login successful. Session: {dict(session)}")
                return jsonify({'success': True, 'message': 'Login successful', 'user': {'email': 'admin@example.com', 'id': 1}}), 200

            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("SELECT * FROM login_details WHERE LOWER(email) = LOWER(%s)", (email.lower(),))
            account = cursor.fetchone()
            cursor.close()
            
            if account:
                if bcrypt.checkpw(password.encode('utf-8'), account['password'].encode('utf-8')):
                    session['loggedin'] = True
                    session['user_email'] = account['email']
                    session['user_id'] = account['id']
                    session.permanent = True
                    logging.info(f"User {email} logged in successfully. Session: {dict(session)}")
                    return jsonify({
                        'success': True,
                        'message': 'Login successful',
                        'user': {'email': account['email'], 'id': account['id']}
                    }), 200
                else:
                    logging.warning(f"Invalid password for {email}")
                    return jsonify({'success': False, 'message': 'Invalid credentials'}), 401
            else:
                logging.warning(f"Email {email} not found")
                return jsonify({'success': False, 'message': 'Invalid credentials'}), 401
        except Exception as e:
            logging.error(f"Unexpected error during login: {str(e)}")
            return jsonify({'success': False, 'message': f'Unexpected error: {str(e)}'}), 500

    @app.route('/check-auth', methods=['GET'])
    @app.route('/api/auth/check-auth', methods=['GET'])
    def check_auth():
        try:
            logging.debug(f"Checking auth with session: {dict(session)}")
            if 'loggedin' in session and 'user_id' in session:
                conn = get_db_connection()
                cursor = conn.cursor(dictionary=True)
                cursor.execute("SELECT email, first_name FROM login_details WHERE id = %s", (session['user_id'],))
                user = cursor.fetchone()
                cursor.close()
                if user:
                    logging.info(f"User {session.get('user_email')} is authenticated")
                    return jsonify({
                        'success': True,
                        'user': {
                            'email': user['email'],
                            'id': session['user_id'],
                            'first_name': user['first_name']
                        }
                    })
                else:
                    logging.warning("User not found in database")  
                    session.clear()
                    return jsonify({'success': False, 'message': 'User not found'}), 401
            logging.warning("User not authenticated")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        except Exception as e:
            logging.error(f"Error in check-auth endpoint: {str(e)}")
            return jsonify({'success': False, 'message': f'Server error: {str(e)}'}), 500

    @app.route('/register', methods=['POST'])
    @app.route('/api/auth/register', methods=['POST'])
    def register():
        first_name = request.form.get('first_name')
        last_name = request.form.get('last_name')
        email = request.form.get('email')
        mobile = request.form.get('mobile')
        password = request.form.get('password')
        confirm_password = request.form.get('confirm_password')

        if not all([first_name, last_name, email, mobile, password, confirm_password]):
            return jsonify({'success': False, 'message': 'All fields are required'}), 400
        if password != confirm_password:
            return jsonify({'success': False, 'message': 'Passwords do not match'}), 400

        hashed_password = bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
        try:
            conn = get_db_connection()
            cursor = conn.cursor()
            cursor.execute("""
                INSERT INTO login_details (first_name, last_name, email, mobile, password)
                VALUES (%s, %s, %s, %s, %s)
            """, (first_name, last_name, email, mobile, hashed_password))
            user_id = cursor.lastrowid
            conn.commit()
            cursor.close()
            session['loggedin'] = True
            session['user_email'] = email
            session['user_id'] = user_id
            return jsonify({
                'success': True,
                'message': 'Registration successful',
                'user': {'email': email, 'id': user_id}
            }), 200
        except mysql.connector.Error as e:
            logging.error(f"Database error during registration: {str(e)}")
            return jsonify({'success': False, 'message': f'Registration error: {str(e)}'}), 500

    @app.route('/logout', methods=['POST'])
    @app.route('/api/auth/logout', methods=['POST'])
    def logout():
        logging.info(f"User {session.get('user_email', 'unknown')} logged out")
        session.clear()
        return jsonify({'success': True, 'message': 'Logged out successfully'})

    # Template routes
    @app.route('/templates', methods=['GET'])
    @app.route('/api/templates', methods=['GET'])
    def get_templates():
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /templates: session missing")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("""
                SELECT template_id, template_name, created_at, status
                FROM excel_templates
                WHERE user_id = %s AND status = 'ACTIVE'
                ORDER BY created_at DESC
                LIMIT 100
            """, (session['user_id'],))
            templates = cursor.fetchall()
            cursor.close()
            logging.info(f"Fetched {len(templates)} templates for user {session['user_id']}")
            return jsonify({'success': True, 'templates': templates})
        except mysql.connector.Error as e:
            logging.error(f'Error fetching templates: {str(e)}')
            return jsonify({'success': False, 'message': f'Error fetching templates: {str(e)}'}), 500
        except Exception as e:
            logging.error(f'Unexpected error fetching templates: {str(e)}')
            return jsonify({'success': False, 'message': f'Unexpected error: {str(e)}'}), 500

    # Rule Configuration routes
    @app.route('/rule-configurations', methods=['GET'])
    @app.route('/api/validation/rule-configurations', methods=['GET'])
    def get_rule_configurations():
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning(f"Unauthorized access to /rule-configurations: session={dict(session)}")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            user_id = session['user_id']
            logging.debug(f"Fetching rule configurations for user_id: {user_id}")

            # Main query to fetch templates with configured rules
            cursor.execute("""
                SELECT 
                    t.template_id, 
                    t.template_name, 
                    t.created_at, 
                    COUNT(cvr.column_validation_id) as rule_count
                FROM excel_templates t
                LEFT JOIN template_columns tc ON t.template_id = tc.template_id
                LEFT JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                WHERE t.user_id = %s AND t.status = 'ACTIVE' AND t.is_corrected = FALSE
                GROUP BY t.template_id, t.template_name, t.created_at
                HAVING rule_count > 0
                ORDER BY t.created_at DESC
                LIMIT 100
            """, (user_id,))
            templates = cursor.fetchall()
            logging.debug(f"Fetched rule-configured templates: {templates}")

            cursor.close()

            if not templates:
                logging.info(f"No templates with rules found for user_id: {user_id}")
            else:
                logging.info(f"Found {len(templates)} templates with rules for user_id: {user_id}")

            return jsonify({'success': True, 'templates': templates})
        except mysql.connector.Error as e:
            logging.error(f"Database error fetching rule configurations: {str(e)}")
            return jsonify({'success': False, 'message': f"Database error: {str(e)}"}), 500
        except Exception as e:
            logging.error(f"Unexpected error fetching rule configurations: {str(e)}")
            return jsonify({'success': False, 'message': f"Unexpected error: {str(e)}"}), 500

    # File upload route
    @app.route('/upload', methods=['POST'])
    @app.route('/api/templates/upload', methods=['POST'])
    @app.route('/api/upload', methods=['POST'])  # Additional common path
    def upload():
        logging.info(f"Upload endpoint called: {request.endpoint}, method: {request.method}")
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /upload: session missing")
            return jsonify({'error': 'Not logged in'}), 401
        if 'file' not in request.files:
            logging.warning("No file provided in upload request")
            return jsonify({'error': 'No file uploaded'}), 400
        file = request.files['file']
        if file.filename == '':
            logging.warning("No file selected in upload request")
            return jsonify({'error': 'No file selected'}), 400
        
        file_path = os.path.join(app.config['UPLOAD_FOLDER'], file.filename)
        try:
            file.save(file_path)
            logging.info(f"File saved: {file_path}")
        except Exception as e:
            logging.error(f"Failed to save file {file.filename}: {str(e)}")
            return jsonify({'error': f'Failed to save file: {str(e)}'}), 500

        try:
            # Read the file to get sheets and headers
            if file.filename.endswith('.xlsx') or file.filename.endswith('.xls'):
                xl = pd.ExcelFile(file_path)
                sheets = {sheet_name: pd.read_excel(file_path, sheet_name=sheet_name, header=None) 
                         for sheet_name in xl.sheet_names}
            elif file.filename.endswith(('.txt', '.csv', '.dat')):
                df = pd.read_csv(file_path, header=None, encoding='utf-8')
                sheets = {'Sheet1': df}
            else:
                logging.error("Unsupported file type")
                return jsonify({'error': 'Unsupported file type'}), 400
            
            logging.debug(f"Sheets extracted: {list(sheets.keys())}")
        except Exception as e:
            logging.error(f"Failed to read file {file_path}: {str(e)}")
            return jsonify({'error': f'Failed to read file: {str(e)}'}), 400

        try:
            sheet_names = list(sheets.keys())
            if not sheet_names:
                logging.error("No sheets found in the file")
                return jsonify({'error': 'No sheets found in the file'}), 400
            sheet_name = sheet_names[0]
            df = sheets[sheet_name]
            
            # Find header row
            header_row = 0
            for i in range(min(len(df), 10)):
                row = df.iloc[i].dropna()
                if not row.empty and all(isinstance(x, str) for x in row if pd.notna(x)):
                    header_row = i
                    break
                    
            headers = df.iloc[header_row].tolist()
            logging.debug(f"Headers extracted: {headers}")
            
            if not headers or all(not h for h in headers):
                logging.error("No valid headers found in file")
                return jsonify({'error': 'No valid headers found in the file'}), 400
        except Exception as e:
            logging.error(f"Error processing file {file.filename}: {str(e)}")
            return jsonify({'error': f'Error processing file: {str(e)}'}), 400

        # Clear existing session data
        for key in ['df', 'header_row', 'headers', 'sheet_name', 'current_step', 'selected_headers', 'validations', 'error_cell_locations', 'data_rows', 'corrected_file_path']:
            session.pop(key, None)

        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)

            # Check if template exists
            cursor.execute("""
                SELECT template_id, headers, sheet_name
                FROM excel_templates
                WHERE template_name = %s AND user_id = %s AND status = 'ACTIVE'
                ORDER BY created_at DESC
            """, (file.filename, session['user_id']))
            existing_templates = cursor.fetchall()
            logging.info(f"Found {len(existing_templates)} existing templates with name {file.filename}")

            template_id = None
            has_existing_rules = False
            validations = {}
            selected_headers = []

            # Check for matching template
            matching_template = None
            for template in existing_templates:
                stored_headers = json.loads(template['headers']) if template['headers'] else []
                stored_sheet_name = template['sheet_name']
                if stored_headers == headers and stored_sheet_name == sheet_name:
                    matching_template = template
                    break

            if matching_template:
                template_id = matching_template['template_id']
                # Check for existing rules
                cursor.execute("""
                    SELECT tc.column_name, vrt.rule_name
                    FROM template_columns tc
                    JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                    JOIN validation_rule_types vrt ON cvr.rule_type_id = vrt.rule_type_id
                    WHERE tc.template_id = %s AND tc.is_selected = TRUE
                """, (template_id,))
                rules_data = cursor.fetchall()
                for row in rules_data:
                    column_name = row['column_name']
                    rule_name = row['rule_name']
                    if column_name not in validations:
                        validations[column_name] = []
                    validations[column_name].append(rule_name)
                    if column_name not in selected_headers:
                        selected_headers.append(column_name)
                has_existing_rules = len(validations) > 0
            else:
                # New template
                cursor.execute("""
                    INSERT INTO excel_templates (template_name, user_id, sheet_name, headers, is_corrected)
                    VALUES (%s, %s, %s, %s, %s)
                """, (file.filename, session['user_id'], sheet_name, json.dumps(headers), False))
                template_id = cursor.lastrowid
                column_data = [(template_id, header, i + 1, False) for i, header in enumerate(headers)]
                cursor.executemany("""
                    INSERT INTO template_columns (template_id, column_name, column_position, is_selected)
                    VALUES (%s, %s, %s, %s)
                """, column_data)

            conn.commit()
            cursor.close()

            # Store session data
            session['file_path'] = file_path
            session['template_id'] = template_id
            session['df'] = df.to_json()
            session['header_row'] = header_row
            session['headers'] = headers
            session['sheet_name'] = sheet_name
            session['current_step'] = 1 if not has_existing_rules else 3
            session['validations'] = validations
            session['selected_headers'] = selected_headers
            session['has_existing_rules'] = has_existing_rules

            logging.info(f"Upload processed: template_id={template_id}, filename={file.filename}, has_existing_rules={has_existing_rules}")

            return jsonify({
                'success': True,
                'sheets': {sheet_name: {'headers': headers}},
                'file_name': file.filename,
                'template_id': template_id,
                'has_existing_rules': has_existing_rules,
                'sheet_name': sheet_name,
                'skip_to_step_3': has_existing_rules
            })
        except mysql.connector.Error as e:
            logging.error(f'Error saving template: {str(e)}')
            return jsonify({'error': f'Error saving template: {str(e)}'}), 500
        except Exception as e:
            logging.error(f'Unexpected error saving template: {str(e)}')
            return jsonify({'error': f'Unexpected error: {str(e)}'}), 500

    # Multi-step workflow endpoints
    @app.route('/step/1', methods=['GET', 'POST'])
    @app.route('/api/step/1', methods=['GET', 'POST'])
    def step_one():
        if 'loggedin' not in session:
            return jsonify({'error': 'Not logged in'}), 401
        
        if request.method == 'POST':
            try:
                headers = request.form.getlist('headers')
                new_header_row = request.form.get('new_header_row')
                logging.debug(f"Step 1 submitted: headers={headers}, new_header_row={new_header_row}")
                
                if not headers:
                    logging.error("No headers provided in step 1")
                    return jsonify({'success': False, 'message': 'No headers provided'}), 400
                    
                if 'template_id' not in session:
                    logging.error("Session missing template_id")
                    return jsonify({'success': False, 'message': 'Session data missing'}), 400

                template_id = session['template_id']
                
                # Get the dataframe from session for auto-detection
                df_json = session.get('df')
                if df_json:
                    df = pd.read_json(StringIO(df_json))
                    session_headers = session.get('headers', [])
                    df.columns = session_headers
                    header_row = session.get('header_row', 0)
                    df = df.iloc[header_row + 1:].reset_index(drop=True)
                    
                    # Auto-detect rules for selected headers
                    validations = assign_default_rules_to_columns(df, headers)
                    session['validations'] = validations
                    logging.debug(f"Auto-assigned rules: {validations}")
                else:
                    validations = {}

                session['selected_headers'] = headers
                session['current_step'] = 2

                # Mark selected headers in the database
                conn = get_db_connection()
                cursor = conn.cursor()
                cursor.execute("UPDATE template_columns SET is_selected = FALSE WHERE template_id = %s", (template_id,))
                for header in headers:
                    cursor.execute("""
                        UPDATE template_columns
                        SET is_selected = TRUE
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    
                    # Get column_id and add auto-detected rules
                    cursor.execute("""
                        SELECT column_id FROM template_columns
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    result = cursor.fetchone()
                    if result:
                        column_id = result[0]
                        for rule_name in validations.get(header, []):
                            cursor.execute("""
                                SELECT rule_type_id FROM validation_rule_types
                                WHERE rule_name = %s AND is_custom = FALSE
                            """, (rule_name,))
                            rule_result = cursor.fetchone()
                            if rule_result:
                                rule_type_id = rule_result[0]
                                cursor.execute("""
                                    INSERT IGNORE INTO column_validation_rules (column_id, rule_type_id, rule_config)
                                    VALUES (%s, %s, %s)
                                """, (column_id, rule_type_id, '{}'))
                
                conn.commit()
                cursor.close()

                logging.info(f"Step 1 completed: headers={headers}, auto-assigned rules={validations}")
                return jsonify({'success': True, 'headers': headers, 'validations': validations})
            except Exception as e:
                logging.error(f"Error in step 1: {str(e)}")
                return jsonify({'success': False, 'message': str(e)}), 500
        
        # GET request - return current headers
        headers = session.get('headers', [])
        return jsonify({'headers': headers})

    @app.route('/step/2', methods=['GET', 'POST'])
    @app.route('/api/step/2', methods=['GET', 'POST'])
    def step_two():
        if 'loggedin' not in session:
            return jsonify({'error': 'Not logged in'}), 401
            
        if request.method == 'POST':
            try:
                action = request.form.get('action', 'save')
                validations = {}
                for key, values in request.form.lists():
                    if key.startswith('validations_'):
                        header = key.replace('validations_', '')
                        validations[header] = values
                        
                logging.debug(f"Step 2 submitted: action={action}, validations={validations}")
                
                template_id = session.get('template_id')
                if not template_id:
                    return jsonify({'success': False, 'message': 'Session data missing'}), 400

                # Save validations to database
                conn = get_db_connection()
                cursor = conn.cursor()
                
                # Clear existing rules
                cursor.execute("""
                    DELETE FROM column_validation_rules
                    WHERE column_id IN (
                        SELECT column_id FROM template_columns WHERE template_id = %s
                    )
                """, (template_id,))
                
                # Add new rules
                for header, rules in validations.items():
                    cursor.execute("""
                        SELECT column_id FROM template_columns
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    result = cursor.fetchone()
                    if not result:
                        continue
                    column_id = result[0]
                    
                    for rule_name in rules:
                        cursor.execute("""
                            SELECT rule_type_id FROM validation_rule_types
                            WHERE rule_name = %s
                        """, (rule_name,))
                        result = cursor.fetchone()
                        if result:
                            rule_type_id = result[0]
                            cursor.execute("""
                                INSERT IGNORE INTO column_validation_rules (column_id, rule_type_id, rule_config)
                                VALUES (%s, %s, %s)
                            """, (column_id, rule_type_id, '{}'))
                
                conn.commit()
                cursor.close()

                session['validations'] = validations
                session['current_step'] = 3 if action == 'review' else 2
                
                logging.info(f"Step 2 completed: action={action}, validations={validations}")
                return jsonify({'success': True, 'message': 'Step 2 completed successfully'})
            except Exception as e:
                logging.error(f"Error in step 2: {str(e)}")
                return jsonify({'success': False, 'message': str(e)}), 500
        
        # GET request
        selected_headers = session.get('selected_headers', [])
        return jsonify({'selected_headers': selected_headers})

    # Rules endpoint
    @app.route('/rules', methods=['GET'])
    @app.route('/api/rules', methods=['GET'])
    def get_rules():
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            
            cursor.execute("""
                SELECT rule_type_id AS rule_id, rule_name, description, parameters, is_custom, 
                       column_name, template_id, source_format, target_format, data_type, is_active
                FROM validation_rule_types
            """)
            rules = cursor.fetchall()
            cursor.close()
            
            logging.info(f"Returning {len(rules)} rules from getRules endpoint")
            return jsonify({'success': True, 'rules': rules})
        except mysql.connector.Error as e:
            logging.error(f"Database error fetching rules: {str(e)}")
            return jsonify({'success': False, 'message': str(e)}), 500
        except Exception as e:
            logging.error(f"Unexpected error fetching rules: {str(e)}")
            return jsonify({'success': False, 'message': str(e)}), 500

    # Template details endpoint
    @app.route('/template/<int:template_id>/<sheet_name>', methods=['GET'])
    @app.route('/api/template/<int:template_id>/<sheet_name>', methods=['GET'])
    def get_template(template_id, sheet_name):
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /template: session missing")
            return jsonify({'error': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("""
                SELECT template_name, sheet_name, headers
                FROM excel_templates
                WHERE template_id = %s AND user_id = %s AND status = 'ACTIVE'
            """, (template_id, session['user_id']))
            template_record = cursor.fetchone()
            
            if not template_record:
                logging.error(f"Template not found for template_id: {template_id}, user_id: {session['user_id']}")
                cursor.close()
                return jsonify({'error': 'Template not found'}), 404

            headers = json.loads(template_record['headers']) if template_record['headers'] else []
            stored_sheet_name = template_record['sheet_name'] or sheet_name
            file_path = os.path.join(app.config['UPLOAD_FOLDER'], template_record['template_name'])
            
            cursor.execute("""
                SELECT COUNT(*) as rule_count
                FROM template_columns tc
                JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                WHERE tc.template_id = %s AND tc.is_selected = TRUE
            """, (template_id,))
            rule_count = cursor.fetchone()['rule_count']
            has_existing_rules = rule_count > 0
            
            cursor.close()
            
            return jsonify({
                'success': True,
                'sheets': {stored_sheet_name: {'headers': headers}},
                'file_name': template_record['template_name'],
                'file_path': file_path,
                'sheet_name': stored_sheet_name,
                'has_existing_rules': has_existing_rules
            })
        except mysql.connector.Error as e:
            logging.error(f"Database error in get_template: {str(e)}")
            return jsonify({'error': f'Database error: {str(e)}'}), 500
        except Exception as e:
            logging.error(f"Unexpected error in get_template: {str(e)}")
            return jsonify({'error': f'Unexpected error: {str(e)}'}), 500

    # Debug route to show all registered routes
    @app.route('/debug/routes', methods=['GET'])
    def list_routes():
        routes = []
        for rule in app.url_map.iter_rules():
            routes.append({
                'endpoint': rule.endpoint,
                'methods': list(rule.methods),
                'rule': rule.rule
            })
        return jsonify(routes)

    # 404 handler to debug missing routes
    @app.errorhandler(404)
    def not_found_handler(error):
        logging.error(f"404 Error: {request.method} {request.url} not found")
        logging.error(f"Available routes: {[rule.rule for rule in app.url_map.iter_rules()]}")
        return jsonify({
            'error': 'Endpoint not found', 
            'method': request.method,
            'url': request.url,
            'path': request.path
        }), 404

    return app

def initialize_app_data():
    """Initialize database and create default data"""
    try:
        logging.info("Initializing database schema...")
        init_db()
        
        logging.info("Creating admin user...")
        create_admin_user()
        
        logging.info("Creating default validation rules...")
        create_default_validation_rules()
        
        logging.info("Application initialization completed successfully")
    except Exception as e:
        logging.error(f"Failed to initialize application: {e}")
        raise

DB_CONFIG = {
    'host': os.getenv('MYSQL_HOST', 'localhost'),
    'user': os.getenv('MYSQL_USER', 'root'),
    'password': os.getenv('MYSQL_PASSWORD', 'Keansa@2024'),
    'database': os.getenv('MYSQL_DATABASE', 'data_validation_2'),
}

def get_db_connection():
    if 'db' not in g:
        try:
            conn = mysql.connector.connect(
                host=DB_CONFIG['host'],
                user=DB_CONFIG['user'],
                password=DB_CONFIG['password']
            )
            cursor = conn.cursor()
            cursor.execute(f"CREATE DATABASE IF NOT EXISTS {DB_CONFIG['database']}")
            cursor.close()
            conn.close()
            g.db = mysql.connector.connect(**DB_CONFIG)
            logging.info("Database connection established successfully")
        except mysql.connector.Error as err:
            if err.errno == errorcode.ER_ACCESS_DENIED_ERROR:
                logging.error("Database connection failed: Access denied for user - check username/password")
            elif err.errno == errorcode.ER_BAD_DB_ERROR:
                logging.error("Database connection failed: Database does not exist")
            else:
                logging.error(f"Database connection failed: {err}")
            raise Exception(f"Failed to connect to database: {str(err)}")
    return g.db

def close_db(error):
    db = g.pop('db', None)
    if db is not None:
        db.close()

def init_db():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        tables = [
            """
            CREATE TABLE IF NOT EXISTS login_details (
                id INT AUTO_INCREMENT PRIMARY KEY,
                first_name VARCHAR(100),
                last_name VARCHAR(100),
                email VARCHAR(255) UNIQUE,
                mobile VARCHAR(10),
                password VARCHAR(255)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS excel_templates (
                template_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_name VARCHAR(255) NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
                user_id INT NOT NULL,
                sheet_name VARCHAR(255),
                headers JSON,
                status ENUM('ACTIVE', 'INACTIVE') DEFAULT 'ACTIVE',
                is_corrected BOOLEAN DEFAULT FALSE,
                remote_file_path VARCHAR(512),
                FOREIGN KEY (user_id) REFERENCES login_details(id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS template_columns (
                column_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_id BIGINT NOT NULL,
                column_name VARCHAR(255) NOT NULL,
                column_position INT NOT NULL,
                is_validation_enabled BOOLEAN DEFAULT FALSE,
                is_selected BOOLEAN DEFAULT FALSE,
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE,
                UNIQUE (template_id, column_name)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_rule_types (
                rule_type_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                rule_name VARCHAR(255) NOT NULL,
                description TEXT,
                parameters TEXT,
                is_active BOOLEAN DEFAULT TRUE,
                is_custom BOOLEAN DEFAULT FALSE,
                column_name VARCHAR(255),
                template_id BIGINT,
                data_type VARCHAR(50),
                source_format VARCHAR(50),
                target_format VARCHAR(50),
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS column_validation_rules (
                column_validation_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                column_id BIGINT NOT NULL,
                rule_type_id BIGINT NOT NULL,
                rule_config JSON,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (column_id) REFERENCES template_columns(column_id) ON DELETE CASCADE,
                FOREIGN KEY (rule_type_id) REFERENCES validation_rule_types(rule_type_id) ON DELETE RESTRICT,
                UNIQUE (column_id, rule_type_id)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_history (
                history_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_id BIGINT NOT NULL,
                template_name VARCHAR(255) NOT NULL,
                error_count INT NOT NULL,
                corrected_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                corrected_file_path VARCHAR(512) NOT NULL,
                user_id INT NOT NULL,
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE,
                FOREIGN KEY (user_id) REFERENCES login_details(id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_corrections (
                correction_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                history_id BIGINT NOT NULL,
                row_index INT NOT NULL,
                column_name VARCHAR(255) NOT NULL,
                original_value TEXT,
                corrected_value TEXT,
                rule_failed VARCHAR(255) DEFAULT NULL,
                FOREIGN KEY (history_id) REFERENCES validation_history(history_id) ON DELETE CASCADE
            )
            """
        ]
        for table_sql in tables:
            cursor.execute(table_sql)
        
        # Add missing columns if they don't exist
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'source_format'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN source_format VARCHAR(50)")
            logging.info("Added source_format column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'target_format'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN target_format VARCHAR(50)")
            logging.info("Added target_format column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'data_type'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN data_type VARCHAR(50)")
            logging.info("Added data_type column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM excel_templates LIKE 'remote_file_path'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE excel_templates ADD COLUMN remote_file_path VARCHAR(512)")
            logging.info("Added remote_file_path column to excel_templates table")
            
        cursor.execute("SHOW COLUMNS FROM template_columns LIKE 'is_selected'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE template_columns ADD COLUMN is_selected BOOLEAN DEFAULT FALSE")
            logging.info("Added is_selected column to template_columns table")
            
        conn.commit()
        cursor.close()
        logging.info("Database tables initialized")
    except Exception as e:
        logging.error(f"Failed to initialize database: {str(e)}")
        raise

def create_admin_user():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        admin_password = bcrypt.hashpw('admin'.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
        cursor.execute("""
            INSERT IGNORE INTO login_details (first_name, last_name, email, mobile, password)
            VALUES (%s, %s, %s, %s, %s)
        """, ('Admin', 'User', 'admin@example.com', '1234567890', admin_password))
        conn.commit()
        cursor.close()
        logging.info("Admin user created or already exists")
    except Exception as e:
        logging.error(f"Failed to create admin user: {str(e)}")
        raise

def create_default_validation_rules():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        default_rules = [
            ("Required", "Ensures the field is not null", '{"allow_null": false}', None, None, None),
            ("Int", "Validates integer format", '{"format": "integer"}', None, None, "Int"),
            ("Float", "Validates number format (integer or decimal)", '{"format": "float"}', None, None, "Float"),
            ("Text", "Allows text with quotes and parentheses", '{"allow_special": false}', None, None, "Text"),
            ("Email", "Validates email format", '{"regex": "^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\\\.[a-zA-Z0-9-.]+$"}', None, None, "Email"),
            ("Date(DD-MM-YYYY)", "Validates date format DD-MM-YYYY", '{"format": "%d-%m-%Y"}', "DD-MM-YYYY", None, "Date"),
            ("Boolean", "Validates boolean format (true/false or 0/1)", '{"format": "boolean"}', None, None, "Boolean"),
            ("Alphanumeric", "Validates alphanumeric format", '{"format": "alphanumeric"}', None, None, "Alphanumeric")
        ]
        cursor.executemany("""
            INSERT IGNORE INTO validation_rule_types (rule_name, description, parameters, is_custom, source_format, target_format, data_type)
            VALUES (%s, %s, %s, %s, %s, %s, %s)
        """, [(name, desc, params, False, source, target, dtype) for name, desc, params, source, target, dtype in default_rules])
        conn.commit()
        cursor.close()
        logging.info("Default validation rules ensured successfully")
    except Exception as e:
        logging.error(f"Failed to ensure default validation rules: {str(e)}")
        raise

if __name__ == '__main__':
    try:
        # Create the application using factory pattern
        app = create_app()
        
        # Initialize database and default data within app context
        with app.app_context():
            initialize_app_data()
        
        # Get port from environment or use default
        port = int(os.getenv('PORT', 5000))
        
        # Start the application server
        logging.info("Starting Flask server...")
        app.run(debug=True, host='0.0.0.0', port=port)
        
    except Exception as e:
        logging.error(f"Failed to start application: {e}")
        raise
).all():
        return "Email"
    
    # Date pattern detection
    try:
        pd.to_datetime(non_null, format="%d-%m-%Y")
        return "Date"
    except Exception:
        try:
            pd.to_datetime(non_null, format="%Y-%m-%d")
            return "Date"
        except Exception:
            pass
    
    # Boolean detection
    if non_null.str.lower().isin(['true', 'false', '0', '1']).all():
        return "Boolean"
    
    # Numeric detection
    if non_null.str.match(r'^-?\d+

def create_app():
    """Application factory pattern for different environments"""
    # Set the path to the frontend dist folder
    current_dir = os.path.dirname(os.path.abspath(__file__))
    frontend_dist_path = os.path.join(current_dir, '..', '..', 'Keansa-Ai-Suite2025may-frontend11', 'dist')
    frontend_dist_path = os.path.abspath(frontend_dist_path)
    
    # Create Flask application instance
    app = Flask(__name__, static_folder=frontend_dist_path, static_url_path='')
    CORS(app, supports_credentials=True, origins=["http://localhost:3000", "http://localhost:8080", "http://localhost:5000", "*"])

    app.secret_key = os.urandom(24).hex()
    app.config['SESSION_TYPE'] = 'filesystem'
    app.config['SESSION_FILE_DIR'] = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'sessions')
    app.config['SESSION_COOKIE_SAMESITE'] = 'Lax'
    app.config['SESSION_COOKIE_HTTPONLY'] = True
    app.config['SESSION_COOKIE_SECURE'] = False
    app.config['PERMANENT_SESSION_LIFETIME'] = 86400  # 24 hours
    app.config['UPLOAD_FOLDER'] = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'uploads')
    Session(app)

    # Ensure directories exist
    try:
        os.makedirs(app.config['UPLOAD_FOLDER'], exist_ok=True)
        os.makedirs(app.config['SESSION_FILE_DIR'], exist_ok=True)
    except OSError as e:
        logging.error(f"Failed to create directories: {e}")

    # Register cleanup handlers
    app.teardown_appcontext(close_db)
    
    # Register all routes directly in create_app
    
    # Static file serving for React frontend
    @app.route('/', defaults={'path': ''})
    @app.route('/<path:path>')
    def serve(path):
        if path and os.path.exists(os.path.join(app.static_folder, path)):
            return app.send_static_file(path)
        return app.send_static_file('index.html')

    # Health check endpoint
    @app.route('/health', methods=['GET'])
    def health_check():
        return jsonify({
            'status': 'healthy',
            'timestamp': datetime.now().isoformat(),
            'version': '2.0.0'
        })

    # Authentication endpoint - both old and new paths
    @app.route('/authenticate', methods=['POST'])
    @app.route('/api/auth/authenticate', methods=['POST'])
    def authenticate():
        try:
            email = request.form.get('username') or request.form.get('email')
            password = request.form.get('password')
            logging.debug(f"Login attempt: email={email}, password={'*' * len(password) if password else 'None'}")
            
            if not email or not password:
                logging.warning(f"Login failed: Email or password missing")
                return jsonify({'success': False, 'message': 'Email and password are required'}), 400

            # Check for admin login
            if email == "admin" and password == "admin":
                session['loggedin'] = True
                session['user_email'] = "admin@example.com"
                session['user_id'] = 1
                session.permanent = True
                logging.info(f"Admin login successful. Session: {dict(session)}")
                return jsonify({'success': True, 'message': 'Login successful', 'user': {'email': 'admin@example.com', 'id': 1}}), 200

            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("SELECT * FROM login_details WHERE LOWER(email) = LOWER(%s)", (email.lower(),))
            account = cursor.fetchone()
            cursor.close()
            
            if account:
                if bcrypt.checkpw(password.encode('utf-8'), account['password'].encode('utf-8')):
                    session['loggedin'] = True
                    session['user_email'] = account['email']
                    session['user_id'] = account['id']
                    session.permanent = True
                    logging.info(f"User {email} logged in successfully. Session: {dict(session)}")
                    return jsonify({
                        'success': True,
                        'message': 'Login successful',
                        'user': {'email': account['email'], 'id': account['id']}
                    }), 200
                else:
                    logging.warning(f"Invalid password for {email}")
                    return jsonify({'success': False, 'message': 'Invalid credentials'}), 401
            else:
                logging.warning(f"Email {email} not found")
                return jsonify({'success': False, 'message': 'Invalid credentials'}), 401
        except Exception as e:
            logging.error(f"Unexpected error during login: {str(e)}")
            return jsonify({'success': False, 'message': f'Unexpected error: {str(e)}'}), 500

    @app.route('/check-auth', methods=['GET'])
    @app.route('/api/auth/check-auth', methods=['GET'])
    def check_auth():
        try:
            logging.debug(f"Checking auth with session: {dict(session)}")
            if 'loggedin' in session and 'user_id' in session:
                conn = get_db_connection()
                cursor = conn.cursor(dictionary=True)
                cursor.execute("SELECT email, first_name FROM login_details WHERE id = %s", (session['user_id'],))
                user = cursor.fetchone()
                cursor.close()
                if user:
                    logging.info(f"User {session.get('user_email')} is authenticated")
                    return jsonify({
                        'success': True,
                        'user': {
                            'email': user['email'],
                            'id': session['user_id'],
                            'first_name': user['first_name']
                        }
                    })
                else:
                    logging.warning("User not found in database")  
                    session.clear()
                    return jsonify({'success': False, 'message': 'User not found'}), 401
            logging.warning("User not authenticated")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        except Exception as e:
            logging.error(f"Error in check-auth endpoint: {str(e)}")
            return jsonify({'success': False, 'message': f'Server error: {str(e)}'}), 500

    @app.route('/register', methods=['POST'])
    @app.route('/api/auth/register', methods=['POST'])
    def register():
        first_name = request.form.get('first_name')
        last_name = request.form.get('last_name')
        email = request.form.get('email')
        mobile = request.form.get('mobile')
        password = request.form.get('password')
        confirm_password = request.form.get('confirm_password')

        if not all([first_name, last_name, email, mobile, password, confirm_password]):
            return jsonify({'success': False, 'message': 'All fields are required'}), 400
        if password != confirm_password:
            return jsonify({'success': False, 'message': 'Passwords do not match'}), 400

        hashed_password = bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
        try:
            conn = get_db_connection()
            cursor = conn.cursor()
            cursor.execute("""
                INSERT INTO login_details (first_name, last_name, email, mobile, password)
                VALUES (%s, %s, %s, %s, %s)
            """, (first_name, last_name, email, mobile, hashed_password))
            user_id = cursor.lastrowid
            conn.commit()
            cursor.close()
            session['loggedin'] = True
            session['user_email'] = email
            session['user_id'] = user_id
            return jsonify({
                'success': True,
                'message': 'Registration successful',
                'user': {'email': email, 'id': user_id}
            }), 200
        except mysql.connector.Error as e:
            logging.error(f"Database error during registration: {str(e)}")
            return jsonify({'success': False, 'message': f'Registration error: {str(e)}'}), 500

    @app.route('/logout', methods=['POST'])
    @app.route('/api/auth/logout', methods=['POST'])
    def logout():
        logging.info(f"User {session.get('user_email', 'unknown')} logged out")
        session.clear()
        return jsonify({'success': True, 'message': 'Logged out successfully'})

    # Template routes
    @app.route('/templates', methods=['GET'])
    @app.route('/api/templates', methods=['GET'])
    def get_templates():
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /templates: session missing")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("""
                SELECT template_id, template_name, created_at, status
                FROM excel_templates
                WHERE user_id = %s AND status = 'ACTIVE'
                ORDER BY created_at DESC
                LIMIT 100
            """, (session['user_id'],))
            templates = cursor.fetchall()
            cursor.close()
            logging.info(f"Fetched {len(templates)} templates for user {session['user_id']}")
            return jsonify({'success': True, 'templates': templates})
        except mysql.connector.Error as e:
            logging.error(f'Error fetching templates: {str(e)}')
            return jsonify({'success': False, 'message': f'Error fetching templates: {str(e)}'}), 500
        except Exception as e:
            logging.error(f'Unexpected error fetching templates: {str(e)}')
            return jsonify({'success': False, 'message': f'Unexpected error: {str(e)}'}), 500

    # Rule Configuration routes
    @app.route('/rule-configurations', methods=['GET'])
    @app.route('/api/validation/rule-configurations', methods=['GET'])
    def get_rule_configurations():
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning(f"Unauthorized access to /rule-configurations: session={dict(session)}")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            user_id = session['user_id']
            logging.debug(f"Fetching rule configurations for user_id: {user_id}")

            # Main query to fetch templates with configured rules
            cursor.execute("""
                SELECT 
                    t.template_id, 
                    t.template_name, 
                    t.created_at, 
                    COUNT(cvr.column_validation_id) as rule_count
                FROM excel_templates t
                LEFT JOIN template_columns tc ON t.template_id = tc.template_id
                LEFT JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                WHERE t.user_id = %s AND t.status = 'ACTIVE' AND t.is_corrected = FALSE
                GROUP BY t.template_id, t.template_name, t.created_at
                HAVING rule_count > 0
                ORDER BY t.created_at DESC
                LIMIT 100
            """, (user_id,))
            templates = cursor.fetchall()
            logging.debug(f"Fetched rule-configured templates: {templates}")

            cursor.close()

            if not templates:
                logging.info(f"No templates with rules found for user_id: {user_id}")
            else:
                logging.info(f"Found {len(templates)} templates with rules for user_id: {user_id}")

            return jsonify({'success': True, 'templates': templates})
        except mysql.connector.Error as e:
            logging.error(f"Database error fetching rule configurations: {str(e)}")
            return jsonify({'success': False, 'message': f"Database error: {str(e)}"}), 500
        except Exception as e:
            logging.error(f"Unexpected error fetching rule configurations: {str(e)}")
            return jsonify({'success': False, 'message': f"Unexpected error: {str(e)}"}), 500

    # File upload route
    @app.route('/upload', methods=['POST'])
    @app.route('/api/templates/upload', methods=['POST'])
    @app.route('/api/upload', methods=['POST'])  # Additional common path
    def upload():
        logging.info(f"Upload endpoint called: {request.endpoint}, method: {request.method}")
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /upload: session missing")
            return jsonify({'error': 'Not logged in'}), 401
        if 'file' not in request.files:
            logging.warning("No file provided in upload request")
            return jsonify({'error': 'No file uploaded'}), 400
        file = request.files['file']
        if file.filename == '':
            logging.warning("No file selected in upload request")
            return jsonify({'error': 'No file selected'}), 400
        
        file_path = os.path.join(app.config['UPLOAD_FOLDER'], file.filename)
        try:
            file.save(file_path)
            logging.info(f"File saved: {file_path}")
        except Exception as e:
            logging.error(f"Failed to save file {file.filename}: {str(e)}")
            return jsonify({'error': f'Failed to save file: {str(e)}'}), 500

        try:
            # Read the file to get sheets and headers
            if file.filename.endswith('.xlsx') or file.filename.endswith('.xls'):
                xl = pd.ExcelFile(file_path)
                sheets = {sheet_name: pd.read_excel(file_path, sheet_name=sheet_name, header=None) 
                         for sheet_name in xl.sheet_names}
            elif file.filename.endswith(('.txt', '.csv', '.dat')):
                df = pd.read_csv(file_path, header=None, encoding='utf-8')
                sheets = {'Sheet1': df}
            else:
                logging.error("Unsupported file type")
                return jsonify({'error': 'Unsupported file type'}), 400
            
            logging.debug(f"Sheets extracted: {list(sheets.keys())}")
        except Exception as e:
            logging.error(f"Failed to read file {file_path}: {str(e)}")
            return jsonify({'error': f'Failed to read file: {str(e)}'}), 400

        try:
            sheet_names = list(sheets.keys())
            if not sheet_names:
                logging.error("No sheets found in the file")
                return jsonify({'error': 'No sheets found in the file'}), 400
            sheet_name = sheet_names[0]
            df = sheets[sheet_name]
            
            # Find header row
            header_row = 0
            for i in range(min(len(df), 10)):
                row = df.iloc[i].dropna()
                if not row.empty and all(isinstance(x, str) for x in row if pd.notna(x)):
                    header_row = i
                    break
                    
            headers = df.iloc[header_row].tolist()
            logging.debug(f"Headers extracted: {headers}")
            
            if not headers or all(not h for h in headers):
                logging.error("No valid headers found in file")
                return jsonify({'error': 'No valid headers found in the file'}), 400
        except Exception as e:
            logging.error(f"Error processing file {file.filename}: {str(e)}")
            return jsonify({'error': f'Error processing file: {str(e)}'}), 400

        # Clear existing session data
        for key in ['df', 'header_row', 'headers', 'sheet_name', 'current_step', 'selected_headers', 'validations', 'error_cell_locations', 'data_rows', 'corrected_file_path']:
            session.pop(key, None)

        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)

            # Check if template exists
            cursor.execute("""
                SELECT template_id, headers, sheet_name
                FROM excel_templates
                WHERE template_name = %s AND user_id = %s AND status = 'ACTIVE'
                ORDER BY created_at DESC
            """, (file.filename, session['user_id']))
            existing_templates = cursor.fetchall()
            logging.info(f"Found {len(existing_templates)} existing templates with name {file.filename}")

            template_id = None
            has_existing_rules = False
            validations = {}
            selected_headers = []

            # Check for matching template
            matching_template = None
            for template in existing_templates:
                stored_headers = json.loads(template['headers']) if template['headers'] else []
                stored_sheet_name = template['sheet_name']
                if stored_headers == headers and stored_sheet_name == sheet_name:
                    matching_template = template
                    break

            if matching_template:
                template_id = matching_template['template_id']
                # Check for existing rules
                cursor.execute("""
                    SELECT tc.column_name, vrt.rule_name
                    FROM template_columns tc
                    JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                    JOIN validation_rule_types vrt ON cvr.rule_type_id = vrt.rule_type_id
                    WHERE tc.template_id = %s AND tc.is_selected = TRUE
                """, (template_id,))
                rules_data = cursor.fetchall()
                for row in rules_data:
                    column_name = row['column_name']
                    rule_name = row['rule_name']
                    if column_name not in validations:
                        validations[column_name] = []
                    validations[column_name].append(rule_name)
                    if column_name not in selected_headers:
                        selected_headers.append(column_name)
                has_existing_rules = len(validations) > 0
            else:
                # New template
                cursor.execute("""
                    INSERT INTO excel_templates (template_name, user_id, sheet_name, headers, is_corrected)
                    VALUES (%s, %s, %s, %s, %s)
                """, (file.filename, session['user_id'], sheet_name, json.dumps(headers), False))
                template_id = cursor.lastrowid
                column_data = [(template_id, header, i + 1, False) for i, header in enumerate(headers)]
                cursor.executemany("""
                    INSERT INTO template_columns (template_id, column_name, column_position, is_selected)
                    VALUES (%s, %s, %s, %s)
                """, column_data)

            conn.commit()
            cursor.close()

            # Store session data
            session['file_path'] = file_path
            session['template_id'] = template_id
            session['df'] = df.to_json()
            session['header_row'] = header_row
            session['headers'] = headers
            session['sheet_name'] = sheet_name
            session['current_step'] = 1 if not has_existing_rules else 3
            session['validations'] = validations
            session['selected_headers'] = selected_headers
            session['has_existing_rules'] = has_existing_rules

            logging.info(f"Upload processed: template_id={template_id}, filename={file.filename}, has_existing_rules={has_existing_rules}")

            return jsonify({
                'success': True,
                'sheets': {sheet_name: {'headers': headers}},
                'file_name': file.filename,
                'template_id': template_id,
                'has_existing_rules': has_existing_rules,
                'sheet_name': sheet_name,
                'skip_to_step_3': has_existing_rules
            })
        except mysql.connector.Error as e:
            logging.error(f'Error saving template: {str(e)}')
            return jsonify({'error': f'Error saving template: {str(e)}'}), 500
        except Exception as e:
            logging.error(f'Unexpected error saving template: {str(e)}')
            return jsonify({'error': f'Unexpected error: {str(e)}'}), 500

    # Multi-step workflow endpoints
    @app.route('/step/1', methods=['GET', 'POST'])
    @app.route('/api/step/1', methods=['GET', 'POST'])
    def step_one():
        if 'loggedin' not in session:
            return jsonify({'error': 'Not logged in'}), 401
        
        if request.method == 'POST':
            try:
                headers = request.form.getlist('headers')
                new_header_row = request.form.get('new_header_row')
                logging.debug(f"Step 1 submitted: headers={headers}, new_header_row={new_header_row}")
                
                if not headers:
                    logging.error("No headers provided in step 1")
                    return jsonify({'success': False, 'message': 'No headers provided'}), 400
                    
                if 'template_id' not in session:
                    logging.error("Session missing template_id")
                    return jsonify({'success': False, 'message': 'Session data missing'}), 400

                template_id = session['template_id']
                
                # Get the dataframe from session for auto-detection
                df_json = session.get('df')
                if df_json:
                    df = pd.read_json(StringIO(df_json))
                    session_headers = session.get('headers', [])
                    df.columns = session_headers
                    header_row = session.get('header_row', 0)
                    df = df.iloc[header_row + 1:].reset_index(drop=True)
                    
                    # Auto-detect rules for selected headers
                    validations = assign_default_rules_to_columns(df, headers)
                    session['validations'] = validations
                    logging.debug(f"Auto-assigned rules: {validations}")
                else:
                    validations = {}

                session['selected_headers'] = headers
                session['current_step'] = 2

                # Mark selected headers in the database
                conn = get_db_connection()
                cursor = conn.cursor()
                cursor.execute("UPDATE template_columns SET is_selected = FALSE WHERE template_id = %s", (template_id,))
                for header in headers:
                    cursor.execute("""
                        UPDATE template_columns
                        SET is_selected = TRUE
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    
                    # Get column_id and add auto-detected rules
                    cursor.execute("""
                        SELECT column_id FROM template_columns
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    result = cursor.fetchone()
                    if result:
                        column_id = result[0]
                        for rule_name in validations.get(header, []):
                            cursor.execute("""
                                SELECT rule_type_id FROM validation_rule_types
                                WHERE rule_name = %s AND is_custom = FALSE
                            """, (rule_name,))
                            rule_result = cursor.fetchone()
                            if rule_result:
                                rule_type_id = rule_result[0]
                                cursor.execute("""
                                    INSERT IGNORE INTO column_validation_rules (column_id, rule_type_id, rule_config)
                                    VALUES (%s, %s, %s)
                                """, (column_id, rule_type_id, '{}'))
                
                conn.commit()
                cursor.close()

                logging.info(f"Step 1 completed: headers={headers}, auto-assigned rules={validations}")
                return jsonify({'success': True, 'headers': headers, 'validations': validations})
            except Exception as e:
                logging.error(f"Error in step 1: {str(e)}")
                return jsonify({'success': False, 'message': str(e)}), 500
        
        # GET request - return current headers
        headers = session.get('headers', [])
        return jsonify({'headers': headers})

    @app.route('/step/2', methods=['GET', 'POST'])
    @app.route('/api/step/2', methods=['GET', 'POST'])
    def step_two():
        if 'loggedin' not in session:
            return jsonify({'error': 'Not logged in'}), 401
            
        if request.method == 'POST':
            try:
                action = request.form.get('action', 'save')
                validations = {}
                for key, values in request.form.lists():
                    if key.startswith('validations_'):
                        header = key.replace('validations_', '')
                        validations[header] = values
                        
                logging.debug(f"Step 2 submitted: action={action}, validations={validations}")
                
                template_id = session.get('template_id')
                if not template_id:
                    return jsonify({'success': False, 'message': 'Session data missing'}), 400

                # Save validations to database
                conn = get_db_connection()
                cursor = conn.cursor()
                
                # Clear existing rules
                cursor.execute("""
                    DELETE FROM column_validation_rules
                    WHERE column_id IN (
                        SELECT column_id FROM template_columns WHERE template_id = %s
                    )
                """, (template_id,))
                
                # Add new rules
                for header, rules in validations.items():
                    cursor.execute("""
                        SELECT column_id FROM template_columns
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    result = cursor.fetchone()
                    if not result:
                        continue
                    column_id = result[0]
                    
                    for rule_name in rules:
                        cursor.execute("""
                            SELECT rule_type_id FROM validation_rule_types
                            WHERE rule_name = %s
                        """, (rule_name,))
                        result = cursor.fetchone()
                        if result:
                            rule_type_id = result[0]
                            cursor.execute("""
                                INSERT IGNORE INTO column_validation_rules (column_id, rule_type_id, rule_config)
                                VALUES (%s, %s, %s)
                            """, (column_id, rule_type_id, '{}'))
                
                conn.commit()
                cursor.close()

                session['validations'] = validations
                session['current_step'] = 3 if action == 'review' else 2
                
                logging.info(f"Step 2 completed: action={action}, validations={validations}")
                return jsonify({'success': True, 'message': 'Step 2 completed successfully'})
            except Exception as e:
                logging.error(f"Error in step 2: {str(e)}")
                return jsonify({'success': False, 'message': str(e)}), 500
        
        # GET request
        selected_headers = session.get('selected_headers', [])
        return jsonify({'selected_headers': selected_headers})

    # Rules endpoint
    @app.route('/rules', methods=['GET'])
    @app.route('/api/rules', methods=['GET'])
    def get_rules():
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            
            cursor.execute("""
                SELECT rule_type_id AS rule_id, rule_name, description, parameters, is_custom, 
                       column_name, template_id, source_format, target_format, data_type, is_active
                FROM validation_rule_types
            """)
            rules = cursor.fetchall()
            cursor.close()
            
            logging.info(f"Returning {len(rules)} rules from getRules endpoint")
            return jsonify({'success': True, 'rules': rules})
        except mysql.connector.Error as e:
            logging.error(f"Database error fetching rules: {str(e)}")
            return jsonify({'success': False, 'message': str(e)}), 500
        except Exception as e:
            logging.error(f"Unexpected error fetching rules: {str(e)}")
            return jsonify({'success': False, 'message': str(e)}), 500

    # Template details endpoint
    @app.route('/template/<int:template_id>/<sheet_name>', methods=['GET'])
    @app.route('/api/template/<int:template_id>/<sheet_name>', methods=['GET'])
    def get_template(template_id, sheet_name):
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /template: session missing")
            return jsonify({'error': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("""
                SELECT template_name, sheet_name, headers
                FROM excel_templates
                WHERE template_id = %s AND user_id = %s AND status = 'ACTIVE'
            """, (template_id, session['user_id']))
            template_record = cursor.fetchone()
            
            if not template_record:
                logging.error(f"Template not found for template_id: {template_id}, user_id: {session['user_id']}")
                cursor.close()
                return jsonify({'error': 'Template not found'}), 404

            headers = json.loads(template_record['headers']) if template_record['headers'] else []
            stored_sheet_name = template_record['sheet_name'] or sheet_name
            file_path = os.path.join(app.config['UPLOAD_FOLDER'], template_record['template_name'])
            
            cursor.execute("""
                SELECT COUNT(*) as rule_count
                FROM template_columns tc
                JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                WHERE tc.template_id = %s AND tc.is_selected = TRUE
            """, (template_id,))
            rule_count = cursor.fetchone()['rule_count']
            has_existing_rules = rule_count > 0
            
            cursor.close()
            
            return jsonify({
                'success': True,
                'sheets': {stored_sheet_name: {'headers': headers}},
                'file_name': template_record['template_name'],
                'file_path': file_path,
                'sheet_name': stored_sheet_name,
                'has_existing_rules': has_existing_rules
            })
        except mysql.connector.Error as e:
            logging.error(f"Database error in get_template: {str(e)}")
            return jsonify({'error': f'Database error: {str(e)}'}), 500
        except Exception as e:
            logging.error(f"Unexpected error in get_template: {str(e)}")
            return jsonify({'error': f'Unexpected error: {str(e)}'}), 500

    # Debug route to show all registered routes
    @app.route('/debug/routes', methods=['GET'])
    def list_routes():
        routes = []
        for rule in app.url_map.iter_rules():
            routes.append({
                'endpoint': rule.endpoint,
                'methods': list(rule.methods),
                'rule': rule.rule
            })
        return jsonify(routes)

    # 404 handler to debug missing routes
    @app.errorhandler(404)
    def not_found_handler(error):
        logging.error(f"404 Error: {request.method} {request.url} not found")
        logging.error(f"Available routes: {[rule.rule for rule in app.url_map.iter_rules()]}")
        return jsonify({
            'error': 'Endpoint not found', 
            'method': request.method,
            'url': request.url,
            'path': request.path
        }), 404

    return app

def initialize_app_data():
    """Initialize database and create default data"""
    try:
        logging.info("Initializing database schema...")
        init_db()
        
        logging.info("Creating admin user...")
        create_admin_user()
        
        logging.info("Creating default validation rules...")
        create_default_validation_rules()
        
        logging.info("Application initialization completed successfully")
    except Exception as e:
        logging.error(f"Failed to initialize application: {e}")
        raise

DB_CONFIG = {
    'host': os.getenv('MYSQL_HOST', 'localhost'),
    'user': os.getenv('MYSQL_USER', 'root'),
    'password': os.getenv('MYSQL_PASSWORD', 'Keansa@2024'),
    'database': os.getenv('MYSQL_DATABASE', 'data_validation_2'),
}

def get_db_connection():
    if 'db' not in g:
        try:
            conn = mysql.connector.connect(
                host=DB_CONFIG['host'],
                user=DB_CONFIG['user'],
                password=DB_CONFIG['password']
            )
            cursor = conn.cursor()
            cursor.execute(f"CREATE DATABASE IF NOT EXISTS {DB_CONFIG['database']}")
            cursor.close()
            conn.close()
            g.db = mysql.connector.connect(**DB_CONFIG)
            logging.info("Database connection established successfully")
        except mysql.connector.Error as err:
            if err.errno == errorcode.ER_ACCESS_DENIED_ERROR:
                logging.error("Database connection failed: Access denied for user - check username/password")
            elif err.errno == errorcode.ER_BAD_DB_ERROR:
                logging.error("Database connection failed: Database does not exist")
            else:
                logging.error(f"Database connection failed: {err}")
            raise Exception(f"Failed to connect to database: {str(err)}")
    return g.db

def close_db(error):
    db = g.pop('db', None)
    if db is not None:
        db.close()

def init_db():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        tables = [
            """
            CREATE TABLE IF NOT EXISTS login_details (
                id INT AUTO_INCREMENT PRIMARY KEY,
                first_name VARCHAR(100),
                last_name VARCHAR(100),
                email VARCHAR(255) UNIQUE,
                mobile VARCHAR(10),
                password VARCHAR(255)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS excel_templates (
                template_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_name VARCHAR(255) NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
                user_id INT NOT NULL,
                sheet_name VARCHAR(255),
                headers JSON,
                status ENUM('ACTIVE', 'INACTIVE') DEFAULT 'ACTIVE',
                is_corrected BOOLEAN DEFAULT FALSE,
                remote_file_path VARCHAR(512),
                FOREIGN KEY (user_id) REFERENCES login_details(id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS template_columns (
                column_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_id BIGINT NOT NULL,
                column_name VARCHAR(255) NOT NULL,
                column_position INT NOT NULL,
                is_validation_enabled BOOLEAN DEFAULT FALSE,
                is_selected BOOLEAN DEFAULT FALSE,
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE,
                UNIQUE (template_id, column_name)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_rule_types (
                rule_type_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                rule_name VARCHAR(255) NOT NULL,
                description TEXT,
                parameters TEXT,
                is_active BOOLEAN DEFAULT TRUE,
                is_custom BOOLEAN DEFAULT FALSE,
                column_name VARCHAR(255),
                template_id BIGINT,
                data_type VARCHAR(50),
                source_format VARCHAR(50),
                target_format VARCHAR(50),
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS column_validation_rules (
                column_validation_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                column_id BIGINT NOT NULL,
                rule_type_id BIGINT NOT NULL,
                rule_config JSON,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (column_id) REFERENCES template_columns(column_id) ON DELETE CASCADE,
                FOREIGN KEY (rule_type_id) REFERENCES validation_rule_types(rule_type_id) ON DELETE RESTRICT,
                UNIQUE (column_id, rule_type_id)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_history (
                history_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_id BIGINT NOT NULL,
                template_name VARCHAR(255) NOT NULL,
                error_count INT NOT NULL,
                corrected_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                corrected_file_path VARCHAR(512) NOT NULL,
                user_id INT NOT NULL,
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE,
                FOREIGN KEY (user_id) REFERENCES login_details(id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_corrections (
                correction_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                history_id BIGINT NOT NULL,
                row_index INT NOT NULL,
                column_name VARCHAR(255) NOT NULL,
                original_value TEXT,
                corrected_value TEXT,
                rule_failed VARCHAR(255) DEFAULT NULL,
                FOREIGN KEY (history_id) REFERENCES validation_history(history_id) ON DELETE CASCADE
            )
            """
        ]
        for table_sql in tables:
            cursor.execute(table_sql)
        
        # Add missing columns if they don't exist
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'source_format'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN source_format VARCHAR(50)")
            logging.info("Added source_format column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'target_format'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN target_format VARCHAR(50)")
            logging.info("Added target_format column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'data_type'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN data_type VARCHAR(50)")
            logging.info("Added data_type column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM excel_templates LIKE 'remote_file_path'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE excel_templates ADD COLUMN remote_file_path VARCHAR(512)")
            logging.info("Added remote_file_path column to excel_templates table")
            
        cursor.execute("SHOW COLUMNS FROM template_columns LIKE 'is_selected'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE template_columns ADD COLUMN is_selected BOOLEAN DEFAULT FALSE")
            logging.info("Added is_selected column to template_columns table")
            
        conn.commit()
        cursor.close()
        logging.info("Database tables initialized")
    except Exception as e:
        logging.error(f"Failed to initialize database: {str(e)}")
        raise

def create_admin_user():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        admin_password = bcrypt.hashpw('admin'.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
        cursor.execute("""
            INSERT IGNORE INTO login_details (first_name, last_name, email, mobile, password)
            VALUES (%s, %s, %s, %s, %s)
        """, ('Admin', 'User', 'admin@example.com', '1234567890', admin_password))
        conn.commit()
        cursor.close()
        logging.info("Admin user created or already exists")
    except Exception as e:
        logging.error(f"Failed to create admin user: {str(e)}")
        raise

def create_default_validation_rules():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        default_rules = [
            ("Required", "Ensures the field is not null", '{"allow_null": false}', None, None, None),
            ("Int", "Validates integer format", '{"format": "integer"}', None, None, "Int"),
            ("Float", "Validates number format (integer or decimal)", '{"format": "float"}', None, None, "Float"),
            ("Text", "Allows text with quotes and parentheses", '{"allow_special": false}', None, None, "Text"),
            ("Email", "Validates email format", '{"regex": "^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\\\.[a-zA-Z0-9-.]+$"}', None, None, "Email"),
            ("Date(DD-MM-YYYY)", "Validates date format DD-MM-YYYY", '{"format": "%d-%m-%Y"}', "DD-MM-YYYY", None, "Date"),
            ("Boolean", "Validates boolean format (true/false or 0/1)", '{"format": "boolean"}', None, None, "Boolean"),
            ("Alphanumeric", "Validates alphanumeric format", '{"format": "alphanumeric"}', None, None, "Alphanumeric")
        ]
        cursor.executemany("""
            INSERT IGNORE INTO validation_rule_types (rule_name, description, parameters, is_custom, source_format, target_format, data_type)
            VALUES (%s, %s, %s, %s, %s, %s, %s)
        """, [(name, desc, params, False, source, target, dtype) for name, desc, params, source, target, dtype in default_rules])
        conn.commit()
        cursor.close()
        logging.info("Default validation rules ensured successfully")
    except Exception as e:
        logging.error(f"Failed to ensure default validation rules: {str(e)}")
        raise

if __name__ == '__main__':
    try:
        # Create the application using factory pattern
        app = create_app()
        
        # Initialize database and default data within app context
        with app.app_context():
            initialize_app_data()
        
        # Get port from environment or use default
        port = int(os.getenv('PORT', 5000))
        
        # Start the application server
        logging.info("Starting Flask server...")
        app.run(debug=True, host='0.0.0.0', port=port)
        
    except Exception as e:
        logging.error(f"Failed to start application: {e}")
        raise
).all():
        return "Int"
    
    if non_null.str.match(r'^-?\d+(\.\d+)?

def create_app():
    """Application factory pattern for different environments"""
    # Set the path to the frontend dist folder
    current_dir = os.path.dirname(os.path.abspath(__file__))
    frontend_dist_path = os.path.join(current_dir, '..', '..', 'Keansa-Ai-Suite2025may-frontend11', 'dist')
    frontend_dist_path = os.path.abspath(frontend_dist_path)
    
    # Create Flask application instance
    app = Flask(__name__, static_folder=frontend_dist_path, static_url_path='')
    CORS(app, supports_credentials=True, origins=["http://localhost:3000", "http://localhost:8080", "http://localhost:5000", "*"])

    app.secret_key = os.urandom(24).hex()
    app.config['SESSION_TYPE'] = 'filesystem'
    app.config['SESSION_FILE_DIR'] = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'sessions')
    app.config['SESSION_COOKIE_SAMESITE'] = 'Lax'
    app.config['SESSION_COOKIE_HTTPONLY'] = True
    app.config['SESSION_COOKIE_SECURE'] = False
    app.config['PERMANENT_SESSION_LIFETIME'] = 86400  # 24 hours
    app.config['UPLOAD_FOLDER'] = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'uploads')
    Session(app)

    # Ensure directories exist
    try:
        os.makedirs(app.config['UPLOAD_FOLDER'], exist_ok=True)
        os.makedirs(app.config['SESSION_FILE_DIR'], exist_ok=True)
    except OSError as e:
        logging.error(f"Failed to create directories: {e}")

    # Register cleanup handlers
    app.teardown_appcontext(close_db)
    
    # Register all routes directly in create_app
    
    # Static file serving for React frontend
    @app.route('/', defaults={'path': ''})
    @app.route('/<path:path>')
    def serve(path):
        if path and os.path.exists(os.path.join(app.static_folder, path)):
            return app.send_static_file(path)
        return app.send_static_file('index.html')

    # Health check endpoint
    @app.route('/health', methods=['GET'])
    def health_check():
        return jsonify({
            'status': 'healthy',
            'timestamp': datetime.now().isoformat(),
            'version': '2.0.0'
        })

    # Authentication endpoint - both old and new paths
    @app.route('/authenticate', methods=['POST'])
    @app.route('/api/auth/authenticate', methods=['POST'])
    def authenticate():
        try:
            email = request.form.get('username') or request.form.get('email')
            password = request.form.get('password')
            logging.debug(f"Login attempt: email={email}, password={'*' * len(password) if password else 'None'}")
            
            if not email or not password:
                logging.warning(f"Login failed: Email or password missing")
                return jsonify({'success': False, 'message': 'Email and password are required'}), 400

            # Check for admin login
            if email == "admin" and password == "admin":
                session['loggedin'] = True
                session['user_email'] = "admin@example.com"
                session['user_id'] = 1
                session.permanent = True
                logging.info(f"Admin login successful. Session: {dict(session)}")
                return jsonify({'success': True, 'message': 'Login successful', 'user': {'email': 'admin@example.com', 'id': 1}}), 200

            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("SELECT * FROM login_details WHERE LOWER(email) = LOWER(%s)", (email.lower(),))
            account = cursor.fetchone()
            cursor.close()
            
            if account:
                if bcrypt.checkpw(password.encode('utf-8'), account['password'].encode('utf-8')):
                    session['loggedin'] = True
                    session['user_email'] = account['email']
                    session['user_id'] = account['id']
                    session.permanent = True
                    logging.info(f"User {email} logged in successfully. Session: {dict(session)}")
                    return jsonify({
                        'success': True,
                        'message': 'Login successful',
                        'user': {'email': account['email'], 'id': account['id']}
                    }), 200
                else:
                    logging.warning(f"Invalid password for {email}")
                    return jsonify({'success': False, 'message': 'Invalid credentials'}), 401
            else:
                logging.warning(f"Email {email} not found")
                return jsonify({'success': False, 'message': 'Invalid credentials'}), 401
        except Exception as e:
            logging.error(f"Unexpected error during login: {str(e)}")
            return jsonify({'success': False, 'message': f'Unexpected error: {str(e)}'}), 500

    @app.route('/check-auth', methods=['GET'])
    @app.route('/api/auth/check-auth', methods=['GET'])
    def check_auth():
        try:
            logging.debug(f"Checking auth with session: {dict(session)}")
            if 'loggedin' in session and 'user_id' in session:
                conn = get_db_connection()
                cursor = conn.cursor(dictionary=True)
                cursor.execute("SELECT email, first_name FROM login_details WHERE id = %s", (session['user_id'],))
                user = cursor.fetchone()
                cursor.close()
                if user:
                    logging.info(f"User {session.get('user_email')} is authenticated")
                    return jsonify({
                        'success': True,
                        'user': {
                            'email': user['email'],
                            'id': session['user_id'],
                            'first_name': user['first_name']
                        }
                    })
                else:
                    logging.warning("User not found in database")  
                    session.clear()
                    return jsonify({'success': False, 'message': 'User not found'}), 401
            logging.warning("User not authenticated")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        except Exception as e:
            logging.error(f"Error in check-auth endpoint: {str(e)}")
            return jsonify({'success': False, 'message': f'Server error: {str(e)}'}), 500

    @app.route('/register', methods=['POST'])
    @app.route('/api/auth/register', methods=['POST'])
    def register():
        first_name = request.form.get('first_name')
        last_name = request.form.get('last_name')
        email = request.form.get('email')
        mobile = request.form.get('mobile')
        password = request.form.get('password')
        confirm_password = request.form.get('confirm_password')

        if not all([first_name, last_name, email, mobile, password, confirm_password]):
            return jsonify({'success': False, 'message': 'All fields are required'}), 400
        if password != confirm_password:
            return jsonify({'success': False, 'message': 'Passwords do not match'}), 400

        hashed_password = bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
        try:
            conn = get_db_connection()
            cursor = conn.cursor()
            cursor.execute("""
                INSERT INTO login_details (first_name, last_name, email, mobile, password)
                VALUES (%s, %s, %s, %s, %s)
            """, (first_name, last_name, email, mobile, hashed_password))
            user_id = cursor.lastrowid
            conn.commit()
            cursor.close()
            session['loggedin'] = True
            session['user_email'] = email
            session['user_id'] = user_id
            return jsonify({
                'success': True,
                'message': 'Registration successful',
                'user': {'email': email, 'id': user_id}
            }), 200
        except mysql.connector.Error as e:
            logging.error(f"Database error during registration: {str(e)}")
            return jsonify({'success': False, 'message': f'Registration error: {str(e)}'}), 500

    @app.route('/logout', methods=['POST'])
    @app.route('/api/auth/logout', methods=['POST'])
    def logout():
        logging.info(f"User {session.get('user_email', 'unknown')} logged out")
        session.clear()
        return jsonify({'success': True, 'message': 'Logged out successfully'})

    # Template routes
    @app.route('/templates', methods=['GET'])
    @app.route('/api/templates', methods=['GET'])
    def get_templates():
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /templates: session missing")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("""
                SELECT template_id, template_name, created_at, status
                FROM excel_templates
                WHERE user_id = %s AND status = 'ACTIVE'
                ORDER BY created_at DESC
                LIMIT 100
            """, (session['user_id'],))
            templates = cursor.fetchall()
            cursor.close()
            logging.info(f"Fetched {len(templates)} templates for user {session['user_id']}")
            return jsonify({'success': True, 'templates': templates})
        except mysql.connector.Error as e:
            logging.error(f'Error fetching templates: {str(e)}')
            return jsonify({'success': False, 'message': f'Error fetching templates: {str(e)}'}), 500
        except Exception as e:
            logging.error(f'Unexpected error fetching templates: {str(e)}')
            return jsonify({'success': False, 'message': f'Unexpected error: {str(e)}'}), 500

    # Rule Configuration routes
    @app.route('/rule-configurations', methods=['GET'])
    @app.route('/api/validation/rule-configurations', methods=['GET'])
    def get_rule_configurations():
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning(f"Unauthorized access to /rule-configurations: session={dict(session)}")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            user_id = session['user_id']
            logging.debug(f"Fetching rule configurations for user_id: {user_id}")

            # Main query to fetch templates with configured rules
            cursor.execute("""
                SELECT 
                    t.template_id, 
                    t.template_name, 
                    t.created_at, 
                    COUNT(cvr.column_validation_id) as rule_count
                FROM excel_templates t
                LEFT JOIN template_columns tc ON t.template_id = tc.template_id
                LEFT JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                WHERE t.user_id = %s AND t.status = 'ACTIVE' AND t.is_corrected = FALSE
                GROUP BY t.template_id, t.template_name, t.created_at
                HAVING rule_count > 0
                ORDER BY t.created_at DESC
                LIMIT 100
            """, (user_id,))
            templates = cursor.fetchall()
            logging.debug(f"Fetched rule-configured templates: {templates}")

            cursor.close()

            if not templates:
                logging.info(f"No templates with rules found for user_id: {user_id}")
            else:
                logging.info(f"Found {len(templates)} templates with rules for user_id: {user_id}")

            return jsonify({'success': True, 'templates': templates})
        except mysql.connector.Error as e:
            logging.error(f"Database error fetching rule configurations: {str(e)}")
            return jsonify({'success': False, 'message': f"Database error: {str(e)}"}), 500
        except Exception as e:
            logging.error(f"Unexpected error fetching rule configurations: {str(e)}")
            return jsonify({'success': False, 'message': f"Unexpected error: {str(e)}"}), 500

    # File upload route
    @app.route('/upload', methods=['POST'])
    @app.route('/api/templates/upload', methods=['POST'])
    @app.route('/api/upload', methods=['POST'])  # Additional common path
    def upload():
        logging.info(f"Upload endpoint called: {request.endpoint}, method: {request.method}")
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /upload: session missing")
            return jsonify({'error': 'Not logged in'}), 401
        if 'file' not in request.files:
            logging.warning("No file provided in upload request")
            return jsonify({'error': 'No file uploaded'}), 400
        file = request.files['file']
        if file.filename == '':
            logging.warning("No file selected in upload request")
            return jsonify({'error': 'No file selected'}), 400
        
        file_path = os.path.join(app.config['UPLOAD_FOLDER'], file.filename)
        try:
            file.save(file_path)
            logging.info(f"File saved: {file_path}")
        except Exception as e:
            logging.error(f"Failed to save file {file.filename}: {str(e)}")
            return jsonify({'error': f'Failed to save file: {str(e)}'}), 500

        try:
            # Read the file to get sheets and headers
            if file.filename.endswith('.xlsx') or file.filename.endswith('.xls'):
                xl = pd.ExcelFile(file_path)
                sheets = {sheet_name: pd.read_excel(file_path, sheet_name=sheet_name, header=None) 
                         for sheet_name in xl.sheet_names}
            elif file.filename.endswith(('.txt', '.csv', '.dat')):
                df = pd.read_csv(file_path, header=None, encoding='utf-8')
                sheets = {'Sheet1': df}
            else:
                logging.error("Unsupported file type")
                return jsonify({'error': 'Unsupported file type'}), 400
            
            logging.debug(f"Sheets extracted: {list(sheets.keys())}")
        except Exception as e:
            logging.error(f"Failed to read file {file_path}: {str(e)}")
            return jsonify({'error': f'Failed to read file: {str(e)}'}), 400

        try:
            sheet_names = list(sheets.keys())
            if not sheet_names:
                logging.error("No sheets found in the file")
                return jsonify({'error': 'No sheets found in the file'}), 400
            sheet_name = sheet_names[0]
            df = sheets[sheet_name]
            
            # Find header row
            header_row = 0
            for i in range(min(len(df), 10)):
                row = df.iloc[i].dropna()
                if not row.empty and all(isinstance(x, str) for x in row if pd.notna(x)):
                    header_row = i
                    break
                    
            headers = df.iloc[header_row].tolist()
            logging.debug(f"Headers extracted: {headers}")
            
            if not headers or all(not h for h in headers):
                logging.error("No valid headers found in file")
                return jsonify({'error': 'No valid headers found in the file'}), 400
        except Exception as e:
            logging.error(f"Error processing file {file.filename}: {str(e)}")
            return jsonify({'error': f'Error processing file: {str(e)}'}), 400

        # Clear existing session data
        for key in ['df', 'header_row', 'headers', 'sheet_name', 'current_step', 'selected_headers', 'validations', 'error_cell_locations', 'data_rows', 'corrected_file_path']:
            session.pop(key, None)

        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)

            # Check if template exists
            cursor.execute("""
                SELECT template_id, headers, sheet_name
                FROM excel_templates
                WHERE template_name = %s AND user_id = %s AND status = 'ACTIVE'
                ORDER BY created_at DESC
            """, (file.filename, session['user_id']))
            existing_templates = cursor.fetchall()
            logging.info(f"Found {len(existing_templates)} existing templates with name {file.filename}")

            template_id = None
            has_existing_rules = False
            validations = {}
            selected_headers = []

            # Check for matching template
            matching_template = None
            for template in existing_templates:
                stored_headers = json.loads(template['headers']) if template['headers'] else []
                stored_sheet_name = template['sheet_name']
                if stored_headers == headers and stored_sheet_name == sheet_name:
                    matching_template = template
                    break

            if matching_template:
                template_id = matching_template['template_id']
                # Check for existing rules
                cursor.execute("""
                    SELECT tc.column_name, vrt.rule_name
                    FROM template_columns tc
                    JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                    JOIN validation_rule_types vrt ON cvr.rule_type_id = vrt.rule_type_id
                    WHERE tc.template_id = %s AND tc.is_selected = TRUE
                """, (template_id,))
                rules_data = cursor.fetchall()
                for row in rules_data:
                    column_name = row['column_name']
                    rule_name = row['rule_name']
                    if column_name not in validations:
                        validations[column_name] = []
                    validations[column_name].append(rule_name)
                    if column_name not in selected_headers:
                        selected_headers.append(column_name)
                has_existing_rules = len(validations) > 0
            else:
                # New template
                cursor.execute("""
                    INSERT INTO excel_templates (template_name, user_id, sheet_name, headers, is_corrected)
                    VALUES (%s, %s, %s, %s, %s)
                """, (file.filename, session['user_id'], sheet_name, json.dumps(headers), False))
                template_id = cursor.lastrowid
                column_data = [(template_id, header, i + 1, False) for i, header in enumerate(headers)]
                cursor.executemany("""
                    INSERT INTO template_columns (template_id, column_name, column_position, is_selected)
                    VALUES (%s, %s, %s, %s)
                """, column_data)

            conn.commit()
            cursor.close()

            # Store session data
            session['file_path'] = file_path
            session['template_id'] = template_id
            session['df'] = df.to_json()
            session['header_row'] = header_row
            session['headers'] = headers
            session['sheet_name'] = sheet_name
            session['current_step'] = 1 if not has_existing_rules else 3
            session['validations'] = validations
            session['selected_headers'] = selected_headers
            session['has_existing_rules'] = has_existing_rules

            logging.info(f"Upload processed: template_id={template_id}, filename={file.filename}, has_existing_rules={has_existing_rules}")

            return jsonify({
                'success': True,
                'sheets': {sheet_name: {'headers': headers}},
                'file_name': file.filename,
                'template_id': template_id,
                'has_existing_rules': has_existing_rules,
                'sheet_name': sheet_name,
                'skip_to_step_3': has_existing_rules
            })
        except mysql.connector.Error as e:
            logging.error(f'Error saving template: {str(e)}')
            return jsonify({'error': f'Error saving template: {str(e)}'}), 500
        except Exception as e:
            logging.error(f'Unexpected error saving template: {str(e)}')
            return jsonify({'error': f'Unexpected error: {str(e)}'}), 500

    # Multi-step workflow endpoints
    @app.route('/step/1', methods=['GET', 'POST'])
    @app.route('/api/step/1', methods=['GET', 'POST'])
    def step_one():
        if 'loggedin' not in session:
            return jsonify({'error': 'Not logged in'}), 401
        
        if request.method == 'POST':
            try:
                headers = request.form.getlist('headers')
                new_header_row = request.form.get('new_header_row')
                logging.debug(f"Step 1 submitted: headers={headers}, new_header_row={new_header_row}")
                
                if not headers:
                    logging.error("No headers provided in step 1")
                    return jsonify({'success': False, 'message': 'No headers provided'}), 400
                    
                if 'template_id' not in session:
                    logging.error("Session missing template_id")
                    return jsonify({'success': False, 'message': 'Session data missing'}), 400

                template_id = session['template_id']
                
                # Get the dataframe from session for auto-detection
                df_json = session.get('df')
                if df_json:
                    df = pd.read_json(StringIO(df_json))
                    session_headers = session.get('headers', [])
                    df.columns = session_headers
                    header_row = session.get('header_row', 0)
                    df = df.iloc[header_row + 1:].reset_index(drop=True)
                    
                    # Auto-detect rules for selected headers
                    validations = assign_default_rules_to_columns(df, headers)
                    session['validations'] = validations
                    logging.debug(f"Auto-assigned rules: {validations}")
                else:
                    validations = {}

                session['selected_headers'] = headers
                session['current_step'] = 2

                # Mark selected headers in the database
                conn = get_db_connection()
                cursor = conn.cursor()
                cursor.execute("UPDATE template_columns SET is_selected = FALSE WHERE template_id = %s", (template_id,))
                for header in headers:
                    cursor.execute("""
                        UPDATE template_columns
                        SET is_selected = TRUE
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    
                    # Get column_id and add auto-detected rules
                    cursor.execute("""
                        SELECT column_id FROM template_columns
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    result = cursor.fetchone()
                    if result:
                        column_id = result[0]
                        for rule_name in validations.get(header, []):
                            cursor.execute("""
                                SELECT rule_type_id FROM validation_rule_types
                                WHERE rule_name = %s AND is_custom = FALSE
                            """, (rule_name,))
                            rule_result = cursor.fetchone()
                            if rule_result:
                                rule_type_id = rule_result[0]
                                cursor.execute("""
                                    INSERT IGNORE INTO column_validation_rules (column_id, rule_type_id, rule_config)
                                    VALUES (%s, %s, %s)
                                """, (column_id, rule_type_id, '{}'))
                
                conn.commit()
                cursor.close()

                logging.info(f"Step 1 completed: headers={headers}, auto-assigned rules={validations}")
                return jsonify({'success': True, 'headers': headers, 'validations': validations})
            except Exception as e:
                logging.error(f"Error in step 1: {str(e)}")
                return jsonify({'success': False, 'message': str(e)}), 500
        
        # GET request - return current headers
        headers = session.get('headers', [])
        return jsonify({'headers': headers})

    @app.route('/step/2', methods=['GET', 'POST'])
    @app.route('/api/step/2', methods=['GET', 'POST'])
    def step_two():
        if 'loggedin' not in session:
            return jsonify({'error': 'Not logged in'}), 401
            
        if request.method == 'POST':
            try:
                action = request.form.get('action', 'save')
                validations = {}
                for key, values in request.form.lists():
                    if key.startswith('validations_'):
                        header = key.replace('validations_', '')
                        validations[header] = values
                        
                logging.debug(f"Step 2 submitted: action={action}, validations={validations}")
                
                template_id = session.get('template_id')
                if not template_id:
                    return jsonify({'success': False, 'message': 'Session data missing'}), 400

                # Save validations to database
                conn = get_db_connection()
                cursor = conn.cursor()
                
                # Clear existing rules
                cursor.execute("""
                    DELETE FROM column_validation_rules
                    WHERE column_id IN (
                        SELECT column_id FROM template_columns WHERE template_id = %s
                    )
                """, (template_id,))
                
                # Add new rules
                for header, rules in validations.items():
                    cursor.execute("""
                        SELECT column_id FROM template_columns
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    result = cursor.fetchone()
                    if not result:
                        continue
                    column_id = result[0]
                    
                    for rule_name in rules:
                        cursor.execute("""
                            SELECT rule_type_id FROM validation_rule_types
                            WHERE rule_name = %s
                        """, (rule_name,))
                        result = cursor.fetchone()
                        if result:
                            rule_type_id = result[0]
                            cursor.execute("""
                                INSERT IGNORE INTO column_validation_rules (column_id, rule_type_id, rule_config)
                                VALUES (%s, %s, %s)
                            """, (column_id, rule_type_id, '{}'))
                
                conn.commit()
                cursor.close()

                session['validations'] = validations
                session['current_step'] = 3 if action == 'review' else 2
                
                logging.info(f"Step 2 completed: action={action}, validations={validations}")
                return jsonify({'success': True, 'message': 'Step 2 completed successfully'})
            except Exception as e:
                logging.error(f"Error in step 2: {str(e)}")
                return jsonify({'success': False, 'message': str(e)}), 500
        
        # GET request
        selected_headers = session.get('selected_headers', [])
        return jsonify({'selected_headers': selected_headers})

    # Rules endpoint
    @app.route('/rules', methods=['GET'])
    @app.route('/api/rules', methods=['GET'])
    def get_rules():
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            
            cursor.execute("""
                SELECT rule_type_id AS rule_id, rule_name, description, parameters, is_custom, 
                       column_name, template_id, source_format, target_format, data_type, is_active
                FROM validation_rule_types
            """)
            rules = cursor.fetchall()
            cursor.close()
            
            logging.info(f"Returning {len(rules)} rules from getRules endpoint")
            return jsonify({'success': True, 'rules': rules})
        except mysql.connector.Error as e:
            logging.error(f"Database error fetching rules: {str(e)}")
            return jsonify({'success': False, 'message': str(e)}), 500
        except Exception as e:
            logging.error(f"Unexpected error fetching rules: {str(e)}")
            return jsonify({'success': False, 'message': str(e)}), 500

    # Template details endpoint
    @app.route('/template/<int:template_id>/<sheet_name>', methods=['GET'])
    @app.route('/api/template/<int:template_id>/<sheet_name>', methods=['GET'])
    def get_template(template_id, sheet_name):
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /template: session missing")
            return jsonify({'error': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("""
                SELECT template_name, sheet_name, headers
                FROM excel_templates
                WHERE template_id = %s AND user_id = %s AND status = 'ACTIVE'
            """, (template_id, session['user_id']))
            template_record = cursor.fetchone()
            
            if not template_record:
                logging.error(f"Template not found for template_id: {template_id}, user_id: {session['user_id']}")
                cursor.close()
                return jsonify({'error': 'Template not found'}), 404

            headers = json.loads(template_record['headers']) if template_record['headers'] else []
            stored_sheet_name = template_record['sheet_name'] or sheet_name
            file_path = os.path.join(app.config['UPLOAD_FOLDER'], template_record['template_name'])
            
            cursor.execute("""
                SELECT COUNT(*) as rule_count
                FROM template_columns tc
                JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                WHERE tc.template_id = %s AND tc.is_selected = TRUE
            """, (template_id,))
            rule_count = cursor.fetchone()['rule_count']
            has_existing_rules = rule_count > 0
            
            cursor.close()
            
            return jsonify({
                'success': True,
                'sheets': {stored_sheet_name: {'headers': headers}},
                'file_name': template_record['template_name'],
                'file_path': file_path,
                'sheet_name': stored_sheet_name,
                'has_existing_rules': has_existing_rules
            })
        except mysql.connector.Error as e:
            logging.error(f"Database error in get_template: {str(e)}")
            return jsonify({'error': f'Database error: {str(e)}'}), 500
        except Exception as e:
            logging.error(f"Unexpected error in get_template: {str(e)}")
            return jsonify({'error': f'Unexpected error: {str(e)}'}), 500

    # Debug route to show all registered routes
    @app.route('/debug/routes', methods=['GET'])
    def list_routes():
        routes = []
        for rule in app.url_map.iter_rules():
            routes.append({
                'endpoint': rule.endpoint,
                'methods': list(rule.methods),
                'rule': rule.rule
            })
        return jsonify(routes)

    # 404 handler to debug missing routes
    @app.errorhandler(404)
    def not_found_handler(error):
        logging.error(f"404 Error: {request.method} {request.url} not found")
        logging.error(f"Available routes: {[rule.rule for rule in app.url_map.iter_rules()]}")
        return jsonify({
            'error': 'Endpoint not found', 
            'method': request.method,
            'url': request.url,
            'path': request.path
        }), 404

    return app

def initialize_app_data():
    """Initialize database and create default data"""
    try:
        logging.info("Initializing database schema...")
        init_db()
        
        logging.info("Creating admin user...")
        create_admin_user()
        
        logging.info("Creating default validation rules...")
        create_default_validation_rules()
        
        logging.info("Application initialization completed successfully")
    except Exception as e:
        logging.error(f"Failed to initialize application: {e}")
        raise

DB_CONFIG = {
    'host': os.getenv('MYSQL_HOST', 'localhost'),
    'user': os.getenv('MYSQL_USER', 'root'),
    'password': os.getenv('MYSQL_PASSWORD', 'Keansa@2024'),
    'database': os.getenv('MYSQL_DATABASE', 'data_validation_2'),
}

def get_db_connection():
    if 'db' not in g:
        try:
            conn = mysql.connector.connect(
                host=DB_CONFIG['host'],
                user=DB_CONFIG['user'],
                password=DB_CONFIG['password']
            )
            cursor = conn.cursor()
            cursor.execute(f"CREATE DATABASE IF NOT EXISTS {DB_CONFIG['database']}")
            cursor.close()
            conn.close()
            g.db = mysql.connector.connect(**DB_CONFIG)
            logging.info("Database connection established successfully")
        except mysql.connector.Error as err:
            if err.errno == errorcode.ER_ACCESS_DENIED_ERROR:
                logging.error("Database connection failed: Access denied for user - check username/password")
            elif err.errno == errorcode.ER_BAD_DB_ERROR:
                logging.error("Database connection failed: Database does not exist")
            else:
                logging.error(f"Database connection failed: {err}")
            raise Exception(f"Failed to connect to database: {str(err)}")
    return g.db

def close_db(error):
    db = g.pop('db', None)
    if db is not None:
        db.close()

def init_db():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        tables = [
            """
            CREATE TABLE IF NOT EXISTS login_details (
                id INT AUTO_INCREMENT PRIMARY KEY,
                first_name VARCHAR(100),
                last_name VARCHAR(100),
                email VARCHAR(255) UNIQUE,
                mobile VARCHAR(10),
                password VARCHAR(255)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS excel_templates (
                template_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_name VARCHAR(255) NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
                user_id INT NOT NULL,
                sheet_name VARCHAR(255),
                headers JSON,
                status ENUM('ACTIVE', 'INACTIVE') DEFAULT 'ACTIVE',
                is_corrected BOOLEAN DEFAULT FALSE,
                remote_file_path VARCHAR(512),
                FOREIGN KEY (user_id) REFERENCES login_details(id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS template_columns (
                column_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_id BIGINT NOT NULL,
                column_name VARCHAR(255) NOT NULL,
                column_position INT NOT NULL,
                is_validation_enabled BOOLEAN DEFAULT FALSE,
                is_selected BOOLEAN DEFAULT FALSE,
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE,
                UNIQUE (template_id, column_name)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_rule_types (
                rule_type_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                rule_name VARCHAR(255) NOT NULL,
                description TEXT,
                parameters TEXT,
                is_active BOOLEAN DEFAULT TRUE,
                is_custom BOOLEAN DEFAULT FALSE,
                column_name VARCHAR(255),
                template_id BIGINT,
                data_type VARCHAR(50),
                source_format VARCHAR(50),
                target_format VARCHAR(50),
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS column_validation_rules (
                column_validation_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                column_id BIGINT NOT NULL,
                rule_type_id BIGINT NOT NULL,
                rule_config JSON,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (column_id) REFERENCES template_columns(column_id) ON DELETE CASCADE,
                FOREIGN KEY (rule_type_id) REFERENCES validation_rule_types(rule_type_id) ON DELETE RESTRICT,
                UNIQUE (column_id, rule_type_id)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_history (
                history_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_id BIGINT NOT NULL,
                template_name VARCHAR(255) NOT NULL,
                error_count INT NOT NULL,
                corrected_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                corrected_file_path VARCHAR(512) NOT NULL,
                user_id INT NOT NULL,
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE,
                FOREIGN KEY (user_id) REFERENCES login_details(id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_corrections (
                correction_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                history_id BIGINT NOT NULL,
                row_index INT NOT NULL,
                column_name VARCHAR(255) NOT NULL,
                original_value TEXT,
                corrected_value TEXT,
                rule_failed VARCHAR(255) DEFAULT NULL,
                FOREIGN KEY (history_id) REFERENCES validation_history(history_id) ON DELETE CASCADE
            )
            """
        ]
        for table_sql in tables:
            cursor.execute(table_sql)
        
        # Add missing columns if they don't exist
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'source_format'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN source_format VARCHAR(50)")
            logging.info("Added source_format column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'target_format'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN target_format VARCHAR(50)")
            logging.info("Added target_format column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'data_type'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN data_type VARCHAR(50)")
            logging.info("Added data_type column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM excel_templates LIKE 'remote_file_path'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE excel_templates ADD COLUMN remote_file_path VARCHAR(512)")
            logging.info("Added remote_file_path column to excel_templates table")
            
        cursor.execute("SHOW COLUMNS FROM template_columns LIKE 'is_selected'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE template_columns ADD COLUMN is_selected BOOLEAN DEFAULT FALSE")
            logging.info("Added is_selected column to template_columns table")
            
        conn.commit()
        cursor.close()
        logging.info("Database tables initialized")
    except Exception as e:
        logging.error(f"Failed to initialize database: {str(e)}")
        raise

def create_admin_user():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        admin_password = bcrypt.hashpw('admin'.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
        cursor.execute("""
            INSERT IGNORE INTO login_details (first_name, last_name, email, mobile, password)
            VALUES (%s, %s, %s, %s, %s)
        """, ('Admin', 'User', 'admin@example.com', '1234567890', admin_password))
        conn.commit()
        cursor.close()
        logging.info("Admin user created or already exists")
    except Exception as e:
        logging.error(f"Failed to create admin user: {str(e)}")
        raise

def create_default_validation_rules():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        default_rules = [
            ("Required", "Ensures the field is not null", '{"allow_null": false}', None, None, None),
            ("Int", "Validates integer format", '{"format": "integer"}', None, None, "Int"),
            ("Float", "Validates number format (integer or decimal)", '{"format": "float"}', None, None, "Float"),
            ("Text", "Allows text with quotes and parentheses", '{"allow_special": false}', None, None, "Text"),
            ("Email", "Validates email format", '{"regex": "^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\\\.[a-zA-Z0-9-.]+$"}', None, None, "Email"),
            ("Date(DD-MM-YYYY)", "Validates date format DD-MM-YYYY", '{"format": "%d-%m-%Y"}', "DD-MM-YYYY", None, "Date"),
            ("Boolean", "Validates boolean format (true/false or 0/1)", '{"format": "boolean"}', None, None, "Boolean"),
            ("Alphanumeric", "Validates alphanumeric format", '{"format": "alphanumeric"}', None, None, "Alphanumeric")
        ]
        cursor.executemany("""
            INSERT IGNORE INTO validation_rule_types (rule_name, description, parameters, is_custom, source_format, target_format, data_type)
            VALUES (%s, %s, %s, %s, %s, %s, %s)
        """, [(name, desc, params, False, source, target, dtype) for name, desc, params, source, target, dtype in default_rules])
        conn.commit()
        cursor.close()
        logging.info("Default validation rules ensured successfully")
    except Exception as e:
        logging.error(f"Failed to ensure default validation rules: {str(e)}")
        raise

if __name__ == '__main__':
    try:
        # Create the application using factory pattern
        app = create_app()
        
        # Initialize database and default data within app context
        with app.app_context():
            initialize_app_data()
        
        # Get port from environment or use default
        port = int(os.getenv('PORT', 5000))
        
        # Start the application server
        logging.info("Starting Flask server...")
        app.run(debug=True, host='0.0.0.0', port=port)
        
    except Exception as e:
        logging.error(f"Failed to start application: {e}")
        raise
).all():
        return "Float"
    
    # Alphanumeric detection
    if non_null.str.match(r'^[a-zA-Z0-9]+

def create_app():
    """Application factory pattern for different environments"""
    # Set the path to the frontend dist folder
    current_dir = os.path.dirname(os.path.abspath(__file__))
    frontend_dist_path = os.path.join(current_dir, '..', '..', 'Keansa-Ai-Suite2025may-frontend11', 'dist')
    frontend_dist_path = os.path.abspath(frontend_dist_path)
    
    # Create Flask application instance
    app = Flask(__name__, static_folder=frontend_dist_path, static_url_path='')
    CORS(app, supports_credentials=True, origins=["http://localhost:3000", "http://localhost:8080", "http://localhost:5000", "*"])

    app.secret_key = os.urandom(24).hex()
    app.config['SESSION_TYPE'] = 'filesystem'
    app.config['SESSION_FILE_DIR'] = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'sessions')
    app.config['SESSION_COOKIE_SAMESITE'] = 'Lax'
    app.config['SESSION_COOKIE_HTTPONLY'] = True
    app.config['SESSION_COOKIE_SECURE'] = False
    app.config['PERMANENT_SESSION_LIFETIME'] = 86400  # 24 hours
    app.config['UPLOAD_FOLDER'] = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'uploads')
    Session(app)

    # Ensure directories exist
    try:
        os.makedirs(app.config['UPLOAD_FOLDER'], exist_ok=True)
        os.makedirs(app.config['SESSION_FILE_DIR'], exist_ok=True)
    except OSError as e:
        logging.error(f"Failed to create directories: {e}")

    # Register cleanup handlers
    app.teardown_appcontext(close_db)
    
    # Register all routes directly in create_app
    
    # Static file serving for React frontend
    @app.route('/', defaults={'path': ''})
    @app.route('/<path:path>')
    def serve(path):
        if path and os.path.exists(os.path.join(app.static_folder, path)):
            return app.send_static_file(path)
        return app.send_static_file('index.html')

    # Health check endpoint
    @app.route('/health', methods=['GET'])
    def health_check():
        return jsonify({
            'status': 'healthy',
            'timestamp': datetime.now().isoformat(),
            'version': '2.0.0'
        })

    # Authentication endpoint - both old and new paths
    @app.route('/authenticate', methods=['POST'])
    @app.route('/api/auth/authenticate', methods=['POST'])
    def authenticate():
        try:
            email = request.form.get('username') or request.form.get('email')
            password = request.form.get('password')
            logging.debug(f"Login attempt: email={email}, password={'*' * len(password) if password else 'None'}")
            
            if not email or not password:
                logging.warning(f"Login failed: Email or password missing")
                return jsonify({'success': False, 'message': 'Email and password are required'}), 400

            # Check for admin login
            if email == "admin" and password == "admin":
                session['loggedin'] = True
                session['user_email'] = "admin@example.com"
                session['user_id'] = 1
                session.permanent = True
                logging.info(f"Admin login successful. Session: {dict(session)}")
                return jsonify({'success': True, 'message': 'Login successful', 'user': {'email': 'admin@example.com', 'id': 1}}), 200

            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("SELECT * FROM login_details WHERE LOWER(email) = LOWER(%s)", (email.lower(),))
            account = cursor.fetchone()
            cursor.close()
            
            if account:
                if bcrypt.checkpw(password.encode('utf-8'), account['password'].encode('utf-8')):
                    session['loggedin'] = True
                    session['user_email'] = account['email']
                    session['user_id'] = account['id']
                    session.permanent = True
                    logging.info(f"User {email} logged in successfully. Session: {dict(session)}")
                    return jsonify({
                        'success': True,
                        'message': 'Login successful',
                        'user': {'email': account['email'], 'id': account['id']}
                    }), 200
                else:
                    logging.warning(f"Invalid password for {email}")
                    return jsonify({'success': False, 'message': 'Invalid credentials'}), 401
            else:
                logging.warning(f"Email {email} not found")
                return jsonify({'success': False, 'message': 'Invalid credentials'}), 401
        except Exception as e:
            logging.error(f"Unexpected error during login: {str(e)}")
            return jsonify({'success': False, 'message': f'Unexpected error: {str(e)}'}), 500

    @app.route('/check-auth', methods=['GET'])
    @app.route('/api/auth/check-auth', methods=['GET'])
    def check_auth():
        try:
            logging.debug(f"Checking auth with session: {dict(session)}")
            if 'loggedin' in session and 'user_id' in session:
                conn = get_db_connection()
                cursor = conn.cursor(dictionary=True)
                cursor.execute("SELECT email, first_name FROM login_details WHERE id = %s", (session['user_id'],))
                user = cursor.fetchone()
                cursor.close()
                if user:
                    logging.info(f"User {session.get('user_email')} is authenticated")
                    return jsonify({
                        'success': True,
                        'user': {
                            'email': user['email'],
                            'id': session['user_id'],
                            'first_name': user['first_name']
                        }
                    })
                else:
                    logging.warning("User not found in database")  
                    session.clear()
                    return jsonify({'success': False, 'message': 'User not found'}), 401
            logging.warning("User not authenticated")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        except Exception as e:
            logging.error(f"Error in check-auth endpoint: {str(e)}")
            return jsonify({'success': False, 'message': f'Server error: {str(e)}'}), 500

    @app.route('/register', methods=['POST'])
    @app.route('/api/auth/register', methods=['POST'])
    def register():
        first_name = request.form.get('first_name')
        last_name = request.form.get('last_name')
        email = request.form.get('email')
        mobile = request.form.get('mobile')
        password = request.form.get('password')
        confirm_password = request.form.get('confirm_password')

        if not all([first_name, last_name, email, mobile, password, confirm_password]):
            return jsonify({'success': False, 'message': 'All fields are required'}), 400
        if password != confirm_password:
            return jsonify({'success': False, 'message': 'Passwords do not match'}), 400

        hashed_password = bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
        try:
            conn = get_db_connection()
            cursor = conn.cursor()
            cursor.execute("""
                INSERT INTO login_details (first_name, last_name, email, mobile, password)
                VALUES (%s, %s, %s, %s, %s)
            """, (first_name, last_name, email, mobile, hashed_password))
            user_id = cursor.lastrowid
            conn.commit()
            cursor.close()
            session['loggedin'] = True
            session['user_email'] = email
            session['user_id'] = user_id
            return jsonify({
                'success': True,
                'message': 'Registration successful',
                'user': {'email': email, 'id': user_id}
            }), 200
        except mysql.connector.Error as e:
            logging.error(f"Database error during registration: {str(e)}")
            return jsonify({'success': False, 'message': f'Registration error: {str(e)}'}), 500

    @app.route('/logout', methods=['POST'])
    @app.route('/api/auth/logout', methods=['POST'])
    def logout():
        logging.info(f"User {session.get('user_email', 'unknown')} logged out")
        session.clear()
        return jsonify({'success': True, 'message': 'Logged out successfully'})

    # Template routes
    @app.route('/templates', methods=['GET'])
    @app.route('/api/templates', methods=['GET'])
    def get_templates():
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /templates: session missing")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("""
                SELECT template_id, template_name, created_at, status
                FROM excel_templates
                WHERE user_id = %s AND status = 'ACTIVE'
                ORDER BY created_at DESC
                LIMIT 100
            """, (session['user_id'],))
            templates = cursor.fetchall()
            cursor.close()
            logging.info(f"Fetched {len(templates)} templates for user {session['user_id']}")
            return jsonify({'success': True, 'templates': templates})
        except mysql.connector.Error as e:
            logging.error(f'Error fetching templates: {str(e)}')
            return jsonify({'success': False, 'message': f'Error fetching templates: {str(e)}'}), 500
        except Exception as e:
            logging.error(f'Unexpected error fetching templates: {str(e)}')
            return jsonify({'success': False, 'message': f'Unexpected error: {str(e)}'}), 500

    # Rule Configuration routes
    @app.route('/rule-configurations', methods=['GET'])
    @app.route('/api/validation/rule-configurations', methods=['GET'])
    def get_rule_configurations():
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning(f"Unauthorized access to /rule-configurations: session={dict(session)}")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            user_id = session['user_id']
            logging.debug(f"Fetching rule configurations for user_id: {user_id}")

            # Main query to fetch templates with configured rules
            cursor.execute("""
                SELECT 
                    t.template_id, 
                    t.template_name, 
                    t.created_at, 
                    COUNT(cvr.column_validation_id) as rule_count
                FROM excel_templates t
                LEFT JOIN template_columns tc ON t.template_id = tc.template_id
                LEFT JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                WHERE t.user_id = %s AND t.status = 'ACTIVE' AND t.is_corrected = FALSE
                GROUP BY t.template_id, t.template_name, t.created_at
                HAVING rule_count > 0
                ORDER BY t.created_at DESC
                LIMIT 100
            """, (user_id,))
            templates = cursor.fetchall()
            logging.debug(f"Fetched rule-configured templates: {templates}")

            cursor.close()

            if not templates:
                logging.info(f"No templates with rules found for user_id: {user_id}")
            else:
                logging.info(f"Found {len(templates)} templates with rules for user_id: {user_id}")

            return jsonify({'success': True, 'templates': templates})
        except mysql.connector.Error as e:
            logging.error(f"Database error fetching rule configurations: {str(e)}")
            return jsonify({'success': False, 'message': f"Database error: {str(e)}"}), 500
        except Exception as e:
            logging.error(f"Unexpected error fetching rule configurations: {str(e)}")
            return jsonify({'success': False, 'message': f"Unexpected error: {str(e)}"}), 500

    # File upload route
    @app.route('/upload', methods=['POST'])
    @app.route('/api/templates/upload', methods=['POST'])
    @app.route('/api/upload', methods=['POST'])  # Additional common path
    def upload():
        logging.info(f"Upload endpoint called: {request.endpoint}, method: {request.method}")
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /upload: session missing")
            return jsonify({'error': 'Not logged in'}), 401
        if 'file' not in request.files:
            logging.warning("No file provided in upload request")
            return jsonify({'error': 'No file uploaded'}), 400
        file = request.files['file']
        if file.filename == '':
            logging.warning("No file selected in upload request")
            return jsonify({'error': 'No file selected'}), 400
        
        file_path = os.path.join(app.config['UPLOAD_FOLDER'], file.filename)
        try:
            file.save(file_path)
            logging.info(f"File saved: {file_path}")
        except Exception as e:
            logging.error(f"Failed to save file {file.filename}: {str(e)}")
            return jsonify({'error': f'Failed to save file: {str(e)}'}), 500

        try:
            # Read the file to get sheets and headers
            if file.filename.endswith('.xlsx') or file.filename.endswith('.xls'):
                xl = pd.ExcelFile(file_path)
                sheets = {sheet_name: pd.read_excel(file_path, sheet_name=sheet_name, header=None) 
                         for sheet_name in xl.sheet_names}
            elif file.filename.endswith(('.txt', '.csv', '.dat')):
                df = pd.read_csv(file_path, header=None, encoding='utf-8')
                sheets = {'Sheet1': df}
            else:
                logging.error("Unsupported file type")
                return jsonify({'error': 'Unsupported file type'}), 400
            
            logging.debug(f"Sheets extracted: {list(sheets.keys())}")
        except Exception as e:
            logging.error(f"Failed to read file {file_path}: {str(e)}")
            return jsonify({'error': f'Failed to read file: {str(e)}'}), 400

        try:
            sheet_names = list(sheets.keys())
            if not sheet_names:
                logging.error("No sheets found in the file")
                return jsonify({'error': 'No sheets found in the file'}), 400
            sheet_name = sheet_names[0]
            df = sheets[sheet_name]
            
            # Find header row
            header_row = 0
            for i in range(min(len(df), 10)):
                row = df.iloc[i].dropna()
                if not row.empty and all(isinstance(x, str) for x in row if pd.notna(x)):
                    header_row = i
                    break
                    
            headers = df.iloc[header_row].tolist()
            logging.debug(f"Headers extracted: {headers}")
            
            if not headers or all(not h for h in headers):
                logging.error("No valid headers found in file")
                return jsonify({'error': 'No valid headers found in the file'}), 400
        except Exception as e:
            logging.error(f"Error processing file {file.filename}: {str(e)}")
            return jsonify({'error': f'Error processing file: {str(e)}'}), 400

        # Clear existing session data
        for key in ['df', 'header_row', 'headers', 'sheet_name', 'current_step', 'selected_headers', 'validations', 'error_cell_locations', 'data_rows', 'corrected_file_path']:
            session.pop(key, None)

        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)

            # Check if template exists
            cursor.execute("""
                SELECT template_id, headers, sheet_name
                FROM excel_templates
                WHERE template_name = %s AND user_id = %s AND status = 'ACTIVE'
                ORDER BY created_at DESC
            """, (file.filename, session['user_id']))
            existing_templates = cursor.fetchall()
            logging.info(f"Found {len(existing_templates)} existing templates with name {file.filename}")

            template_id = None
            has_existing_rules = False
            validations = {}
            selected_headers = []

            # Check for matching template
            matching_template = None
            for template in existing_templates:
                stored_headers = json.loads(template['headers']) if template['headers'] else []
                stored_sheet_name = template['sheet_name']
                if stored_headers == headers and stored_sheet_name == sheet_name:
                    matching_template = template
                    break

            if matching_template:
                template_id = matching_template['template_id']
                # Check for existing rules
                cursor.execute("""
                    SELECT tc.column_name, vrt.rule_name
                    FROM template_columns tc
                    JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                    JOIN validation_rule_types vrt ON cvr.rule_type_id = vrt.rule_type_id
                    WHERE tc.template_id = %s AND tc.is_selected = TRUE
                """, (template_id,))
                rules_data = cursor.fetchall()
                for row in rules_data:
                    column_name = row['column_name']
                    rule_name = row['rule_name']
                    if column_name not in validations:
                        validations[column_name] = []
                    validations[column_name].append(rule_name)
                    if column_name not in selected_headers:
                        selected_headers.append(column_name)
                has_existing_rules = len(validations) > 0
            else:
                # New template
                cursor.execute("""
                    INSERT INTO excel_templates (template_name, user_id, sheet_name, headers, is_corrected)
                    VALUES (%s, %s, %s, %s, %s)
                """, (file.filename, session['user_id'], sheet_name, json.dumps(headers), False))
                template_id = cursor.lastrowid
                column_data = [(template_id, header, i + 1, False) for i, header in enumerate(headers)]
                cursor.executemany("""
                    INSERT INTO template_columns (template_id, column_name, column_position, is_selected)
                    VALUES (%s, %s, %s, %s)
                """, column_data)

            conn.commit()
            cursor.close()

            # Store session data
            session['file_path'] = file_path
            session['template_id'] = template_id
            session['df'] = df.to_json()
            session['header_row'] = header_row
            session['headers'] = headers
            session['sheet_name'] = sheet_name
            session['current_step'] = 1 if not has_existing_rules else 3
            session['validations'] = validations
            session['selected_headers'] = selected_headers
            session['has_existing_rules'] = has_existing_rules

            logging.info(f"Upload processed: template_id={template_id}, filename={file.filename}, has_existing_rules={has_existing_rules}")

            return jsonify({
                'success': True,
                'sheets': {sheet_name: {'headers': headers}},
                'file_name': file.filename,
                'template_id': template_id,
                'has_existing_rules': has_existing_rules,
                'sheet_name': sheet_name,
                'skip_to_step_3': has_existing_rules
            })
        except mysql.connector.Error as e:
            logging.error(f'Error saving template: {str(e)}')
            return jsonify({'error': f'Error saving template: {str(e)}'}), 500
        except Exception as e:
            logging.error(f'Unexpected error saving template: {str(e)}')
            return jsonify({'error': f'Unexpected error: {str(e)}'}), 500

    # Multi-step workflow endpoints
    @app.route('/step/1', methods=['GET', 'POST'])
    @app.route('/api/step/1', methods=['GET', 'POST'])
    def step_one():
        if 'loggedin' not in session:
            return jsonify({'error': 'Not logged in'}), 401
        
        if request.method == 'POST':
            try:
                headers = request.form.getlist('headers')
                new_header_row = request.form.get('new_header_row')
                logging.debug(f"Step 1 submitted: headers={headers}, new_header_row={new_header_row}")
                
                if not headers:
                    logging.error("No headers provided in step 1")
                    return jsonify({'success': False, 'message': 'No headers provided'}), 400
                    
                if 'template_id' not in session:
                    logging.error("Session missing template_id")
                    return jsonify({'success': False, 'message': 'Session data missing'}), 400

                template_id = session['template_id']
                
                # Get the dataframe from session for auto-detection
                df_json = session.get('df')
                if df_json:
                    df = pd.read_json(StringIO(df_json))
                    session_headers = session.get('headers', [])
                    df.columns = session_headers
                    header_row = session.get('header_row', 0)
                    df = df.iloc[header_row + 1:].reset_index(drop=True)
                    
                    # Auto-detect rules for selected headers
                    validations = assign_default_rules_to_columns(df, headers)
                    session['validations'] = validations
                    logging.debug(f"Auto-assigned rules: {validations}")
                else:
                    validations = {}

                session['selected_headers'] = headers
                session['current_step'] = 2

                # Mark selected headers in the database
                conn = get_db_connection()
                cursor = conn.cursor()
                cursor.execute("UPDATE template_columns SET is_selected = FALSE WHERE template_id = %s", (template_id,))
                for header in headers:
                    cursor.execute("""
                        UPDATE template_columns
                        SET is_selected = TRUE
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    
                    # Get column_id and add auto-detected rules
                    cursor.execute("""
                        SELECT column_id FROM template_columns
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    result = cursor.fetchone()
                    if result:
                        column_id = result[0]
                        for rule_name in validations.get(header, []):
                            cursor.execute("""
                                SELECT rule_type_id FROM validation_rule_types
                                WHERE rule_name = %s AND is_custom = FALSE
                            """, (rule_name,))
                            rule_result = cursor.fetchone()
                            if rule_result:
                                rule_type_id = rule_result[0]
                                cursor.execute("""
                                    INSERT IGNORE INTO column_validation_rules (column_id, rule_type_id, rule_config)
                                    VALUES (%s, %s, %s)
                                """, (column_id, rule_type_id, '{}'))
                
                conn.commit()
                cursor.close()

                logging.info(f"Step 1 completed: headers={headers}, auto-assigned rules={validations}")
                return jsonify({'success': True, 'headers': headers, 'validations': validations})
            except Exception as e:
                logging.error(f"Error in step 1: {str(e)}")
                return jsonify({'success': False, 'message': str(e)}), 500
        
        # GET request - return current headers
        headers = session.get('headers', [])
        return jsonify({'headers': headers})

    @app.route('/step/2', methods=['GET', 'POST'])
    @app.route('/api/step/2', methods=['GET', 'POST'])
    def step_two():
        if 'loggedin' not in session:
            return jsonify({'error': 'Not logged in'}), 401
            
        if request.method == 'POST':
            try:
                action = request.form.get('action', 'save')
                validations = {}
                for key, values in request.form.lists():
                    if key.startswith('validations_'):
                        header = key.replace('validations_', '')
                        validations[header] = values
                        
                logging.debug(f"Step 2 submitted: action={action}, validations={validations}")
                
                template_id = session.get('template_id')
                if not template_id:
                    return jsonify({'success': False, 'message': 'Session data missing'}), 400

                # Save validations to database
                conn = get_db_connection()
                cursor = conn.cursor()
                
                # Clear existing rules
                cursor.execute("""
                    DELETE FROM column_validation_rules
                    WHERE column_id IN (
                        SELECT column_id FROM template_columns WHERE template_id = %s
                    )
                """, (template_id,))
                
                # Add new rules
                for header, rules in validations.items():
                    cursor.execute("""
                        SELECT column_id FROM template_columns
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    result = cursor.fetchone()
                    if not result:
                        continue
                    column_id = result[0]
                    
                    for rule_name in rules:
                        cursor.execute("""
                            SELECT rule_type_id FROM validation_rule_types
                            WHERE rule_name = %s
                        """, (rule_name,))
                        result = cursor.fetchone()
                        if result:
                            rule_type_id = result[0]
                            cursor.execute("""
                                INSERT IGNORE INTO column_validation_rules (column_id, rule_type_id, rule_config)
                                VALUES (%s, %s, %s)
                            """, (column_id, rule_type_id, '{}'))
                
                conn.commit()
                cursor.close()

                session['validations'] = validations
                session['current_step'] = 3 if action == 'review' else 2
                
                logging.info(f"Step 2 completed: action={action}, validations={validations}")
                return jsonify({'success': True, 'message': 'Step 2 completed successfully'})
            except Exception as e:
                logging.error(f"Error in step 2: {str(e)}")
                return jsonify({'success': False, 'message': str(e)}), 500
        
        # GET request
        selected_headers = session.get('selected_headers', [])
        return jsonify({'selected_headers': selected_headers})

    # Rules endpoint
    @app.route('/rules', methods=['GET'])
    @app.route('/api/rules', methods=['GET'])
    def get_rules():
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            
            cursor.execute("""
                SELECT rule_type_id AS rule_id, rule_name, description, parameters, is_custom, 
                       column_name, template_id, source_format, target_format, data_type, is_active
                FROM validation_rule_types
            """)
            rules = cursor.fetchall()
            cursor.close()
            
            logging.info(f"Returning {len(rules)} rules from getRules endpoint")
            return jsonify({'success': True, 'rules': rules})
        except mysql.connector.Error as e:
            logging.error(f"Database error fetching rules: {str(e)}")
            return jsonify({'success': False, 'message': str(e)}), 500
        except Exception as e:
            logging.error(f"Unexpected error fetching rules: {str(e)}")
            return jsonify({'success': False, 'message': str(e)}), 500

    # Template details endpoint
    @app.route('/template/<int:template_id>/<sheet_name>', methods=['GET'])
    @app.route('/api/template/<int:template_id>/<sheet_name>', methods=['GET'])
    def get_template(template_id, sheet_name):
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /template: session missing")
            return jsonify({'error': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("""
                SELECT template_name, sheet_name, headers
                FROM excel_templates
                WHERE template_id = %s AND user_id = %s AND status = 'ACTIVE'
            """, (template_id, session['user_id']))
            template_record = cursor.fetchone()
            
            if not template_record:
                logging.error(f"Template not found for template_id: {template_id}, user_id: {session['user_id']}")
                cursor.close()
                return jsonify({'error': 'Template not found'}), 404

            headers = json.loads(template_record['headers']) if template_record['headers'] else []
            stored_sheet_name = template_record['sheet_name'] or sheet_name
            file_path = os.path.join(app.config['UPLOAD_FOLDER'], template_record['template_name'])
            
            cursor.execute("""
                SELECT COUNT(*) as rule_count
                FROM template_columns tc
                JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                WHERE tc.template_id = %s AND tc.is_selected = TRUE
            """, (template_id,))
            rule_count = cursor.fetchone()['rule_count']
            has_existing_rules = rule_count > 0
            
            cursor.close()
            
            return jsonify({
                'success': True,
                'sheets': {stored_sheet_name: {'headers': headers}},
                'file_name': template_record['template_name'],
                'file_path': file_path,
                'sheet_name': stored_sheet_name,
                'has_existing_rules': has_existing_rules
            })
        except mysql.connector.Error as e:
            logging.error(f"Database error in get_template: {str(e)}")
            return jsonify({'error': f'Database error: {str(e)}'}), 500
        except Exception as e:
            logging.error(f"Unexpected error in get_template: {str(e)}")
            return jsonify({'error': f'Unexpected error: {str(e)}'}), 500

    # Debug route to show all registered routes
    @app.route('/debug/routes', methods=['GET'])
    def list_routes():
        routes = []
        for rule in app.url_map.iter_rules():
            routes.append({
                'endpoint': rule.endpoint,
                'methods': list(rule.methods),
                'rule': rule.rule
            })
        return jsonify(routes)

    # 404 handler to debug missing routes
    @app.errorhandler(404)
    def not_found_handler(error):
        logging.error(f"404 Error: {request.method} {request.url} not found")
        logging.error(f"Available routes: {[rule.rule for rule in app.url_map.iter_rules()]}")
        return jsonify({
            'error': 'Endpoint not found', 
            'method': request.method,
            'url': request.url,
            'path': request.path
        }), 404

    return app

def initialize_app_data():
    """Initialize database and create default data"""
    try:
        logging.info("Initializing database schema...")
        init_db()
        
        logging.info("Creating admin user...")
        create_admin_user()
        
        logging.info("Creating default validation rules...")
        create_default_validation_rules()
        
        logging.info("Application initialization completed successfully")
    except Exception as e:
        logging.error(f"Failed to initialize application: {e}")
        raise

DB_CONFIG = {
    'host': os.getenv('MYSQL_HOST', 'localhost'),
    'user': os.getenv('MYSQL_USER', 'root'),
    'password': os.getenv('MYSQL_PASSWORD', 'Keansa@2024'),
    'database': os.getenv('MYSQL_DATABASE', 'data_validation_2'),
}

def get_db_connection():
    if 'db' not in g:
        try:
            conn = mysql.connector.connect(
                host=DB_CONFIG['host'],
                user=DB_CONFIG['user'],
                password=DB_CONFIG['password']
            )
            cursor = conn.cursor()
            cursor.execute(f"CREATE DATABASE IF NOT EXISTS {DB_CONFIG['database']}")
            cursor.close()
            conn.close()
            g.db = mysql.connector.connect(**DB_CONFIG)
            logging.info("Database connection established successfully")
        except mysql.connector.Error as err:
            if err.errno == errorcode.ER_ACCESS_DENIED_ERROR:
                logging.error("Database connection failed: Access denied for user - check username/password")
            elif err.errno == errorcode.ER_BAD_DB_ERROR:
                logging.error("Database connection failed: Database does not exist")
            else:
                logging.error(f"Database connection failed: {err}")
            raise Exception(f"Failed to connect to database: {str(err)}")
    return g.db

def close_db(error):
    db = g.pop('db', None)
    if db is not None:
        db.close()

def init_db():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        tables = [
            """
            CREATE TABLE IF NOT EXISTS login_details (
                id INT AUTO_INCREMENT PRIMARY KEY,
                first_name VARCHAR(100),
                last_name VARCHAR(100),
                email VARCHAR(255) UNIQUE,
                mobile VARCHAR(10),
                password VARCHAR(255)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS excel_templates (
                template_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_name VARCHAR(255) NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
                user_id INT NOT NULL,
                sheet_name VARCHAR(255),
                headers JSON,
                status ENUM('ACTIVE', 'INACTIVE') DEFAULT 'ACTIVE',
                is_corrected BOOLEAN DEFAULT FALSE,
                remote_file_path VARCHAR(512),
                FOREIGN KEY (user_id) REFERENCES login_details(id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS template_columns (
                column_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_id BIGINT NOT NULL,
                column_name VARCHAR(255) NOT NULL,
                column_position INT NOT NULL,
                is_validation_enabled BOOLEAN DEFAULT FALSE,
                is_selected BOOLEAN DEFAULT FALSE,
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE,
                UNIQUE (template_id, column_name)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_rule_types (
                rule_type_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                rule_name VARCHAR(255) NOT NULL,
                description TEXT,
                parameters TEXT,
                is_active BOOLEAN DEFAULT TRUE,
                is_custom BOOLEAN DEFAULT FALSE,
                column_name VARCHAR(255),
                template_id BIGINT,
                data_type VARCHAR(50),
                source_format VARCHAR(50),
                target_format VARCHAR(50),
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS column_validation_rules (
                column_validation_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                column_id BIGINT NOT NULL,
                rule_type_id BIGINT NOT NULL,
                rule_config JSON,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (column_id) REFERENCES template_columns(column_id) ON DELETE CASCADE,
                FOREIGN KEY (rule_type_id) REFERENCES validation_rule_types(rule_type_id) ON DELETE RESTRICT,
                UNIQUE (column_id, rule_type_id)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_history (
                history_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_id BIGINT NOT NULL,
                template_name VARCHAR(255) NOT NULL,
                error_count INT NOT NULL,
                corrected_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                corrected_file_path VARCHAR(512) NOT NULL,
                user_id INT NOT NULL,
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE,
                FOREIGN KEY (user_id) REFERENCES login_details(id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_corrections (
                correction_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                history_id BIGINT NOT NULL,
                row_index INT NOT NULL,
                column_name VARCHAR(255) NOT NULL,
                original_value TEXT,
                corrected_value TEXT,
                rule_failed VARCHAR(255) DEFAULT NULL,
                FOREIGN KEY (history_id) REFERENCES validation_history(history_id) ON DELETE CASCADE
            )
            """
        ]
        for table_sql in tables:
            cursor.execute(table_sql)
        
        # Add missing columns if they don't exist
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'source_format'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN source_format VARCHAR(50)")
            logging.info("Added source_format column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'target_format'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN target_format VARCHAR(50)")
            logging.info("Added target_format column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'data_type'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN data_type VARCHAR(50)")
            logging.info("Added data_type column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM excel_templates LIKE 'remote_file_path'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE excel_templates ADD COLUMN remote_file_path VARCHAR(512)")
            logging.info("Added remote_file_path column to excel_templates table")
            
        cursor.execute("SHOW COLUMNS FROM template_columns LIKE 'is_selected'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE template_columns ADD COLUMN is_selected BOOLEAN DEFAULT FALSE")
            logging.info("Added is_selected column to template_columns table")
            
        conn.commit()
        cursor.close()
        logging.info("Database tables initialized")
    except Exception as e:
        logging.error(f"Failed to initialize database: {str(e)}")
        raise

def create_admin_user():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        admin_password = bcrypt.hashpw('admin'.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
        cursor.execute("""
            INSERT IGNORE INTO login_details (first_name, last_name, email, mobile, password)
            VALUES (%s, %s, %s, %s, %s)
        """, ('Admin', 'User', 'admin@example.com', '1234567890', admin_password))
        conn.commit()
        cursor.close()
        logging.info("Admin user created or already exists")
    except Exception as e:
        logging.error(f"Failed to create admin user: {str(e)}")
        raise

def create_default_validation_rules():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        default_rules = [
            ("Required", "Ensures the field is not null", '{"allow_null": false}', None, None, None),
            ("Int", "Validates integer format", '{"format": "integer"}', None, None, "Int"),
            ("Float", "Validates number format (integer or decimal)", '{"format": "float"}', None, None, "Float"),
            ("Text", "Allows text with quotes and parentheses", '{"allow_special": false}', None, None, "Text"),
            ("Email", "Validates email format", '{"regex": "^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\\\.[a-zA-Z0-9-.]+$"}', None, None, "Email"),
            ("Date(DD-MM-YYYY)", "Validates date format DD-MM-YYYY", '{"format": "%d-%m-%Y"}', "DD-MM-YYYY", None, "Date"),
            ("Boolean", "Validates boolean format (true/false or 0/1)", '{"format": "boolean"}', None, None, "Boolean"),
            ("Alphanumeric", "Validates alphanumeric format", '{"format": "alphanumeric"}', None, None, "Alphanumeric")
        ]
        cursor.executemany("""
            INSERT IGNORE INTO validation_rule_types (rule_name, description, parameters, is_custom, source_format, target_format, data_type)
            VALUES (%s, %s, %s, %s, %s, %s, %s)
        """, [(name, desc, params, False, source, target, dtype) for name, desc, params, source, target, dtype in default_rules])
        conn.commit()
        cursor.close()
        logging.info("Default validation rules ensured successfully")
    except Exception as e:
        logging.error(f"Failed to ensure default validation rules: {str(e)}")
        raise

if __name__ == '__main__':
    try:
        # Create the application using factory pattern
        app = create_app()
        
        # Initialize database and default data within app context
        with app.app_context():
            initialize_app_data()
        
        # Get port from environment or use default
        port = int(os.getenv('PORT', 5000))
        
        # Start the application server
        logging.info("Starting Flask server...")
        app.run(debug=True, host='0.0.0.0', port=port)
        
    except Exception as e:
        logging.error(f"Failed to start application: {e}")
        raise
).all():
        return "Alphanumeric"
    
    return "Text"

def assign_default_rules_to_columns(df, headers):
    """Intelligently assign validation rules based on column content"""
    assignments = {}
    
    for col in headers:
        if col not in df.columns:
            logging.warning(f"Column {col} not found in dataframe")
            continue
            
        col_type = detect_column_type(df[col])
        rules = ["Required"]  # Default rule for all columns
        
        # Special handling for optional columns
        if not any(col.lower().startswith(prefix) for prefix in
                  ["name", "address", "phone", "username", "status", "period"]):
            rules.append(col_type)
        else:
            rules.append("Text")  # Optional text fields
        
        assignments[col] = rules
    
    return assignments

def create_app():
    """Application factory pattern for different environments"""
    # Set the path to the frontend dist folder
    current_dir = os.path.dirname(os.path.abspath(__file__))
    frontend_dist_path = os.path.join(current_dir, '..', '..', 'Keansa-Ai-Suite2025may-frontend11', 'dist')
    frontend_dist_path = os.path.abspath(frontend_dist_path)
    
    # Create Flask application instance
    app = Flask(__name__, static_folder=frontend_dist_path, static_url_path='')
    CORS(app, supports_credentials=True, origins=["http://localhost:3000", "http://localhost:8080", "http://localhost:5000", "*"])

    app.secret_key = os.urandom(24).hex()
    app.config['SESSION_TYPE'] = 'filesystem'
    app.config['SESSION_FILE_DIR'] = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'sessions')
    app.config['SESSION_COOKIE_SAMESITE'] = 'Lax'
    app.config['SESSION_COOKIE_HTTPONLY'] = True
    app.config['SESSION_COOKIE_SECURE'] = False
    app.config['PERMANENT_SESSION_LIFETIME'] = 86400  # 24 hours
    app.config['UPLOAD_FOLDER'] = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'uploads')
    Session(app)

    # Ensure directories exist
    try:
        os.makedirs(app.config['UPLOAD_FOLDER'], exist_ok=True)
        os.makedirs(app.config['SESSION_FILE_DIR'], exist_ok=True)
    except OSError as e:
        logging.error(f"Failed to create directories: {e}")

    # Register cleanup handlers
    app.teardown_appcontext(close_db)
    
    # Register all routes directly in create_app
    
    # Static file serving for React frontend
    @app.route('/', defaults={'path': ''})
    @app.route('/<path:path>')
    def serve(path):
        if path and os.path.exists(os.path.join(app.static_folder, path)):
            return app.send_static_file(path)
        return app.send_static_file('index.html')

    # Health check endpoint
    @app.route('/health', methods=['GET'])
    def health_check():
        return jsonify({
            'status': 'healthy',
            'timestamp': datetime.now().isoformat(),
            'version': '2.0.0'
        })

    # Authentication endpoint - both old and new paths
    @app.route('/authenticate', methods=['POST'])
    @app.route('/api/auth/authenticate', methods=['POST'])
    def authenticate():
        try:
            email = request.form.get('username') or request.form.get('email')
            password = request.form.get('password')
            logging.debug(f"Login attempt: email={email}, password={'*' * len(password) if password else 'None'}")
            
            if not email or not password:
                logging.warning(f"Login failed: Email or password missing")
                return jsonify({'success': False, 'message': 'Email and password are required'}), 400

            # Check for admin login
            if email == "admin" and password == "admin":
                session['loggedin'] = True
                session['user_email'] = "admin@example.com"
                session['user_id'] = 1
                session.permanent = True
                logging.info(f"Admin login successful. Session: {dict(session)}")
                return jsonify({'success': True, 'message': 'Login successful', 'user': {'email': 'admin@example.com', 'id': 1}}), 200

            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("SELECT * FROM login_details WHERE LOWER(email) = LOWER(%s)", (email.lower(),))
            account = cursor.fetchone()
            cursor.close()
            
            if account:
                if bcrypt.checkpw(password.encode('utf-8'), account['password'].encode('utf-8')):
                    session['loggedin'] = True
                    session['user_email'] = account['email']
                    session['user_id'] = account['id']
                    session.permanent = True
                    logging.info(f"User {email} logged in successfully. Session: {dict(session)}")
                    return jsonify({
                        'success': True,
                        'message': 'Login successful',
                        'user': {'email': account['email'], 'id': account['id']}
                    }), 200
                else:
                    logging.warning(f"Invalid password for {email}")
                    return jsonify({'success': False, 'message': 'Invalid credentials'}), 401
            else:
                logging.warning(f"Email {email} not found")
                return jsonify({'success': False, 'message': 'Invalid credentials'}), 401
        except Exception as e:
            logging.error(f"Unexpected error during login: {str(e)}")
            return jsonify({'success': False, 'message': f'Unexpected error: {str(e)}'}), 500

    @app.route('/check-auth', methods=['GET'])
    @app.route('/api/auth/check-auth', methods=['GET'])
    def check_auth():
        try:
            logging.debug(f"Checking auth with session: {dict(session)}")
            if 'loggedin' in session and 'user_id' in session:
                conn = get_db_connection()
                cursor = conn.cursor(dictionary=True)
                cursor.execute("SELECT email, first_name FROM login_details WHERE id = %s", (session['user_id'],))
                user = cursor.fetchone()
                cursor.close()
                if user:
                    logging.info(f"User {session.get('user_email')} is authenticated")
                    return jsonify({
                        'success': True,
                        'user': {
                            'email': user['email'],
                            'id': session['user_id'],
                            'first_name': user['first_name']
                        }
                    })
                else:
                    logging.warning("User not found in database")  
                    session.clear()
                    return jsonify({'success': False, 'message': 'User not found'}), 401
            logging.warning("User not authenticated")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        except Exception as e:
            logging.error(f"Error in check-auth endpoint: {str(e)}")
            return jsonify({'success': False, 'message': f'Server error: {str(e)}'}), 500

    @app.route('/register', methods=['POST'])
    @app.route('/api/auth/register', methods=['POST'])
    def register():
        first_name = request.form.get('first_name')
        last_name = request.form.get('last_name')
        email = request.form.get('email')
        mobile = request.form.get('mobile')
        password = request.form.get('password')
        confirm_password = request.form.get('confirm_password')

        if not all([first_name, last_name, email, mobile, password, confirm_password]):
            return jsonify({'success': False, 'message': 'All fields are required'}), 400
        if password != confirm_password:
            return jsonify({'success': False, 'message': 'Passwords do not match'}), 400

        hashed_password = bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
        try:
            conn = get_db_connection()
            cursor = conn.cursor()
            cursor.execute("""
                INSERT INTO login_details (first_name, last_name, email, mobile, password)
                VALUES (%s, %s, %s, %s, %s)
            """, (first_name, last_name, email, mobile, hashed_password))
            user_id = cursor.lastrowid
            conn.commit()
            cursor.close()
            session['loggedin'] = True
            session['user_email'] = email
            session['user_id'] = user_id
            return jsonify({
                'success': True,
                'message': 'Registration successful',
                'user': {'email': email, 'id': user_id}
            }), 200
        except mysql.connector.Error as e:
            logging.error(f"Database error during registration: {str(e)}")
            return jsonify({'success': False, 'message': f'Registration error: {str(e)}'}), 500

    @app.route('/logout', methods=['POST'])
    @app.route('/api/auth/logout', methods=['POST'])
    def logout():
        logging.info(f"User {session.get('user_email', 'unknown')} logged out")
        session.clear()
        return jsonify({'success': True, 'message': 'Logged out successfully'})

    # Template routes
    @app.route('/templates', methods=['GET'])
    @app.route('/api/templates', methods=['GET'])
    def get_templates():
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /templates: session missing")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("""
                SELECT template_id, template_name, created_at, status
                FROM excel_templates
                WHERE user_id = %s AND status = 'ACTIVE'
                ORDER BY created_at DESC
                LIMIT 100
            """, (session['user_id'],))
            templates = cursor.fetchall()
            cursor.close()
            logging.info(f"Fetched {len(templates)} templates for user {session['user_id']}")
            return jsonify({'success': True, 'templates': templates})
        except mysql.connector.Error as e:
            logging.error(f'Error fetching templates: {str(e)}')
            return jsonify({'success': False, 'message': f'Error fetching templates: {str(e)}'}), 500
        except Exception as e:
            logging.error(f'Unexpected error fetching templates: {str(e)}')
            return jsonify({'success': False, 'message': f'Unexpected error: {str(e)}'}), 500

    # Rule Configuration routes
    @app.route('/rule-configurations', methods=['GET'])
    @app.route('/api/validation/rule-configurations', methods=['GET'])
    def get_rule_configurations():
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning(f"Unauthorized access to /rule-configurations: session={dict(session)}")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            user_id = session['user_id']
            logging.debug(f"Fetching rule configurations for user_id: {user_id}")

            # Main query to fetch templates with configured rules
            cursor.execute("""
                SELECT 
                    t.template_id, 
                    t.template_name, 
                    t.created_at, 
                    COUNT(cvr.column_validation_id) as rule_count
                FROM excel_templates t
                LEFT JOIN template_columns tc ON t.template_id = tc.template_id
                LEFT JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                WHERE t.user_id = %s AND t.status = 'ACTIVE' AND t.is_corrected = FALSE
                GROUP BY t.template_id, t.template_name, t.created_at
                HAVING rule_count > 0
                ORDER BY t.created_at DESC
                LIMIT 100
            """, (user_id,))
            templates = cursor.fetchall()
            logging.debug(f"Fetched rule-configured templates: {templates}")

            cursor.close()

            if not templates:
                logging.info(f"No templates with rules found for user_id: {user_id}")
            else:
                logging.info(f"Found {len(templates)} templates with rules for user_id: {user_id}")

            return jsonify({'success': True, 'templates': templates})
        except mysql.connector.Error as e:
            logging.error(f"Database error fetching rule configurations: {str(e)}")
            return jsonify({'success': False, 'message': f"Database error: {str(e)}"}), 500
        except Exception as e:
            logging.error(f"Unexpected error fetching rule configurations: {str(e)}")
            return jsonify({'success': False, 'message': f"Unexpected error: {str(e)}"}), 500

    # File upload route
    @app.route('/upload', methods=['POST'])
    @app.route('/api/templates/upload', methods=['POST'])
    @app.route('/api/upload', methods=['POST'])  # Additional common path
    def upload():
        logging.info(f"Upload endpoint called: {request.endpoint}, method: {request.method}")
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /upload: session missing")
            return jsonify({'error': 'Not logged in'}), 401
        if 'file' not in request.files:
            logging.warning("No file provided in upload request")
            return jsonify({'error': 'No file uploaded'}), 400
        file = request.files['file']
        if file.filename == '':
            logging.warning("No file selected in upload request")
            return jsonify({'error': 'No file selected'}), 400
        
        file_path = os.path.join(app.config['UPLOAD_FOLDER'], file.filename)
        try:
            file.save(file_path)
            logging.info(f"File saved: {file_path}")
        except Exception as e:
            logging.error(f"Failed to save file {file.filename}: {str(e)}")
            return jsonify({'error': f'Failed to save file: {str(e)}'}), 500

        try:
            # Read the file to get sheets and headers
            if file.filename.endswith('.xlsx') or file.filename.endswith('.xls'):
                xl = pd.ExcelFile(file_path)
                sheets = {sheet_name: pd.read_excel(file_path, sheet_name=sheet_name, header=None) 
                         for sheet_name in xl.sheet_names}
            elif file.filename.endswith(('.txt', '.csv', '.dat')):
                df = pd.read_csv(file_path, header=None, encoding='utf-8')
                sheets = {'Sheet1': df}
            else:
                logging.error("Unsupported file type")
                return jsonify({'error': 'Unsupported file type'}), 400
            
            logging.debug(f"Sheets extracted: {list(sheets.keys())}")
        except Exception as e:
            logging.error(f"Failed to read file {file_path}: {str(e)}")
            return jsonify({'error': f'Failed to read file: {str(e)}'}), 400

        try:
            sheet_names = list(sheets.keys())
            if not sheet_names:
                logging.error("No sheets found in the file")
                return jsonify({'error': 'No sheets found in the file'}), 400
            sheet_name = sheet_names[0]
            df = sheets[sheet_name]
            
            # Find header row
            header_row = 0
            for i in range(min(len(df), 10)):
                row = df.iloc[i].dropna()
                if not row.empty and all(isinstance(x, str) for x in row if pd.notna(x)):
                    header_row = i
                    break
                    
            headers = df.iloc[header_row].tolist()
            logging.debug(f"Headers extracted: {headers}")
            
            if not headers or all(not h for h in headers):
                logging.error("No valid headers found in file")
                return jsonify({'error': 'No valid headers found in the file'}), 400
        except Exception as e:
            logging.error(f"Error processing file {file.filename}: {str(e)}")
            return jsonify({'error': f'Error processing file: {str(e)}'}), 400

        # Clear existing session data
        for key in ['df', 'header_row', 'headers', 'sheet_name', 'current_step', 'selected_headers', 'validations', 'error_cell_locations', 'data_rows', 'corrected_file_path']:
            session.pop(key, None)

        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)

            # Check if template exists
            cursor.execute("""
                SELECT template_id, headers, sheet_name
                FROM excel_templates
                WHERE template_name = %s AND user_id = %s AND status = 'ACTIVE'
                ORDER BY created_at DESC
            """, (file.filename, session['user_id']))
            existing_templates = cursor.fetchall()
            logging.info(f"Found {len(existing_templates)} existing templates with name {file.filename}")

            template_id = None
            has_existing_rules = False
            validations = {}
            selected_headers = []

            # Check for matching template
            matching_template = None
            for template in existing_templates:
                stored_headers = json.loads(template['headers']) if template['headers'] else []
                stored_sheet_name = template['sheet_name']
                if stored_headers == headers and stored_sheet_name == sheet_name:
                    matching_template = template
                    break

            if matching_template:
                template_id = matching_template['template_id']
                # Check for existing rules
                cursor.execute("""
                    SELECT tc.column_name, vrt.rule_name
                    FROM template_columns tc
                    JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                    JOIN validation_rule_types vrt ON cvr.rule_type_id = vrt.rule_type_id
                    WHERE tc.template_id = %s AND tc.is_selected = TRUE
                """, (template_id,))
                rules_data = cursor.fetchall()
                for row in rules_data:
                    column_name = row['column_name']
                    rule_name = row['rule_name']
                    if column_name not in validations:
                        validations[column_name] = []
                    validations[column_name].append(rule_name)
                    if column_name not in selected_headers:
                        selected_headers.append(column_name)
                has_existing_rules = len(validations) > 0
            else:
                # New template
                cursor.execute("""
                    INSERT INTO excel_templates (template_name, user_id, sheet_name, headers, is_corrected)
                    VALUES (%s, %s, %s, %s, %s)
                """, (file.filename, session['user_id'], sheet_name, json.dumps(headers), False))
                template_id = cursor.lastrowid
                column_data = [(template_id, header, i + 1, False) for i, header in enumerate(headers)]
                cursor.executemany("""
                    INSERT INTO template_columns (template_id, column_name, column_position, is_selected)
                    VALUES (%s, %s, %s, %s)
                """, column_data)

            conn.commit()
            cursor.close()

            # Store session data
            session['file_path'] = file_path
            session['template_id'] = template_id
            session['df'] = df.to_json()
            session['header_row'] = header_row
            session['headers'] = headers
            session['sheet_name'] = sheet_name
            session['current_step'] = 1 if not has_existing_rules else 3
            session['validations'] = validations
            session['selected_headers'] = selected_headers
            session['has_existing_rules'] = has_existing_rules

            logging.info(f"Upload processed: template_id={template_id}, filename={file.filename}, has_existing_rules={has_existing_rules}")

            return jsonify({
                'success': True,
                'sheets': {sheet_name: {'headers': headers}},
                'file_name': file.filename,
                'template_id': template_id,
                'has_existing_rules': has_existing_rules,
                'sheet_name': sheet_name,
                'skip_to_step_3': has_existing_rules
            })
        except mysql.connector.Error as e:
            logging.error(f'Error saving template: {str(e)}')
            return jsonify({'error': f'Error saving template: {str(e)}'}), 500
        except Exception as e:
            logging.error(f'Unexpected error saving template: {str(e)}')
            return jsonify({'error': f'Unexpected error: {str(e)}'}), 500

    # Multi-step workflow endpoints
    @app.route('/step/1', methods=['GET', 'POST'])
    @app.route('/api/step/1', methods=['GET', 'POST'])
    def step_one():
        if 'loggedin' not in session:
            return jsonify({'error': 'Not logged in'}), 401
        
        if request.method == 'POST':
            try:
                headers = request.form.getlist('headers')
                new_header_row = request.form.get('new_header_row')
                logging.debug(f"Step 1 submitted: headers={headers}, new_header_row={new_header_row}")
                
                if not headers:
                    logging.error("No headers provided in step 1")
                    return jsonify({'success': False, 'message': 'No headers provided'}), 400
                    
                if 'template_id' not in session:
                    logging.error("Session missing template_id")
                    return jsonify({'success': False, 'message': 'Session data missing'}), 400

                template_id = session['template_id']
                
                # Get the dataframe from session for auto-detection
                df_json = session.get('df')
                if df_json:
                    df = pd.read_json(StringIO(df_json))
                    session_headers = session.get('headers', [])
                    df.columns = session_headers
                    header_row = session.get('header_row', 0)
                    df = df.iloc[header_row + 1:].reset_index(drop=True)
                    
                    # Auto-detect rules for selected headers
                    validations = assign_default_rules_to_columns(df, headers)
                    session['validations'] = validations
                    logging.debug(f"Auto-assigned rules: {validations}")
                else:
                    validations = {}

                session['selected_headers'] = headers
                session['current_step'] = 2

                # Mark selected headers in the database
                conn = get_db_connection()
                cursor = conn.cursor()
                cursor.execute("UPDATE template_columns SET is_selected = FALSE WHERE template_id = %s", (template_id,))
                for header in headers:
                    cursor.execute("""
                        UPDATE template_columns
                        SET is_selected = TRUE
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    
                    # Get column_id and add auto-detected rules
                    cursor.execute("""
                        SELECT column_id FROM template_columns
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    result = cursor.fetchone()
                    if result:
                        column_id = result[0]
                        for rule_name in validations.get(header, []):
                            cursor.execute("""
                                SELECT rule_type_id FROM validation_rule_types
                                WHERE rule_name = %s AND is_custom = FALSE
                            """, (rule_name,))
                            rule_result = cursor.fetchone()
                            if rule_result:
                                rule_type_id = rule_result[0]
                                cursor.execute("""
                                    INSERT IGNORE INTO column_validation_rules (column_id, rule_type_id, rule_config)
                                    VALUES (%s, %s, %s)
                                """, (column_id, rule_type_id, '{}'))
                
                conn.commit()
                cursor.close()

                logging.info(f"Step 1 completed: headers={headers}, auto-assigned rules={validations}")
                return jsonify({'success': True, 'headers': headers, 'validations': validations})
            except Exception as e:
                logging.error(f"Error in step 1: {str(e)}")
                return jsonify({'success': False, 'message': str(e)}), 500
        
        # GET request - return current headers
        headers = session.get('headers', [])
        return jsonify({'headers': headers})

    @app.route('/step/2', methods=['GET', 'POST'])
    @app.route('/api/step/2', methods=['GET', 'POST'])
    def step_two():
        if 'loggedin' not in session:
            return jsonify({'error': 'Not logged in'}), 401
            
        if request.method == 'POST':
            try:
                action = request.form.get('action', 'save')
                validations = {}
                for key, values in request.form.lists():
                    if key.startswith('validations_'):
                        header = key.replace('validations_', '')
                        validations[header] = values
                        
                logging.debug(f"Step 2 submitted: action={action}, validations={validations}")
                
                template_id = session.get('template_id')
                if not template_id:
                    return jsonify({'success': False, 'message': 'Session data missing'}), 400

                # Save validations to database
                conn = get_db_connection()
                cursor = conn.cursor()
                
                # Clear existing rules
                cursor.execute("""
                    DELETE FROM column_validation_rules
                    WHERE column_id IN (
                        SELECT column_id FROM template_columns WHERE template_id = %s
                    )
                """, (template_id,))
                
                # Add new rules
                for header, rules in validations.items():
                    cursor.execute("""
                        SELECT column_id FROM template_columns
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    result = cursor.fetchone()
                    if not result:
                        continue
                    column_id = result[0]
                    
                    for rule_name in rules:
                        cursor.execute("""
                            SELECT rule_type_id FROM validation_rule_types
                            WHERE rule_name = %s
                        """, (rule_name,))
                        result = cursor.fetchone()
                        if result:
                            rule_type_id = result[0]
                            cursor.execute("""
                                INSERT IGNORE INTO column_validation_rules (column_id, rule_type_id, rule_config)
                                VALUES (%s, %s, %s)
                            """, (column_id, rule_type_id, '{}'))
                
                conn.commit()
                cursor.close()

                session['validations'] = validations
                session['current_step'] = 3 if action == 'review' else 2
                
                logging.info(f"Step 2 completed: action={action}, validations={validations}")
                return jsonify({'success': True, 'message': 'Step 2 completed successfully'})
            except Exception as e:
                logging.error(f"Error in step 2: {str(e)}")
                return jsonify({'success': False, 'message': str(e)}), 500
        
        # GET request
        selected_headers = session.get('selected_headers', [])
        return jsonify({'selected_headers': selected_headers})

    # Rules endpoint
    @app.route('/rules', methods=['GET'])
    @app.route('/api/rules', methods=['GET'])
    def get_rules():
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            
            cursor.execute("""
                SELECT rule_type_id AS rule_id, rule_name, description, parameters, is_custom, 
                       column_name, template_id, source_format, target_format, data_type, is_active
                FROM validation_rule_types
            """)
            rules = cursor.fetchall()
            cursor.close()
            
            logging.info(f"Returning {len(rules)} rules from getRules endpoint")
            return jsonify({'success': True, 'rules': rules})
        except mysql.connector.Error as e:
            logging.error(f"Database error fetching rules: {str(e)}")
            return jsonify({'success': False, 'message': str(e)}), 500
        except Exception as e:
            logging.error(f"Unexpected error fetching rules: {str(e)}")
            return jsonify({'success': False, 'message': str(e)}), 500

    # Template details endpoint
    @app.route('/template/<int:template_id>/<sheet_name>', methods=['GET'])
    @app.route('/api/template/<int:template_id>/<sheet_name>', methods=['GET'])
    def get_template(template_id, sheet_name):
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /template: session missing")
            return jsonify({'error': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("""
                SELECT template_name, sheet_name, headers
                FROM excel_templates
                WHERE template_id = %s AND user_id = %s AND status = 'ACTIVE'
            """, (template_id, session['user_id']))
            template_record = cursor.fetchone()
            
            if not template_record:
                logging.error(f"Template not found for template_id: {template_id}, user_id: {session['user_id']}")
                cursor.close()
                return jsonify({'error': 'Template not found'}), 404

            headers = json.loads(template_record['headers']) if template_record['headers'] else []
            stored_sheet_name = template_record['sheet_name'] or sheet_name
            file_path = os.path.join(app.config['UPLOAD_FOLDER'], template_record['template_name'])
            
            cursor.execute("""
                SELECT COUNT(*) as rule_count
                FROM template_columns tc
                JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                WHERE tc.template_id = %s AND tc.is_selected = TRUE
            """, (template_id,))
            rule_count = cursor.fetchone()['rule_count']
            has_existing_rules = rule_count > 0
            
            cursor.close()
            
            return jsonify({
                'success': True,
                'sheets': {stored_sheet_name: {'headers': headers}},
                'file_name': template_record['template_name'],
                'file_path': file_path,
                'sheet_name': stored_sheet_name,
                'has_existing_rules': has_existing_rules
            })
        except mysql.connector.Error as e:
            logging.error(f"Database error in get_template: {str(e)}")
            return jsonify({'error': f'Database error: {str(e)}'}), 500
        except Exception as e:
            logging.error(f"Unexpected error in get_template: {str(e)}")
            return jsonify({'error': f'Unexpected error: {str(e)}'}), 500

    # Debug route to show all registered routes
    @app.route('/debug/routes', methods=['GET'])
    def list_routes():
        routes = []
        for rule in app.url_map.iter_rules():
            routes.append({
                'endpoint': rule.endpoint,
                'methods': list(rule.methods),
                'rule': rule.rule
            })
        return jsonify(routes)

    # 404 handler to debug missing routes
    @app.errorhandler(404)
    def not_found_handler(error):
        logging.error(f"404 Error: {request.method} {request.url} not found")
        logging.error(f"Available routes: {[rule.rule for rule in app.url_map.iter_rules()]}")
        return jsonify({
            'error': 'Endpoint not found', 
            'method': request.method,
            'url': request.url,
            'path': request.path
        }), 404

    return app

def initialize_app_data():
    """Initialize database and create default data"""
    try:
        logging.info("Initializing database schema...")
        init_db()
        
        logging.info("Creating admin user...")
        create_admin_user()
        
        logging.info("Creating default validation rules...")
        create_default_validation_rules()
        
        logging.info("Application initialization completed successfully")
    except Exception as e:
        logging.error(f"Failed to initialize application: {e}")
        raise

DB_CONFIG = {
    'host': os.getenv('MYSQL_HOST', 'localhost'),
    'user': os.getenv('MYSQL_USER', 'root'),
    'password': os.getenv('MYSQL_PASSWORD', 'Keansa@2024'),
    'database': os.getenv('MYSQL_DATABASE', 'data_validation_2'),
}

def get_db_connection():
    if 'db' not in g:
        try:
            conn = mysql.connector.connect(
                host=DB_CONFIG['host'],
                user=DB_CONFIG['user'],
                password=DB_CONFIG['password']
            )
            cursor = conn.cursor()
            cursor.execute(f"CREATE DATABASE IF NOT EXISTS {DB_CONFIG['database']}")
            cursor.close()
            conn.close()
            g.db = mysql.connector.connect(**DB_CONFIG)
            logging.info("Database connection established successfully")
        except mysql.connector.Error as err:
            if err.errno == errorcode.ER_ACCESS_DENIED_ERROR:
                logging.error("Database connection failed: Access denied for user - check username/password")
            elif err.errno == errorcode.ER_BAD_DB_ERROR:
                logging.error("Database connection failed: Database does not exist")
            else:
                logging.error(f"Database connection failed: {err}")
            raise Exception(f"Failed to connect to database: {str(err)}")
    return g.db

def close_db(error):
    db = g.pop('db', None)
    if db is not None:
        db.close()

def init_db():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        tables = [
            """
            CREATE TABLE IF NOT EXISTS login_details (
                id INT AUTO_INCREMENT PRIMARY KEY,
                first_name VARCHAR(100),
                last_name VARCHAR(100),
                email VARCHAR(255) UNIQUE,
                mobile VARCHAR(10),
                password VARCHAR(255)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS excel_templates (
                template_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_name VARCHAR(255) NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
                user_id INT NOT NULL,
                sheet_name VARCHAR(255),
                headers JSON,
                status ENUM('ACTIVE', 'INACTIVE') DEFAULT 'ACTIVE',
                is_corrected BOOLEAN DEFAULT FALSE,
                remote_file_path VARCHAR(512),
                FOREIGN KEY (user_id) REFERENCES login_details(id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS template_columns (
                column_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_id BIGINT NOT NULL,
                column_name VARCHAR(255) NOT NULL,
                column_position INT NOT NULL,
                is_validation_enabled BOOLEAN DEFAULT FALSE,
                is_selected BOOLEAN DEFAULT FALSE,
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE,
                UNIQUE (template_id, column_name)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_rule_types (
                rule_type_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                rule_name VARCHAR(255) NOT NULL,
                description TEXT,
                parameters TEXT,
                is_active BOOLEAN DEFAULT TRUE,
                is_custom BOOLEAN DEFAULT FALSE,
                column_name VARCHAR(255),
                template_id BIGINT,
                data_type VARCHAR(50),
                source_format VARCHAR(50),
                target_format VARCHAR(50),
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS column_validation_rules (
                column_validation_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                column_id BIGINT NOT NULL,
                rule_type_id BIGINT NOT NULL,
                rule_config JSON,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (column_id) REFERENCES template_columns(column_id) ON DELETE CASCADE,
                FOREIGN KEY (rule_type_id) REFERENCES validation_rule_types(rule_type_id) ON DELETE RESTRICT,
                UNIQUE (column_id, rule_type_id)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_history (
                history_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_id BIGINT NOT NULL,
                template_name VARCHAR(255) NOT NULL,
                error_count INT NOT NULL,
                corrected_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                corrected_file_path VARCHAR(512) NOT NULL,
                user_id INT NOT NULL,
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE,
                FOREIGN KEY (user_id) REFERENCES login_details(id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_corrections (
                correction_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                history_id BIGINT NOT NULL,
                row_index INT NOT NULL,
                column_name VARCHAR(255) NOT NULL,
                original_value TEXT,
                corrected_value TEXT,
                rule_failed VARCHAR(255) DEFAULT NULL,
                FOREIGN KEY (history_id) REFERENCES validation_history(history_id) ON DELETE CASCADE
            )
            """
        ]
        for table_sql in tables:
            cursor.execute(table_sql)
        
        # Add missing columns if they don't exist
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'source_format'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN source_format VARCHAR(50)")
            logging.info("Added source_format column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'target_format'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN target_format VARCHAR(50)")
            logging.info("Added target_format column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'data_type'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN data_type VARCHAR(50)")
            logging.info("Added data_type column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM excel_templates LIKE 'remote_file_path'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE excel_templates ADD COLUMN remote_file_path VARCHAR(512)")
            logging.info("Added remote_file_path column to excel_templates table")
            
        cursor.execute("SHOW COLUMNS FROM template_columns LIKE 'is_selected'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE template_columns ADD COLUMN is_selected BOOLEAN DEFAULT FALSE")
            logging.info("Added is_selected column to template_columns table")
            
        conn.commit()
        cursor.close()
        logging.info("Database tables initialized")
    except Exception as e:
        logging.error(f"Failed to initialize database: {str(e)}")
        raise

def create_admin_user():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        admin_password = bcrypt.hashpw('admin'.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
        cursor.execute("""
            INSERT IGNORE INTO login_details (first_name, last_name, email, mobile, password)
            VALUES (%s, %s, %s, %s, %s)
        """, ('Admin', 'User', 'admin@example.com', '1234567890', admin_password))
        conn.commit()
        cursor.close()
        logging.info("Admin user created or already exists")
    except Exception as e:
        logging.error(f"Failed to create admin user: {str(e)}")
        raise

def create_default_validation_rules():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        default_rules = [
            ("Required", "Ensures the field is not null", '{"allow_null": false}', None, None, None),
            ("Int", "Validates integer format", '{"format": "integer"}', None, None, "Int"),
            ("Float", "Validates number format (integer or decimal)", '{"format": "float"}', None, None, "Float"),
            ("Text", "Allows text with quotes and parentheses", '{"allow_special": false}', None, None, "Text"),
            ("Email", "Validates email format", '{"regex": "^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\\\.[a-zA-Z0-9-.]+$"}', None, None, "Email"),
            ("Date(DD-MM-YYYY)", "Validates date format DD-MM-YYYY", '{"format": "%d-%m-%Y"}', "DD-MM-YYYY", None, "Date"),
            ("Boolean", "Validates boolean format (true/false or 0/1)", '{"format": "boolean"}', None, None, "Boolean"),
            ("Alphanumeric", "Validates alphanumeric format", '{"format": "alphanumeric"}', None, None, "Alphanumeric")
        ]
        cursor.executemany("""
            INSERT IGNORE INTO validation_rule_types (rule_name, description, parameters, is_custom, source_format, target_format, data_type)
            VALUES (%s, %s, %s, %s, %s, %s, %s)
        """, [(name, desc, params, False, source, target, dtype) for name, desc, params, source, target, dtype in default_rules])
        conn.commit()
        cursor.close()
        logging.info("Default validation rules ensured successfully")
    except Exception as e:
        logging.error(f"Failed to ensure default validation rules: {str(e)}")
        raise

if __name__ == '__main__':
    try:
        # Create the application using factory pattern
        app = create_app()
        
        # Initialize database and default data within app context
        with app.app_context():
            initialize_app_data()
        
        # Get port from environment or use default
        port = int(os.getenv('PORT', 5000))
        
        # Start the application server
        logging.info("Starting Flask server...")
        app.run(debug=True, host='0.0.0.0', port=port)
        
    except Exception as e:
        logging.error(f"Failed to start application: {e}")
        raise
).all():
        return "Float"
    
    # Alphanumeric detection
    if non_null.str.match(r'^[a-zA-Z0-9]+

def create_app():
    """Application factory pattern for different environments"""
    # Set the path to the frontend dist folder
    current_dir = os.path.dirname(os.path.abspath(__file__))
    frontend_dist_path = os.path.join(current_dir, '..', '..', 'Keansa-Ai-Suite2025may-frontend11', 'dist')
    frontend_dist_path = os.path.abspath(frontend_dist_path)
    
    # Create Flask application instance
    app = Flask(__name__, static_folder=frontend_dist_path, static_url_path='')
    CORS(app, supports_credentials=True, origins=["http://localhost:3000", "http://localhost:8080", "http://localhost:5000", "*"])

    app.secret_key = os.urandom(24).hex()
    app.config['SESSION_TYPE'] = 'filesystem'
    app.config['SESSION_FILE_DIR'] = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'sessions')
    app.config['SESSION_COOKIE_SAMESITE'] = 'Lax'
    app.config['SESSION_COOKIE_HTTPONLY'] = True
    app.config['SESSION_COOKIE_SECURE'] = False
    app.config['PERMANENT_SESSION_LIFETIME'] = 86400  # 24 hours
    app.config['UPLOAD_FOLDER'] = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'uploads')
    Session(app)

    # Ensure directories exist
    try:
        os.makedirs(app.config['UPLOAD_FOLDER'], exist_ok=True)
        os.makedirs(app.config['SESSION_FILE_DIR'], exist_ok=True)
    except OSError as e:
        logging.error(f"Failed to create directories: {e}")

    # Register cleanup handlers
    app.teardown_appcontext(close_db)
    
    # Register all routes directly in create_app
    
    # Static file serving for React frontend
    @app.route('/', defaults={'path': ''})
    @app.route('/<path:path>')
    def serve(path):
        if path and os.path.exists(os.path.join(app.static_folder, path)):
            return app.send_static_file(path)
        return app.send_static_file('index.html')

    # Health check endpoint
    @app.route('/health', methods=['GET'])
    def health_check():
        return jsonify({
            'status': 'healthy',
            'timestamp': datetime.now().isoformat(),
            'version': '2.0.0'
        })

    # Authentication endpoint - both old and new paths
    @app.route('/authenticate', methods=['POST'])
    @app.route('/api/auth/authenticate', methods=['POST'])
    def authenticate():
        try:
            email = request.form.get('username') or request.form.get('email')
            password = request.form.get('password')
            logging.debug(f"Login attempt: email={email}, password={'*' * len(password) if password else 'None'}")
            
            if not email or not password:
                logging.warning(f"Login failed: Email or password missing")
                return jsonify({'success': False, 'message': 'Email and password are required'}), 400

            # Check for admin login
            if email == "admin" and password == "admin":
                session['loggedin'] = True
                session['user_email'] = "admin@example.com"
                session['user_id'] = 1
                session.permanent = True
                logging.info(f"Admin login successful. Session: {dict(session)}")
                return jsonify({'success': True, 'message': 'Login successful', 'user': {'email': 'admin@example.com', 'id': 1}}), 200

            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("SELECT * FROM login_details WHERE LOWER(email) = LOWER(%s)", (email.lower(),))
            account = cursor.fetchone()
            cursor.close()
            
            if account:
                if bcrypt.checkpw(password.encode('utf-8'), account['password'].encode('utf-8')):
                    session['loggedin'] = True
                    session['user_email'] = account['email']
                    session['user_id'] = account['id']
                    session.permanent = True
                    logging.info(f"User {email} logged in successfully. Session: {dict(session)}")
                    return jsonify({
                        'success': True,
                        'message': 'Login successful',
                        'user': {'email': account['email'], 'id': account['id']}
                    }), 200
                else:
                    logging.warning(f"Invalid password for {email}")
                    return jsonify({'success': False, 'message': 'Invalid credentials'}), 401
            else:
                logging.warning(f"Email {email} not found")
                return jsonify({'success': False, 'message': 'Invalid credentials'}), 401
        except Exception as e:
            logging.error(f"Unexpected error during login: {str(e)}")
            return jsonify({'success': False, 'message': f'Unexpected error: {str(e)}'}), 500

    @app.route('/check-auth', methods=['GET'])
    @app.route('/api/auth/check-auth', methods=['GET'])
    def check_auth():
        try:
            logging.debug(f"Checking auth with session: {dict(session)}")
            if 'loggedin' in session and 'user_id' in session:
                conn = get_db_connection()
                cursor = conn.cursor(dictionary=True)
                cursor.execute("SELECT email, first_name FROM login_details WHERE id = %s", (session['user_id'],))
                user = cursor.fetchone()
                cursor.close()
                if user:
                    logging.info(f"User {session.get('user_email')} is authenticated")
                    return jsonify({
                        'success': True,
                        'user': {
                            'email': user['email'],
                            'id': session['user_id'],
                            'first_name': user['first_name']
                        }
                    })
                else:
                    logging.warning("User not found in database")  
                    session.clear()
                    return jsonify({'success': False, 'message': 'User not found'}), 401
            logging.warning("User not authenticated")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        except Exception as e:
            logging.error(f"Error in check-auth endpoint: {str(e)}")
            return jsonify({'success': False, 'message': f'Server error: {str(e)}'}), 500

    @app.route('/register', methods=['POST'])
    @app.route('/api/auth/register', methods=['POST'])
    def register():
        first_name = request.form.get('first_name')
        last_name = request.form.get('last_name')
        email = request.form.get('email')
        mobile = request.form.get('mobile')
        password = request.form.get('password')
        confirm_password = request.form.get('confirm_password')

        if not all([first_name, last_name, email, mobile, password, confirm_password]):
            return jsonify({'success': False, 'message': 'All fields are required'}), 400
        if password != confirm_password:
            return jsonify({'success': False, 'message': 'Passwords do not match'}), 400

        hashed_password = bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
        try:
            conn = get_db_connection()
            cursor = conn.cursor()
            cursor.execute("""
                INSERT INTO login_details (first_name, last_name, email, mobile, password)
                VALUES (%s, %s, %s, %s, %s)
            """, (first_name, last_name, email, mobile, hashed_password))
            user_id = cursor.lastrowid
            conn.commit()
            cursor.close()
            session['loggedin'] = True
            session['user_email'] = email
            session['user_id'] = user_id
            return jsonify({
                'success': True,
                'message': 'Registration successful',
                'user': {'email': email, 'id': user_id}
            }), 200
        except mysql.connector.Error as e:
            logging.error(f"Database error during registration: {str(e)}")
            return jsonify({'success': False, 'message': f'Registration error: {str(e)}'}), 500

    @app.route('/logout', methods=['POST'])
    @app.route('/api/auth/logout', methods=['POST'])
    def logout():
        logging.info(f"User {session.get('user_email', 'unknown')} logged out")
        session.clear()
        return jsonify({'success': True, 'message': 'Logged out successfully'})

    # Template routes
    @app.route('/templates', methods=['GET'])
    @app.route('/api/templates', methods=['GET'])
    def get_templates():
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /templates: session missing")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("""
                SELECT template_id, template_name, created_at, status
                FROM excel_templates
                WHERE user_id = %s AND status = 'ACTIVE'
                ORDER BY created_at DESC
                LIMIT 100
            """, (session['user_id'],))
            templates = cursor.fetchall()
            cursor.close()
            logging.info(f"Fetched {len(templates)} templates for user {session['user_id']}")
            return jsonify({'success': True, 'templates': templates})
        except mysql.connector.Error as e:
            logging.error(f'Error fetching templates: {str(e)}')
            return jsonify({'success': False, 'message': f'Error fetching templates: {str(e)}'}), 500
        except Exception as e:
            logging.error(f'Unexpected error fetching templates: {str(e)}')
            return jsonify({'success': False, 'message': f'Unexpected error: {str(e)}'}), 500

    # Rule Configuration routes
    @app.route('/rule-configurations', methods=['GET'])
    @app.route('/api/validation/rule-configurations', methods=['GET'])
    def get_rule_configurations():
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning(f"Unauthorized access to /rule-configurations: session={dict(session)}")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            user_id = session['user_id']
            logging.debug(f"Fetching rule configurations for user_id: {user_id}")

            # Main query to fetch templates with configured rules
            cursor.execute("""
                SELECT 
                    t.template_id, 
                    t.template_name, 
                    t.created_at, 
                    COUNT(cvr.column_validation_id) as rule_count
                FROM excel_templates t
                LEFT JOIN template_columns tc ON t.template_id = tc.template_id
                LEFT JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                WHERE t.user_id = %s AND t.status = 'ACTIVE' AND t.is_corrected = FALSE
                GROUP BY t.template_id, t.template_name, t.created_at
                HAVING rule_count > 0
                ORDER BY t.created_at DESC
                LIMIT 100
            """, (user_id,))
            templates = cursor.fetchall()
            logging.debug(f"Fetched rule-configured templates: {templates}")

            cursor.close()

            if not templates:
                logging.info(f"No templates with rules found for user_id: {user_id}")
            else:
                logging.info(f"Found {len(templates)} templates with rules for user_id: {user_id}")

            return jsonify({'success': True, 'templates': templates})
        except mysql.connector.Error as e:
            logging.error(f"Database error fetching rule configurations: {str(e)}")
            return jsonify({'success': False, 'message': f"Database error: {str(e)}"}), 500
        except Exception as e:
            logging.error(f"Unexpected error fetching rule configurations: {str(e)}")
            return jsonify({'success': False, 'message': f"Unexpected error: {str(e)}"}), 500

    # File upload route
    @app.route('/upload', methods=['POST'])
    @app.route('/api/templates/upload', methods=['POST'])
    @app.route('/api/upload', methods=['POST'])  # Additional common path
    def upload():
        logging.info(f"Upload endpoint called: {request.endpoint}, method: {request.method}")
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /upload: session missing")
            return jsonify({'error': 'Not logged in'}), 401
        if 'file' not in request.files:
            logging.warning("No file provided in upload request")
            return jsonify({'error': 'No file uploaded'}), 400
        file = request.files['file']
        if file.filename == '':
            logging.warning("No file selected in upload request")
            return jsonify({'error': 'No file selected'}), 400
        
        file_path = os.path.join(app.config['UPLOAD_FOLDER'], file.filename)
        try:
            file.save(file_path)
            logging.info(f"File saved: {file_path}")
        except Exception as e:
            logging.error(f"Failed to save file {file.filename}: {str(e)}")
            return jsonify({'error': f'Failed to save file: {str(e)}'}), 500

        try:
            # Read the file to get sheets and headers
            if file.filename.endswith('.xlsx') or file.filename.endswith('.xls'):
                xl = pd.ExcelFile(file_path)
                sheets = {sheet_name: pd.read_excel(file_path, sheet_name=sheet_name, header=None) 
                         for sheet_name in xl.sheet_names}
            elif file.filename.endswith(('.txt', '.csv', '.dat')):
                df = pd.read_csv(file_path, header=None, encoding='utf-8')
                sheets = {'Sheet1': df}
            else:
                logging.error("Unsupported file type")
                return jsonify({'error': 'Unsupported file type'}), 400
            
            logging.debug(f"Sheets extracted: {list(sheets.keys())}")
        except Exception as e:
            logging.error(f"Failed to read file {file_path}: {str(e)}")
            return jsonify({'error': f'Failed to read file: {str(e)}'}), 400

        try:
            sheet_names = list(sheets.keys())
            if not sheet_names:
                logging.error("No sheets found in the file")
                return jsonify({'error': 'No sheets found in the file'}), 400
            sheet_name = sheet_names[0]
            df = sheets[sheet_name]
            
            # Find header row
            header_row = 0
            for i in range(min(len(df), 10)):
                row = df.iloc[i].dropna()
                if not row.empty and all(isinstance(x, str) for x in row if pd.notna(x)):
                    header_row = i
                    break
                    
            headers = df.iloc[header_row].tolist()
            logging.debug(f"Headers extracted: {headers}")
            
            if not headers or all(not h for h in headers):
                logging.error("No valid headers found in file")
                return jsonify({'error': 'No valid headers found in the file'}), 400
        except Exception as e:
            logging.error(f"Error processing file {file.filename}: {str(e)}")
            return jsonify({'error': f'Error processing file: {str(e)}'}), 400

        # Clear existing session data
        for key in ['df', 'header_row', 'headers', 'sheet_name', 'current_step', 'selected_headers', 'validations', 'error_cell_locations', 'data_rows', 'corrected_file_path']:
            session.pop(key, None)

        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)

            # Check if template exists
            cursor.execute("""
                SELECT template_id, headers, sheet_name
                FROM excel_templates
                WHERE template_name = %s AND user_id = %s AND status = 'ACTIVE'
                ORDER BY created_at DESC
            """, (file.filename, session['user_id']))
            existing_templates = cursor.fetchall()
            logging.info(f"Found {len(existing_templates)} existing templates with name {file.filename}")

            template_id = None
            has_existing_rules = False
            validations = {}
            selected_headers = []

            # Check for matching template
            matching_template = None
            for template in existing_templates:
                stored_headers = json.loads(template['headers']) if template['headers'] else []
                stored_sheet_name = template['sheet_name']
                if stored_headers == headers and stored_sheet_name == sheet_name:
                    matching_template = template
                    break

            if matching_template:
                template_id = matching_template['template_id']
                # Check for existing rules
                cursor.execute("""
                    SELECT tc.column_name, vrt.rule_name
                    FROM template_columns tc
                    JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                    JOIN validation_rule_types vrt ON cvr.rule_type_id = vrt.rule_type_id
                    WHERE tc.template_id = %s AND tc.is_selected = TRUE
                """, (template_id,))
                rules_data = cursor.fetchall()
                for row in rules_data:
                    column_name = row['column_name']
                    rule_name = row['rule_name']
                    if column_name not in validations:
                        validations[column_name] = []
                    validations[column_name].append(rule_name)
                    if column_name not in selected_headers:
                        selected_headers.append(column_name)
                has_existing_rules = len(validations) > 0
            else:
                # New template
                cursor.execute("""
                    INSERT INTO excel_templates (template_name, user_id, sheet_name, headers, is_corrected)
                    VALUES (%s, %s, %s, %s, %s)
                """, (file.filename, session['user_id'], sheet_name, json.dumps(headers), False))
                template_id = cursor.lastrowid
                column_data = [(template_id, header, i + 1, False) for i, header in enumerate(headers)]
                cursor.executemany("""
                    INSERT INTO template_columns (template_id, column_name, column_position, is_selected)
                    VALUES (%s, %s, %s, %s)
                """, column_data)

            conn.commit()
            cursor.close()

            # Store session data
            session['file_path'] = file_path
            session['template_id'] = template_id
            session['df'] = df.to_json()
            session['header_row'] = header_row
            session['headers'] = headers
            session['sheet_name'] = sheet_name
            session['current_step'] = 1 if not has_existing_rules else 3
            session['validations'] = validations
            session['selected_headers'] = selected_headers
            session['has_existing_rules'] = has_existing_rules

            logging.info(f"Upload processed: template_id={template_id}, filename={file.filename}, has_existing_rules={has_existing_rules}")

            return jsonify({
                'success': True,
                'sheets': {sheet_name: {'headers': headers}},
                'file_name': file.filename,
                'template_id': template_id,
                'has_existing_rules': has_existing_rules,
                'sheet_name': sheet_name,
                'skip_to_step_3': has_existing_rules
            })
        except mysql.connector.Error as e:
            logging.error(f'Error saving template: {str(e)}')
            return jsonify({'error': f'Error saving template: {str(e)}'}), 500
        except Exception as e:
            logging.error(f'Unexpected error saving template: {str(e)}')
            return jsonify({'error': f'Unexpected error: {str(e)}'}), 500

    # Multi-step workflow endpoints
    @app.route('/step/1', methods=['GET', 'POST'])
    @app.route('/api/step/1', methods=['GET', 'POST'])
    def step_one():
        if 'loggedin' not in session:
            return jsonify({'error': 'Not logged in'}), 401
        
        if request.method == 'POST':
            try:
                headers = request.form.getlist('headers')
                new_header_row = request.form.get('new_header_row')
                logging.debug(f"Step 1 submitted: headers={headers}, new_header_row={new_header_row}")
                
                if not headers:
                    logging.error("No headers provided in step 1")
                    return jsonify({'success': False, 'message': 'No headers provided'}), 400
                    
                if 'template_id' not in session:
                    logging.error("Session missing template_id")
                    return jsonify({'success': False, 'message': 'Session data missing'}), 400

                template_id = session['template_id']
                
                # Get the dataframe from session for auto-detection
                df_json = session.get('df')
                if df_json:
                    df = pd.read_json(StringIO(df_json))
                    session_headers = session.get('headers', [])
                    df.columns = session_headers
                    header_row = session.get('header_row', 0)
                    df = df.iloc[header_row + 1:].reset_index(drop=True)
                    
                    # Auto-detect rules for selected headers
                    validations = assign_default_rules_to_columns(df, headers)
                    session['validations'] = validations
                    logging.debug(f"Auto-assigned rules: {validations}")
                else:
                    validations = {}

                session['selected_headers'] = headers
                session['current_step'] = 2

                # Mark selected headers in the database
                conn = get_db_connection()
                cursor = conn.cursor()
                cursor.execute("UPDATE template_columns SET is_selected = FALSE WHERE template_id = %s", (template_id,))
                for header in headers:
                    cursor.execute("""
                        UPDATE template_columns
                        SET is_selected = TRUE
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    
                    # Get column_id and add auto-detected rules
                    cursor.execute("""
                        SELECT column_id FROM template_columns
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    result = cursor.fetchone()
                    if result:
                        column_id = result[0]
                        for rule_name in validations.get(header, []):
                            cursor.execute("""
                                SELECT rule_type_id FROM validation_rule_types
                                WHERE rule_name = %s AND is_custom = FALSE
                            """, (rule_name,))
                            rule_result = cursor.fetchone()
                            if rule_result:
                                rule_type_id = rule_result[0]
                                cursor.execute("""
                                    INSERT IGNORE INTO column_validation_rules (column_id, rule_type_id, rule_config)
                                    VALUES (%s, %s, %s)
                                """, (column_id, rule_type_id, '{}'))
                
                conn.commit()
                cursor.close()

                logging.info(f"Step 1 completed: headers={headers}, auto-assigned rules={validations}")
                return jsonify({'success': True, 'headers': headers, 'validations': validations})
            except Exception as e:
                logging.error(f"Error in step 1: {str(e)}")
                return jsonify({'success': False, 'message': str(e)}), 500
        
        # GET request - return current headers
        headers = session.get('headers', [])
        return jsonify({'headers': headers})

    @app.route('/step/2', methods=['GET', 'POST'])
    @app.route('/api/step/2', methods=['GET', 'POST'])
    def step_two():
        if 'loggedin' not in session:
            return jsonify({'error': 'Not logged in'}), 401
            
        if request.method == 'POST':
            try:
                action = request.form.get('action', 'save')
                validations = {}
                for key, values in request.form.lists():
                    if key.startswith('validations_'):
                        header = key.replace('validations_', '')
                        validations[header] = values
                        
                logging.debug(f"Step 2 submitted: action={action}, validations={validations}")
                
                template_id = session.get('template_id')
                if not template_id:
                    return jsonify({'success': False, 'message': 'Session data missing'}), 400

                # Save validations to database
                conn = get_db_connection()
                cursor = conn.cursor()
                
                # Clear existing rules
                cursor.execute("""
                    DELETE FROM column_validation_rules
                    WHERE column_id IN (
                        SELECT column_id FROM template_columns WHERE template_id = %s
                    )
                """, (template_id,))
                
                # Add new rules
                for header, rules in validations.items():
                    cursor.execute("""
                        SELECT column_id FROM template_columns
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    result = cursor.fetchone()
                    if not result:
                        continue
                    column_id = result[0]
                    
                    for rule_name in rules:
                        cursor.execute("""
                            SELECT rule_type_id FROM validation_rule_types
                            WHERE rule_name = %s
                        """, (rule_name,))
                        result = cursor.fetchone()
                        if result:
                            rule_type_id = result[0]
                            cursor.execute("""
                                INSERT IGNORE INTO column_validation_rules (column_id, rule_type_id, rule_config)
                                VALUES (%s, %s, %s)
                            """, (column_id, rule_type_id, '{}'))
                
                conn.commit()
                cursor.close()

                session['validations'] = validations
                session['current_step'] = 3 if action == 'review' else 2
                
                logging.info(f"Step 2 completed: action={action}, validations={validations}")
                return jsonify({'success': True, 'message': 'Step 2 completed successfully'})
            except Exception as e:
                logging.error(f"Error in step 2: {str(e)}")
                return jsonify({'success': False, 'message': str(e)}), 500
        
        # GET request
        selected_headers = session.get('selected_headers', [])
        return jsonify({'selected_headers': selected_headers})

    # Rules endpoint
    @app.route('/rules', methods=['GET'])
    @app.route('/api/rules', methods=['GET'])
    def get_rules():
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            
            cursor.execute("""
                SELECT rule_type_id AS rule_id, rule_name, description, parameters, is_custom, 
                       column_name, template_id, source_format, target_format, data_type, is_active
                FROM validation_rule_types
            """)
            rules = cursor.fetchall()
            cursor.close()
            
            logging.info(f"Returning {len(rules)} rules from getRules endpoint")
            return jsonify({'success': True, 'rules': rules})
        except mysql.connector.Error as e:
            logging.error(f"Database error fetching rules: {str(e)}")
            return jsonify({'success': False, 'message': str(e)}), 500
        except Exception as e:
            logging.error(f"Unexpected error fetching rules: {str(e)}")
            return jsonify({'success': False, 'message': str(e)}), 500

    # Template details endpoint
    @app.route('/template/<int:template_id>/<sheet_name>', methods=['GET'])
    @app.route('/api/template/<int:template_id>/<sheet_name>', methods=['GET'])
    def get_template(template_id, sheet_name):
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /template: session missing")
            return jsonify({'error': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("""
                SELECT template_name, sheet_name, headers
                FROM excel_templates
                WHERE template_id = %s AND user_id = %s AND status = 'ACTIVE'
            """, (template_id, session['user_id']))
            template_record = cursor.fetchone()
            
            if not template_record:
                logging.error(f"Template not found for template_id: {template_id}, user_id: {session['user_id']}")
                cursor.close()
                return jsonify({'error': 'Template not found'}), 404

            headers = json.loads(template_record['headers']) if template_record['headers'] else []
            stored_sheet_name = template_record['sheet_name'] or sheet_name
            file_path = os.path.join(app.config['UPLOAD_FOLDER'], template_record['template_name'])
            
            cursor.execute("""
                SELECT COUNT(*) as rule_count
                FROM template_columns tc
                JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                WHERE tc.template_id = %s AND tc.is_selected = TRUE
            """, (template_id,))
            rule_count = cursor.fetchone()['rule_count']
            has_existing_rules = rule_count > 0
            
            cursor.close()
            
            return jsonify({
                'success': True,
                'sheets': {stored_sheet_name: {'headers': headers}},
                'file_name': template_record['template_name'],
                'file_path': file_path,
                'sheet_name': stored_sheet_name,
                'has_existing_rules': has_existing_rules
            })
        except mysql.connector.Error as e:
            logging.error(f"Database error in get_template: {str(e)}")
            return jsonify({'error': f'Database error: {str(e)}'}), 500
        except Exception as e:
            logging.error(f"Unexpected error in get_template: {str(e)}")
            return jsonify({'error': f'Unexpected error: {str(e)}'}), 500

    # Debug route to show all registered routes
    @app.route('/debug/routes', methods=['GET'])
    def list_routes():
        routes = []
        for rule in app.url_map.iter_rules():
            routes.append({
                'endpoint': rule.endpoint,
                'methods': list(rule.methods),
                'rule': rule.rule
            })
        return jsonify(routes)

    # 404 handler to debug missing routes
    @app.errorhandler(404)
    def not_found_handler(error):
        logging.error(f"404 Error: {request.method} {request.url} not found")
        logging.error(f"Available routes: {[rule.rule for rule in app.url_map.iter_rules()]}")
        return jsonify({
            'error': 'Endpoint not found', 
            'method': request.method,
            'url': request.url,
            'path': request.path
        }), 404

    return app

def initialize_app_data():
    """Initialize database and create default data"""
    try:
        logging.info("Initializing database schema...")
        init_db()
        
        logging.info("Creating admin user...")
        create_admin_user()
        
        logging.info("Creating default validation rules...")
        create_default_validation_rules()
        
        logging.info("Application initialization completed successfully")
    except Exception as e:
        logging.error(f"Failed to initialize application: {e}")
        raise

DB_CONFIG = {
    'host': os.getenv('MYSQL_HOST', 'localhost'),
    'user': os.getenv('MYSQL_USER', 'root'),
    'password': os.getenv('MYSQL_PASSWORD', 'Keansa@2024'),
    'database': os.getenv('MYSQL_DATABASE', 'data_validation_2'),
}

def get_db_connection():
    if 'db' not in g:
        try:
            conn = mysql.connector.connect(
                host=DB_CONFIG['host'],
                user=DB_CONFIG['user'],
                password=DB_CONFIG['password']
            )
            cursor = conn.cursor()
            cursor.execute(f"CREATE DATABASE IF NOT EXISTS {DB_CONFIG['database']}")
            cursor.close()
            conn.close()
            g.db = mysql.connector.connect(**DB_CONFIG)
            logging.info("Database connection established successfully")
        except mysql.connector.Error as err:
            if err.errno == errorcode.ER_ACCESS_DENIED_ERROR:
                logging.error("Database connection failed: Access denied for user - check username/password")
            elif err.errno == errorcode.ER_BAD_DB_ERROR:
                logging.error("Database connection failed: Database does not exist")
            else:
                logging.error(f"Database connection failed: {err}")
            raise Exception(f"Failed to connect to database: {str(err)}")
    return g.db

def close_db(error):
    db = g.pop('db', None)
    if db is not None:
        db.close()

def init_db():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        tables = [
            """
            CREATE TABLE IF NOT EXISTS login_details (
                id INT AUTO_INCREMENT PRIMARY KEY,
                first_name VARCHAR(100),
                last_name VARCHAR(100),
                email VARCHAR(255) UNIQUE,
                mobile VARCHAR(10),
                password VARCHAR(255)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS excel_templates (
                template_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_name VARCHAR(255) NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
                user_id INT NOT NULL,
                sheet_name VARCHAR(255),
                headers JSON,
                status ENUM('ACTIVE', 'INACTIVE') DEFAULT 'ACTIVE',
                is_corrected BOOLEAN DEFAULT FALSE,
                remote_file_path VARCHAR(512),
                FOREIGN KEY (user_id) REFERENCES login_details(id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS template_columns (
                column_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_id BIGINT NOT NULL,
                column_name VARCHAR(255) NOT NULL,
                column_position INT NOT NULL,
                is_validation_enabled BOOLEAN DEFAULT FALSE,
                is_selected BOOLEAN DEFAULT FALSE,
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE,
                UNIQUE (template_id, column_name)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_rule_types (
                rule_type_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                rule_name VARCHAR(255) NOT NULL,
                description TEXT,
                parameters TEXT,
                is_active BOOLEAN DEFAULT TRUE,
                is_custom BOOLEAN DEFAULT FALSE,
                column_name VARCHAR(255),
                template_id BIGINT,
                data_type VARCHAR(50),
                source_format VARCHAR(50),
                target_format VARCHAR(50),
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS column_validation_rules (
                column_validation_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                column_id BIGINT NOT NULL,
                rule_type_id BIGINT NOT NULL,
                rule_config JSON,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (column_id) REFERENCES template_columns(column_id) ON DELETE CASCADE,
                FOREIGN KEY (rule_type_id) REFERENCES validation_rule_types(rule_type_id) ON DELETE RESTRICT,
                UNIQUE (column_id, rule_type_id)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_history (
                history_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_id BIGINT NOT NULL,
                template_name VARCHAR(255) NOT NULL,
                error_count INT NOT NULL,
                corrected_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                corrected_file_path VARCHAR(512) NOT NULL,
                user_id INT NOT NULL,
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE,
                FOREIGN KEY (user_id) REFERENCES login_details(id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_corrections (
                correction_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                history_id BIGINT NOT NULL,
                row_index INT NOT NULL,
                column_name VARCHAR(255) NOT NULL,
                original_value TEXT,
                corrected_value TEXT,
                rule_failed VARCHAR(255) DEFAULT NULL,
                FOREIGN KEY (history_id) REFERENCES validation_history(history_id) ON DELETE CASCADE
            )
            """
        ]
        for table_sql in tables:
            cursor.execute(table_sql)
        
        # Add missing columns if they don't exist
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'source_format'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN source_format VARCHAR(50)")
            logging.info("Added source_format column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'target_format'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN target_format VARCHAR(50)")
            logging.info("Added target_format column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'data_type'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN data_type VARCHAR(50)")
            logging.info("Added data_type column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM excel_templates LIKE 'remote_file_path'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE excel_templates ADD COLUMN remote_file_path VARCHAR(512)")
            logging.info("Added remote_file_path column to excel_templates table")
            
        cursor.execute("SHOW COLUMNS FROM template_columns LIKE 'is_selected'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE template_columns ADD COLUMN is_selected BOOLEAN DEFAULT FALSE")
            logging.info("Added is_selected column to template_columns table")
            
        conn.commit()
        cursor.close()
        logging.info("Database tables initialized")
    except Exception as e:
        logging.error(f"Failed to initialize database: {str(e)}")
        raise

def create_admin_user():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        admin_password = bcrypt.hashpw('admin'.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
        cursor.execute("""
            INSERT IGNORE INTO login_details (first_name, last_name, email, mobile, password)
            VALUES (%s, %s, %s, %s, %s)
        """, ('Admin', 'User', 'admin@example.com', '1234567890', admin_password))
        conn.commit()
        cursor.close()
        logging.info("Admin user created or already exists")
    except Exception as e:
        logging.error(f"Failed to create admin user: {str(e)}")
        raise

def create_default_validation_rules():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        default_rules = [
            ("Required", "Ensures the field is not null", '{"allow_null": false}', None, None, None),
            ("Int", "Validates integer format", '{"format": "integer"}', None, None, "Int"),
            ("Float", "Validates number format (integer or decimal)", '{"format": "float"}', None, None, "Float"),
            ("Text", "Allows text with quotes and parentheses", '{"allow_special": false}', None, None, "Text"),
            ("Email", "Validates email format", '{"regex": "^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\\\.[a-zA-Z0-9-.]+$"}', None, None, "Email"),
            ("Date(DD-MM-YYYY)", "Validates date format DD-MM-YYYY", '{"format": "%d-%m-%Y"}', "DD-MM-YYYY", None, "Date"),
            ("Boolean", "Validates boolean format (true/false or 0/1)", '{"format": "boolean"}', None, None, "Boolean"),
            ("Alphanumeric", "Validates alphanumeric format", '{"format": "alphanumeric"}', None, None, "Alphanumeric")
        ]
        cursor.executemany("""
            INSERT IGNORE INTO validation_rule_types (rule_name, description, parameters, is_custom, source_format, target_format, data_type)
            VALUES (%s, %s, %s, %s, %s, %s, %s)
        """, [(name, desc, params, False, source, target, dtype) for name, desc, params, source, target, dtype in default_rules])
        conn.commit()
        cursor.close()
        logging.info("Default validation rules ensured successfully")
    except Exception as e:
        logging.error(f"Failed to ensure default validation rules: {str(e)}")
        raise

if __name__ == '__main__':
    try:
        # Create the application using factory pattern
        app = create_app()
        
        # Initialize database and default data within app context
        with app.app_context():
            initialize_app_data()
        
        # Get port from environment or use default
        port = int(os.getenv('PORT', 5000))
        
        # Start the application server
        logging.info("Starting Flask server...")
        app.run(debug=True, host='0.0.0.0', port=port)
        
    except Exception as e:
        logging.error(f"Failed to start application: {e}")
        raise
).all():
        return "Email"
    
    # Date pattern detection
    try:
        pd.to_datetime(non_null, format="%d-%m-%Y")
        return "Date"
    except Exception:
        try:
            pd.to_datetime(non_null, format="%Y-%m-%d")
            return "Date"
        except Exception:
            pass
    
    # Boolean detection
    if non_null.str.lower().isin(['true', 'false', '0', '1']).all():
        return "Boolean"
    
    # Numeric detection
    if non_null.str.match(r'^-?\d+

def create_app():
    """Application factory pattern for different environments"""
    # Set the path to the frontend dist folder
    current_dir = os.path.dirname(os.path.abspath(__file__))
    frontend_dist_path = os.path.join(current_dir, '..', '..', 'Keansa-Ai-Suite2025may-frontend11', 'dist')
    frontend_dist_path = os.path.abspath(frontend_dist_path)
    
    # Create Flask application instance
    app = Flask(__name__, static_folder=frontend_dist_path, static_url_path='')
    CORS(app, supports_credentials=True, origins=["http://localhost:3000", "http://localhost:8080", "http://localhost:5000", "*"])

    app.secret_key = os.urandom(24).hex()
    app.config['SESSION_TYPE'] = 'filesystem'
    app.config['SESSION_FILE_DIR'] = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'sessions')
    app.config['SESSION_COOKIE_SAMESITE'] = 'Lax'
    app.config['SESSION_COOKIE_HTTPONLY'] = True
    app.config['SESSION_COOKIE_SECURE'] = False
    app.config['PERMANENT_SESSION_LIFETIME'] = 86400  # 24 hours
    app.config['UPLOAD_FOLDER'] = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'uploads')
    Session(app)

    # Ensure directories exist
    try:
        os.makedirs(app.config['UPLOAD_FOLDER'], exist_ok=True)
        os.makedirs(app.config['SESSION_FILE_DIR'], exist_ok=True)
    except OSError as e:
        logging.error(f"Failed to create directories: {e}")

    # Register cleanup handlers
    app.teardown_appcontext(close_db)
    
    # Register all routes directly in create_app
    
    # Static file serving for React frontend
    @app.route('/', defaults={'path': ''})
    @app.route('/<path:path>')
    def serve(path):
        if path and os.path.exists(os.path.join(app.static_folder, path)):
            return app.send_static_file(path)
        return app.send_static_file('index.html')

    # Health check endpoint
    @app.route('/health', methods=['GET'])
    def health_check():
        return jsonify({
            'status': 'healthy',
            'timestamp': datetime.now().isoformat(),
            'version': '2.0.0'
        })

    # Authentication endpoint - both old and new paths
    @app.route('/authenticate', methods=['POST'])
    @app.route('/api/auth/authenticate', methods=['POST'])
    def authenticate():
        try:
            email = request.form.get('username') or request.form.get('email')
            password = request.form.get('password')
            logging.debug(f"Login attempt: email={email}, password={'*' * len(password) if password else 'None'}")
            
            if not email or not password:
                logging.warning(f"Login failed: Email or password missing")
                return jsonify({'success': False, 'message': 'Email and password are required'}), 400

            # Check for admin login
            if email == "admin" and password == "admin":
                session['loggedin'] = True
                session['user_email'] = "admin@example.com"
                session['user_id'] = 1
                session.permanent = True
                logging.info(f"Admin login successful. Session: {dict(session)}")
                return jsonify({'success': True, 'message': 'Login successful', 'user': {'email': 'admin@example.com', 'id': 1}}), 200

            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("SELECT * FROM login_details WHERE LOWER(email) = LOWER(%s)", (email.lower(),))
            account = cursor.fetchone()
            cursor.close()
            
            if account:
                if bcrypt.checkpw(password.encode('utf-8'), account['password'].encode('utf-8')):
                    session['loggedin'] = True
                    session['user_email'] = account['email']
                    session['user_id'] = account['id']
                    session.permanent = True
                    logging.info(f"User {email} logged in successfully. Session: {dict(session)}")
                    return jsonify({
                        'success': True,
                        'message': 'Login successful',
                        'user': {'email': account['email'], 'id': account['id']}
                    }), 200
                else:
                    logging.warning(f"Invalid password for {email}")
                    return jsonify({'success': False, 'message': 'Invalid credentials'}), 401
            else:
                logging.warning(f"Email {email} not found")
                return jsonify({'success': False, 'message': 'Invalid credentials'}), 401
        except Exception as e:
            logging.error(f"Unexpected error during login: {str(e)}")
            return jsonify({'success': False, 'message': f'Unexpected error: {str(e)}'}), 500

    @app.route('/check-auth', methods=['GET'])
    @app.route('/api/auth/check-auth', methods=['GET'])
    def check_auth():
        try:
            logging.debug(f"Checking auth with session: {dict(session)}")
            if 'loggedin' in session and 'user_id' in session:
                conn = get_db_connection()
                cursor = conn.cursor(dictionary=True)
                cursor.execute("SELECT email, first_name FROM login_details WHERE id = %s", (session['user_id'],))
                user = cursor.fetchone()
                cursor.close()
                if user:
                    logging.info(f"User {session.get('user_email')} is authenticated")
                    return jsonify({
                        'success': True,
                        'user': {
                            'email': user['email'],
                            'id': session['user_id'],
                            'first_name': user['first_name']
                        }
                    })
                else:
                    logging.warning("User not found in database")  
                    session.clear()
                    return jsonify({'success': False, 'message': 'User not found'}), 401
            logging.warning("User not authenticated")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        except Exception as e:
            logging.error(f"Error in check-auth endpoint: {str(e)}")
            return jsonify({'success': False, 'message': f'Server error: {str(e)}'}), 500

    @app.route('/register', methods=['POST'])
    @app.route('/api/auth/register', methods=['POST'])
    def register():
        first_name = request.form.get('first_name')
        last_name = request.form.get('last_name')
        email = request.form.get('email')
        mobile = request.form.get('mobile')
        password = request.form.get('password')
        confirm_password = request.form.get('confirm_password')

        if not all([first_name, last_name, email, mobile, password, confirm_password]):
            return jsonify({'success': False, 'message': 'All fields are required'}), 400
        if password != confirm_password:
            return jsonify({'success': False, 'message': 'Passwords do not match'}), 400

        hashed_password = bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
        try:
            conn = get_db_connection()
            cursor = conn.cursor()
            cursor.execute("""
                INSERT INTO login_details (first_name, last_name, email, mobile, password)
                VALUES (%s, %s, %s, %s, %s)
            """, (first_name, last_name, email, mobile, hashed_password))
            user_id = cursor.lastrowid
            conn.commit()
            cursor.close()
            session['loggedin'] = True
            session['user_email'] = email
            session['user_id'] = user_id
            return jsonify({
                'success': True,
                'message': 'Registration successful',
                'user': {'email': email, 'id': user_id}
            }), 200
        except mysql.connector.Error as e:
            logging.error(f"Database error during registration: {str(e)}")
            return jsonify({'success': False, 'message': f'Registration error: {str(e)}'}), 500

    @app.route('/logout', methods=['POST'])
    @app.route('/api/auth/logout', methods=['POST'])
    def logout():
        logging.info(f"User {session.get('user_email', 'unknown')} logged out")
        session.clear()
        return jsonify({'success': True, 'message': 'Logged out successfully'})

    # Template routes
    @app.route('/templates', methods=['GET'])
    @app.route('/api/templates', methods=['GET'])
    def get_templates():
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /templates: session missing")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("""
                SELECT template_id, template_name, created_at, status
                FROM excel_templates
                WHERE user_id = %s AND status = 'ACTIVE'
                ORDER BY created_at DESC
                LIMIT 100
            """, (session['user_id'],))
            templates = cursor.fetchall()
            cursor.close()
            logging.info(f"Fetched {len(templates)} templates for user {session['user_id']}")
            return jsonify({'success': True, 'templates': templates})
        except mysql.connector.Error as e:
            logging.error(f'Error fetching templates: {str(e)}')
            return jsonify({'success': False, 'message': f'Error fetching templates: {str(e)}'}), 500
        except Exception as e:
            logging.error(f'Unexpected error fetching templates: {str(e)}')
            return jsonify({'success': False, 'message': f'Unexpected error: {str(e)}'}), 500

    # Rule Configuration routes
    @app.route('/rule-configurations', methods=['GET'])
    @app.route('/api/validation/rule-configurations', methods=['GET'])
    def get_rule_configurations():
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning(f"Unauthorized access to /rule-configurations: session={dict(session)}")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            user_id = session['user_id']
            logging.debug(f"Fetching rule configurations for user_id: {user_id}")

            # Main query to fetch templates with configured rules
            cursor.execute("""
                SELECT 
                    t.template_id, 
                    t.template_name, 
                    t.created_at, 
                    COUNT(cvr.column_validation_id) as rule_count
                FROM excel_templates t
                LEFT JOIN template_columns tc ON t.template_id = tc.template_id
                LEFT JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                WHERE t.user_id = %s AND t.status = 'ACTIVE' AND t.is_corrected = FALSE
                GROUP BY t.template_id, t.template_name, t.created_at
                HAVING rule_count > 0
                ORDER BY t.created_at DESC
                LIMIT 100
            """, (user_id,))
            templates = cursor.fetchall()
            logging.debug(f"Fetched rule-configured templates: {templates}")

            cursor.close()

            if not templates:
                logging.info(f"No templates with rules found for user_id: {user_id}")
            else:
                logging.info(f"Found {len(templates)} templates with rules for user_id: {user_id}")

            return jsonify({'success': True, 'templates': templates})
        except mysql.connector.Error as e:
            logging.error(f"Database error fetching rule configurations: {str(e)}")
            return jsonify({'success': False, 'message': f"Database error: {str(e)}"}), 500
        except Exception as e:
            logging.error(f"Unexpected error fetching rule configurations: {str(e)}")
            return jsonify({'success': False, 'message': f"Unexpected error: {str(e)}"}), 500

    # File upload route
    @app.route('/upload', methods=['POST'])
    @app.route('/api/templates/upload', methods=['POST'])
    @app.route('/api/upload', methods=['POST'])  # Additional common path
    def upload():
        logging.info(f"Upload endpoint called: {request.endpoint}, method: {request.method}")
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /upload: session missing")
            return jsonify({'error': 'Not logged in'}), 401
        if 'file' not in request.files:
            logging.warning("No file provided in upload request")
            return jsonify({'error': 'No file uploaded'}), 400
        file = request.files['file']
        if file.filename == '':
            logging.warning("No file selected in upload request")
            return jsonify({'error': 'No file selected'}), 400
        
        file_path = os.path.join(app.config['UPLOAD_FOLDER'], file.filename)
        try:
            file.save(file_path)
            logging.info(f"File saved: {file_path}")
        except Exception as e:
            logging.error(f"Failed to save file {file.filename}: {str(e)}")
            return jsonify({'error': f'Failed to save file: {str(e)}'}), 500

        try:
            # Read the file to get sheets and headers
            if file.filename.endswith('.xlsx') or file.filename.endswith('.xls'):
                xl = pd.ExcelFile(file_path)
                sheets = {sheet_name: pd.read_excel(file_path, sheet_name=sheet_name, header=None) 
                         for sheet_name in xl.sheet_names}
            elif file.filename.endswith(('.txt', '.csv', '.dat')):
                df = pd.read_csv(file_path, header=None, encoding='utf-8')
                sheets = {'Sheet1': df}
            else:
                logging.error("Unsupported file type")
                return jsonify({'error': 'Unsupported file type'}), 400
            
            logging.debug(f"Sheets extracted: {list(sheets.keys())}")
        except Exception as e:
            logging.error(f"Failed to read file {file_path}: {str(e)}")
            return jsonify({'error': f'Failed to read file: {str(e)}'}), 400

        try:
            sheet_names = list(sheets.keys())
            if not sheet_names:
                logging.error("No sheets found in the file")
                return jsonify({'error': 'No sheets found in the file'}), 400
            sheet_name = sheet_names[0]
            df = sheets[sheet_name]
            
            # Find header row
            header_row = 0
            for i in range(min(len(df), 10)):
                row = df.iloc[i].dropna()
                if not row.empty and all(isinstance(x, str) for x in row if pd.notna(x)):
                    header_row = i
                    break
                    
            headers = df.iloc[header_row].tolist()
            logging.debug(f"Headers extracted: {headers}")
            
            if not headers or all(not h for h in headers):
                logging.error("No valid headers found in file")
                return jsonify({'error': 'No valid headers found in the file'}), 400
        except Exception as e:
            logging.error(f"Error processing file {file.filename}: {str(e)}")
            return jsonify({'error': f'Error processing file: {str(e)}'}), 400

        # Clear existing session data
        for key in ['df', 'header_row', 'headers', 'sheet_name', 'current_step', 'selected_headers', 'validations', 'error_cell_locations', 'data_rows', 'corrected_file_path']:
            session.pop(key, None)

        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)

            # Check if template exists
            cursor.execute("""
                SELECT template_id, headers, sheet_name
                FROM excel_templates
                WHERE template_name = %s AND user_id = %s AND status = 'ACTIVE'
                ORDER BY created_at DESC
            """, (file.filename, session['user_id']))
            existing_templates = cursor.fetchall()
            logging.info(f"Found {len(existing_templates)} existing templates with name {file.filename}")

            template_id = None
            has_existing_rules = False
            validations = {}
            selected_headers = []

            # Check for matching template
            matching_template = None
            for template in existing_templates:
                stored_headers = json.loads(template['headers']) if template['headers'] else []
                stored_sheet_name = template['sheet_name']
                if stored_headers == headers and stored_sheet_name == sheet_name:
                    matching_template = template
                    break

            if matching_template:
                template_id = matching_template['template_id']
                # Check for existing rules
                cursor.execute("""
                    SELECT tc.column_name, vrt.rule_name
                    FROM template_columns tc
                    JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                    JOIN validation_rule_types vrt ON cvr.rule_type_id = vrt.rule_type_id
                    WHERE tc.template_id = %s AND tc.is_selected = TRUE
                """, (template_id,))
                rules_data = cursor.fetchall()
                for row in rules_data:
                    column_name = row['column_name']
                    rule_name = row['rule_name']
                    if column_name not in validations:
                        validations[column_name] = []
                    validations[column_name].append(rule_name)
                    if column_name not in selected_headers:
                        selected_headers.append(column_name)
                has_existing_rules = len(validations) > 0
            else:
                # New template
                cursor.execute("""
                    INSERT INTO excel_templates (template_name, user_id, sheet_name, headers, is_corrected)
                    VALUES (%s, %s, %s, %s, %s)
                """, (file.filename, session['user_id'], sheet_name, json.dumps(headers), False))
                template_id = cursor.lastrowid
                column_data = [(template_id, header, i + 1, False) for i, header in enumerate(headers)]
                cursor.executemany("""
                    INSERT INTO template_columns (template_id, column_name, column_position, is_selected)
                    VALUES (%s, %s, %s, %s)
                """, column_data)

            conn.commit()
            cursor.close()

            # Store session data
            session['file_path'] = file_path
            session['template_id'] = template_id
            session['df'] = df.to_json()
            session['header_row'] = header_row
            session['headers'] = headers
            session['sheet_name'] = sheet_name
            session['current_step'] = 1 if not has_existing_rules else 3
            session['validations'] = validations
            session['selected_headers'] = selected_headers
            session['has_existing_rules'] = has_existing_rules

            logging.info(f"Upload processed: template_id={template_id}, filename={file.filename}, has_existing_rules={has_existing_rules}")

            return jsonify({
                'success': True,
                'sheets': {sheet_name: {'headers': headers}},
                'file_name': file.filename,
                'template_id': template_id,
                'has_existing_rules': has_existing_rules,
                'sheet_name': sheet_name,
                'skip_to_step_3': has_existing_rules
            })
        except mysql.connector.Error as e:
            logging.error(f'Error saving template: {str(e)}')
            return jsonify({'error': f'Error saving template: {str(e)}'}), 500
        except Exception as e:
            logging.error(f'Unexpected error saving template: {str(e)}')
            return jsonify({'error': f'Unexpected error: {str(e)}'}), 500

    # Multi-step workflow endpoints
    @app.route('/step/1', methods=['GET', 'POST'])
    @app.route('/api/step/1', methods=['GET', 'POST'])
    def step_one():
        if 'loggedin' not in session:
            return jsonify({'error': 'Not logged in'}), 401
        
        if request.method == 'POST':
            try:
                headers = request.form.getlist('headers')
                new_header_row = request.form.get('new_header_row')
                logging.debug(f"Step 1 submitted: headers={headers}, new_header_row={new_header_row}")
                
                if not headers:
                    logging.error("No headers provided in step 1")
                    return jsonify({'success': False, 'message': 'No headers provided'}), 400
                    
                if 'template_id' not in session:
                    logging.error("Session missing template_id")
                    return jsonify({'success': False, 'message': 'Session data missing'}), 400

                template_id = session['template_id']
                
                # Get the dataframe from session for auto-detection
                df_json = session.get('df')
                if df_json:
                    df = pd.read_json(StringIO(df_json))
                    session_headers = session.get('headers', [])
                    df.columns = session_headers
                    header_row = session.get('header_row', 0)
                    df = df.iloc[header_row + 1:].reset_index(drop=True)
                    
                    # Auto-detect rules for selected headers
                    validations = assign_default_rules_to_columns(df, headers)
                    session['validations'] = validations
                    logging.debug(f"Auto-assigned rules: {validations}")
                else:
                    validations = {}

                session['selected_headers'] = headers
                session['current_step'] = 2

                # Mark selected headers in the database
                conn = get_db_connection()
                cursor = conn.cursor()
                cursor.execute("UPDATE template_columns SET is_selected = FALSE WHERE template_id = %s", (template_id,))
                for header in headers:
                    cursor.execute("""
                        UPDATE template_columns
                        SET is_selected = TRUE
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    
                    # Get column_id and add auto-detected rules
                    cursor.execute("""
                        SELECT column_id FROM template_columns
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    result = cursor.fetchone()
                    if result:
                        column_id = result[0]
                        for rule_name in validations.get(header, []):
                            cursor.execute("""
                                SELECT rule_type_id FROM validation_rule_types
                                WHERE rule_name = %s AND is_custom = FALSE
                            """, (rule_name,))
                            rule_result = cursor.fetchone()
                            if rule_result:
                                rule_type_id = rule_result[0]
                                cursor.execute("""
                                    INSERT IGNORE INTO column_validation_rules (column_id, rule_type_id, rule_config)
                                    VALUES (%s, %s, %s)
                                """, (column_id, rule_type_id, '{}'))
                
                conn.commit()
                cursor.close()

                logging.info(f"Step 1 completed: headers={headers}, auto-assigned rules={validations}")
                return jsonify({'success': True, 'headers': headers, 'validations': validations})
            except Exception as e:
                logging.error(f"Error in step 1: {str(e)}")
                return jsonify({'success': False, 'message': str(e)}), 500
        
        # GET request - return current headers
        headers = session.get('headers', [])
        return jsonify({'headers': headers})

    @app.route('/step/2', methods=['GET', 'POST'])
    @app.route('/api/step/2', methods=['GET', 'POST'])
    def step_two():
        if 'loggedin' not in session:
            return jsonify({'error': 'Not logged in'}), 401
            
        if request.method == 'POST':
            try:
                action = request.form.get('action', 'save')
                validations = {}
                for key, values in request.form.lists():
                    if key.startswith('validations_'):
                        header = key.replace('validations_', '')
                        validations[header] = values
                        
                logging.debug(f"Step 2 submitted: action={action}, validations={validations}")
                
                template_id = session.get('template_id')
                if not template_id:
                    return jsonify({'success': False, 'message': 'Session data missing'}), 400

                # Save validations to database
                conn = get_db_connection()
                cursor = conn.cursor()
                
                # Clear existing rules
                cursor.execute("""
                    DELETE FROM column_validation_rules
                    WHERE column_id IN (
                        SELECT column_id FROM template_columns WHERE template_id = %s
                    )
                """, (template_id,))
                
                # Add new rules
                for header, rules in validations.items():
                    cursor.execute("""
                        SELECT column_id FROM template_columns
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    result = cursor.fetchone()
                    if not result:
                        continue
                    column_id = result[0]
                    
                    for rule_name in rules:
                        cursor.execute("""
                            SELECT rule_type_id FROM validation_rule_types
                            WHERE rule_name = %s
                        """, (rule_name,))
                        result = cursor.fetchone()
                        if result:
                            rule_type_id = result[0]
                            cursor.execute("""
                                INSERT IGNORE INTO column_validation_rules (column_id, rule_type_id, rule_config)
                                VALUES (%s, %s, %s)
                            """, (column_id, rule_type_id, '{}'))
                
                conn.commit()
                cursor.close()

                session['validations'] = validations
                session['current_step'] = 3 if action == 'review' else 2
                
                logging.info(f"Step 2 completed: action={action}, validations={validations}")
                return jsonify({'success': True, 'message': 'Step 2 completed successfully'})
            except Exception as e:
                logging.error(f"Error in step 2: {str(e)}")
                return jsonify({'success': False, 'message': str(e)}), 500
        
        # GET request
        selected_headers = session.get('selected_headers', [])
        return jsonify({'selected_headers': selected_headers})

    # Rules endpoint
    @app.route('/rules', methods=['GET'])
    @app.route('/api/rules', methods=['GET'])
    def get_rules():
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            
            cursor.execute("""
                SELECT rule_type_id AS rule_id, rule_name, description, parameters, is_custom, 
                       column_name, template_id, source_format, target_format, data_type, is_active
                FROM validation_rule_types
            """)
            rules = cursor.fetchall()
            cursor.close()
            
            logging.info(f"Returning {len(rules)} rules from getRules endpoint")
            return jsonify({'success': True, 'rules': rules})
        except mysql.connector.Error as e:
            logging.error(f"Database error fetching rules: {str(e)}")
            return jsonify({'success': False, 'message': str(e)}), 500
        except Exception as e:
            logging.error(f"Unexpected error fetching rules: {str(e)}")
            return jsonify({'success': False, 'message': str(e)}), 500

    # Template details endpoint
    @app.route('/template/<int:template_id>/<sheet_name>', methods=['GET'])
    @app.route('/api/template/<int:template_id>/<sheet_name>', methods=['GET'])
    def get_template(template_id, sheet_name):
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /template: session missing")
            return jsonify({'error': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("""
                SELECT template_name, sheet_name, headers
                FROM excel_templates
                WHERE template_id = %s AND user_id = %s AND status = 'ACTIVE'
            """, (template_id, session['user_id']))
            template_record = cursor.fetchone()
            
            if not template_record:
                logging.error(f"Template not found for template_id: {template_id}, user_id: {session['user_id']}")
                cursor.close()
                return jsonify({'error': 'Template not found'}), 404

            headers = json.loads(template_record['headers']) if template_record['headers'] else []
            stored_sheet_name = template_record['sheet_name'] or sheet_name
            file_path = os.path.join(app.config['UPLOAD_FOLDER'], template_record['template_name'])
            
            cursor.execute("""
                SELECT COUNT(*) as rule_count
                FROM template_columns tc
                JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                WHERE tc.template_id = %s AND tc.is_selected = TRUE
            """, (template_id,))
            rule_count = cursor.fetchone()['rule_count']
            has_existing_rules = rule_count > 0
            
            cursor.close()
            
            return jsonify({
                'success': True,
                'sheets': {stored_sheet_name: {'headers': headers}},
                'file_name': template_record['template_name'],
                'file_path': file_path,
                'sheet_name': stored_sheet_name,
                'has_existing_rules': has_existing_rules
            })
        except mysql.connector.Error as e:
            logging.error(f"Database error in get_template: {str(e)}")
            return jsonify({'error': f'Database error: {str(e)}'}), 500
        except Exception as e:
            logging.error(f"Unexpected error in get_template: {str(e)}")
            return jsonify({'error': f'Unexpected error: {str(e)}'}), 500

    # Debug route to show all registered routes
    @app.route('/debug/routes', methods=['GET'])
    def list_routes():
        routes = []
        for rule in app.url_map.iter_rules():
            routes.append({
                'endpoint': rule.endpoint,
                'methods': list(rule.methods),
                'rule': rule.rule
            })
        return jsonify(routes)

    # 404 handler to debug missing routes
    @app.errorhandler(404)
    def not_found_handler(error):
        logging.error(f"404 Error: {request.method} {request.url} not found")
        logging.error(f"Available routes: {[rule.rule for rule in app.url_map.iter_rules()]}")
        return jsonify({
            'error': 'Endpoint not found', 
            'method': request.method,
            'url': request.url,
            'path': request.path
        }), 404

    return app

def initialize_app_data():
    """Initialize database and create default data"""
    try:
        logging.info("Initializing database schema...")
        init_db()
        
        logging.info("Creating admin user...")
        create_admin_user()
        
        logging.info("Creating default validation rules...")
        create_default_validation_rules()
        
        logging.info("Application initialization completed successfully")
    except Exception as e:
        logging.error(f"Failed to initialize application: {e}")
        raise

DB_CONFIG = {
    'host': os.getenv('MYSQL_HOST', 'localhost'),
    'user': os.getenv('MYSQL_USER', 'root'),
    'password': os.getenv('MYSQL_PASSWORD', 'Keansa@2024'),
    'database': os.getenv('MYSQL_DATABASE', 'data_validation_2'),
}

def get_db_connection():
    if 'db' not in g:
        try:
            conn = mysql.connector.connect(
                host=DB_CONFIG['host'],
                user=DB_CONFIG['user'],
                password=DB_CONFIG['password']
            )
            cursor = conn.cursor()
            cursor.execute(f"CREATE DATABASE IF NOT EXISTS {DB_CONFIG['database']}")
            cursor.close()
            conn.close()
            g.db = mysql.connector.connect(**DB_CONFIG)
            logging.info("Database connection established successfully")
        except mysql.connector.Error as err:
            if err.errno == errorcode.ER_ACCESS_DENIED_ERROR:
                logging.error("Database connection failed: Access denied for user - check username/password")
            elif err.errno == errorcode.ER_BAD_DB_ERROR:
                logging.error("Database connection failed: Database does not exist")
            else:
                logging.error(f"Database connection failed: {err}")
            raise Exception(f"Failed to connect to database: {str(err)}")
    return g.db

def close_db(error):
    db = g.pop('db', None)
    if db is not None:
        db.close()

def init_db():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        tables = [
            """
            CREATE TABLE IF NOT EXISTS login_details (
                id INT AUTO_INCREMENT PRIMARY KEY,
                first_name VARCHAR(100),
                last_name VARCHAR(100),
                email VARCHAR(255) UNIQUE,
                mobile VARCHAR(10),
                password VARCHAR(255)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS excel_templates (
                template_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_name VARCHAR(255) NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
                user_id INT NOT NULL,
                sheet_name VARCHAR(255),
                headers JSON,
                status ENUM('ACTIVE', 'INACTIVE') DEFAULT 'ACTIVE',
                is_corrected BOOLEAN DEFAULT FALSE,
                remote_file_path VARCHAR(512),
                FOREIGN KEY (user_id) REFERENCES login_details(id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS template_columns (
                column_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_id BIGINT NOT NULL,
                column_name VARCHAR(255) NOT NULL,
                column_position INT NOT NULL,
                is_validation_enabled BOOLEAN DEFAULT FALSE,
                is_selected BOOLEAN DEFAULT FALSE,
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE,
                UNIQUE (template_id, column_name)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_rule_types (
                rule_type_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                rule_name VARCHAR(255) NOT NULL,
                description TEXT,
                parameters TEXT,
                is_active BOOLEAN DEFAULT TRUE,
                is_custom BOOLEAN DEFAULT FALSE,
                column_name VARCHAR(255),
                template_id BIGINT,
                data_type VARCHAR(50),
                source_format VARCHAR(50),
                target_format VARCHAR(50),
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS column_validation_rules (
                column_validation_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                column_id BIGINT NOT NULL,
                rule_type_id BIGINT NOT NULL,
                rule_config JSON,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (column_id) REFERENCES template_columns(column_id) ON DELETE CASCADE,
                FOREIGN KEY (rule_type_id) REFERENCES validation_rule_types(rule_type_id) ON DELETE RESTRICT,
                UNIQUE (column_id, rule_type_id)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_history (
                history_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_id BIGINT NOT NULL,
                template_name VARCHAR(255) NOT NULL,
                error_count INT NOT NULL,
                corrected_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                corrected_file_path VARCHAR(512) NOT NULL,
                user_id INT NOT NULL,
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE,
                FOREIGN KEY (user_id) REFERENCES login_details(id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_corrections (
                correction_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                history_id BIGINT NOT NULL,
                row_index INT NOT NULL,
                column_name VARCHAR(255) NOT NULL,
                original_value TEXT,
                corrected_value TEXT,
                rule_failed VARCHAR(255) DEFAULT NULL,
                FOREIGN KEY (history_id) REFERENCES validation_history(history_id) ON DELETE CASCADE
            )
            """
        ]
        for table_sql in tables:
            cursor.execute(table_sql)
        
        # Add missing columns if they don't exist
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'source_format'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN source_format VARCHAR(50)")
            logging.info("Added source_format column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'target_format'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN target_format VARCHAR(50)")
            logging.info("Added target_format column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'data_type'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN data_type VARCHAR(50)")
            logging.info("Added data_type column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM excel_templates LIKE 'remote_file_path'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE excel_templates ADD COLUMN remote_file_path VARCHAR(512)")
            logging.info("Added remote_file_path column to excel_templates table")
            
        cursor.execute("SHOW COLUMNS FROM template_columns LIKE 'is_selected'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE template_columns ADD COLUMN is_selected BOOLEAN DEFAULT FALSE")
            logging.info("Added is_selected column to template_columns table")
            
        conn.commit()
        cursor.close()
        logging.info("Database tables initialized")
    except Exception as e:
        logging.error(f"Failed to initialize database: {str(e)}")
        raise

def create_admin_user():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        admin_password = bcrypt.hashpw('admin'.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
        cursor.execute("""
            INSERT IGNORE INTO login_details (first_name, last_name, email, mobile, password)
            VALUES (%s, %s, %s, %s, %s)
        """, ('Admin', 'User', 'admin@example.com', '1234567890', admin_password))
        conn.commit()
        cursor.close()
        logging.info("Admin user created or already exists")
    except Exception as e:
        logging.error(f"Failed to create admin user: {str(e)}")
        raise

def create_default_validation_rules():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        default_rules = [
            ("Required", "Ensures the field is not null", '{"allow_null": false}', None, None, None),
            ("Int", "Validates integer format", '{"format": "integer"}', None, None, "Int"),
            ("Float", "Validates number format (integer or decimal)", '{"format": "float"}', None, None, "Float"),
            ("Text", "Allows text with quotes and parentheses", '{"allow_special": false}', None, None, "Text"),
            ("Email", "Validates email format", '{"regex": "^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\\\.[a-zA-Z0-9-.]+$"}', None, None, "Email"),
            ("Date(DD-MM-YYYY)", "Validates date format DD-MM-YYYY", '{"format": "%d-%m-%Y"}', "DD-MM-YYYY", None, "Date"),
            ("Boolean", "Validates boolean format (true/false or 0/1)", '{"format": "boolean"}', None, None, "Boolean"),
            ("Alphanumeric", "Validates alphanumeric format", '{"format": "alphanumeric"}', None, None, "Alphanumeric")
        ]
        cursor.executemany("""
            INSERT IGNORE INTO validation_rule_types (rule_name, description, parameters, is_custom, source_format, target_format, data_type)
            VALUES (%s, %s, %s, %s, %s, %s, %s)
        """, [(name, desc, params, False, source, target, dtype) for name, desc, params, source, target, dtype in default_rules])
        conn.commit()
        cursor.close()
        logging.info("Default validation rules ensured successfully")
    except Exception as e:
        logging.error(f"Failed to ensure default validation rules: {str(e)}")
        raise

if __name__ == '__main__':
    try:
        # Create the application using factory pattern
        app = create_app()
        
        # Initialize database and default data within app context
        with app.app_context():
            initialize_app_data()
        
        # Get port from environment or use default
        port = int(os.getenv('PORT', 5000))
        
        # Start the application server
        logging.info("Starting Flask server...")
        app.run(debug=True, host='0.0.0.0', port=port)
        
    except Exception as e:
        logging.error(f"Failed to start application: {e}")
        raise
).all():
        return "Int"
    
    if non_null.str.match(r'^-?\d+(\.\d+)?

def create_app():
    """Application factory pattern for different environments"""
    # Set the path to the frontend dist folder
    current_dir = os.path.dirname(os.path.abspath(__file__))
    frontend_dist_path = os.path.join(current_dir, '..', '..', 'Keansa-Ai-Suite2025may-frontend11', 'dist')
    frontend_dist_path = os.path.abspath(frontend_dist_path)
    
    # Create Flask application instance
    app = Flask(__name__, static_folder=frontend_dist_path, static_url_path='')
    CORS(app, supports_credentials=True, origins=["http://localhost:3000", "http://localhost:8080", "http://localhost:5000", "*"])

    app.secret_key = os.urandom(24).hex()
    app.config['SESSION_TYPE'] = 'filesystem'
    app.config['SESSION_FILE_DIR'] = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'sessions')
    app.config['SESSION_COOKIE_SAMESITE'] = 'Lax'
    app.config['SESSION_COOKIE_HTTPONLY'] = True
    app.config['SESSION_COOKIE_SECURE'] = False
    app.config['PERMANENT_SESSION_LIFETIME'] = 86400  # 24 hours
    app.config['UPLOAD_FOLDER'] = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'uploads')
    Session(app)

    # Ensure directories exist
    try:
        os.makedirs(app.config['UPLOAD_FOLDER'], exist_ok=True)
        os.makedirs(app.config['SESSION_FILE_DIR'], exist_ok=True)
    except OSError as e:
        logging.error(f"Failed to create directories: {e}")

    # Register cleanup handlers
    app.teardown_appcontext(close_db)
    
    # Register all routes directly in create_app
    
    # Static file serving for React frontend
    @app.route('/', defaults={'path': ''})
    @app.route('/<path:path>')
    def serve(path):
        if path and os.path.exists(os.path.join(app.static_folder, path)):
            return app.send_static_file(path)
        return app.send_static_file('index.html')

    # Health check endpoint
    @app.route('/health', methods=['GET'])
    def health_check():
        return jsonify({
            'status': 'healthy',
            'timestamp': datetime.now().isoformat(),
            'version': '2.0.0'
        })

    # Authentication endpoint - both old and new paths
    @app.route('/authenticate', methods=['POST'])
    @app.route('/api/auth/authenticate', methods=['POST'])
    def authenticate():
        try:
            email = request.form.get('username') or request.form.get('email')
            password = request.form.get('password')
            logging.debug(f"Login attempt: email={email}, password={'*' * len(password) if password else 'None'}")
            
            if not email or not password:
                logging.warning(f"Login failed: Email or password missing")
                return jsonify({'success': False, 'message': 'Email and password are required'}), 400

            # Check for admin login
            if email == "admin" and password == "admin":
                session['loggedin'] = True
                session['user_email'] = "admin@example.com"
                session['user_id'] = 1
                session.permanent = True
                logging.info(f"Admin login successful. Session: {dict(session)}")
                return jsonify({'success': True, 'message': 'Login successful', 'user': {'email': 'admin@example.com', 'id': 1}}), 200

            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("SELECT * FROM login_details WHERE LOWER(email) = LOWER(%s)", (email.lower(),))
            account = cursor.fetchone()
            cursor.close()
            
            if account:
                if bcrypt.checkpw(password.encode('utf-8'), account['password'].encode('utf-8')):
                    session['loggedin'] = True
                    session['user_email'] = account['email']
                    session['user_id'] = account['id']
                    session.permanent = True
                    logging.info(f"User {email} logged in successfully. Session: {dict(session)}")
                    return jsonify({
                        'success': True,
                        'message': 'Login successful',
                        'user': {'email': account['email'], 'id': account['id']}
                    }), 200
                else:
                    logging.warning(f"Invalid password for {email}")
                    return jsonify({'success': False, 'message': 'Invalid credentials'}), 401
            else:
                logging.warning(f"Email {email} not found")
                return jsonify({'success': False, 'message': 'Invalid credentials'}), 401
        except Exception as e:
            logging.error(f"Unexpected error during login: {str(e)}")
            return jsonify({'success': False, 'message': f'Unexpected error: {str(e)}'}), 500

    @app.route('/check-auth', methods=['GET'])
    @app.route('/api/auth/check-auth', methods=['GET'])
    def check_auth():
        try:
            logging.debug(f"Checking auth with session: {dict(session)}")
            if 'loggedin' in session and 'user_id' in session:
                conn = get_db_connection()
                cursor = conn.cursor(dictionary=True)
                cursor.execute("SELECT email, first_name FROM login_details WHERE id = %s", (session['user_id'],))
                user = cursor.fetchone()
                cursor.close()
                if user:
                    logging.info(f"User {session.get('user_email')} is authenticated")
                    return jsonify({
                        'success': True,
                        'user': {
                            'email': user['email'],
                            'id': session['user_id'],
                            'first_name': user['first_name']
                        }
                    })
                else:
                    logging.warning("User not found in database")  
                    session.clear()
                    return jsonify({'success': False, 'message': 'User not found'}), 401
            logging.warning("User not authenticated")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        except Exception as e:
            logging.error(f"Error in check-auth endpoint: {str(e)}")
            return jsonify({'success': False, 'message': f'Server error: {str(e)}'}), 500

    @app.route('/register', methods=['POST'])
    @app.route('/api/auth/register', methods=['POST'])
    def register():
        first_name = request.form.get('first_name')
        last_name = request.form.get('last_name')
        email = request.form.get('email')
        mobile = request.form.get('mobile')
        password = request.form.get('password')
        confirm_password = request.form.get('confirm_password')

        if not all([first_name, last_name, email, mobile, password, confirm_password]):
            return jsonify({'success': False, 'message': 'All fields are required'}), 400
        if password != confirm_password:
            return jsonify({'success': False, 'message': 'Passwords do not match'}), 400

        hashed_password = bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
        try:
            conn = get_db_connection()
            cursor = conn.cursor()
            cursor.execute("""
                INSERT INTO login_details (first_name, last_name, email, mobile, password)
                VALUES (%s, %s, %s, %s, %s)
            """, (first_name, last_name, email, mobile, hashed_password))
            user_id = cursor.lastrowid
            conn.commit()
            cursor.close()
            session['loggedin'] = True
            session['user_email'] = email
            session['user_id'] = user_id
            return jsonify({
                'success': True,
                'message': 'Registration successful',
                'user': {'email': email, 'id': user_id}
            }), 200
        except mysql.connector.Error as e:
            logging.error(f"Database error during registration: {str(e)}")
            return jsonify({'success': False, 'message': f'Registration error: {str(e)}'}), 500

    @app.route('/logout', methods=['POST'])
    @app.route('/api/auth/logout', methods=['POST'])
    def logout():
        logging.info(f"User {session.get('user_email', 'unknown')} logged out")
        session.clear()
        return jsonify({'success': True, 'message': 'Logged out successfully'})

    # Template routes
    @app.route('/templates', methods=['GET'])
    @app.route('/api/templates', methods=['GET'])
    def get_templates():
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /templates: session missing")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("""
                SELECT template_id, template_name, created_at, status
                FROM excel_templates
                WHERE user_id = %s AND status = 'ACTIVE'
                ORDER BY created_at DESC
                LIMIT 100
            """, (session['user_id'],))
            templates = cursor.fetchall()
            cursor.close()
            logging.info(f"Fetched {len(templates)} templates for user {session['user_id']}")
            return jsonify({'success': True, 'templates': templates})
        except mysql.connector.Error as e:
            logging.error(f'Error fetching templates: {str(e)}')
            return jsonify({'success': False, 'message': f'Error fetching templates: {str(e)}'}), 500
        except Exception as e:
            logging.error(f'Unexpected error fetching templates: {str(e)}')
            return jsonify({'success': False, 'message': f'Unexpected error: {str(e)}'}), 500

    # Rule Configuration routes
    @app.route('/rule-configurations', methods=['GET'])
    @app.route('/api/validation/rule-configurations', methods=['GET'])
    def get_rule_configurations():
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning(f"Unauthorized access to /rule-configurations: session={dict(session)}")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            user_id = session['user_id']
            logging.debug(f"Fetching rule configurations for user_id: {user_id}")

            # Main query to fetch templates with configured rules
            cursor.execute("""
                SELECT 
                    t.template_id, 
                    t.template_name, 
                    t.created_at, 
                    COUNT(cvr.column_validation_id) as rule_count
                FROM excel_templates t
                LEFT JOIN template_columns tc ON t.template_id = tc.template_id
                LEFT JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                WHERE t.user_id = %s AND t.status = 'ACTIVE' AND t.is_corrected = FALSE
                GROUP BY t.template_id, t.template_name, t.created_at
                HAVING rule_count > 0
                ORDER BY t.created_at DESC
                LIMIT 100
            """, (user_id,))
            templates = cursor.fetchall()
            logging.debug(f"Fetched rule-configured templates: {templates}")

            cursor.close()

            if not templates:
                logging.info(f"No templates with rules found for user_id: {user_id}")
            else:
                logging.info(f"Found {len(templates)} templates with rules for user_id: {user_id}")

            return jsonify({'success': True, 'templates': templates})
        except mysql.connector.Error as e:
            logging.error(f"Database error fetching rule configurations: {str(e)}")
            return jsonify({'success': False, 'message': f"Database error: {str(e)}"}), 500
        except Exception as e:
            logging.error(f"Unexpected error fetching rule configurations: {str(e)}")
            return jsonify({'success': False, 'message': f"Unexpected error: {str(e)}"}), 500

    # File upload route
    @app.route('/upload', methods=['POST'])
    @app.route('/api/templates/upload', methods=['POST'])
    @app.route('/api/upload', methods=['POST'])  # Additional common path
    def upload():
        logging.info(f"Upload endpoint called: {request.endpoint}, method: {request.method}")
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /upload: session missing")
            return jsonify({'error': 'Not logged in'}), 401
        if 'file' not in request.files:
            logging.warning("No file provided in upload request")
            return jsonify({'error': 'No file uploaded'}), 400
        file = request.files['file']
        if file.filename == '':
            logging.warning("No file selected in upload request")
            return jsonify({'error': 'No file selected'}), 400
        
        file_path = os.path.join(app.config['UPLOAD_FOLDER'], file.filename)
        try:
            file.save(file_path)
            logging.info(f"File saved: {file_path}")
        except Exception as e:
            logging.error(f"Failed to save file {file.filename}: {str(e)}")
            return jsonify({'error': f'Failed to save file: {str(e)}'}), 500

        try:
            # Read the file to get sheets and headers
            if file.filename.endswith('.xlsx') or file.filename.endswith('.xls'):
                xl = pd.ExcelFile(file_path)
                sheets = {sheet_name: pd.read_excel(file_path, sheet_name=sheet_name, header=None) 
                         for sheet_name in xl.sheet_names}
            elif file.filename.endswith(('.txt', '.csv', '.dat')):
                df = pd.read_csv(file_path, header=None, encoding='utf-8')
                sheets = {'Sheet1': df}
            else:
                logging.error("Unsupported file type")
                return jsonify({'error': 'Unsupported file type'}), 400
            
            logging.debug(f"Sheets extracted: {list(sheets.keys())}")
        except Exception as e:
            logging.error(f"Failed to read file {file_path}: {str(e)}")
            return jsonify({'error': f'Failed to read file: {str(e)}'}), 400

        try:
            sheet_names = list(sheets.keys())
            if not sheet_names:
                logging.error("No sheets found in the file")
                return jsonify({'error': 'No sheets found in the file'}), 400
            sheet_name = sheet_names[0]
            df = sheets[sheet_name]
            
            # Find header row
            header_row = 0
            for i in range(min(len(df), 10)):
                row = df.iloc[i].dropna()
                if not row.empty and all(isinstance(x, str) for x in row if pd.notna(x)):
                    header_row = i
                    break
                    
            headers = df.iloc[header_row].tolist()
            logging.debug(f"Headers extracted: {headers}")
            
            if not headers or all(not h for h in headers):
                logging.error("No valid headers found in file")
                return jsonify({'error': 'No valid headers found in the file'}), 400
        except Exception as e:
            logging.error(f"Error processing file {file.filename}: {str(e)}")
            return jsonify({'error': f'Error processing file: {str(e)}'}), 400

        # Clear existing session data
        for key in ['df', 'header_row', 'headers', 'sheet_name', 'current_step', 'selected_headers', 'validations', 'error_cell_locations', 'data_rows', 'corrected_file_path']:
            session.pop(key, None)

        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)

            # Check if template exists
            cursor.execute("""
                SELECT template_id, headers, sheet_name
                FROM excel_templates
                WHERE template_name = %s AND user_id = %s AND status = 'ACTIVE'
                ORDER BY created_at DESC
            """, (file.filename, session['user_id']))
            existing_templates = cursor.fetchall()
            logging.info(f"Found {len(existing_templates)} existing templates with name {file.filename}")

            template_id = None
            has_existing_rules = False
            validations = {}
            selected_headers = []

            # Check for matching template
            matching_template = None
            for template in existing_templates:
                stored_headers = json.loads(template['headers']) if template['headers'] else []
                stored_sheet_name = template['sheet_name']
                if stored_headers == headers and stored_sheet_name == sheet_name:
                    matching_template = template
                    break

            if matching_template:
                template_id = matching_template['template_id']
                # Check for existing rules
                cursor.execute("""
                    SELECT tc.column_name, vrt.rule_name
                    FROM template_columns tc
                    JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                    JOIN validation_rule_types vrt ON cvr.rule_type_id = vrt.rule_type_id
                    WHERE tc.template_id = %s AND tc.is_selected = TRUE
                """, (template_id,))
                rules_data = cursor.fetchall()
                for row in rules_data:
                    column_name = row['column_name']
                    rule_name = row['rule_name']
                    if column_name not in validations:
                        validations[column_name] = []
                    validations[column_name].append(rule_name)
                    if column_name not in selected_headers:
                        selected_headers.append(column_name)
                has_existing_rules = len(validations) > 0
            else:
                # New template
                cursor.execute("""
                    INSERT INTO excel_templates (template_name, user_id, sheet_name, headers, is_corrected)
                    VALUES (%s, %s, %s, %s, %s)
                """, (file.filename, session['user_id'], sheet_name, json.dumps(headers), False))
                template_id = cursor.lastrowid
                column_data = [(template_id, header, i + 1, False) for i, header in enumerate(headers)]
                cursor.executemany("""
                    INSERT INTO template_columns (template_id, column_name, column_position, is_selected)
                    VALUES (%s, %s, %s, %s)
                """, column_data)

            conn.commit()
            cursor.close()

            # Store session data
            session['file_path'] = file_path
            session['template_id'] = template_id
            session['df'] = df.to_json()
            session['header_row'] = header_row
            session['headers'] = headers
            session['sheet_name'] = sheet_name
            session['current_step'] = 1 if not has_existing_rules else 3
            session['validations'] = validations
            session['selected_headers'] = selected_headers
            session['has_existing_rules'] = has_existing_rules

            logging.info(f"Upload processed: template_id={template_id}, filename={file.filename}, has_existing_rules={has_existing_rules}")

            return jsonify({
                'success': True,
                'sheets': {sheet_name: {'headers': headers}},
                'file_name': file.filename,
                'template_id': template_id,
                'has_existing_rules': has_existing_rules,
                'sheet_name': sheet_name,
                'skip_to_step_3': has_existing_rules
            })
        except mysql.connector.Error as e:
            logging.error(f'Error saving template: {str(e)}')
            return jsonify({'error': f'Error saving template: {str(e)}'}), 500
        except Exception as e:
            logging.error(f'Unexpected error saving template: {str(e)}')
            return jsonify({'error': f'Unexpected error: {str(e)}'}), 500

    # Multi-step workflow endpoints
    @app.route('/step/1', methods=['GET', 'POST'])
    @app.route('/api/step/1', methods=['GET', 'POST'])
    def step_one():
        if 'loggedin' not in session:
            return jsonify({'error': 'Not logged in'}), 401
        
        if request.method == 'POST':
            try:
                headers = request.form.getlist('headers')
                new_header_row = request.form.get('new_header_row')
                logging.debug(f"Step 1 submitted: headers={headers}, new_header_row={new_header_row}")
                
                if not headers:
                    logging.error("No headers provided in step 1")
                    return jsonify({'success': False, 'message': 'No headers provided'}), 400
                    
                if 'template_id' not in session:
                    logging.error("Session missing template_id")
                    return jsonify({'success': False, 'message': 'Session data missing'}), 400

                template_id = session['template_id']
                
                # Get the dataframe from session for auto-detection
                df_json = session.get('df')
                if df_json:
                    df = pd.read_json(StringIO(df_json))
                    session_headers = session.get('headers', [])
                    df.columns = session_headers
                    header_row = session.get('header_row', 0)
                    df = df.iloc[header_row + 1:].reset_index(drop=True)
                    
                    # Auto-detect rules for selected headers
                    validations = assign_default_rules_to_columns(df, headers)
                    session['validations'] = validations
                    logging.debug(f"Auto-assigned rules: {validations}")
                else:
                    validations = {}

                session['selected_headers'] = headers
                session['current_step'] = 2

                # Mark selected headers in the database
                conn = get_db_connection()
                cursor = conn.cursor()
                cursor.execute("UPDATE template_columns SET is_selected = FALSE WHERE template_id = %s", (template_id,))
                for header in headers:
                    cursor.execute("""
                        UPDATE template_columns
                        SET is_selected = TRUE
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    
                    # Get column_id and add auto-detected rules
                    cursor.execute("""
                        SELECT column_id FROM template_columns
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    result = cursor.fetchone()
                    if result:
                        column_id = result[0]
                        for rule_name in validations.get(header, []):
                            cursor.execute("""
                                SELECT rule_type_id FROM validation_rule_types
                                WHERE rule_name = %s AND is_custom = FALSE
                            """, (rule_name,))
                            rule_result = cursor.fetchone()
                            if rule_result:
                                rule_type_id = rule_result[0]
                                cursor.execute("""
                                    INSERT IGNORE INTO column_validation_rules (column_id, rule_type_id, rule_config)
                                    VALUES (%s, %s, %s)
                                """, (column_id, rule_type_id, '{}'))
                
                conn.commit()
                cursor.close()

                logging.info(f"Step 1 completed: headers={headers}, auto-assigned rules={validations}")
                return jsonify({'success': True, 'headers': headers, 'validations': validations})
            except Exception as e:
                logging.error(f"Error in step 1: {str(e)}")
                return jsonify({'success': False, 'message': str(e)}), 500
        
        # GET request - return current headers
        headers = session.get('headers', [])
        return jsonify({'headers': headers})

    @app.route('/step/2', methods=['GET', 'POST'])
    @app.route('/api/step/2', methods=['GET', 'POST'])
    def step_two():
        if 'loggedin' not in session:
            return jsonify({'error': 'Not logged in'}), 401
            
        if request.method == 'POST':
            try:
                action = request.form.get('action', 'save')
                validations = {}
                for key, values in request.form.lists():
                    if key.startswith('validations_'):
                        header = key.replace('validations_', '')
                        validations[header] = values
                        
                logging.debug(f"Step 2 submitted: action={action}, validations={validations}")
                
                template_id = session.get('template_id')
                if not template_id:
                    return jsonify({'success': False, 'message': 'Session data missing'}), 400

                # Save validations to database
                conn = get_db_connection()
                cursor = conn.cursor()
                
                # Clear existing rules
                cursor.execute("""
                    DELETE FROM column_validation_rules
                    WHERE column_id IN (
                        SELECT column_id FROM template_columns WHERE template_id = %s
                    )
                """, (template_id,))
                
                # Add new rules
                for header, rules in validations.items():
                    cursor.execute("""
                        SELECT column_id FROM template_columns
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    result = cursor.fetchone()
                    if not result:
                        continue
                    column_id = result[0]
                    
                    for rule_name in rules:
                        cursor.execute("""
                            SELECT rule_type_id FROM validation_rule_types
                            WHERE rule_name = %s
                        """, (rule_name,))
                        result = cursor.fetchone()
                        if result:
                            rule_type_id = result[0]
                            cursor.execute("""
                                INSERT IGNORE INTO column_validation_rules (column_id, rule_type_id, rule_config)
                                VALUES (%s, %s, %s)
                            """, (column_id, rule_type_id, '{}'))
                
                conn.commit()
                cursor.close()

                session['validations'] = validations
                session['current_step'] = 3 if action == 'review' else 2
                
                logging.info(f"Step 2 completed: action={action}, validations={validations}")
                return jsonify({'success': True, 'message': 'Step 2 completed successfully'})
            except Exception as e:
                logging.error(f"Error in step 2: {str(e)}")
                return jsonify({'success': False, 'message': str(e)}), 500
        
        # GET request
        selected_headers = session.get('selected_headers', [])
        return jsonify({'selected_headers': selected_headers})

    # Rules endpoint
    @app.route('/rules', methods=['GET'])
    @app.route('/api/rules', methods=['GET'])
    def get_rules():
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            
            cursor.execute("""
                SELECT rule_type_id AS rule_id, rule_name, description, parameters, is_custom, 
                       column_name, template_id, source_format, target_format, data_type, is_active
                FROM validation_rule_types
            """)
            rules = cursor.fetchall()
            cursor.close()
            
            logging.info(f"Returning {len(rules)} rules from getRules endpoint")
            return jsonify({'success': True, 'rules': rules})
        except mysql.connector.Error as e:
            logging.error(f"Database error fetching rules: {str(e)}")
            return jsonify({'success': False, 'message': str(e)}), 500
        except Exception as e:
            logging.error(f"Unexpected error fetching rules: {str(e)}")
            return jsonify({'success': False, 'message': str(e)}), 500

    # Template details endpoint
    @app.route('/template/<int:template_id>/<sheet_name>', methods=['GET'])
    @app.route('/api/template/<int:template_id>/<sheet_name>', methods=['GET'])
    def get_template(template_id, sheet_name):
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /template: session missing")
            return jsonify({'error': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("""
                SELECT template_name, sheet_name, headers
                FROM excel_templates
                WHERE template_id = %s AND user_id = %s AND status = 'ACTIVE'
            """, (template_id, session['user_id']))
            template_record = cursor.fetchone()
            
            if not template_record:
                logging.error(f"Template not found for template_id: {template_id}, user_id: {session['user_id']}")
                cursor.close()
                return jsonify({'error': 'Template not found'}), 404

            headers = json.loads(template_record['headers']) if template_record['headers'] else []
            stored_sheet_name = template_record['sheet_name'] or sheet_name
            file_path = os.path.join(app.config['UPLOAD_FOLDER'], template_record['template_name'])
            
            cursor.execute("""
                SELECT COUNT(*) as rule_count
                FROM template_columns tc
                JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                WHERE tc.template_id = %s AND tc.is_selected = TRUE
            """, (template_id,))
            rule_count = cursor.fetchone()['rule_count']
            has_existing_rules = rule_count > 0
            
            cursor.close()
            
            return jsonify({
                'success': True,
                'sheets': {stored_sheet_name: {'headers': headers}},
                'file_name': template_record['template_name'],
                'file_path': file_path,
                'sheet_name': stored_sheet_name,
                'has_existing_rules': has_existing_rules
            })
        except mysql.connector.Error as e:
            logging.error(f"Database error in get_template: {str(e)}")
            return jsonify({'error': f'Database error: {str(e)}'}), 500
        except Exception as e:
            logging.error(f"Unexpected error in get_template: {str(e)}")
            return jsonify({'error': f'Unexpected error: {str(e)}'}), 500

    # Debug route to show all registered routes
    @app.route('/debug/routes', methods=['GET'])
    def list_routes():
        routes = []
        for rule in app.url_map.iter_rules():
            routes.append({
                'endpoint': rule.endpoint,
                'methods': list(rule.methods),
                'rule': rule.rule
            })
        return jsonify(routes)

    # 404 handler to debug missing routes
    @app.errorhandler(404)
    def not_found_handler(error):
        logging.error(f"404 Error: {request.method} {request.url} not found")
        logging.error(f"Available routes: {[rule.rule for rule in app.url_map.iter_rules()]}")
        return jsonify({
            'error': 'Endpoint not found', 
            'method': request.method,
            'url': request.url,
            'path': request.path
        }), 404

    return app

def initialize_app_data():
    """Initialize database and create default data"""
    try:
        logging.info("Initializing database schema...")
        init_db()
        
        logging.info("Creating admin user...")
        create_admin_user()
        
        logging.info("Creating default validation rules...")
        create_default_validation_rules()
        
        logging.info("Application initialization completed successfully")
    except Exception as e:
        logging.error(f"Failed to initialize application: {e}")
        raise

DB_CONFIG = {
    'host': os.getenv('MYSQL_HOST', 'localhost'),
    'user': os.getenv('MYSQL_USER', 'root'),
    'password': os.getenv('MYSQL_PASSWORD', 'Keansa@2024'),
    'database': os.getenv('MYSQL_DATABASE', 'data_validation_2'),
}

def get_db_connection():
    if 'db' not in g:
        try:
            conn = mysql.connector.connect(
                host=DB_CONFIG['host'],
                user=DB_CONFIG['user'],
                password=DB_CONFIG['password']
            )
            cursor = conn.cursor()
            cursor.execute(f"CREATE DATABASE IF NOT EXISTS {DB_CONFIG['database']}")
            cursor.close()
            conn.close()
            g.db = mysql.connector.connect(**DB_CONFIG)
            logging.info("Database connection established successfully")
        except mysql.connector.Error as err:
            if err.errno == errorcode.ER_ACCESS_DENIED_ERROR:
                logging.error("Database connection failed: Access denied for user - check username/password")
            elif err.errno == errorcode.ER_BAD_DB_ERROR:
                logging.error("Database connection failed: Database does not exist")
            else:
                logging.error(f"Database connection failed: {err}")
            raise Exception(f"Failed to connect to database: {str(err)}")
    return g.db

def close_db(error):
    db = g.pop('db', None)
    if db is not None:
        db.close()

def init_db():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        tables = [
            """
            CREATE TABLE IF NOT EXISTS login_details (
                id INT AUTO_INCREMENT PRIMARY KEY,
                first_name VARCHAR(100),
                last_name VARCHAR(100),
                email VARCHAR(255) UNIQUE,
                mobile VARCHAR(10),
                password VARCHAR(255)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS excel_templates (
                template_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_name VARCHAR(255) NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
                user_id INT NOT NULL,
                sheet_name VARCHAR(255),
                headers JSON,
                status ENUM('ACTIVE', 'INACTIVE') DEFAULT 'ACTIVE',
                is_corrected BOOLEAN DEFAULT FALSE,
                remote_file_path VARCHAR(512),
                FOREIGN KEY (user_id) REFERENCES login_details(id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS template_columns (
                column_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_id BIGINT NOT NULL,
                column_name VARCHAR(255) NOT NULL,
                column_position INT NOT NULL,
                is_validation_enabled BOOLEAN DEFAULT FALSE,
                is_selected BOOLEAN DEFAULT FALSE,
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE,
                UNIQUE (template_id, column_name)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_rule_types (
                rule_type_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                rule_name VARCHAR(255) NOT NULL,
                description TEXT,
                parameters TEXT,
                is_active BOOLEAN DEFAULT TRUE,
                is_custom BOOLEAN DEFAULT FALSE,
                column_name VARCHAR(255),
                template_id BIGINT,
                data_type VARCHAR(50),
                source_format VARCHAR(50),
                target_format VARCHAR(50),
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS column_validation_rules (
                column_validation_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                column_id BIGINT NOT NULL,
                rule_type_id BIGINT NOT NULL,
                rule_config JSON,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (column_id) REFERENCES template_columns(column_id) ON DELETE CASCADE,
                FOREIGN KEY (rule_type_id) REFERENCES validation_rule_types(rule_type_id) ON DELETE RESTRICT,
                UNIQUE (column_id, rule_type_id)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_history (
                history_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_id BIGINT NOT NULL,
                template_name VARCHAR(255) NOT NULL,
                error_count INT NOT NULL,
                corrected_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                corrected_file_path VARCHAR(512) NOT NULL,
                user_id INT NOT NULL,
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE,
                FOREIGN KEY (user_id) REFERENCES login_details(id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_corrections (
                correction_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                history_id BIGINT NOT NULL,
                row_index INT NOT NULL,
                column_name VARCHAR(255) NOT NULL,
                original_value TEXT,
                corrected_value TEXT,
                rule_failed VARCHAR(255) DEFAULT NULL,
                FOREIGN KEY (history_id) REFERENCES validation_history(history_id) ON DELETE CASCADE
            )
            """
        ]
        for table_sql in tables:
            cursor.execute(table_sql)
        
        # Add missing columns if they don't exist
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'source_format'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN source_format VARCHAR(50)")
            logging.info("Added source_format column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'target_format'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN target_format VARCHAR(50)")
            logging.info("Added target_format column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'data_type'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN data_type VARCHAR(50)")
            logging.info("Added data_type column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM excel_templates LIKE 'remote_file_path'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE excel_templates ADD COLUMN remote_file_path VARCHAR(512)")
            logging.info("Added remote_file_path column to excel_templates table")
            
        cursor.execute("SHOW COLUMNS FROM template_columns LIKE 'is_selected'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE template_columns ADD COLUMN is_selected BOOLEAN DEFAULT FALSE")
            logging.info("Added is_selected column to template_columns table")
            
        conn.commit()
        cursor.close()
        logging.info("Database tables initialized")
    except Exception as e:
        logging.error(f"Failed to initialize database: {str(e)}")
        raise

def create_admin_user():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        admin_password = bcrypt.hashpw('admin'.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
        cursor.execute("""
            INSERT IGNORE INTO login_details (first_name, last_name, email, mobile, password)
            VALUES (%s, %s, %s, %s, %s)
        """, ('Admin', 'User', 'admin@example.com', '1234567890', admin_password))
        conn.commit()
        cursor.close()
        logging.info("Admin user created or already exists")
    except Exception as e:
        logging.error(f"Failed to create admin user: {str(e)}")
        raise

def create_default_validation_rules():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        default_rules = [
            ("Required", "Ensures the field is not null", '{"allow_null": false}', None, None, None),
            ("Int", "Validates integer format", '{"format": "integer"}', None, None, "Int"),
            ("Float", "Validates number format (integer or decimal)", '{"format": "float"}', None, None, "Float"),
            ("Text", "Allows text with quotes and parentheses", '{"allow_special": false}', None, None, "Text"),
            ("Email", "Validates email format", '{"regex": "^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\\\.[a-zA-Z0-9-.]+$"}', None, None, "Email"),
            ("Date(DD-MM-YYYY)", "Validates date format DD-MM-YYYY", '{"format": "%d-%m-%Y"}', "DD-MM-YYYY", None, "Date"),
            ("Boolean", "Validates boolean format (true/false or 0/1)", '{"format": "boolean"}', None, None, "Boolean"),
            ("Alphanumeric", "Validates alphanumeric format", '{"format": "alphanumeric"}', None, None, "Alphanumeric")
        ]
        cursor.executemany("""
            INSERT IGNORE INTO validation_rule_types (rule_name, description, parameters, is_custom, source_format, target_format, data_type)
            VALUES (%s, %s, %s, %s, %s, %s, %s)
        """, [(name, desc, params, False, source, target, dtype) for name, desc, params, source, target, dtype in default_rules])
        conn.commit()
        cursor.close()
        logging.info("Default validation rules ensured successfully")
    except Exception as e:
        logging.error(f"Failed to ensure default validation rules: {str(e)}")
        raise

if __name__ == '__main__':
    try:
        # Create the application using factory pattern
        app = create_app()
        
        # Initialize database and default data within app context
        with app.app_context():
            initialize_app_data()
        
        # Get port from environment or use default
        port = int(os.getenv('PORT', 5000))
        
        # Start the application server
        logging.info("Starting Flask server...")
        app.run(debug=True, host='0.0.0.0', port=port)
        
    except Exception as e:
        logging.error(f"Failed to start application: {e}")
        raise
).all():
        return "Float"
    
    # Alphanumeric detection
    if non_null.str.match(r'^[a-zA-Z0-9]+

def create_app():
    """Application factory pattern for different environments"""
    # Set the path to the frontend dist folder
    current_dir = os.path.dirname(os.path.abspath(__file__))
    frontend_dist_path = os.path.join(current_dir, '..', '..', 'Keansa-Ai-Suite2025may-frontend11', 'dist')
    frontend_dist_path = os.path.abspath(frontend_dist_path)
    
    # Create Flask application instance
    app = Flask(__name__, static_folder=frontend_dist_path, static_url_path='')
    CORS(app, supports_credentials=True, origins=["http://localhost:3000", "http://localhost:8080", "http://localhost:5000", "*"])

    app.secret_key = os.urandom(24).hex()
    app.config['SESSION_TYPE'] = 'filesystem'
    app.config['SESSION_FILE_DIR'] = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'sessions')
    app.config['SESSION_COOKIE_SAMESITE'] = 'Lax'
    app.config['SESSION_COOKIE_HTTPONLY'] = True
    app.config['SESSION_COOKIE_SECURE'] = False
    app.config['PERMANENT_SESSION_LIFETIME'] = 86400  # 24 hours
    app.config['UPLOAD_FOLDER'] = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'uploads')
    Session(app)

    # Ensure directories exist
    try:
        os.makedirs(app.config['UPLOAD_FOLDER'], exist_ok=True)
        os.makedirs(app.config['SESSION_FILE_DIR'], exist_ok=True)
    except OSError as e:
        logging.error(f"Failed to create directories: {e}")

    # Register cleanup handlers
    app.teardown_appcontext(close_db)
    
    # Register all routes directly in create_app
    
    # Static file serving for React frontend
    @app.route('/', defaults={'path': ''})
    @app.route('/<path:path>')
    def serve(path):
        if path and os.path.exists(os.path.join(app.static_folder, path)):
            return app.send_static_file(path)
        return app.send_static_file('index.html')

    # Health check endpoint
    @app.route('/health', methods=['GET'])
    def health_check():
        return jsonify({
            'status': 'healthy',
            'timestamp': datetime.now().isoformat(),
            'version': '2.0.0'
        })

    # Authentication endpoint - both old and new paths
    @app.route('/authenticate', methods=['POST'])
    @app.route('/api/auth/authenticate', methods=['POST'])
    def authenticate():
        try:
            email = request.form.get('username') or request.form.get('email')
            password = request.form.get('password')
            logging.debug(f"Login attempt: email={email}, password={'*' * len(password) if password else 'None'}")
            
            if not email or not password:
                logging.warning(f"Login failed: Email or password missing")
                return jsonify({'success': False, 'message': 'Email and password are required'}), 400

            # Check for admin login
            if email == "admin" and password == "admin":
                session['loggedin'] = True
                session['user_email'] = "admin@example.com"
                session['user_id'] = 1
                session.permanent = True
                logging.info(f"Admin login successful. Session: {dict(session)}")
                return jsonify({'success': True, 'message': 'Login successful', 'user': {'email': 'admin@example.com', 'id': 1}}), 200

            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("SELECT * FROM login_details WHERE LOWER(email) = LOWER(%s)", (email.lower(),))
            account = cursor.fetchone()
            cursor.close()
            
            if account:
                if bcrypt.checkpw(password.encode('utf-8'), account['password'].encode('utf-8')):
                    session['loggedin'] = True
                    session['user_email'] = account['email']
                    session['user_id'] = account['id']
                    session.permanent = True
                    logging.info(f"User {email} logged in successfully. Session: {dict(session)}")
                    return jsonify({
                        'success': True,
                        'message': 'Login successful',
                        'user': {'email': account['email'], 'id': account['id']}
                    }), 200
                else:
                    logging.warning(f"Invalid password for {email}")
                    return jsonify({'success': False, 'message': 'Invalid credentials'}), 401
            else:
                logging.warning(f"Email {email} not found")
                return jsonify({'success': False, 'message': 'Invalid credentials'}), 401
        except Exception as e:
            logging.error(f"Unexpected error during login: {str(e)}")
            return jsonify({'success': False, 'message': f'Unexpected error: {str(e)}'}), 500

    @app.route('/check-auth', methods=['GET'])
    @app.route('/api/auth/check-auth', methods=['GET'])
    def check_auth():
        try:
            logging.debug(f"Checking auth with session: {dict(session)}")
            if 'loggedin' in session and 'user_id' in session:
                conn = get_db_connection()
                cursor = conn.cursor(dictionary=True)
                cursor.execute("SELECT email, first_name FROM login_details WHERE id = %s", (session['user_id'],))
                user = cursor.fetchone()
                cursor.close()
                if user:
                    logging.info(f"User {session.get('user_email')} is authenticated")
                    return jsonify({
                        'success': True,
                        'user': {
                            'email': user['email'],
                            'id': session['user_id'],
                            'first_name': user['first_name']
                        }
                    })
                else:
                    logging.warning("User not found in database")  
                    session.clear()
                    return jsonify({'success': False, 'message': 'User not found'}), 401
            logging.warning("User not authenticated")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        except Exception as e:
            logging.error(f"Error in check-auth endpoint: {str(e)}")
            return jsonify({'success': False, 'message': f'Server error: {str(e)}'}), 500

    @app.route('/register', methods=['POST'])
    @app.route('/api/auth/register', methods=['POST'])
    def register():
        first_name = request.form.get('first_name')
        last_name = request.form.get('last_name')
        email = request.form.get('email')
        mobile = request.form.get('mobile')
        password = request.form.get('password')
        confirm_password = request.form.get('confirm_password')

        if not all([first_name, last_name, email, mobile, password, confirm_password]):
            return jsonify({'success': False, 'message': 'All fields are required'}), 400
        if password != confirm_password:
            return jsonify({'success': False, 'message': 'Passwords do not match'}), 400

        hashed_password = bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
        try:
            conn = get_db_connection()
            cursor = conn.cursor()
            cursor.execute("""
                INSERT INTO login_details (first_name, last_name, email, mobile, password)
                VALUES (%s, %s, %s, %s, %s)
            """, (first_name, last_name, email, mobile, hashed_password))
            user_id = cursor.lastrowid
            conn.commit()
            cursor.close()
            session['loggedin'] = True
            session['user_email'] = email
            session['user_id'] = user_id
            return jsonify({
                'success': True,
                'message': 'Registration successful',
                'user': {'email': email, 'id': user_id}
            }), 200
        except mysql.connector.Error as e:
            logging.error(f"Database error during registration: {str(e)}")
            return jsonify({'success': False, 'message': f'Registration error: {str(e)}'}), 500

    @app.route('/logout', methods=['POST'])
    @app.route('/api/auth/logout', methods=['POST'])
    def logout():
        logging.info(f"User {session.get('user_email', 'unknown')} logged out")
        session.clear()
        return jsonify({'success': True, 'message': 'Logged out successfully'})

    # Template routes
    @app.route('/templates', methods=['GET'])
    @app.route('/api/templates', methods=['GET'])
    def get_templates():
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /templates: session missing")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("""
                SELECT template_id, template_name, created_at, status
                FROM excel_templates
                WHERE user_id = %s AND status = 'ACTIVE'
                ORDER BY created_at DESC
                LIMIT 100
            """, (session['user_id'],))
            templates = cursor.fetchall()
            cursor.close()
            logging.info(f"Fetched {len(templates)} templates for user {session['user_id']}")
            return jsonify({'success': True, 'templates': templates})
        except mysql.connector.Error as e:
            logging.error(f'Error fetching templates: {str(e)}')
            return jsonify({'success': False, 'message': f'Error fetching templates: {str(e)}'}), 500
        except Exception as e:
            logging.error(f'Unexpected error fetching templates: {str(e)}')
            return jsonify({'success': False, 'message': f'Unexpected error: {str(e)}'}), 500

    # Rule Configuration routes
    @app.route('/rule-configurations', methods=['GET'])
    @app.route('/api/validation/rule-configurations', methods=['GET'])
    def get_rule_configurations():
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning(f"Unauthorized access to /rule-configurations: session={dict(session)}")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            user_id = session['user_id']
            logging.debug(f"Fetching rule configurations for user_id: {user_id}")

            # Main query to fetch templates with configured rules
            cursor.execute("""
                SELECT 
                    t.template_id, 
                    t.template_name, 
                    t.created_at, 
                    COUNT(cvr.column_validation_id) as rule_count
                FROM excel_templates t
                LEFT JOIN template_columns tc ON t.template_id = tc.template_id
                LEFT JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                WHERE t.user_id = %s AND t.status = 'ACTIVE' AND t.is_corrected = FALSE
                GROUP BY t.template_id, t.template_name, t.created_at
                HAVING rule_count > 0
                ORDER BY t.created_at DESC
                LIMIT 100
            """, (user_id,))
            templates = cursor.fetchall()
            logging.debug(f"Fetched rule-configured templates: {templates}")

            cursor.close()

            if not templates:
                logging.info(f"No templates with rules found for user_id: {user_id}")
            else:
                logging.info(f"Found {len(templates)} templates with rules for user_id: {user_id}")

            return jsonify({'success': True, 'templates': templates})
        except mysql.connector.Error as e:
            logging.error(f"Database error fetching rule configurations: {str(e)}")
            return jsonify({'success': False, 'message': f"Database error: {str(e)}"}), 500
        except Exception as e:
            logging.error(f"Unexpected error fetching rule configurations: {str(e)}")
            return jsonify({'success': False, 'message': f"Unexpected error: {str(e)}"}), 500

    # File upload route
    @app.route('/upload', methods=['POST'])
    @app.route('/api/templates/upload', methods=['POST'])
    @app.route('/api/upload', methods=['POST'])  # Additional common path
    def upload():
        logging.info(f"Upload endpoint called: {request.endpoint}, method: {request.method}")
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /upload: session missing")
            return jsonify({'error': 'Not logged in'}), 401
        if 'file' not in request.files:
            logging.warning("No file provided in upload request")
            return jsonify({'error': 'No file uploaded'}), 400
        file = request.files['file']
        if file.filename == '':
            logging.warning("No file selected in upload request")
            return jsonify({'error': 'No file selected'}), 400
        
        file_path = os.path.join(app.config['UPLOAD_FOLDER'], file.filename)
        try:
            file.save(file_path)
            logging.info(f"File saved: {file_path}")
        except Exception as e:
            logging.error(f"Failed to save file {file.filename}: {str(e)}")
            return jsonify({'error': f'Failed to save file: {str(e)}'}), 500

        try:
            # Read the file to get sheets and headers
            if file.filename.endswith('.xlsx') or file.filename.endswith('.xls'):
                xl = pd.ExcelFile(file_path)
                sheets = {sheet_name: pd.read_excel(file_path, sheet_name=sheet_name, header=None) 
                         for sheet_name in xl.sheet_names}
            elif file.filename.endswith(('.txt', '.csv', '.dat')):
                df = pd.read_csv(file_path, header=None, encoding='utf-8')
                sheets = {'Sheet1': df}
            else:
                logging.error("Unsupported file type")
                return jsonify({'error': 'Unsupported file type'}), 400
            
            logging.debug(f"Sheets extracted: {list(sheets.keys())}")
        except Exception as e:
            logging.error(f"Failed to read file {file_path}: {str(e)}")
            return jsonify({'error': f'Failed to read file: {str(e)}'}), 400

        try:
            sheet_names = list(sheets.keys())
            if not sheet_names:
                logging.error("No sheets found in the file")
                return jsonify({'error': 'No sheets found in the file'}), 400
            sheet_name = sheet_names[0]
            df = sheets[sheet_name]
            
            # Find header row
            header_row = 0
            for i in range(min(len(df), 10)):
                row = df.iloc[i].dropna()
                if not row.empty and all(isinstance(x, str) for x in row if pd.notna(x)):
                    header_row = i
                    break
                    
            headers = df.iloc[header_row].tolist()
            logging.debug(f"Headers extracted: {headers}")
            
            if not headers or all(not h for h in headers):
                logging.error("No valid headers found in file")
                return jsonify({'error': 'No valid headers found in the file'}), 400
        except Exception as e:
            logging.error(f"Error processing file {file.filename}: {str(e)}")
            return jsonify({'error': f'Error processing file: {str(e)}'}), 400

        # Clear existing session data
        for key in ['df', 'header_row', 'headers', 'sheet_name', 'current_step', 'selected_headers', 'validations', 'error_cell_locations', 'data_rows', 'corrected_file_path']:
            session.pop(key, None)

        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)

            # Check if template exists
            cursor.execute("""
                SELECT template_id, headers, sheet_name
                FROM excel_templates
                WHERE template_name = %s AND user_id = %s AND status = 'ACTIVE'
                ORDER BY created_at DESC
            """, (file.filename, session['user_id']))
            existing_templates = cursor.fetchall()
            logging.info(f"Found {len(existing_templates)} existing templates with name {file.filename}")

            template_id = None
            has_existing_rules = False
            validations = {}
            selected_headers = []

            # Check for matching template
            matching_template = None
            for template in existing_templates:
                stored_headers = json.loads(template['headers']) if template['headers'] else []
                stored_sheet_name = template['sheet_name']
                if stored_headers == headers and stored_sheet_name == sheet_name:
                    matching_template = template
                    break

            if matching_template:
                template_id = matching_template['template_id']
                # Check for existing rules
                cursor.execute("""
                    SELECT tc.column_name, vrt.rule_name
                    FROM template_columns tc
                    JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                    JOIN validation_rule_types vrt ON cvr.rule_type_id = vrt.rule_type_id
                    WHERE tc.template_id = %s AND tc.is_selected = TRUE
                """, (template_id,))
                rules_data = cursor.fetchall()
                for row in rules_data:
                    column_name = row['column_name']
                    rule_name = row['rule_name']
                    if column_name not in validations:
                        validations[column_name] = []
                    validations[column_name].append(rule_name)
                    if column_name not in selected_headers:
                        selected_headers.append(column_name)
                has_existing_rules = len(validations) > 0
            else:
                # New template
                cursor.execute("""
                    INSERT INTO excel_templates (template_name, user_id, sheet_name, headers, is_corrected)
                    VALUES (%s, %s, %s, %s, %s)
                """, (file.filename, session['user_id'], sheet_name, json.dumps(headers), False))
                template_id = cursor.lastrowid
                column_data = [(template_id, header, i + 1, False) for i, header in enumerate(headers)]
                cursor.executemany("""
                    INSERT INTO template_columns (template_id, column_name, column_position, is_selected)
                    VALUES (%s, %s, %s, %s)
                """, column_data)

            conn.commit()
            cursor.close()

            # Store session data
            session['file_path'] = file_path
            session['template_id'] = template_id
            session['df'] = df.to_json()
            session['header_row'] = header_row
            session['headers'] = headers
            session['sheet_name'] = sheet_name
            session['current_step'] = 1 if not has_existing_rules else 3
            session['validations'] = validations
            session['selected_headers'] = selected_headers
            session['has_existing_rules'] = has_existing_rules

            logging.info(f"Upload processed: template_id={template_id}, filename={file.filename}, has_existing_rules={has_existing_rules}")

            return jsonify({
                'success': True,
                'sheets': {sheet_name: {'headers': headers}},
                'file_name': file.filename,
                'template_id': template_id,
                'has_existing_rules': has_existing_rules,
                'sheet_name': sheet_name,
                'skip_to_step_3': has_existing_rules
            })
        except mysql.connector.Error as e:
            logging.error(f'Error saving template: {str(e)}')
            return jsonify({'error': f'Error saving template: {str(e)}'}), 500
        except Exception as e:
            logging.error(f'Unexpected error saving template: {str(e)}')
            return jsonify({'error': f'Unexpected error: {str(e)}'}), 500

    # Multi-step workflow endpoints
    @app.route('/step/1', methods=['GET', 'POST'])
    @app.route('/api/step/1', methods=['GET', 'POST'])
    def step_one():
        if 'loggedin' not in session:
            return jsonify({'error': 'Not logged in'}), 401
        
        if request.method == 'POST':
            try:
                headers = request.form.getlist('headers')
                new_header_row = request.form.get('new_header_row')
                logging.debug(f"Step 1 submitted: headers={headers}, new_header_row={new_header_row}")
                
                if not headers:
                    logging.error("No headers provided in step 1")
                    return jsonify({'success': False, 'message': 'No headers provided'}), 400
                    
                if 'template_id' not in session:
                    logging.error("Session missing template_id")
                    return jsonify({'success': False, 'message': 'Session data missing'}), 400

                template_id = session['template_id']
                
                # Get the dataframe from session for auto-detection
                df_json = session.get('df')
                if df_json:
                    df = pd.read_json(StringIO(df_json))
                    session_headers = session.get('headers', [])
                    df.columns = session_headers
                    header_row = session.get('header_row', 0)
                    df = df.iloc[header_row + 1:].reset_index(drop=True)
                    
                    # Auto-detect rules for selected headers
                    validations = assign_default_rules_to_columns(df, headers)
                    session['validations'] = validations
                    logging.debug(f"Auto-assigned rules: {validations}")
                else:
                    validations = {}

                session['selected_headers'] = headers
                session['current_step'] = 2

                # Mark selected headers in the database
                conn = get_db_connection()
                cursor = conn.cursor()
                cursor.execute("UPDATE template_columns SET is_selected = FALSE WHERE template_id = %s", (template_id,))
                for header in headers:
                    cursor.execute("""
                        UPDATE template_columns
                        SET is_selected = TRUE
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    
                    # Get column_id and add auto-detected rules
                    cursor.execute("""
                        SELECT column_id FROM template_columns
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    result = cursor.fetchone()
                    if result:
                        column_id = result[0]
                        for rule_name in validations.get(header, []):
                            cursor.execute("""
                                SELECT rule_type_id FROM validation_rule_types
                                WHERE rule_name = %s AND is_custom = FALSE
                            """, (rule_name,))
                            rule_result = cursor.fetchone()
                            if rule_result:
                                rule_type_id = rule_result[0]
                                cursor.execute("""
                                    INSERT IGNORE INTO column_validation_rules (column_id, rule_type_id, rule_config)
                                    VALUES (%s, %s, %s)
                                """, (column_id, rule_type_id, '{}'))
                
                conn.commit()
                cursor.close()

                logging.info(f"Step 1 completed: headers={headers}, auto-assigned rules={validations}")
                return jsonify({'success': True, 'headers': headers, 'validations': validations})
            except Exception as e:
                logging.error(f"Error in step 1: {str(e)}")
                return jsonify({'success': False, 'message': str(e)}), 500
        
        # GET request - return current headers
        headers = session.get('headers', [])
        return jsonify({'headers': headers})

    @app.route('/step/2', methods=['GET', 'POST'])
    @app.route('/api/step/2', methods=['GET', 'POST'])
    def step_two():
        if 'loggedin' not in session:
            return jsonify({'error': 'Not logged in'}), 401
            
        if request.method == 'POST':
            try:
                action = request.form.get('action', 'save')
                validations = {}
                for key, values in request.form.lists():
                    if key.startswith('validations_'):
                        header = key.replace('validations_', '')
                        validations[header] = values
                        
                logging.debug(f"Step 2 submitted: action={action}, validations={validations}")
                
                template_id = session.get('template_id')
                if not template_id:
                    return jsonify({'success': False, 'message': 'Session data missing'}), 400

                # Save validations to database
                conn = get_db_connection()
                cursor = conn.cursor()
                
                # Clear existing rules
                cursor.execute("""
                    DELETE FROM column_validation_rules
                    WHERE column_id IN (
                        SELECT column_id FROM template_columns WHERE template_id = %s
                    )
                """, (template_id,))
                
                # Add new rules
                for header, rules in validations.items():
                    cursor.execute("""
                        SELECT column_id FROM template_columns
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    result = cursor.fetchone()
                    if not result:
                        continue
                    column_id = result[0]
                    
                    for rule_name in rules:
                        cursor.execute("""
                            SELECT rule_type_id FROM validation_rule_types
                            WHERE rule_name = %s
                        """, (rule_name,))
                        result = cursor.fetchone()
                        if result:
                            rule_type_id = result[0]
                            cursor.execute("""
                                INSERT IGNORE INTO column_validation_rules (column_id, rule_type_id, rule_config)
                                VALUES (%s, %s, %s)
                            """, (column_id, rule_type_id, '{}'))
                
                conn.commit()
                cursor.close()

                session['validations'] = validations
                session['current_step'] = 3 if action == 'review' else 2
                
                logging.info(f"Step 2 completed: action={action}, validations={validations}")
                return jsonify({'success': True, 'message': 'Step 2 completed successfully'})
            except Exception as e:
                logging.error(f"Error in step 2: {str(e)}")
                return jsonify({'success': False, 'message': str(e)}), 500
        
        # GET request
        selected_headers = session.get('selected_headers', [])
        return jsonify({'selected_headers': selected_headers})

    # Rules endpoint
    @app.route('/rules', methods=['GET'])
    @app.route('/api/rules', methods=['GET'])
    def get_rules():
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            
            cursor.execute("""
                SELECT rule_type_id AS rule_id, rule_name, description, parameters, is_custom, 
                       column_name, template_id, source_format, target_format, data_type, is_active
                FROM validation_rule_types
            """)
            rules = cursor.fetchall()
            cursor.close()
            
            logging.info(f"Returning {len(rules)} rules from getRules endpoint")
            return jsonify({'success': True, 'rules': rules})
        except mysql.connector.Error as e:
            logging.error(f"Database error fetching rules: {str(e)}")
            return jsonify({'success': False, 'message': str(e)}), 500
        except Exception as e:
            logging.error(f"Unexpected error fetching rules: {str(e)}")
            return jsonify({'success': False, 'message': str(e)}), 500

    # Template details endpoint
    @app.route('/template/<int:template_id>/<sheet_name>', methods=['GET'])
    @app.route('/api/template/<int:template_id>/<sheet_name>', methods=['GET'])
    def get_template(template_id, sheet_name):
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /template: session missing")
            return jsonify({'error': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("""
                SELECT template_name, sheet_name, headers
                FROM excel_templates
                WHERE template_id = %s AND user_id = %s AND status = 'ACTIVE'
            """, (template_id, session['user_id']))
            template_record = cursor.fetchone()
            
            if not template_record:
                logging.error(f"Template not found for template_id: {template_id}, user_id: {session['user_id']}")
                cursor.close()
                return jsonify({'error': 'Template not found'}), 404

            headers = json.loads(template_record['headers']) if template_record['headers'] else []
            stored_sheet_name = template_record['sheet_name'] or sheet_name
            file_path = os.path.join(app.config['UPLOAD_FOLDER'], template_record['template_name'])
            
            cursor.execute("""
                SELECT COUNT(*) as rule_count
                FROM template_columns tc
                JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                WHERE tc.template_id = %s AND tc.is_selected = TRUE
            """, (template_id,))
            rule_count = cursor.fetchone()['rule_count']
            has_existing_rules = rule_count > 0
            
            cursor.close()
            
            return jsonify({
                'success': True,
                'sheets': {stored_sheet_name: {'headers': headers}},
                'file_name': template_record['template_name'],
                'file_path': file_path,
                'sheet_name': stored_sheet_name,
                'has_existing_rules': has_existing_rules
            })
        except mysql.connector.Error as e:
            logging.error(f"Database error in get_template: {str(e)}")
            return jsonify({'error': f'Database error: {str(e)}'}), 500
        except Exception as e:
            logging.error(f"Unexpected error in get_template: {str(e)}")
            return jsonify({'error': f'Unexpected error: {str(e)}'}), 500

    # Debug route to show all registered routes
    @app.route('/debug/routes', methods=['GET'])
    def list_routes():
        routes = []
        for rule in app.url_map.iter_rules():
            routes.append({
                'endpoint': rule.endpoint,
                'methods': list(rule.methods),
                'rule': rule.rule
            })
        return jsonify(routes)

    # 404 handler to debug missing routes
    @app.errorhandler(404)
    def not_found_handler(error):
        logging.error(f"404 Error: {request.method} {request.url} not found")
        logging.error(f"Available routes: {[rule.rule for rule in app.url_map.iter_rules()]}")
        return jsonify({
            'error': 'Endpoint not found', 
            'method': request.method,
            'url': request.url,
            'path': request.path
        }), 404

    return app

def initialize_app_data():
    """Initialize database and create default data"""
    try:
        logging.info("Initializing database schema...")
        init_db()
        
        logging.info("Creating admin user...")
        create_admin_user()
        
        logging.info("Creating default validation rules...")
        create_default_validation_rules()
        
        logging.info("Application initialization completed successfully")
    except Exception as e:
        logging.error(f"Failed to initialize application: {e}")
        raise

DB_CONFIG = {
    'host': os.getenv('MYSQL_HOST', 'localhost'),
    'user': os.getenv('MYSQL_USER', 'root'),
    'password': os.getenv('MYSQL_PASSWORD', 'Keansa@2024'),
    'database': os.getenv('MYSQL_DATABASE', 'data_validation_2'),
}

def get_db_connection():
    if 'db' not in g:
        try:
            conn = mysql.connector.connect(
                host=DB_CONFIG['host'],
                user=DB_CONFIG['user'],
                password=DB_CONFIG['password']
            )
            cursor = conn.cursor()
            cursor.execute(f"CREATE DATABASE IF NOT EXISTS {DB_CONFIG['database']}")
            cursor.close()
            conn.close()
            g.db = mysql.connector.connect(**DB_CONFIG)
            logging.info("Database connection established successfully")
        except mysql.connector.Error as err:
            if err.errno == errorcode.ER_ACCESS_DENIED_ERROR:
                logging.error("Database connection failed: Access denied for user - check username/password")
            elif err.errno == errorcode.ER_BAD_DB_ERROR:
                logging.error("Database connection failed: Database does not exist")
            else:
                logging.error(f"Database connection failed: {err}")
            raise Exception(f"Failed to connect to database: {str(err)}")
    return g.db

def close_db(error):
    db = g.pop('db', None)
    if db is not None:
        db.close()

def init_db():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        tables = [
            """
            CREATE TABLE IF NOT EXISTS login_details (
                id INT AUTO_INCREMENT PRIMARY KEY,
                first_name VARCHAR(100),
                last_name VARCHAR(100),
                email VARCHAR(255) UNIQUE,
                mobile VARCHAR(10),
                password VARCHAR(255)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS excel_templates (
                template_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_name VARCHAR(255) NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
                user_id INT NOT NULL,
                sheet_name VARCHAR(255),
                headers JSON,
                status ENUM('ACTIVE', 'INACTIVE') DEFAULT 'ACTIVE',
                is_corrected BOOLEAN DEFAULT FALSE,
                remote_file_path VARCHAR(512),
                FOREIGN KEY (user_id) REFERENCES login_details(id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS template_columns (
                column_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_id BIGINT NOT NULL,
                column_name VARCHAR(255) NOT NULL,
                column_position INT NOT NULL,
                is_validation_enabled BOOLEAN DEFAULT FALSE,
                is_selected BOOLEAN DEFAULT FALSE,
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE,
                UNIQUE (template_id, column_name)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_rule_types (
                rule_type_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                rule_name VARCHAR(255) NOT NULL,
                description TEXT,
                parameters TEXT,
                is_active BOOLEAN DEFAULT TRUE,
                is_custom BOOLEAN DEFAULT FALSE,
                column_name VARCHAR(255),
                template_id BIGINT,
                data_type VARCHAR(50),
                source_format VARCHAR(50),
                target_format VARCHAR(50),
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS column_validation_rules (
                column_validation_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                column_id BIGINT NOT NULL,
                rule_type_id BIGINT NOT NULL,
                rule_config JSON,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (column_id) REFERENCES template_columns(column_id) ON DELETE CASCADE,
                FOREIGN KEY (rule_type_id) REFERENCES validation_rule_types(rule_type_id) ON DELETE RESTRICT,
                UNIQUE (column_id, rule_type_id)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_history (
                history_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_id BIGINT NOT NULL,
                template_name VARCHAR(255) NOT NULL,
                error_count INT NOT NULL,
                corrected_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                corrected_file_path VARCHAR(512) NOT NULL,
                user_id INT NOT NULL,
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE,
                FOREIGN KEY (user_id) REFERENCES login_details(id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_corrections (
                correction_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                history_id BIGINT NOT NULL,
                row_index INT NOT NULL,
                column_name VARCHAR(255) NOT NULL,
                original_value TEXT,
                corrected_value TEXT,
                rule_failed VARCHAR(255) DEFAULT NULL,
                FOREIGN KEY (history_id) REFERENCES validation_history(history_id) ON DELETE CASCADE
            )
            """
        ]
        for table_sql in tables:
            cursor.execute(table_sql)
        
        # Add missing columns if they don't exist
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'source_format'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN source_format VARCHAR(50)")
            logging.info("Added source_format column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'target_format'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN target_format VARCHAR(50)")
            logging.info("Added target_format column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'data_type'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN data_type VARCHAR(50)")
            logging.info("Added data_type column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM excel_templates LIKE 'remote_file_path'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE excel_templates ADD COLUMN remote_file_path VARCHAR(512)")
            logging.info("Added remote_file_path column to excel_templates table")
            
        cursor.execute("SHOW COLUMNS FROM template_columns LIKE 'is_selected'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE template_columns ADD COLUMN is_selected BOOLEAN DEFAULT FALSE")
            logging.info("Added is_selected column to template_columns table")
            
        conn.commit()
        cursor.close()
        logging.info("Database tables initialized")
    except Exception as e:
        logging.error(f"Failed to initialize database: {str(e)}")
        raise

def create_admin_user():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        admin_password = bcrypt.hashpw('admin'.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
        cursor.execute("""
            INSERT IGNORE INTO login_details (first_name, last_name, email, mobile, password)
            VALUES (%s, %s, %s, %s, %s)
        """, ('Admin', 'User', 'admin@example.com', '1234567890', admin_password))
        conn.commit()
        cursor.close()
        logging.info("Admin user created or already exists")
    except Exception as e:
        logging.error(f"Failed to create admin user: {str(e)}")
        raise

def create_default_validation_rules():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        default_rules = [
            ("Required", "Ensures the field is not null", '{"allow_null": false}', None, None, None),
            ("Int", "Validates integer format", '{"format": "integer"}', None, None, "Int"),
            ("Float", "Validates number format (integer or decimal)", '{"format": "float"}', None, None, "Float"),
            ("Text", "Allows text with quotes and parentheses", '{"allow_special": false}', None, None, "Text"),
            ("Email", "Validates email format", '{"regex": "^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\\\.[a-zA-Z0-9-.]+$"}', None, None, "Email"),
            ("Date(DD-MM-YYYY)", "Validates date format DD-MM-YYYY", '{"format": "%d-%m-%Y"}', "DD-MM-YYYY", None, "Date"),
            ("Boolean", "Validates boolean format (true/false or 0/1)", '{"format": "boolean"}', None, None, "Boolean"),
            ("Alphanumeric", "Validates alphanumeric format", '{"format": "alphanumeric"}', None, None, "Alphanumeric")
        ]
        cursor.executemany("""
            INSERT IGNORE INTO validation_rule_types (rule_name, description, parameters, is_custom, source_format, target_format, data_type)
            VALUES (%s, %s, %s, %s, %s, %s, %s)
        """, [(name, desc, params, False, source, target, dtype) for name, desc, params, source, target, dtype in default_rules])
        conn.commit()
        cursor.close()
        logging.info("Default validation rules ensured successfully")
    except Exception as e:
        logging.error(f"Failed to ensure default validation rules: {str(e)}")
        raise

if __name__ == '__main__':
    try:
        # Create the application using factory pattern
        app = create_app()
        
        # Initialize database and default data within app context
        with app.app_context():
            initialize_app_data()
        
        # Get port from environment or use default
        port = int(os.getenv('PORT', 5000))
        
        # Start the application server
        logging.info("Starting Flask server...")
        app.run(debug=True, host='0.0.0.0', port=port)
        
    except Exception as e:
        logging.error(f"Failed to start application: {e}")
        raise
).all():
        return "Alphanumeric"
    
    return "Text"

def assign_default_rules_to_columns(df, headers):
    """Intelligently assign validation rules based on column content"""
    assignments = {}
    
    for col in headers:
        if col not in df.columns:
            logging.warning(f"Column {col} not found in dataframe")
            continue
            
        col_type = detect_column_type(df[col])
        rules = ["Required"]  # Default rule for all columns
        
        # Special handling for optional columns
        if not any(col.lower().startswith(prefix) for prefix in
                  ["name", "address", "phone", "username", "status", "period"]):
            rules.append(col_type)
        else:
            rules.append("Text")  # Optional text fields
        
        assignments[col] = rules
    
    return assignments

def create_app():
    """Application factory pattern for different environments"""
    # Set the path to the frontend dist folder
    current_dir = os.path.dirname(os.path.abspath(__file__))
    frontend_dist_path = os.path.join(current_dir, '..', '..', 'Keansa-Ai-Suite2025may-frontend11', 'dist')
    frontend_dist_path = os.path.abspath(frontend_dist_path)
    
    # Create Flask application instance
    app = Flask(__name__, static_folder=frontend_dist_path, static_url_path='')
    CORS(app, supports_credentials=True, origins=["http://localhost:3000", "http://localhost:8080", "http://localhost:5000", "*"])

    app.secret_key = os.urandom(24).hex()
    app.config['SESSION_TYPE'] = 'filesystem'
    app.config['SESSION_FILE_DIR'] = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'sessions')
    app.config['SESSION_COOKIE_SAMESITE'] = 'Lax'
    app.config['SESSION_COOKIE_HTTPONLY'] = True
    app.config['SESSION_COOKIE_SECURE'] = False
    app.config['PERMANENT_SESSION_LIFETIME'] = 86400  # 24 hours
    app.config['UPLOAD_FOLDER'] = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'uploads')
    Session(app)

    # Ensure directories exist
    try:
        os.makedirs(app.config['UPLOAD_FOLDER'], exist_ok=True)
        os.makedirs(app.config['SESSION_FILE_DIR'], exist_ok=True)
    except OSError as e:
        logging.error(f"Failed to create directories: {e}")

    # Register cleanup handlers
    app.teardown_appcontext(close_db)
    
    # Register all routes directly in create_app
    
    # Static file serving for React frontend
    @app.route('/', defaults={'path': ''})
    @app.route('/<path:path>')
    def serve(path):
        if path and os.path.exists(os.path.join(app.static_folder, path)):
            return app.send_static_file(path)
        return app.send_static_file('index.html')

    # Health check endpoint
    @app.route('/health', methods=['GET'])
    def health_check():
        return jsonify({
            'status': 'healthy',
            'timestamp': datetime.now().isoformat(),
            'version': '2.0.0'
        })

    # Authentication endpoint - both old and new paths
    @app.route('/authenticate', methods=['POST'])
    @app.route('/api/auth/authenticate', methods=['POST'])
    def authenticate():
        try:
            email = request.form.get('username') or request.form.get('email')
            password = request.form.get('password')
            logging.debug(f"Login attempt: email={email}, password={'*' * len(password) if password else 'None'}")
            
            if not email or not password:
                logging.warning(f"Login failed: Email or password missing")
                return jsonify({'success': False, 'message': 'Email and password are required'}), 400

            # Check for admin login
            if email == "admin" and password == "admin":
                session['loggedin'] = True
                session['user_email'] = "admin@example.com"
                session['user_id'] = 1
                session.permanent = True
                logging.info(f"Admin login successful. Session: {dict(session)}")
                return jsonify({'success': True, 'message': 'Login successful', 'user': {'email': 'admin@example.com', 'id': 1}}), 200

            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("SELECT * FROM login_details WHERE LOWER(email) = LOWER(%s)", (email.lower(),))
            account = cursor.fetchone()
            cursor.close()
            
            if account:
                if bcrypt.checkpw(password.encode('utf-8'), account['password'].encode('utf-8')):
                    session['loggedin'] = True
                    session['user_email'] = account['email']
                    session['user_id'] = account['id']
                    session.permanent = True
                    logging.info(f"User {email} logged in successfully. Session: {dict(session)}")
                    return jsonify({
                        'success': True,
                        'message': 'Login successful',
                        'user': {'email': account['email'], 'id': account['id']}
                    }), 200
                else:
                    logging.warning(f"Invalid password for {email}")
                    return jsonify({'success': False, 'message': 'Invalid credentials'}), 401
            else:
                logging.warning(f"Email {email} not found")
                return jsonify({'success': False, 'message': 'Invalid credentials'}), 401
        except Exception as e:
            logging.error(f"Unexpected error during login: {str(e)}")
            return jsonify({'success': False, 'message': f'Unexpected error: {str(e)}'}), 500

    @app.route('/check-auth', methods=['GET'])
    @app.route('/api/auth/check-auth', methods=['GET'])
    def check_auth():
        try:
            logging.debug(f"Checking auth with session: {dict(session)}")
            if 'loggedin' in session and 'user_id' in session:
                conn = get_db_connection()
                cursor = conn.cursor(dictionary=True)
                cursor.execute("SELECT email, first_name FROM login_details WHERE id = %s", (session['user_id'],))
                user = cursor.fetchone()
                cursor.close()
                if user:
                    logging.info(f"User {session.get('user_email')} is authenticated")
                    return jsonify({
                        'success': True,
                        'user': {
                            'email': user['email'],
                            'id': session['user_id'],
                            'first_name': user['first_name']
                        }
                    })
                else:
                    logging.warning("User not found in database")  
                    session.clear()
                    return jsonify({'success': False, 'message': 'User not found'}), 401
            logging.warning("User not authenticated")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        except Exception as e:
            logging.error(f"Error in check-auth endpoint: {str(e)}")
            return jsonify({'success': False, 'message': f'Server error: {str(e)}'}), 500

    @app.route('/register', methods=['POST'])
    @app.route('/api/auth/register', methods=['POST'])
    def register():
        first_name = request.form.get('first_name')
        last_name = request.form.get('last_name')
        email = request.form.get('email')
        mobile = request.form.get('mobile')
        password = request.form.get('password')
        confirm_password = request.form.get('confirm_password')

        if not all([first_name, last_name, email, mobile, password, confirm_password]):
            return jsonify({'success': False, 'message': 'All fields are required'}), 400
        if password != confirm_password:
            return jsonify({'success': False, 'message': 'Passwords do not match'}), 400

        hashed_password = bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
        try:
            conn = get_db_connection()
            cursor = conn.cursor()
            cursor.execute("""
                INSERT INTO login_details (first_name, last_name, email, mobile, password)
                VALUES (%s, %s, %s, %s, %s)
            """, (first_name, last_name, email, mobile, hashed_password))
            user_id = cursor.lastrowid
            conn.commit()
            cursor.close()
            session['loggedin'] = True
            session['user_email'] = email
            session['user_id'] = user_id
            return jsonify({
                'success': True,
                'message': 'Registration successful',
                'user': {'email': email, 'id': user_id}
            }), 200
        except mysql.connector.Error as e:
            logging.error(f"Database error during registration: {str(e)}")
            return jsonify({'success': False, 'message': f'Registration error: {str(e)}'}), 500

    @app.route('/logout', methods=['POST'])
    @app.route('/api/auth/logout', methods=['POST'])
    def logout():
        logging.info(f"User {session.get('user_email', 'unknown')} logged out")
        session.clear()
        return jsonify({'success': True, 'message': 'Logged out successfully'})

    # Template routes
    @app.route('/templates', methods=['GET'])
    @app.route('/api/templates', methods=['GET'])
    def get_templates():
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /templates: session missing")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("""
                SELECT template_id, template_name, created_at, status
                FROM excel_templates
                WHERE user_id = %s AND status = 'ACTIVE'
                ORDER BY created_at DESC
                LIMIT 100
            """, (session['user_id'],))
            templates = cursor.fetchall()
            cursor.close()
            logging.info(f"Fetched {len(templates)} templates for user {session['user_id']}")
            return jsonify({'success': True, 'templates': templates})
        except mysql.connector.Error as e:
            logging.error(f'Error fetching templates: {str(e)}')
            return jsonify({'success': False, 'message': f'Error fetching templates: {str(e)}'}), 500
        except Exception as e:
            logging.error(f'Unexpected error fetching templates: {str(e)}')
            return jsonify({'success': False, 'message': f'Unexpected error: {str(e)}'}), 500

    # Rule Configuration routes
    @app.route('/rule-configurations', methods=['GET'])
    @app.route('/api/validation/rule-configurations', methods=['GET'])
    def get_rule_configurations():
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning(f"Unauthorized access to /rule-configurations: session={dict(session)}")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            user_id = session['user_id']
            logging.debug(f"Fetching rule configurations for user_id: {user_id}")

            # Main query to fetch templates with configured rules
            cursor.execute("""
                SELECT 
                    t.template_id, 
                    t.template_name, 
                    t.created_at, 
                    COUNT(cvr.column_validation_id) as rule_count
                FROM excel_templates t
                LEFT JOIN template_columns tc ON t.template_id = tc.template_id
                LEFT JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                WHERE t.user_id = %s AND t.status = 'ACTIVE' AND t.is_corrected = FALSE
                GROUP BY t.template_id, t.template_name, t.created_at
                HAVING rule_count > 0
                ORDER BY t.created_at DESC
                LIMIT 100
            """, (user_id,))
            templates = cursor.fetchall()
            logging.debug(f"Fetched rule-configured templates: {templates}")

            cursor.close()

            if not templates:
                logging.info(f"No templates with rules found for user_id: {user_id}")
            else:
                logging.info(f"Found {len(templates)} templates with rules for user_id: {user_id}")

            return jsonify({'success': True, 'templates': templates})
        except mysql.connector.Error as e:
            logging.error(f"Database error fetching rule configurations: {str(e)}")
            return jsonify({'success': False, 'message': f"Database error: {str(e)}"}), 500
        except Exception as e:
            logging.error(f"Unexpected error fetching rule configurations: {str(e)}")
            return jsonify({'success': False, 'message': f"Unexpected error: {str(e)}"}), 500

    # File upload route
    @app.route('/upload', methods=['POST'])
    @app.route('/api/templates/upload', methods=['POST'])
    @app.route('/api/upload', methods=['POST'])  # Additional common path
    def upload():
        logging.info(f"Upload endpoint called: {request.endpoint}, method: {request.method}")
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /upload: session missing")
            return jsonify({'error': 'Not logged in'}), 401
        if 'file' not in request.files:
            logging.warning("No file provided in upload request")
            return jsonify({'error': 'No file uploaded'}), 400
        file = request.files['file']
        if file.filename == '':
            logging.warning("No file selected in upload request")
            return jsonify({'error': 'No file selected'}), 400
        
        file_path = os.path.join(app.config['UPLOAD_FOLDER'], file.filename)
        try:
            file.save(file_path)
            logging.info(f"File saved: {file_path}")
        except Exception as e:
            logging.error(f"Failed to save file {file.filename}: {str(e)}")
            return jsonify({'error': f'Failed to save file: {str(e)}'}), 500

        try:
            # Read the file to get sheets and headers
            if file.filename.endswith('.xlsx') or file.filename.endswith('.xls'):
                xl = pd.ExcelFile(file_path)
                sheets = {sheet_name: pd.read_excel(file_path, sheet_name=sheet_name, header=None) 
                         for sheet_name in xl.sheet_names}
            elif file.filename.endswith(('.txt', '.csv', '.dat')):
                df = pd.read_csv(file_path, header=None, encoding='utf-8')
                sheets = {'Sheet1': df}
            else:
                logging.error("Unsupported file type")
                return jsonify({'error': 'Unsupported file type'}), 400
            
            logging.debug(f"Sheets extracted: {list(sheets.keys())}")
        except Exception as e:
            logging.error(f"Failed to read file {file_path}: {str(e)}")
            return jsonify({'error': f'Failed to read file: {str(e)}'}), 400

        try:
            sheet_names = list(sheets.keys())
            if not sheet_names:
                logging.error("No sheets found in the file")
                return jsonify({'error': 'No sheets found in the file'}), 400
            sheet_name = sheet_names[0]
            df = sheets[sheet_name]
            
            # Find header row
            header_row = 0
            for i in range(min(len(df), 10)):
                row = df.iloc[i].dropna()
                if not row.empty and all(isinstance(x, str) for x in row if pd.notna(x)):
                    header_row = i
                    break
                    
            headers = df.iloc[header_row].tolist()
            logging.debug(f"Headers extracted: {headers}")
            
            if not headers or all(not h for h in headers):
                logging.error("No valid headers found in file")
                return jsonify({'error': 'No valid headers found in the file'}), 400
        except Exception as e:
            logging.error(f"Error processing file {file.filename}: {str(e)}")
            return jsonify({'error': f'Error processing file: {str(e)}'}), 400

        # Clear existing session data
        for key in ['df', 'header_row', 'headers', 'sheet_name', 'current_step', 'selected_headers', 'validations', 'error_cell_locations', 'data_rows', 'corrected_file_path']:
            session.pop(key, None)

        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)

            # Check if template exists
            cursor.execute("""
                SELECT template_id, headers, sheet_name
                FROM excel_templates
                WHERE template_name = %s AND user_id = %s AND status = 'ACTIVE'
                ORDER BY created_at DESC
            """, (file.filename, session['user_id']))
            existing_templates = cursor.fetchall()
            logging.info(f"Found {len(existing_templates)} existing templates with name {file.filename}")

            template_id = None
            has_existing_rules = False
            validations = {}
            selected_headers = []

            # Check for matching template
            matching_template = None
            for template in existing_templates:
                stored_headers = json.loads(template['headers']) if template['headers'] else []
                stored_sheet_name = template['sheet_name']
                if stored_headers == headers and stored_sheet_name == sheet_name:
                    matching_template = template
                    break

            if matching_template:
                template_id = matching_template['template_id']
                # Check for existing rules
                cursor.execute("""
                    SELECT tc.column_name, vrt.rule_name
                    FROM template_columns tc
                    JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                    JOIN validation_rule_types vrt ON cvr.rule_type_id = vrt.rule_type_id
                    WHERE tc.template_id = %s AND tc.is_selected = TRUE
                """, (template_id,))
                rules_data = cursor.fetchall()
                for row in rules_data:
                    column_name = row['column_name']
                    rule_name = row['rule_name']
                    if column_name not in validations:
                        validations[column_name] = []
                    validations[column_name].append(rule_name)
                    if column_name not in selected_headers:
                        selected_headers.append(column_name)
                has_existing_rules = len(validations) > 0
            else:
                # New template
                cursor.execute("""
                    INSERT INTO excel_templates (template_name, user_id, sheet_name, headers, is_corrected)
                    VALUES (%s, %s, %s, %s, %s)
                """, (file.filename, session['user_id'], sheet_name, json.dumps(headers), False))
                template_id = cursor.lastrowid
                column_data = [(template_id, header, i + 1, False) for i, header in enumerate(headers)]
                cursor.executemany("""
                    INSERT INTO template_columns (template_id, column_name, column_position, is_selected)
                    VALUES (%s, %s, %s, %s)
                """, column_data)

            conn.commit()
            cursor.close()

            # Store session data
            session['file_path'] = file_path
            session['template_id'] = template_id
            session['df'] = df.to_json()
            session['header_row'] = header_row
            session['headers'] = headers
            session['sheet_name'] = sheet_name
            session['current_step'] = 1 if not has_existing_rules else 3
            session['validations'] = validations
            session['selected_headers'] = selected_headers
            session['has_existing_rules'] = has_existing_rules

            logging.info(f"Upload processed: template_id={template_id}, filename={file.filename}, has_existing_rules={has_existing_rules}")

            return jsonify({
                'success': True,
                'sheets': {sheet_name: {'headers': headers}},
                'file_name': file.filename,
                'template_id': template_id,
                'has_existing_rules': has_existing_rules,
                'sheet_name': sheet_name,
                'skip_to_step_3': has_existing_rules
            })
        except mysql.connector.Error as e:
            logging.error(f'Error saving template: {str(e)}')
            return jsonify({'error': f'Error saving template: {str(e)}'}), 500
        except Exception as e:
            logging.error(f'Unexpected error saving template: {str(e)}')
            return jsonify({'error': f'Unexpected error: {str(e)}'}), 500

    # Multi-step workflow endpoints
    @app.route('/step/1', methods=['GET', 'POST'])
    @app.route('/api/step/1', methods=['GET', 'POST'])
    def step_one():
        if 'loggedin' not in session:
            return jsonify({'error': 'Not logged in'}), 401
        
        if request.method == 'POST':
            try:
                headers = request.form.getlist('headers')
                new_header_row = request.form.get('new_header_row')
                logging.debug(f"Step 1 submitted: headers={headers}, new_header_row={new_header_row}")
                
                if not headers:
                    logging.error("No headers provided in step 1")
                    return jsonify({'success': False, 'message': 'No headers provided'}), 400
                    
                if 'template_id' not in session:
                    logging.error("Session missing template_id")
                    return jsonify({'success': False, 'message': 'Session data missing'}), 400

                template_id = session['template_id']
                
                # Get the dataframe from session for auto-detection
                df_json = session.get('df')
                if df_json:
                    df = pd.read_json(StringIO(df_json))
                    session_headers = session.get('headers', [])
                    df.columns = session_headers
                    header_row = session.get('header_row', 0)
                    df = df.iloc[header_row + 1:].reset_index(drop=True)
                    
                    # Auto-detect rules for selected headers
                    validations = assign_default_rules_to_columns(df, headers)
                    session['validations'] = validations
                    logging.debug(f"Auto-assigned rules: {validations}")
                else:
                    validations = {}

                session['selected_headers'] = headers
                session['current_step'] = 2

                # Mark selected headers in the database
                conn = get_db_connection()
                cursor = conn.cursor()
                cursor.execute("UPDATE template_columns SET is_selected = FALSE WHERE template_id = %s", (template_id,))
                for header in headers:
                    cursor.execute("""
                        UPDATE template_columns
                        SET is_selected = TRUE
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    
                    # Get column_id and add auto-detected rules
                    cursor.execute("""
                        SELECT column_id FROM template_columns
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    result = cursor.fetchone()
                    if result:
                        column_id = result[0]
                        for rule_name in validations.get(header, []):
                            cursor.execute("""
                                SELECT rule_type_id FROM validation_rule_types
                                WHERE rule_name = %s AND is_custom = FALSE
                            """, (rule_name,))
                            rule_result = cursor.fetchone()
                            if rule_result:
                                rule_type_id = rule_result[0]
                                cursor.execute("""
                                    INSERT IGNORE INTO column_validation_rules (column_id, rule_type_id, rule_config)
                                    VALUES (%s, %s, %s)
                                """, (column_id, rule_type_id, '{}'))
                
                conn.commit()
                cursor.close()

                logging.info(f"Step 1 completed: headers={headers}, auto-assigned rules={validations}")
                return jsonify({'success': True, 'headers': headers, 'validations': validations})
            except Exception as e:
                logging.error(f"Error in step 1: {str(e)}")
                return jsonify({'success': False, 'message': str(e)}), 500
        
        # GET request - return current headers
        headers = session.get('headers', [])
        return jsonify({'headers': headers})

    @app.route('/step/2', methods=['GET', 'POST'])
    @app.route('/api/step/2', methods=['GET', 'POST'])
    def step_two():
        if 'loggedin' not in session:
            return jsonify({'error': 'Not logged in'}), 401
            
        if request.method == 'POST':
            try:
                action = request.form.get('action', 'save')
                validations = {}
                for key, values in request.form.lists():
                    if key.startswith('validations_'):
                        header = key.replace('validations_', '')
                        validations[header] = values
                        
                logging.debug(f"Step 2 submitted: action={action}, validations={validations}")
                
                template_id = session.get('template_id')
                if not template_id:
                    return jsonify({'success': False, 'message': 'Session data missing'}), 400

                # Save validations to database
                conn = get_db_connection()
                cursor = conn.cursor()
                
                # Clear existing rules
                cursor.execute("""
                    DELETE FROM column_validation_rules
                    WHERE column_id IN (
                        SELECT column_id FROM template_columns WHERE template_id = %s
                    )
                """, (template_id,))
                
                # Add new rules
                for header, rules in validations.items():
                    cursor.execute("""
                        SELECT column_id FROM template_columns
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    result = cursor.fetchone()
                    if not result:
                        continue
                    column_id = result[0]
                    
                    for rule_name in rules:
                        cursor.execute("""
                            SELECT rule_type_id FROM validation_rule_types
                            WHERE rule_name = %s
                        """, (rule_name,))
                        result = cursor.fetchone()
                        if result:
                            rule_type_id = result[0]
                            cursor.execute("""
                                INSERT IGNORE INTO column_validation_rules (column_id, rule_type_id, rule_config)
                                VALUES (%s, %s, %s)
                            """, (column_id, rule_type_id, '{}'))
                
                conn.commit()
                cursor.close()

                session['validations'] = validations
                session['current_step'] = 3 if action == 'review' else 2
                
                logging.info(f"Step 2 completed: action={action}, validations={validations}")
                return jsonify({'success': True, 'message': 'Step 2 completed successfully'})
            except Exception as e:
                logging.error(f"Error in step 2: {str(e)}")
                return jsonify({'success': False, 'message': str(e)}), 500
        
        # GET request
        selected_headers = session.get('selected_headers', [])
        return jsonify({'selected_headers': selected_headers})

    # Rules endpoint
    @app.route('/rules', methods=['GET'])
    @app.route('/api/rules', methods=['GET'])
    def get_rules():
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            
            cursor.execute("""
                SELECT rule_type_id AS rule_id, rule_name, description, parameters, is_custom, 
                       column_name, template_id, source_format, target_format, data_type, is_active
                FROM validation_rule_types
            """)
            rules = cursor.fetchall()
            cursor.close()
            
            logging.info(f"Returning {len(rules)} rules from getRules endpoint")
            return jsonify({'success': True, 'rules': rules})
        except mysql.connector.Error as e:
            logging.error(f"Database error fetching rules: {str(e)}")
            return jsonify({'success': False, 'message': str(e)}), 500
        except Exception as e:
            logging.error(f"Unexpected error fetching rules: {str(e)}")
            return jsonify({'success': False, 'message': str(e)}), 500

    # Template details endpoint
    @app.route('/template/<int:template_id>/<sheet_name>', methods=['GET'])
    @app.route('/api/template/<int:template_id>/<sheet_name>', methods=['GET'])
    def get_template(template_id, sheet_name):
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /template: session missing")
            return jsonify({'error': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("""
                SELECT template_name, sheet_name, headers
                FROM excel_templates
                WHERE template_id = %s AND user_id = %s AND status = 'ACTIVE'
            """, (template_id, session['user_id']))
            template_record = cursor.fetchone()
            
            if not template_record:
                logging.error(f"Template not found for template_id: {template_id}, user_id: {session['user_id']}")
                cursor.close()
                return jsonify({'error': 'Template not found'}), 404

            headers = json.loads(template_record['headers']) if template_record['headers'] else []
            stored_sheet_name = template_record['sheet_name'] or sheet_name
            file_path = os.path.join(app.config['UPLOAD_FOLDER'], template_record['template_name'])
            
            cursor.execute("""
                SELECT COUNT(*) as rule_count
                FROM template_columns tc
                JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                WHERE tc.template_id = %s AND tc.is_selected = TRUE
            """, (template_id,))
            rule_count = cursor.fetchone()['rule_count']
            has_existing_rules = rule_count > 0
            
            cursor.close()
            
            return jsonify({
                'success': True,
                'sheets': {stored_sheet_name: {'headers': headers}},
                'file_name': template_record['template_name'],
                'file_path': file_path,
                'sheet_name': stored_sheet_name,
                'has_existing_rules': has_existing_rules
            })
        except mysql.connector.Error as e:
            logging.error(f"Database error in get_template: {str(e)}")
            return jsonify({'error': f'Database error: {str(e)}'}), 500
        except Exception as e:
            logging.error(f"Unexpected error in get_template: {str(e)}")
            return jsonify({'error': f'Unexpected error: {str(e)}'}), 500

    # Debug route to show all registered routes
    @app.route('/debug/routes', methods=['GET'])
    def list_routes():
        routes = []
        for rule in app.url_map.iter_rules():
            routes.append({
                'endpoint': rule.endpoint,
                'methods': list(rule.methods),
                'rule': rule.rule
            })
        return jsonify(routes)

    # 404 handler to debug missing routes
    @app.errorhandler(404)
    def not_found_handler(error):
        logging.error(f"404 Error: {request.method} {request.url} not found")
        logging.error(f"Available routes: {[rule.rule for rule in app.url_map.iter_rules()]}")
        return jsonify({
            'error': 'Endpoint not found', 
            'method': request.method,
            'url': request.url,
            'path': request.path
        }), 404

    return app

def initialize_app_data():
    """Initialize database and create default data"""
    try:
        logging.info("Initializing database schema...")
        init_db()
        
        logging.info("Creating admin user...")
        create_admin_user()
        
        logging.info("Creating default validation rules...")
        create_default_validation_rules()
        
        logging.info("Application initialization completed successfully")
    except Exception as e:
        logging.error(f"Failed to initialize application: {e}")
        raise

DB_CONFIG = {
    'host': os.getenv('MYSQL_HOST', 'localhost'),
    'user': os.getenv('MYSQL_USER', 'root'),
    'password': os.getenv('MYSQL_PASSWORD', 'Keansa@2024'),
    'database': os.getenv('MYSQL_DATABASE', 'data_validation_2'),
}

def get_db_connection():
    if 'db' not in g:
        try:
            conn = mysql.connector.connect(
                host=DB_CONFIG['host'],
                user=DB_CONFIG['user'],
                password=DB_CONFIG['password']
            )
            cursor = conn.cursor()
            cursor.execute(f"CREATE DATABASE IF NOT EXISTS {DB_CONFIG['database']}")
            cursor.close()
            conn.close()
            g.db = mysql.connector.connect(**DB_CONFIG)
            logging.info("Database connection established successfully")
        except mysql.connector.Error as err:
            if err.errno == errorcode.ER_ACCESS_DENIED_ERROR:
                logging.error("Database connection failed: Access denied for user - check username/password")
            elif err.errno == errorcode.ER_BAD_DB_ERROR:
                logging.error("Database connection failed: Database does not exist")
            else:
                logging.error(f"Database connection failed: {err}")
            raise Exception(f"Failed to connect to database: {str(err)}")
    return g.db

def close_db(error):
    db = g.pop('db', None)
    if db is not None:
        db.close()

def init_db():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        tables = [
            """
            CREATE TABLE IF NOT EXISTS login_details (
                id INT AUTO_INCREMENT PRIMARY KEY,
                first_name VARCHAR(100),
                last_name VARCHAR(100),
                email VARCHAR(255) UNIQUE,
                mobile VARCHAR(10),
                password VARCHAR(255)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS excel_templates (
                template_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_name VARCHAR(255) NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
                user_id INT NOT NULL,
                sheet_name VARCHAR(255),
                headers JSON,
                status ENUM('ACTIVE', 'INACTIVE') DEFAULT 'ACTIVE',
                is_corrected BOOLEAN DEFAULT FALSE,
                remote_file_path VARCHAR(512),
                FOREIGN KEY (user_id) REFERENCES login_details(id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS template_columns (
                column_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_id BIGINT NOT NULL,
                column_name VARCHAR(255) NOT NULL,
                column_position INT NOT NULL,
                is_validation_enabled BOOLEAN DEFAULT FALSE,
                is_selected BOOLEAN DEFAULT FALSE,
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE,
                UNIQUE (template_id, column_name)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_rule_types (
                rule_type_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                rule_name VARCHAR(255) NOT NULL,
                description TEXT,
                parameters TEXT,
                is_active BOOLEAN DEFAULT TRUE,
                is_custom BOOLEAN DEFAULT FALSE,
                column_name VARCHAR(255),
                template_id BIGINT,
                data_type VARCHAR(50),
                source_format VARCHAR(50),
                target_format VARCHAR(50),
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS column_validation_rules (
                column_validation_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                column_id BIGINT NOT NULL,
                rule_type_id BIGINT NOT NULL,
                rule_config JSON,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (column_id) REFERENCES template_columns(column_id) ON DELETE CASCADE,
                FOREIGN KEY (rule_type_id) REFERENCES validation_rule_types(rule_type_id) ON DELETE RESTRICT,
                UNIQUE (column_id, rule_type_id)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_history (
                history_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_id BIGINT NOT NULL,
                template_name VARCHAR(255) NOT NULL,
                error_count INT NOT NULL,
                corrected_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                corrected_file_path VARCHAR(512) NOT NULL,
                user_id INT NOT NULL,
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE,
                FOREIGN KEY (user_id) REFERENCES login_details(id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_corrections (
                correction_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                history_id BIGINT NOT NULL,
                row_index INT NOT NULL,
                column_name VARCHAR(255) NOT NULL,
                original_value TEXT,
                corrected_value TEXT,
                rule_failed VARCHAR(255) DEFAULT NULL,
                FOREIGN KEY (history_id) REFERENCES validation_history(history_id) ON DELETE CASCADE
            )
            """
        ]
        for table_sql in tables:
            cursor.execute(table_sql)
        
        # Add missing columns if they don't exist
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'source_format'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN source_format VARCHAR(50)")
            logging.info("Added source_format column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'target_format'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN target_format VARCHAR(50)")
            logging.info("Added target_format column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'data_type'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN data_type VARCHAR(50)")
            logging.info("Added data_type column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM excel_templates LIKE 'remote_file_path'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE excel_templates ADD COLUMN remote_file_path VARCHAR(512)")
            logging.info("Added remote_file_path column to excel_templates table")
            
        cursor.execute("SHOW COLUMNS FROM template_columns LIKE 'is_selected'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE template_columns ADD COLUMN is_selected BOOLEAN DEFAULT FALSE")
            logging.info("Added is_selected column to template_columns table")
            
        conn.commit()
        cursor.close()
        logging.info("Database tables initialized")
    except Exception as e:
        logging.error(f"Failed to initialize database: {str(e)}")
        raise

def create_admin_user():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        admin_password = bcrypt.hashpw('admin'.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
        cursor.execute("""
            INSERT IGNORE INTO login_details (first_name, last_name, email, mobile, password)
            VALUES (%s, %s, %s, %s, %s)
        """, ('Admin', 'User', 'admin@example.com', '1234567890', admin_password))
        conn.commit()
        cursor.close()
        logging.info("Admin user created or already exists")
    except Exception as e:
        logging.error(f"Failed to create admin user: {str(e)}")
        raise

def create_default_validation_rules():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        default_rules = [
            ("Required", "Ensures the field is not null", '{"allow_null": false}', None, None, None),
            ("Int", "Validates integer format", '{"format": "integer"}', None, None, "Int"),
            ("Float", "Validates number format (integer or decimal)", '{"format": "float"}', None, None, "Float"),
            ("Text", "Allows text with quotes and parentheses", '{"allow_special": false}', None, None, "Text"),
            ("Email", "Validates email format", '{"regex": "^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\\\.[a-zA-Z0-9-.]+$"}', None, None, "Email"),
            ("Date(DD-MM-YYYY)", "Validates date format DD-MM-YYYY", '{"format": "%d-%m-%Y"}', "DD-MM-YYYY", None, "Date"),
            ("Boolean", "Validates boolean format (true/false or 0/1)", '{"format": "boolean"}', None, None, "Boolean"),
            ("Alphanumeric", "Validates alphanumeric format", '{"format": "alphanumeric"}', None, None, "Alphanumeric")
        ]
        cursor.executemany("""
            INSERT IGNORE INTO validation_rule_types (rule_name, description, parameters, is_custom, source_format, target_format, data_type)
            VALUES (%s, %s, %s, %s, %s, %s, %s)
        """, [(name, desc, params, False, source, target, dtype) for name, desc, params, source, target, dtype in default_rules])
        conn.commit()
        cursor.close()
        logging.info("Default validation rules ensured successfully")
    except Exception as e:
        logging.error(f"Failed to ensure default validation rules: {str(e)}")
        raise

if __name__ == '__main__':
    try:
        # Create the application using factory pattern
        app = create_app()
        
        # Initialize database and default data within app context
        with app.app_context():
            initialize_app_data()
        
        # Get port from environment or use default
        port = int(os.getenv('PORT', 5000))
        
        # Start the application server
        logging.info("Starting Flask server...")
        app.run(debug=True, host='0.0.0.0', port=port)
        
    except Exception as e:
        logging.error(f"Failed to start application: {e}")
        raise
).any():
        return "Email"

def create_app():
    """Application factory pattern for different environments"""
    # Set the path to the frontend dist folder
    current_dir = os.path.dirname(os.path.abspath(__file__))
    frontend_dist_path = os.path.join(current_dir, '..', '..', 'Keansa-Ai-Suite2025may-frontend11', 'dist')
    frontend_dist_path = os.path.abspath(frontend_dist_path)
    
    # Create Flask application instance
    app = Flask(__name__, static_folder=frontend_dist_path, static_url_path='')
    CORS(app, supports_credentials=True, origins=["http://localhost:3000", "http://localhost:8080", "http://localhost:5000", "*"])

    app.secret_key = os.urandom(24).hex()
    app.config['SESSION_TYPE'] = 'filesystem'
    app.config['SESSION_FILE_DIR'] = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'sessions')
    app.config['SESSION_COOKIE_SAMESITE'] = 'Lax'
    app.config['SESSION_COOKIE_HTTPONLY'] = True
    app.config['SESSION_COOKIE_SECURE'] = False
    app.config['PERMANENT_SESSION_LIFETIME'] = 86400  # 24 hours
    app.config['UPLOAD_FOLDER'] = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'uploads')
    Session(app)

    # Ensure directories exist
    try:
        os.makedirs(app.config['UPLOAD_FOLDER'], exist_ok=True)
        os.makedirs(app.config['SESSION_FILE_DIR'], exist_ok=True)
    except OSError as e:
        logging.error(f"Failed to create directories: {e}")

    # Register cleanup handlers
    app.teardown_appcontext(close_db)
    
    # Register all routes directly in create_app
    
    # Static file serving for React frontend
    @app.route('/', defaults={'path': ''})
    @app.route('/<path:path>')
    def serve(path):
        if path and os.path.exists(os.path.join(app.static_folder, path)):
            return app.send_static_file(path)
        return app.send_static_file('index.html')

    # Health check endpoint
    @app.route('/health', methods=['GET'])
    def health_check():
        return jsonify({
            'status': 'healthy',
            'timestamp': datetime.now().isoformat(),
            'version': '2.0.0'
        })

    # Authentication endpoint - both old and new paths
    @app.route('/authenticate', methods=['POST'])
    @app.route('/api/auth/authenticate', methods=['POST'])
    def authenticate():
        try:
            email = request.form.get('username') or request.form.get('email')
            password = request.form.get('password')
            logging.debug(f"Login attempt: email={email}, password={'*' * len(password) if password else 'None'}")
            
            if not email or not password:
                logging.warning(f"Login failed: Email or password missing")
                return jsonify({'success': False, 'message': 'Email and password are required'}), 400

            # Check for admin login
            if email == "admin" and password == "admin":
                session['loggedin'] = True
                session['user_email'] = "admin@example.com"
                session['user_id'] = 1
                session.permanent = True
                logging.info(f"Admin login successful. Session: {dict(session)}")
                return jsonify({'success': True, 'message': 'Login successful', 'user': {'email': 'admin@example.com', 'id': 1}}), 200

            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("SELECT * FROM login_details WHERE LOWER(email) = LOWER(%s)", (email.lower(),))
            account = cursor.fetchone()
            cursor.close()
            
            if account:
                if bcrypt.checkpw(password.encode('utf-8'), account['password'].encode('utf-8')):
                    session['loggedin'] = True
                    session['user_email'] = account['email']
                    session['user_id'] = account['id']
                    session.permanent = True
                    logging.info(f"User {email} logged in successfully. Session: {dict(session)}")
                    return jsonify({
                        'success': True,
                        'message': 'Login successful',
                        'user': {'email': account['email'], 'id': account['id']}
                    }), 200
                else:
                    logging.warning(f"Invalid password for {email}")
                    return jsonify({'success': False, 'message': 'Invalid credentials'}), 401
            else:
                logging.warning(f"Email {email} not found")
                return jsonify({'success': False, 'message': 'Invalid credentials'}), 401
        except Exception as e:
            logging.error(f"Unexpected error during login: {str(e)}")
            return jsonify({'success': False, 'message': f'Unexpected error: {str(e)}'}), 500

    @app.route('/check-auth', methods=['GET'])
    @app.route('/api/auth/check-auth', methods=['GET'])
    def check_auth():
        try:
            logging.debug(f"Checking auth with session: {dict(session)}")
            if 'loggedin' in session and 'user_id' in session:
                conn = get_db_connection()
                cursor = conn.cursor(dictionary=True)
                cursor.execute("SELECT email, first_name FROM login_details WHERE id = %s", (session['user_id'],))
                user = cursor.fetchone()
                cursor.close()
                if user:
                    logging.info(f"User {session.get('user_email')} is authenticated")
                    return jsonify({
                        'success': True,
                        'user': {
                            'email': user['email'],
                            'id': session['user_id'],
                            'first_name': user['first_name']
                        }
                    })
                else:
                    logging.warning("User not found in database")  
                    session.clear()
                    return jsonify({'success': False, 'message': 'User not found'}), 401
            logging.warning("User not authenticated")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        except Exception as e:
            logging.error(f"Error in check-auth endpoint: {str(e)}")
            return jsonify({'success': False, 'message': f'Server error: {str(e)}'}), 500

    @app.route('/register', methods=['POST'])
    @app.route('/api/auth/register', methods=['POST'])
    def register():
        first_name = request.form.get('first_name')
        last_name = request.form.get('last_name')
        email = request.form.get('email')
        mobile = request.form.get('mobile')
        password = request.form.get('password')
        confirm_password = request.form.get('confirm_password')

        if not all([first_name, last_name, email, mobile, password, confirm_password]):
            return jsonify({'success': False, 'message': 'All fields are required'}), 400
        if password != confirm_password:
            return jsonify({'success': False, 'message': 'Passwords do not match'}), 400

        hashed_password = bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
        try:
            conn = get_db_connection()
            cursor = conn.cursor()
            cursor.execute("""
                INSERT INTO login_details (first_name, last_name, email, mobile, password)
                VALUES (%s, %s, %s, %s, %s)
            """, (first_name, last_name, email, mobile, hashed_password))
            user_id = cursor.lastrowid
            conn.commit()
            cursor.close()
            session['loggedin'] = True
            session['user_email'] = email
            session['user_id'] = user_id
            return jsonify({
                'success': True,
                'message': 'Registration successful',
                'user': {'email': email, 'id': user_id}
            }), 200
        except mysql.connector.Error as e:
            logging.error(f"Database error during registration: {str(e)}")
            return jsonify({'success': False, 'message': f'Registration error: {str(e)}'}), 500

    @app.route('/logout', methods=['POST'])
    @app.route('/api/auth/logout', methods=['POST'])
    def logout():
        logging.info(f"User {session.get('user_email', 'unknown')} logged out")
        session.clear()
        return jsonify({'success': True, 'message': 'Logged out successfully'})

    # Template routes
    @app.route('/templates', methods=['GET'])
    @app.route('/api/templates', methods=['GET'])
    def get_templates():
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /templates: session missing")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("""
                SELECT template_id, template_name, created_at, status
                FROM excel_templates
                WHERE user_id = %s AND status = 'ACTIVE'
                ORDER BY created_at DESC
                LIMIT 100
            """, (session['user_id'],))
            templates = cursor.fetchall()
            cursor.close()
            logging.info(f"Fetched {len(templates)} templates for user {session['user_id']}")
            return jsonify({'success': True, 'templates': templates})
        except mysql.connector.Error as e:
            logging.error(f'Error fetching templates: {str(e)}')
            return jsonify({'success': False, 'message': f'Error fetching templates: {str(e)}'}), 500
        except Exception as e:
            logging.error(f'Unexpected error fetching templates: {str(e)}')
            return jsonify({'success': False, 'message': f'Unexpected error: {str(e)}'}), 500

    # Rule Configuration routes
    @app.route('/rule-configurations', methods=['GET'])
    @app.route('/api/validation/rule-configurations', methods=['GET'])
    def get_rule_configurations():
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning(f"Unauthorized access to /rule-configurations: session={dict(session)}")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            user_id = session['user_id']
            logging.debug(f"Fetching rule configurations for user_id: {user_id}")

            # Main query to fetch templates with configured rules
            cursor.execute("""
                SELECT 
                    t.template_id, 
                    t.template_name, 
                    t.created_at, 
                    COUNT(cvr.column_validation_id) as rule_count
                FROM excel_templates t
                LEFT JOIN template_columns tc ON t.template_id = tc.template_id
                LEFT JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                WHERE t.user_id = %s AND t.status = 'ACTIVE' AND t.is_corrected = FALSE
                GROUP BY t.template_id, t.template_name, t.created_at
                HAVING rule_count > 0
                ORDER BY t.created_at DESC
                LIMIT 100
            """, (user_id,))
            templates = cursor.fetchall()
            logging.debug(f"Fetched rule-configured templates: {templates}")

            cursor.close()

            if not templates:
                logging.info(f"No templates with rules found for user_id: {user_id}")
            else:
                logging.info(f"Found {len(templates)} templates with rules for user_id: {user_id}")

            return jsonify({'success': True, 'templates': templates})
        except mysql.connector.Error as e:
            logging.error(f"Database error fetching rule configurations: {str(e)}")
            return jsonify({'success': False, 'message': f"Database error: {str(e)}"}), 500
        except Exception as e:
            logging.error(f"Unexpected error fetching rule configurations: {str(e)}")
            return jsonify({'success': False, 'message': f"Unexpected error: {str(e)}"}), 500

    # File upload route
    @app.route('/upload', methods=['POST'])
    @app.route('/api/templates/upload', methods=['POST'])
    @app.route('/api/upload', methods=['POST'])  # Additional common path
    def upload():
        logging.info(f"Upload endpoint called: {request.endpoint}, method: {request.method}")
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /upload: session missing")
            return jsonify({'error': 'Not logged in'}), 401
        if 'file' not in request.files:
            logging.warning("No file provided in upload request")
            return jsonify({'error': 'No file uploaded'}), 400
        file = request.files['file']
        if file.filename == '':
            logging.warning("No file selected in upload request")
            return jsonify({'error': 'No file selected'}), 400
        
        file_path = os.path.join(app.config['UPLOAD_FOLDER'], file.filename)
        try:
            file.save(file_path)
            logging.info(f"File saved: {file_path}")
        except Exception as e:
            logging.error(f"Failed to save file {file.filename}: {str(e)}")
            return jsonify({'error': f'Failed to save file: {str(e)}'}), 500

        try:
            # Read the file to get sheets and headers
            if file.filename.endswith('.xlsx') or file.filename.endswith('.xls'):
                xl = pd.ExcelFile(file_path)
                sheets = {sheet_name: pd.read_excel(file_path, sheet_name=sheet_name, header=None) 
                         for sheet_name in xl.sheet_names}
            elif file.filename.endswith(('.txt', '.csv', '.dat')):
                df = pd.read_csv(file_path, header=None, encoding='utf-8')
                sheets = {'Sheet1': df}
            else:
                logging.error("Unsupported file type")
                return jsonify({'error': 'Unsupported file type'}), 400
            
            logging.debug(f"Sheets extracted: {list(sheets.keys())}")
        except Exception as e:
            logging.error(f"Failed to read file {file_path}: {str(e)}")
            return jsonify({'error': f'Failed to read file: {str(e)}'}), 400

        try:
            sheet_names = list(sheets.keys())
            if not sheet_names:
                logging.error("No sheets found in the file")
                return jsonify({'error': 'No sheets found in the file'}), 400
            sheet_name = sheet_names[0]
            df = sheets[sheet_name]
            
            # Find header row
            header_row = 0
            for i in range(min(len(df), 10)):
                row = df.iloc[i].dropna()
                if not row.empty and all(isinstance(x, str) for x in row if pd.notna(x)):
                    header_row = i
                    break
                    
            headers = df.iloc[header_row].tolist()
            logging.debug(f"Headers extracted: {headers}")
            
            if not headers or all(not h for h in headers):
                logging.error("No valid headers found in file")
                return jsonify({'error': 'No valid headers found in the file'}), 400
        except Exception as e:
            logging.error(f"Error processing file {file.filename}: {str(e)}")
            return jsonify({'error': f'Error processing file: {str(e)}'}), 400

        # Clear existing session data
        for key in ['df', 'header_row', 'headers', 'sheet_name', 'current_step', 'selected_headers', 'validations', 'error_cell_locations', 'data_rows', 'corrected_file_path']:
            session.pop(key, None)

        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)

            # Check if template exists
            cursor.execute("""
                SELECT template_id, headers, sheet_name
                FROM excel_templates
                WHERE template_name = %s AND user_id = %s AND status = 'ACTIVE'
                ORDER BY created_at DESC
            """, (file.filename, session['user_id']))
            existing_templates = cursor.fetchall()
            logging.info(f"Found {len(existing_templates)} existing templates with name {file.filename}")

            template_id = None
            has_existing_rules = False
            validations = {}
            selected_headers = []

            # Check for matching template
            matching_template = None
            for template in existing_templates:
                stored_headers = json.loads(template['headers']) if template['headers'] else []
                stored_sheet_name = template['sheet_name']
                if stored_headers == headers and stored_sheet_name == sheet_name:
                    matching_template = template
                    break

            if matching_template:
                template_id = matching_template['template_id']
                # Check for existing rules
                cursor.execute("""
                    SELECT tc.column_name, vrt.rule_name
                    FROM template_columns tc
                    JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                    JOIN validation_rule_types vrt ON cvr.rule_type_id = vrt.rule_type_id
                    WHERE tc.template_id = %s AND tc.is_selected = TRUE
                """, (template_id,))
                rules_data = cursor.fetchall()
                for row in rules_data:
                    column_name = row['column_name']
                    rule_name = row['rule_name']
                    if column_name not in validations:
                        validations[column_name] = []
                    validations[column_name].append(rule_name)
                    if column_name not in selected_headers:
                        selected_headers.append(column_name)
                has_existing_rules = len(validations) > 0
            else:
                # New template
                cursor.execute("""
                    INSERT INTO excel_templates (template_name, user_id, sheet_name, headers, is_corrected)
                    VALUES (%s, %s, %s, %s, %s)
                """, (file.filename, session['user_id'], sheet_name, json.dumps(headers), False))
                template_id = cursor.lastrowid
                column_data = [(template_id, header, i + 1, False) for i, header in enumerate(headers)]
                cursor.executemany("""
                    INSERT INTO template_columns (template_id, column_name, column_position, is_selected)
                    VALUES (%s, %s, %s, %s)
                """, column_data)

            conn.commit()
            cursor.close()

            # Store session data
            session['file_path'] = file_path
            session['template_id'] = template_id
            session['df'] = df.to_json()
            session['header_row'] = header_row
            session['headers'] = headers
            session['sheet_name'] = sheet_name
            session['current_step'] = 1 if not has_existing_rules else 3
            session['validations'] = validations
            session['selected_headers'] = selected_headers
            session['has_existing_rules'] = has_existing_rules

            logging.info(f"Upload processed: template_id={template_id}, filename={file.filename}, has_existing_rules={has_existing_rules}")

            return jsonify({
                'success': True,
                'sheets': {sheet_name: {'headers': headers}},
                'file_name': file.filename,
                'template_id': template_id,
                'has_existing_rules': has_existing_rules,
                'sheet_name': sheet_name,
                'skip_to_step_3': has_existing_rules
            })
        except mysql.connector.Error as e:
            logging.error(f'Error saving template: {str(e)}')
            return jsonify({'error': f'Error saving template: {str(e)}'}), 500
        except Exception as e:
            logging.error(f'Unexpected error saving template: {str(e)}')
            return jsonify({'error': f'Unexpected error: {str(e)}'}), 500

    # Multi-step workflow endpoints
    @app.route('/step/1', methods=['GET', 'POST'])
    @app.route('/api/step/1', methods=['GET', 'POST'])
    def step_one():
        if 'loggedin' not in session:
            return jsonify({'error': 'Not logged in'}), 401
        
        if request.method == 'POST':
            try:
                headers = request.form.getlist('headers')
                new_header_row = request.form.get('new_header_row')
                logging.debug(f"Step 1 submitted: headers={headers}, new_header_row={new_header_row}")
                
                if not headers:
                    logging.error("No headers provided in step 1")
                    return jsonify({'success': False, 'message': 'No headers provided'}), 400
                    
                if 'template_id' not in session:
                    logging.error("Session missing template_id")
                    return jsonify({'success': False, 'message': 'Session data missing'}), 400

                template_id = session['template_id']
                
                # Get the dataframe from session for auto-detection
                df_json = session.get('df')
                if df_json:
                    df = pd.read_json(StringIO(df_json))
                    session_headers = session.get('headers', [])
                    df.columns = session_headers
                    header_row = session.get('header_row', 0)
                    df = df.iloc[header_row + 1:].reset_index(drop=True)
                    
                    # Auto-detect rules for selected headers
                    validations = assign_default_rules_to_columns(df, headers)
                    session['validations'] = validations
                    logging.debug(f"Auto-assigned rules: {validations}")
                else:
                    validations = {}

                session['selected_headers'] = headers
                session['current_step'] = 2

                # Mark selected headers in the database
                conn = get_db_connection()
                cursor = conn.cursor()
                cursor.execute("UPDATE template_columns SET is_selected = FALSE WHERE template_id = %s", (template_id,))
                for header in headers:
                    cursor.execute("""
                        UPDATE template_columns
                        SET is_selected = TRUE
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    
                    # Get column_id and add auto-detected rules
                    cursor.execute("""
                        SELECT column_id FROM template_columns
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    result = cursor.fetchone()
                    if result:
                        column_id = result[0]
                        for rule_name in validations.get(header, []):
                            cursor.execute("""
                                SELECT rule_type_id FROM validation_rule_types
                                WHERE rule_name = %s AND is_custom = FALSE
                            """, (rule_name,))
                            rule_result = cursor.fetchone()
                            if rule_result:
                                rule_type_id = rule_result[0]
                                cursor.execute("""
                                    INSERT IGNORE INTO column_validation_rules (column_id, rule_type_id, rule_config)
                                    VALUES (%s, %s, %s)
                                """, (column_id, rule_type_id, '{}'))
                
                conn.commit()
                cursor.close()

                logging.info(f"Step 1 completed: headers={headers}, auto-assigned rules={validations}")
                return jsonify({'success': True, 'headers': headers, 'validations': validations})
            except Exception as e:
                logging.error(f"Error in step 1: {str(e)}")
                return jsonify({'success': False, 'message': str(e)}), 500
        
        # GET request - return current headers
        headers = session.get('headers', [])
        return jsonify({'headers': headers})

    @app.route('/step/2', methods=['GET', 'POST'])
    @app.route('/api/step/2', methods=['GET', 'POST'])
    def step_two():
        if 'loggedin' not in session:
            return jsonify({'error': 'Not logged in'}), 401
            
        if request.method == 'POST':
            try:
                action = request.form.get('action', 'save')
                validations = {}
                for key, values in request.form.lists():
                    if key.startswith('validations_'):
                        header = key.replace('validations_', '')
                        validations[header] = values
                        
                logging.debug(f"Step 2 submitted: action={action}, validations={validations}")
                
                template_id = session.get('template_id')
                if not template_id:
                    return jsonify({'success': False, 'message': 'Session data missing'}), 400

                # Save validations to database
                conn = get_db_connection()
                cursor = conn.cursor()
                
                # Clear existing rules
                cursor.execute("""
                    DELETE FROM column_validation_rules
                    WHERE column_id IN (
                        SELECT column_id FROM template_columns WHERE template_id = %s
                    )
                """, (template_id,))
                
                # Add new rules
                for header, rules in validations.items():
                    cursor.execute("""
                        SELECT column_id FROM template_columns
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    result = cursor.fetchone()
                    if not result:
                        continue
                    column_id = result[0]
                    
                    for rule_name in rules:
                        cursor.execute("""
                            SELECT rule_type_id FROM validation_rule_types
                            WHERE rule_name = %s
                        """, (rule_name,))
                        result = cursor.fetchone()
                        if result:
                            rule_type_id = result[0]
                            cursor.execute("""
                                INSERT IGNORE INTO column_validation_rules (column_id, rule_type_id, rule_config)
                                VALUES (%s, %s, %s)
                            """, (column_id, rule_type_id, '{}'))
                
                conn.commit()
                cursor.close()

                session['validations'] = validations
                session['current_step'] = 3 if action == 'review' else 2
                
                logging.info(f"Step 2 completed: action={action}, validations={validations}")
                return jsonify({'success': True, 'message': 'Step 2 completed successfully'})
            except Exception as e:
                logging.error(f"Error in step 2: {str(e)}")
                return jsonify({'success': False, 'message': str(e)}), 500
        
        # GET request
        selected_headers = session.get('selected_headers', [])
        return jsonify({'selected_headers': selected_headers})

    # Rules endpoint
    @app.route('/rules', methods=['GET'])
    @app.route('/api/rules', methods=['GET'])
    def get_rules():
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            
            cursor.execute("""
                SELECT rule_type_id AS rule_id, rule_name, description, parameters, is_custom, 
                       column_name, template_id, source_format, target_format, data_type, is_active
                FROM validation_rule_types
            """)
            rules = cursor.fetchall()
            cursor.close()
            
            logging.info(f"Returning {len(rules)} rules from getRules endpoint")
            return jsonify({'success': True, 'rules': rules})
        except mysql.connector.Error as e:
            logging.error(f"Database error fetching rules: {str(e)}")
            return jsonify({'success': False, 'message': str(e)}), 500
        except Exception as e:
            logging.error(f"Unexpected error fetching rules: {str(e)}")
            return jsonify({'success': False, 'message': str(e)}), 500

    # Template details endpoint
    @app.route('/template/<int:template_id>/<sheet_name>', methods=['GET'])
    @app.route('/api/template/<int:template_id>/<sheet_name>', methods=['GET'])
    def get_template(template_id, sheet_name):
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /template: session missing")
            return jsonify({'error': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("""
                SELECT template_name, sheet_name, headers
                FROM excel_templates
                WHERE template_id = %s AND user_id = %s AND status = 'ACTIVE'
            """, (template_id, session['user_id']))
            template_record = cursor.fetchone()
            
            if not template_record:
                logging.error(f"Template not found for template_id: {template_id}, user_id: {session['user_id']}")
                cursor.close()
                return jsonify({'error': 'Template not found'}), 404

            headers = json.loads(template_record['headers']) if template_record['headers'] else []
            stored_sheet_name = template_record['sheet_name'] or sheet_name
            file_path = os.path.join(app.config['UPLOAD_FOLDER'], template_record['template_name'])
            
            cursor.execute("""
                SELECT COUNT(*) as rule_count
                FROM template_columns tc
                JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                WHERE tc.template_id = %s AND tc.is_selected = TRUE
            """, (template_id,))
            rule_count = cursor.fetchone()['rule_count']
            has_existing_rules = rule_count > 0
            
            cursor.close()
            
            return jsonify({
                'success': True,
                'sheets': {stored_sheet_name: {'headers': headers}},
                'file_name': template_record['template_name'],
                'file_path': file_path,
                'sheet_name': stored_sheet_name,
                'has_existing_rules': has_existing_rules
            })
        except mysql.connector.Error as e:
            logging.error(f"Database error in get_template: {str(e)}")
            return jsonify({'error': f'Database error: {str(e)}'}), 500
        except Exception as e:
            logging.error(f"Unexpected error in get_template: {str(e)}")
            return jsonify({'error': f'Unexpected error: {str(e)}'}), 500

    # Debug route to show all registered routes
    @app.route('/debug/routes', methods=['GET'])
    def list_routes():
        routes = []
        for rule in app.url_map.iter_rules():
            routes.append({
                'endpoint': rule.endpoint,
                'methods': list(rule.methods),
                'rule': rule.rule
            })
        return jsonify(routes)

    # 404 handler to debug missing routes
    @app.errorhandler(404)
    def not_found_handler(error):
        logging.error(f"404 Error: {request.method} {request.url} not found")
        logging.error(f"Available routes: {[rule.rule for rule in app.url_map.iter_rules()]}")
        return jsonify({
            'error': 'Endpoint not found', 
            'method': request.method,
            'url': request.url,
            'path': request.path
        }), 404

    return app

def initialize_app_data():
    """Initialize database and create default data"""
    try:
        logging.info("Initializing database schema...")
        init_db()
        
        logging.info("Creating admin user...")
        create_admin_user()
        
        logging.info("Creating default validation rules...")
        create_default_validation_rules()
        
        logging.info("Application initialization completed successfully")
    except Exception as e:
        logging.error(f"Failed to initialize application: {e}")
        raise

DB_CONFIG = {
    'host': os.getenv('MYSQL_HOST', 'localhost'),
    'user': os.getenv('MYSQL_USER', 'root'),
    'password': os.getenv('MYSQL_PASSWORD', 'Keansa@2024'),
    'database': os.getenv('MYSQL_DATABASE', 'data_validation_2'),
}

def get_db_connection():
    if 'db' not in g:
        try:
            conn = mysql.connector.connect(
                host=DB_CONFIG['host'],
                user=DB_CONFIG['user'],
                password=DB_CONFIG['password']
            )
            cursor = conn.cursor()
            cursor.execute(f"CREATE DATABASE IF NOT EXISTS {DB_CONFIG['database']}")
            cursor.close()
            conn.close()
            g.db = mysql.connector.connect(**DB_CONFIG)
            logging.info("Database connection established successfully")
        except mysql.connector.Error as err:
            if err.errno == errorcode.ER_ACCESS_DENIED_ERROR:
                logging.error("Database connection failed: Access denied for user - check username/password")
            elif err.errno == errorcode.ER_BAD_DB_ERROR:
                logging.error("Database connection failed: Database does not exist")
            else:
                logging.error(f"Database connection failed: {err}")
            raise Exception(f"Failed to connect to database: {str(err)}")
    return g.db

def close_db(error):
    db = g.pop('db', None)
    if db is not None:
        db.close()

def init_db():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        tables = [
            """
            CREATE TABLE IF NOT EXISTS login_details (
                id INT AUTO_INCREMENT PRIMARY KEY,
                first_name VARCHAR(100),
                last_name VARCHAR(100),
                email VARCHAR(255) UNIQUE,
                mobile VARCHAR(10),
                password VARCHAR(255)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS excel_templates (
                template_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_name VARCHAR(255) NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
                user_id INT NOT NULL,
                sheet_name VARCHAR(255),
                headers JSON,
                status ENUM('ACTIVE', 'INACTIVE') DEFAULT 'ACTIVE',
                is_corrected BOOLEAN DEFAULT FALSE,
                remote_file_path VARCHAR(512),
                FOREIGN KEY (user_id) REFERENCES login_details(id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS template_columns (
                column_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_id BIGINT NOT NULL,
                column_name VARCHAR(255) NOT NULL,
                column_position INT NOT NULL,
                is_validation_enabled BOOLEAN DEFAULT FALSE,
                is_selected BOOLEAN DEFAULT FALSE,
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE,
                UNIQUE (template_id, column_name)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_rule_types (
                rule_type_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                rule_name VARCHAR(255) NOT NULL,
                description TEXT,
                parameters TEXT,
                is_active BOOLEAN DEFAULT TRUE,
                is_custom BOOLEAN DEFAULT FALSE,
                column_name VARCHAR(255),
                template_id BIGINT,
                data_type VARCHAR(50),
                source_format VARCHAR(50),
                target_format VARCHAR(50),
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS column_validation_rules (
                column_validation_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                column_id BIGINT NOT NULL,
                rule_type_id BIGINT NOT NULL,
                rule_config JSON,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (column_id) REFERENCES template_columns(column_id) ON DELETE CASCADE,
                FOREIGN KEY (rule_type_id) REFERENCES validation_rule_types(rule_type_id) ON DELETE RESTRICT,
                UNIQUE (column_id, rule_type_id)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_history (
                history_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_id BIGINT NOT NULL,
                template_name VARCHAR(255) NOT NULL,
                error_count INT NOT NULL,
                corrected_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                corrected_file_path VARCHAR(512) NOT NULL,
                user_id INT NOT NULL,
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE,
                FOREIGN KEY (user_id) REFERENCES login_details(id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_corrections (
                correction_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                history_id BIGINT NOT NULL,
                row_index INT NOT NULL,
                column_name VARCHAR(255) NOT NULL,
                original_value TEXT,
                corrected_value TEXT,
                rule_failed VARCHAR(255) DEFAULT NULL,
                FOREIGN KEY (history_id) REFERENCES validation_history(history_id) ON DELETE CASCADE
            )
            """
        ]
        for table_sql in tables:
            cursor.execute(table_sql)
        
        # Add missing columns if they don't exist
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'source_format'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN source_format VARCHAR(50)")
            logging.info("Added source_format column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'target_format'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN target_format VARCHAR(50)")
            logging.info("Added target_format column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'data_type'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN data_type VARCHAR(50)")
            logging.info("Added data_type column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM excel_templates LIKE 'remote_file_path'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE excel_templates ADD COLUMN remote_file_path VARCHAR(512)")
            logging.info("Added remote_file_path column to excel_templates table")
            
        cursor.execute("SHOW COLUMNS FROM template_columns LIKE 'is_selected'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE template_columns ADD COLUMN is_selected BOOLEAN DEFAULT FALSE")
            logging.info("Added is_selected column to template_columns table")
            
        conn.commit()
        cursor.close()
        logging.info("Database tables initialized")
    except Exception as e:
        logging.error(f"Failed to initialize database: {str(e)}")
        raise

def create_admin_user():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        admin_password = bcrypt.hashpw('admin'.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
        cursor.execute("""
            INSERT IGNORE INTO login_details (first_name, last_name, email, mobile, password)
            VALUES (%s, %s, %s, %s, %s)
        """, ('Admin', 'User', 'admin@example.com', '1234567890', admin_password))
        conn.commit()
        cursor.close()
        logging.info("Admin user created or already exists")
    except Exception as e:
        logging.error(f"Failed to create admin user: {str(e)}")
        raise

def create_default_validation_rules():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        default_rules = [
            ("Required", "Ensures the field is not null", '{"allow_null": false}', None, None, None),
            ("Int", "Validates integer format", '{"format": "integer"}', None, None, "Int"),
            ("Float", "Validates number format (integer or decimal)", '{"format": "float"}', None, None, "Float"),
            ("Text", "Allows text with quotes and parentheses", '{"allow_special": false}', None, None, "Text"),
            ("Email", "Validates email format", '{"regex": "^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\\\.[a-zA-Z0-9-.]+$"}', None, None, "Email"),
            ("Date(DD-MM-YYYY)", "Validates date format DD-MM-YYYY", '{"format": "%d-%m-%Y"}', "DD-MM-YYYY", None, "Date"),
            ("Boolean", "Validates boolean format (true/false or 0/1)", '{"format": "boolean"}', None, None, "Boolean"),
            ("Alphanumeric", "Validates alphanumeric format", '{"format": "alphanumeric"}', None, None, "Alphanumeric")
        ]
        cursor.executemany("""
            INSERT IGNORE INTO validation_rule_types (rule_name, description, parameters, is_custom, source_format, target_format, data_type)
            VALUES (%s, %s, %s, %s, %s, %s, %s)
        """, [(name, desc, params, False, source, target, dtype) for name, desc, params, source, target, dtype in default_rules])
        conn.commit()
        cursor.close()
        logging.info("Default validation rules ensured successfully")
    except Exception as e:
        logging.error(f"Failed to ensure default validation rules: {str(e)}")
        raise

if __name__ == '__main__':
    try:
        # Create the application using factory pattern
        app = create_app()
        
        # Initialize database and default data within app context
        with app.app_context():
            initialize_app_data()
        
        # Get port from environment or use default
        port = int(os.getenv('PORT', 5000))
        
        # Start the application server
        logging.info("Starting Flask server...")
        app.run(debug=True, host='0.0.0.0', port=port)
        
    except Exception as e:
        logging.error(f"Failed to start application: {e}")
        raise
).all():
        return "Email"
    
    # Date pattern detection
    try:
        pd.to_datetime(non_null, format="%d-%m-%Y")
        return "Date"
    except Exception:
        try:
            pd.to_datetime(non_null, format="%Y-%m-%d")
            return "Date"
        except Exception:
            pass
    
    # Boolean detection
    if non_null.str.lower().isin(['true', 'false', '0', '1']).all():
        return "Boolean"
    
    # Numeric detection
    if non_null.str.match(r'^-?\d+

def create_app():
    """Application factory pattern for different environments"""
    # Set the path to the frontend dist folder
    current_dir = os.path.dirname(os.path.abspath(__file__))
    frontend_dist_path = os.path.join(current_dir, '..', '..', 'Keansa-Ai-Suite2025may-frontend11', 'dist')
    frontend_dist_path = os.path.abspath(frontend_dist_path)
    
    # Create Flask application instance
    app = Flask(__name__, static_folder=frontend_dist_path, static_url_path='')
    CORS(app, supports_credentials=True, origins=["http://localhost:3000", "http://localhost:8080", "http://localhost:5000", "*"])

    app.secret_key = os.urandom(24).hex()
    app.config['SESSION_TYPE'] = 'filesystem'
    app.config['SESSION_FILE_DIR'] = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'sessions')
    app.config['SESSION_COOKIE_SAMESITE'] = 'Lax'
    app.config['SESSION_COOKIE_HTTPONLY'] = True
    app.config['SESSION_COOKIE_SECURE'] = False
    app.config['PERMANENT_SESSION_LIFETIME'] = 86400  # 24 hours
    app.config['UPLOAD_FOLDER'] = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'uploads')
    Session(app)

    # Ensure directories exist
    try:
        os.makedirs(app.config['UPLOAD_FOLDER'], exist_ok=True)
        os.makedirs(app.config['SESSION_FILE_DIR'], exist_ok=True)
    except OSError as e:
        logging.error(f"Failed to create directories: {e}")

    # Register cleanup handlers
    app.teardown_appcontext(close_db)
    
    # Register all routes directly in create_app
    
    # Static file serving for React frontend
    @app.route('/', defaults={'path': ''})
    @app.route('/<path:path>')
    def serve(path):
        if path and os.path.exists(os.path.join(app.static_folder, path)):
            return app.send_static_file(path)
        return app.send_static_file('index.html')

    # Health check endpoint
    @app.route('/health', methods=['GET'])
    def health_check():
        return jsonify({
            'status': 'healthy',
            'timestamp': datetime.now().isoformat(),
            'version': '2.0.0'
        })

    # Authentication endpoint - both old and new paths
    @app.route('/authenticate', methods=['POST'])
    @app.route('/api/auth/authenticate', methods=['POST'])
    def authenticate():
        try:
            email = request.form.get('username') or request.form.get('email')
            password = request.form.get('password')
            logging.debug(f"Login attempt: email={email}, password={'*' * len(password) if password else 'None'}")
            
            if not email or not password:
                logging.warning(f"Login failed: Email or password missing")
                return jsonify({'success': False, 'message': 'Email and password are required'}), 400

            # Check for admin login
            if email == "admin" and password == "admin":
                session['loggedin'] = True
                session['user_email'] = "admin@example.com"
                session['user_id'] = 1
                session.permanent = True
                logging.info(f"Admin login successful. Session: {dict(session)}")
                return jsonify({'success': True, 'message': 'Login successful', 'user': {'email': 'admin@example.com', 'id': 1}}), 200

            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("SELECT * FROM login_details WHERE LOWER(email) = LOWER(%s)", (email.lower(),))
            account = cursor.fetchone()
            cursor.close()
            
            if account:
                if bcrypt.checkpw(password.encode('utf-8'), account['password'].encode('utf-8')):
                    session['loggedin'] = True
                    session['user_email'] = account['email']
                    session['user_id'] = account['id']
                    session.permanent = True
                    logging.info(f"User {email} logged in successfully. Session: {dict(session)}")
                    return jsonify({
                        'success': True,
                        'message': 'Login successful',
                        'user': {'email': account['email'], 'id': account['id']}
                    }), 200
                else:
                    logging.warning(f"Invalid password for {email}")
                    return jsonify({'success': False, 'message': 'Invalid credentials'}), 401
            else:
                logging.warning(f"Email {email} not found")
                return jsonify({'success': False, 'message': 'Invalid credentials'}), 401
        except Exception as e:
            logging.error(f"Unexpected error during login: {str(e)}")
            return jsonify({'success': False, 'message': f'Unexpected error: {str(e)}'}), 500

    @app.route('/check-auth', methods=['GET'])
    @app.route('/api/auth/check-auth', methods=['GET'])
    def check_auth():
        try:
            logging.debug(f"Checking auth with session: {dict(session)}")
            if 'loggedin' in session and 'user_id' in session:
                conn = get_db_connection()
                cursor = conn.cursor(dictionary=True)
                cursor.execute("SELECT email, first_name FROM login_details WHERE id = %s", (session['user_id'],))
                user = cursor.fetchone()
                cursor.close()
                if user:
                    logging.info(f"User {session.get('user_email')} is authenticated")
                    return jsonify({
                        'success': True,
                        'user': {
                            'email': user['email'],
                            'id': session['user_id'],
                            'first_name': user['first_name']
                        }
                    })
                else:
                    logging.warning("User not found in database")  
                    session.clear()
                    return jsonify({'success': False, 'message': 'User not found'}), 401
            logging.warning("User not authenticated")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        except Exception as e:
            logging.error(f"Error in check-auth endpoint: {str(e)}")
            return jsonify({'success': False, 'message': f'Server error: {str(e)}'}), 500

    @app.route('/register', methods=['POST'])
    @app.route('/api/auth/register', methods=['POST'])
    def register():
        first_name = request.form.get('first_name')
        last_name = request.form.get('last_name')
        email = request.form.get('email')
        mobile = request.form.get('mobile')
        password = request.form.get('password')
        confirm_password = request.form.get('confirm_password')

        if not all([first_name, last_name, email, mobile, password, confirm_password]):
            return jsonify({'success': False, 'message': 'All fields are required'}), 400
        if password != confirm_password:
            return jsonify({'success': False, 'message': 'Passwords do not match'}), 400

        hashed_password = bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
        try:
            conn = get_db_connection()
            cursor = conn.cursor()
            cursor.execute("""
                INSERT INTO login_details (first_name, last_name, email, mobile, password)
                VALUES (%s, %s, %s, %s, %s)
            """, (first_name, last_name, email, mobile, hashed_password))
            user_id = cursor.lastrowid
            conn.commit()
            cursor.close()
            session['loggedin'] = True
            session['user_email'] = email
            session['user_id'] = user_id
            return jsonify({
                'success': True,
                'message': 'Registration successful',
                'user': {'email': email, 'id': user_id}
            }), 200
        except mysql.connector.Error as e:
            logging.error(f"Database error during registration: {str(e)}")
            return jsonify({'success': False, 'message': f'Registration error: {str(e)}'}), 500

    @app.route('/logout', methods=['POST'])
    @app.route('/api/auth/logout', methods=['POST'])
    def logout():
        logging.info(f"User {session.get('user_email', 'unknown')} logged out")
        session.clear()
        return jsonify({'success': True, 'message': 'Logged out successfully'})

    # Template routes
    @app.route('/templates', methods=['GET'])
    @app.route('/api/templates', methods=['GET'])
    def get_templates():
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /templates: session missing")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("""
                SELECT template_id, template_name, created_at, status
                FROM excel_templates
                WHERE user_id = %s AND status = 'ACTIVE'
                ORDER BY created_at DESC
                LIMIT 100
            """, (session['user_id'],))
            templates = cursor.fetchall()
            cursor.close()
            logging.info(f"Fetched {len(templates)} templates for user {session['user_id']}")
            return jsonify({'success': True, 'templates': templates})
        except mysql.connector.Error as e:
            logging.error(f'Error fetching templates: {str(e)}')
            return jsonify({'success': False, 'message': f'Error fetching templates: {str(e)}'}), 500
        except Exception as e:
            logging.error(f'Unexpected error fetching templates: {str(e)}')
            return jsonify({'success': False, 'message': f'Unexpected error: {str(e)}'}), 500

    # Rule Configuration routes
    @app.route('/rule-configurations', methods=['GET'])
    @app.route('/api/validation/rule-configurations', methods=['GET'])
    def get_rule_configurations():
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning(f"Unauthorized access to /rule-configurations: session={dict(session)}")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            user_id = session['user_id']
            logging.debug(f"Fetching rule configurations for user_id: {user_id}")

            # Main query to fetch templates with configured rules
            cursor.execute("""
                SELECT 
                    t.template_id, 
                    t.template_name, 
                    t.created_at, 
                    COUNT(cvr.column_validation_id) as rule_count
                FROM excel_templates t
                LEFT JOIN template_columns tc ON t.template_id = tc.template_id
                LEFT JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                WHERE t.user_id = %s AND t.status = 'ACTIVE' AND t.is_corrected = FALSE
                GROUP BY t.template_id, t.template_name, t.created_at
                HAVING rule_count > 0
                ORDER BY t.created_at DESC
                LIMIT 100
            """, (user_id,))
            templates = cursor.fetchall()
            logging.debug(f"Fetched rule-configured templates: {templates}")

            cursor.close()

            if not templates:
                logging.info(f"No templates with rules found for user_id: {user_id}")
            else:
                logging.info(f"Found {len(templates)} templates with rules for user_id: {user_id}")

            return jsonify({'success': True, 'templates': templates})
        except mysql.connector.Error as e:
            logging.error(f"Database error fetching rule configurations: {str(e)}")
            return jsonify({'success': False, 'message': f"Database error: {str(e)}"}), 500
        except Exception as e:
            logging.error(f"Unexpected error fetching rule configurations: {str(e)}")
            return jsonify({'success': False, 'message': f"Unexpected error: {str(e)}"}), 500

    # File upload route
    @app.route('/upload', methods=['POST'])
    @app.route('/api/templates/upload', methods=['POST'])
    @app.route('/api/upload', methods=['POST'])  # Additional common path
    def upload():
        logging.info(f"Upload endpoint called: {request.endpoint}, method: {request.method}")
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /upload: session missing")
            return jsonify({'error': 'Not logged in'}), 401
        if 'file' not in request.files:
            logging.warning("No file provided in upload request")
            return jsonify({'error': 'No file uploaded'}), 400
        file = request.files['file']
        if file.filename == '':
            logging.warning("No file selected in upload request")
            return jsonify({'error': 'No file selected'}), 400
        
        file_path = os.path.join(app.config['UPLOAD_FOLDER'], file.filename)
        try:
            file.save(file_path)
            logging.info(f"File saved: {file_path}")
        except Exception as e:
            logging.error(f"Failed to save file {file.filename}: {str(e)}")
            return jsonify({'error': f'Failed to save file: {str(e)}'}), 500

        try:
            # Read the file to get sheets and headers
            if file.filename.endswith('.xlsx') or file.filename.endswith('.xls'):
                xl = pd.ExcelFile(file_path)
                sheets = {sheet_name: pd.read_excel(file_path, sheet_name=sheet_name, header=None) 
                         for sheet_name in xl.sheet_names}
            elif file.filename.endswith(('.txt', '.csv', '.dat')):
                df = pd.read_csv(file_path, header=None, encoding='utf-8')
                sheets = {'Sheet1': df}
            else:
                logging.error("Unsupported file type")
                return jsonify({'error': 'Unsupported file type'}), 400
            
            logging.debug(f"Sheets extracted: {list(sheets.keys())}")
        except Exception as e:
            logging.error(f"Failed to read file {file_path}: {str(e)}")
            return jsonify({'error': f'Failed to read file: {str(e)}'}), 400

        try:
            sheet_names = list(sheets.keys())
            if not sheet_names:
                logging.error("No sheets found in the file")
                return jsonify({'error': 'No sheets found in the file'}), 400
            sheet_name = sheet_names[0]
            df = sheets[sheet_name]
            
            # Find header row
            header_row = 0
            for i in range(min(len(df), 10)):
                row = df.iloc[i].dropna()
                if not row.empty and all(isinstance(x, str) for x in row if pd.notna(x)):
                    header_row = i
                    break
                    
            headers = df.iloc[header_row].tolist()
            logging.debug(f"Headers extracted: {headers}")
            
            if not headers or all(not h for h in headers):
                logging.error("No valid headers found in file")
                return jsonify({'error': 'No valid headers found in the file'}), 400
        except Exception as e:
            logging.error(f"Error processing file {file.filename}: {str(e)}")
            return jsonify({'error': f'Error processing file: {str(e)}'}), 400

        # Clear existing session data
        for key in ['df', 'header_row', 'headers', 'sheet_name', 'current_step', 'selected_headers', 'validations', 'error_cell_locations', 'data_rows', 'corrected_file_path']:
            session.pop(key, None)

        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)

            # Check if template exists
            cursor.execute("""
                SELECT template_id, headers, sheet_name
                FROM excel_templates
                WHERE template_name = %s AND user_id = %s AND status = 'ACTIVE'
                ORDER BY created_at DESC
            """, (file.filename, session['user_id']))
            existing_templates = cursor.fetchall()
            logging.info(f"Found {len(existing_templates)} existing templates with name {file.filename}")

            template_id = None
            has_existing_rules = False
            validations = {}
            selected_headers = []

            # Check for matching template
            matching_template = None
            for template in existing_templates:
                stored_headers = json.loads(template['headers']) if template['headers'] else []
                stored_sheet_name = template['sheet_name']
                if stored_headers == headers and stored_sheet_name == sheet_name:
                    matching_template = template
                    break

            if matching_template:
                template_id = matching_template['template_id']
                # Check for existing rules
                cursor.execute("""
                    SELECT tc.column_name, vrt.rule_name
                    FROM template_columns tc
                    JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                    JOIN validation_rule_types vrt ON cvr.rule_type_id = vrt.rule_type_id
                    WHERE tc.template_id = %s AND tc.is_selected = TRUE
                """, (template_id,))
                rules_data = cursor.fetchall()
                for row in rules_data:
                    column_name = row['column_name']
                    rule_name = row['rule_name']
                    if column_name not in validations:
                        validations[column_name] = []
                    validations[column_name].append(rule_name)
                    if column_name not in selected_headers:
                        selected_headers.append(column_name)
                has_existing_rules = len(validations) > 0
            else:
                # New template
                cursor.execute("""
                    INSERT INTO excel_templates (template_name, user_id, sheet_name, headers, is_corrected)
                    VALUES (%s, %s, %s, %s, %s)
                """, (file.filename, session['user_id'], sheet_name, json.dumps(headers), False))
                template_id = cursor.lastrowid
                column_data = [(template_id, header, i + 1, False) for i, header in enumerate(headers)]
                cursor.executemany("""
                    INSERT INTO template_columns (template_id, column_name, column_position, is_selected)
                    VALUES (%s, %s, %s, %s)
                """, column_data)

            conn.commit()
            cursor.close()

            # Store session data
            session['file_path'] = file_path
            session['template_id'] = template_id
            session['df'] = df.to_json()
            session['header_row'] = header_row
            session['headers'] = headers
            session['sheet_name'] = sheet_name
            session['current_step'] = 1 if not has_existing_rules else 3
            session['validations'] = validations
            session['selected_headers'] = selected_headers
            session['has_existing_rules'] = has_existing_rules

            logging.info(f"Upload processed: template_id={template_id}, filename={file.filename}, has_existing_rules={has_existing_rules}")

            return jsonify({
                'success': True,
                'sheets': {sheet_name: {'headers': headers}},
                'file_name': file.filename,
                'template_id': template_id,
                'has_existing_rules': has_existing_rules,
                'sheet_name': sheet_name,
                'skip_to_step_3': has_existing_rules
            })
        except mysql.connector.Error as e:
            logging.error(f'Error saving template: {str(e)}')
            return jsonify({'error': f'Error saving template: {str(e)}'}), 500
        except Exception as e:
            logging.error(f'Unexpected error saving template: {str(e)}')
            return jsonify({'error': f'Unexpected error: {str(e)}'}), 500

    # Multi-step workflow endpoints
    @app.route('/step/1', methods=['GET', 'POST'])
    @app.route('/api/step/1', methods=['GET', 'POST'])
    def step_one():
        if 'loggedin' not in session:
            return jsonify({'error': 'Not logged in'}), 401
        
        if request.method == 'POST':
            try:
                headers = request.form.getlist('headers')
                new_header_row = request.form.get('new_header_row')
                logging.debug(f"Step 1 submitted: headers={headers}, new_header_row={new_header_row}")
                
                if not headers:
                    logging.error("No headers provided in step 1")
                    return jsonify({'success': False, 'message': 'No headers provided'}), 400
                    
                if 'template_id' not in session:
                    logging.error("Session missing template_id")
                    return jsonify({'success': False, 'message': 'Session data missing'}), 400

                template_id = session['template_id']
                
                # Get the dataframe from session for auto-detection
                df_json = session.get('df')
                if df_json:
                    df = pd.read_json(StringIO(df_json))
                    session_headers = session.get('headers', [])
                    df.columns = session_headers
                    header_row = session.get('header_row', 0)
                    df = df.iloc[header_row + 1:].reset_index(drop=True)
                    
                    # Auto-detect rules for selected headers
                    validations = assign_default_rules_to_columns(df, headers)
                    session['validations'] = validations
                    logging.debug(f"Auto-assigned rules: {validations}")
                else:
                    validations = {}

                session['selected_headers'] = headers
                session['current_step'] = 2

                # Mark selected headers in the database
                conn = get_db_connection()
                cursor = conn.cursor()
                cursor.execute("UPDATE template_columns SET is_selected = FALSE WHERE template_id = %s", (template_id,))
                for header in headers:
                    cursor.execute("""
                        UPDATE template_columns
                        SET is_selected = TRUE
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    
                    # Get column_id and add auto-detected rules
                    cursor.execute("""
                        SELECT column_id FROM template_columns
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    result = cursor.fetchone()
                    if result:
                        column_id = result[0]
                        for rule_name in validations.get(header, []):
                            cursor.execute("""
                                SELECT rule_type_id FROM validation_rule_types
                                WHERE rule_name = %s AND is_custom = FALSE
                            """, (rule_name,))
                            rule_result = cursor.fetchone()
                            if rule_result:
                                rule_type_id = rule_result[0]
                                cursor.execute("""
                                    INSERT IGNORE INTO column_validation_rules (column_id, rule_type_id, rule_config)
                                    VALUES (%s, %s, %s)
                                """, (column_id, rule_type_id, '{}'))
                
                conn.commit()
                cursor.close()

                logging.info(f"Step 1 completed: headers={headers}, auto-assigned rules={validations}")
                return jsonify({'success': True, 'headers': headers, 'validations': validations})
            except Exception as e:
                logging.error(f"Error in step 1: {str(e)}")
                return jsonify({'success': False, 'message': str(e)}), 500
        
        # GET request - return current headers
        headers = session.get('headers', [])
        return jsonify({'headers': headers})

    @app.route('/step/2', methods=['GET', 'POST'])
    @app.route('/api/step/2', methods=['GET', 'POST'])
    def step_two():
        if 'loggedin' not in session:
            return jsonify({'error': 'Not logged in'}), 401
            
        if request.method == 'POST':
            try:
                action = request.form.get('action', 'save')
                validations = {}
                for key, values in request.form.lists():
                    if key.startswith('validations_'):
                        header = key.replace('validations_', '')
                        validations[header] = values
                        
                logging.debug(f"Step 2 submitted: action={action}, validations={validations}")
                
                template_id = session.get('template_id')
                if not template_id:
                    return jsonify({'success': False, 'message': 'Session data missing'}), 400

                # Save validations to database
                conn = get_db_connection()
                cursor = conn.cursor()
                
                # Clear existing rules
                cursor.execute("""
                    DELETE FROM column_validation_rules
                    WHERE column_id IN (
                        SELECT column_id FROM template_columns WHERE template_id = %s
                    )
                """, (template_id,))
                
                # Add new rules
                for header, rules in validations.items():
                    cursor.execute("""
                        SELECT column_id FROM template_columns
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    result = cursor.fetchone()
                    if not result:
                        continue
                    column_id = result[0]
                    
                    for rule_name in rules:
                        cursor.execute("""
                            SELECT rule_type_id FROM validation_rule_types
                            WHERE rule_name = %s
                        """, (rule_name,))
                        result = cursor.fetchone()
                        if result:
                            rule_type_id = result[0]
                            cursor.execute("""
                                INSERT IGNORE INTO column_validation_rules (column_id, rule_type_id, rule_config)
                                VALUES (%s, %s, %s)
                            """, (column_id, rule_type_id, '{}'))
                
                conn.commit()
                cursor.close()

                session['validations'] = validations
                session['current_step'] = 3 if action == 'review' else 2
                
                logging.info(f"Step 2 completed: action={action}, validations={validations}")
                return jsonify({'success': True, 'message': 'Step 2 completed successfully'})
            except Exception as e:
                logging.error(f"Error in step 2: {str(e)}")
                return jsonify({'success': False, 'message': str(e)}), 500
        
        # GET request
        selected_headers = session.get('selected_headers', [])
        return jsonify({'selected_headers': selected_headers})

    # Rules endpoint
    @app.route('/rules', methods=['GET'])
    @app.route('/api/rules', methods=['GET'])
    def get_rules():
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            
            cursor.execute("""
                SELECT rule_type_id AS rule_id, rule_name, description, parameters, is_custom, 
                       column_name, template_id, source_format, target_format, data_type, is_active
                FROM validation_rule_types
            """)
            rules = cursor.fetchall()
            cursor.close()
            
            logging.info(f"Returning {len(rules)} rules from getRules endpoint")
            return jsonify({'success': True, 'rules': rules})
        except mysql.connector.Error as e:
            logging.error(f"Database error fetching rules: {str(e)}")
            return jsonify({'success': False, 'message': str(e)}), 500
        except Exception as e:
            logging.error(f"Unexpected error fetching rules: {str(e)}")
            return jsonify({'success': False, 'message': str(e)}), 500

    # Template details endpoint
    @app.route('/template/<int:template_id>/<sheet_name>', methods=['GET'])
    @app.route('/api/template/<int:template_id>/<sheet_name>', methods=['GET'])
    def get_template(template_id, sheet_name):
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /template: session missing")
            return jsonify({'error': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("""
                SELECT template_name, sheet_name, headers
                FROM excel_templates
                WHERE template_id = %s AND user_id = %s AND status = 'ACTIVE'
            """, (template_id, session['user_id']))
            template_record = cursor.fetchone()
            
            if not template_record:
                logging.error(f"Template not found for template_id: {template_id}, user_id: {session['user_id']}")
                cursor.close()
                return jsonify({'error': 'Template not found'}), 404

            headers = json.loads(template_record['headers']) if template_record['headers'] else []
            stored_sheet_name = template_record['sheet_name'] or sheet_name
            file_path = os.path.join(app.config['UPLOAD_FOLDER'], template_record['template_name'])
            
            cursor.execute("""
                SELECT COUNT(*) as rule_count
                FROM template_columns tc
                JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                WHERE tc.template_id = %s AND tc.is_selected = TRUE
            """, (template_id,))
            rule_count = cursor.fetchone()['rule_count']
            has_existing_rules = rule_count > 0
            
            cursor.close()
            
            return jsonify({
                'success': True,
                'sheets': {stored_sheet_name: {'headers': headers}},
                'file_name': template_record['template_name'],
                'file_path': file_path,
                'sheet_name': stored_sheet_name,
                'has_existing_rules': has_existing_rules
            })
        except mysql.connector.Error as e:
            logging.error(f"Database error in get_template: {str(e)}")
            return jsonify({'error': f'Database error: {str(e)}'}), 500
        except Exception as e:
            logging.error(f"Unexpected error in get_template: {str(e)}")
            return jsonify({'error': f'Unexpected error: {str(e)}'}), 500

    # Debug route to show all registered routes
    @app.route('/debug/routes', methods=['GET'])
    def list_routes():
        routes = []
        for rule in app.url_map.iter_rules():
            routes.append({
                'endpoint': rule.endpoint,
                'methods': list(rule.methods),
                'rule': rule.rule
            })
        return jsonify(routes)

    # 404 handler to debug missing routes
    @app.errorhandler(404)
    def not_found_handler(error):
        logging.error(f"404 Error: {request.method} {request.url} not found")
        logging.error(f"Available routes: {[rule.rule for rule in app.url_map.iter_rules()]}")
        return jsonify({
            'error': 'Endpoint not found', 
            'method': request.method,
            'url': request.url,
            'path': request.path
        }), 404

    return app

def initialize_app_data():
    """Initialize database and create default data"""
    try:
        logging.info("Initializing database schema...")
        init_db()
        
        logging.info("Creating admin user...")
        create_admin_user()
        
        logging.info("Creating default validation rules...")
        create_default_validation_rules()
        
        logging.info("Application initialization completed successfully")
    except Exception as e:
        logging.error(f"Failed to initialize application: {e}")
        raise

DB_CONFIG = {
    'host': os.getenv('MYSQL_HOST', 'localhost'),
    'user': os.getenv('MYSQL_USER', 'root'),
    'password': os.getenv('MYSQL_PASSWORD', 'Keansa@2024'),
    'database': os.getenv('MYSQL_DATABASE', 'data_validation_2'),
}

def get_db_connection():
    if 'db' not in g:
        try:
            conn = mysql.connector.connect(
                host=DB_CONFIG['host'],
                user=DB_CONFIG['user'],
                password=DB_CONFIG['password']
            )
            cursor = conn.cursor()
            cursor.execute(f"CREATE DATABASE IF NOT EXISTS {DB_CONFIG['database']}")
            cursor.close()
            conn.close()
            g.db = mysql.connector.connect(**DB_CONFIG)
            logging.info("Database connection established successfully")
        except mysql.connector.Error as err:
            if err.errno == errorcode.ER_ACCESS_DENIED_ERROR:
                logging.error("Database connection failed: Access denied for user - check username/password")
            elif err.errno == errorcode.ER_BAD_DB_ERROR:
                logging.error("Database connection failed: Database does not exist")
            else:
                logging.error(f"Database connection failed: {err}")
            raise Exception(f"Failed to connect to database: {str(err)}")
    return g.db

def close_db(error):
    db = g.pop('db', None)
    if db is not None:
        db.close()

def init_db():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        tables = [
            """
            CREATE TABLE IF NOT EXISTS login_details (
                id INT AUTO_INCREMENT PRIMARY KEY,
                first_name VARCHAR(100),
                last_name VARCHAR(100),
                email VARCHAR(255) UNIQUE,
                mobile VARCHAR(10),
                password VARCHAR(255)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS excel_templates (
                template_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_name VARCHAR(255) NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
                user_id INT NOT NULL,
                sheet_name VARCHAR(255),
                headers JSON,
                status ENUM('ACTIVE', 'INACTIVE') DEFAULT 'ACTIVE',
                is_corrected BOOLEAN DEFAULT FALSE,
                remote_file_path VARCHAR(512),
                FOREIGN KEY (user_id) REFERENCES login_details(id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS template_columns (
                column_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_id BIGINT NOT NULL,
                column_name VARCHAR(255) NOT NULL,
                column_position INT NOT NULL,
                is_validation_enabled BOOLEAN DEFAULT FALSE,
                is_selected BOOLEAN DEFAULT FALSE,
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE,
                UNIQUE (template_id, column_name)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_rule_types (
                rule_type_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                rule_name VARCHAR(255) NOT NULL,
                description TEXT,
                parameters TEXT,
                is_active BOOLEAN DEFAULT TRUE,
                is_custom BOOLEAN DEFAULT FALSE,
                column_name VARCHAR(255),
                template_id BIGINT,
                data_type VARCHAR(50),
                source_format VARCHAR(50),
                target_format VARCHAR(50),
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS column_validation_rules (
                column_validation_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                column_id BIGINT NOT NULL,
                rule_type_id BIGINT NOT NULL,
                rule_config JSON,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (column_id) REFERENCES template_columns(column_id) ON DELETE CASCADE,
                FOREIGN KEY (rule_type_id) REFERENCES validation_rule_types(rule_type_id) ON DELETE RESTRICT,
                UNIQUE (column_id, rule_type_id)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_history (
                history_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_id BIGINT NOT NULL,
                template_name VARCHAR(255) NOT NULL,
                error_count INT NOT NULL,
                corrected_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                corrected_file_path VARCHAR(512) NOT NULL,
                user_id INT NOT NULL,
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE,
                FOREIGN KEY (user_id) REFERENCES login_details(id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_corrections (
                correction_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                history_id BIGINT NOT NULL,
                row_index INT NOT NULL,
                column_name VARCHAR(255) NOT NULL,
                original_value TEXT,
                corrected_value TEXT,
                rule_failed VARCHAR(255) DEFAULT NULL,
                FOREIGN KEY (history_id) REFERENCES validation_history(history_id) ON DELETE CASCADE
            )
            """
        ]
        for table_sql in tables:
            cursor.execute(table_sql)
        
        # Add missing columns if they don't exist
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'source_format'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN source_format VARCHAR(50)")
            logging.info("Added source_format column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'target_format'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN target_format VARCHAR(50)")
            logging.info("Added target_format column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'data_type'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN data_type VARCHAR(50)")
            logging.info("Added data_type column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM excel_templates LIKE 'remote_file_path'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE excel_templates ADD COLUMN remote_file_path VARCHAR(512)")
            logging.info("Added remote_file_path column to excel_templates table")
            
        cursor.execute("SHOW COLUMNS FROM template_columns LIKE 'is_selected'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE template_columns ADD COLUMN is_selected BOOLEAN DEFAULT FALSE")
            logging.info("Added is_selected column to template_columns table")
            
        conn.commit()
        cursor.close()
        logging.info("Database tables initialized")
    except Exception as e:
        logging.error(f"Failed to initialize database: {str(e)}")
        raise

def create_admin_user():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        admin_password = bcrypt.hashpw('admin'.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
        cursor.execute("""
            INSERT IGNORE INTO login_details (first_name, last_name, email, mobile, password)
            VALUES (%s, %s, %s, %s, %s)
        """, ('Admin', 'User', 'admin@example.com', '1234567890', admin_password))
        conn.commit()
        cursor.close()
        logging.info("Admin user created or already exists")
    except Exception as e:
        logging.error(f"Failed to create admin user: {str(e)}")
        raise

def create_default_validation_rules():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        default_rules = [
            ("Required", "Ensures the field is not null", '{"allow_null": false}', None, None, None),
            ("Int", "Validates integer format", '{"format": "integer"}', None, None, "Int"),
            ("Float", "Validates number format (integer or decimal)", '{"format": "float"}', None, None, "Float"),
            ("Text", "Allows text with quotes and parentheses", '{"allow_special": false}', None, None, "Text"),
            ("Email", "Validates email format", '{"regex": "^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\\\.[a-zA-Z0-9-.]+$"}', None, None, "Email"),
            ("Date(DD-MM-YYYY)", "Validates date format DD-MM-YYYY", '{"format": "%d-%m-%Y"}', "DD-MM-YYYY", None, "Date"),
            ("Boolean", "Validates boolean format (true/false or 0/1)", '{"format": "boolean"}', None, None, "Boolean"),
            ("Alphanumeric", "Validates alphanumeric format", '{"format": "alphanumeric"}', None, None, "Alphanumeric")
        ]
        cursor.executemany("""
            INSERT IGNORE INTO validation_rule_types (rule_name, description, parameters, is_custom, source_format, target_format, data_type)
            VALUES (%s, %s, %s, %s, %s, %s, %s)
        """, [(name, desc, params, False, source, target, dtype) for name, desc, params, source, target, dtype in default_rules])
        conn.commit()
        cursor.close()
        logging.info("Default validation rules ensured successfully")
    except Exception as e:
        logging.error(f"Failed to ensure default validation rules: {str(e)}")
        raise

if __name__ == '__main__':
    try:
        # Create the application using factory pattern
        app = create_app()
        
        # Initialize database and default data within app context
        with app.app_context():
            initialize_app_data()
        
        # Get port from environment or use default
        port = int(os.getenv('PORT', 5000))
        
        # Start the application server
        logging.info("Starting Flask server...")
        app.run(debug=True, host='0.0.0.0', port=port)
        
    except Exception as e:
        logging.error(f"Failed to start application: {e}")
        raise
).all():
        return "Int"
    
    if non_null.str.match(r'^-?\d+(\.\d+)?

def create_app():
    """Application factory pattern for different environments"""
    # Set the path to the frontend dist folder
    current_dir = os.path.dirname(os.path.abspath(__file__))
    frontend_dist_path = os.path.join(current_dir, '..', '..', 'Keansa-Ai-Suite2025may-frontend11', 'dist')
    frontend_dist_path = os.path.abspath(frontend_dist_path)
    
    # Create Flask application instance
    app = Flask(__name__, static_folder=frontend_dist_path, static_url_path='')
    CORS(app, supports_credentials=True, origins=["http://localhost:3000", "http://localhost:8080", "http://localhost:5000", "*"])

    app.secret_key = os.urandom(24).hex()
    app.config['SESSION_TYPE'] = 'filesystem'
    app.config['SESSION_FILE_DIR'] = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'sessions')
    app.config['SESSION_COOKIE_SAMESITE'] = 'Lax'
    app.config['SESSION_COOKIE_HTTPONLY'] = True
    app.config['SESSION_COOKIE_SECURE'] = False
    app.config['PERMANENT_SESSION_LIFETIME'] = 86400  # 24 hours
    app.config['UPLOAD_FOLDER'] = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'uploads')
    Session(app)

    # Ensure directories exist
    try:
        os.makedirs(app.config['UPLOAD_FOLDER'], exist_ok=True)
        os.makedirs(app.config['SESSION_FILE_DIR'], exist_ok=True)
    except OSError as e:
        logging.error(f"Failed to create directories: {e}")

    # Register cleanup handlers
    app.teardown_appcontext(close_db)
    
    # Register all routes directly in create_app
    
    # Static file serving for React frontend
    @app.route('/', defaults={'path': ''})
    @app.route('/<path:path>')
    def serve(path):
        if path and os.path.exists(os.path.join(app.static_folder, path)):
            return app.send_static_file(path)
        return app.send_static_file('index.html')

    # Health check endpoint
    @app.route('/health', methods=['GET'])
    def health_check():
        return jsonify({
            'status': 'healthy',
            'timestamp': datetime.now().isoformat(),
            'version': '2.0.0'
        })

    # Authentication endpoint - both old and new paths
    @app.route('/authenticate', methods=['POST'])
    @app.route('/api/auth/authenticate', methods=['POST'])
    def authenticate():
        try:
            email = request.form.get('username') or request.form.get('email')
            password = request.form.get('password')
            logging.debug(f"Login attempt: email={email}, password={'*' * len(password) if password else 'None'}")
            
            if not email or not password:
                logging.warning(f"Login failed: Email or password missing")
                return jsonify({'success': False, 'message': 'Email and password are required'}), 400

            # Check for admin login
            if email == "admin" and password == "admin":
                session['loggedin'] = True
                session['user_email'] = "admin@example.com"
                session['user_id'] = 1
                session.permanent = True
                logging.info(f"Admin login successful. Session: {dict(session)}")
                return jsonify({'success': True, 'message': 'Login successful', 'user': {'email': 'admin@example.com', 'id': 1}}), 200

            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("SELECT * FROM login_details WHERE LOWER(email) = LOWER(%s)", (email.lower(),))
            account = cursor.fetchone()
            cursor.close()
            
            if account:
                if bcrypt.checkpw(password.encode('utf-8'), account['password'].encode('utf-8')):
                    session['loggedin'] = True
                    session['user_email'] = account['email']
                    session['user_id'] = account['id']
                    session.permanent = True
                    logging.info(f"User {email} logged in successfully. Session: {dict(session)}")
                    return jsonify({
                        'success': True,
                        'message': 'Login successful',
                        'user': {'email': account['email'], 'id': account['id']}
                    }), 200
                else:
                    logging.warning(f"Invalid password for {email}")
                    return jsonify({'success': False, 'message': 'Invalid credentials'}), 401
            else:
                logging.warning(f"Email {email} not found")
                return jsonify({'success': False, 'message': 'Invalid credentials'}), 401
        except Exception as e:
            logging.error(f"Unexpected error during login: {str(e)}")
            return jsonify({'success': False, 'message': f'Unexpected error: {str(e)}'}), 500

    @app.route('/check-auth', methods=['GET'])
    @app.route('/api/auth/check-auth', methods=['GET'])
    def check_auth():
        try:
            logging.debug(f"Checking auth with session: {dict(session)}")
            if 'loggedin' in session and 'user_id' in session:
                conn = get_db_connection()
                cursor = conn.cursor(dictionary=True)
                cursor.execute("SELECT email, first_name FROM login_details WHERE id = %s", (session['user_id'],))
                user = cursor.fetchone()
                cursor.close()
                if user:
                    logging.info(f"User {session.get('user_email')} is authenticated")
                    return jsonify({
                        'success': True,
                        'user': {
                            'email': user['email'],
                            'id': session['user_id'],
                            'first_name': user['first_name']
                        }
                    })
                else:
                    logging.warning("User not found in database")  
                    session.clear()
                    return jsonify({'success': False, 'message': 'User not found'}), 401
            logging.warning("User not authenticated")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        except Exception as e:
            logging.error(f"Error in check-auth endpoint: {str(e)}")
            return jsonify({'success': False, 'message': f'Server error: {str(e)}'}), 500

    @app.route('/register', methods=['POST'])
    @app.route('/api/auth/register', methods=['POST'])
    def register():
        first_name = request.form.get('first_name')
        last_name = request.form.get('last_name')
        email = request.form.get('email')
        mobile = request.form.get('mobile')
        password = request.form.get('password')
        confirm_password = request.form.get('confirm_password')

        if not all([first_name, last_name, email, mobile, password, confirm_password]):
            return jsonify({'success': False, 'message': 'All fields are required'}), 400
        if password != confirm_password:
            return jsonify({'success': False, 'message': 'Passwords do not match'}), 400

        hashed_password = bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
        try:
            conn = get_db_connection()
            cursor = conn.cursor()
            cursor.execute("""
                INSERT INTO login_details (first_name, last_name, email, mobile, password)
                VALUES (%s, %s, %s, %s, %s)
            """, (first_name, last_name, email, mobile, hashed_password))
            user_id = cursor.lastrowid
            conn.commit()
            cursor.close()
            session['loggedin'] = True
            session['user_email'] = email
            session['user_id'] = user_id
            return jsonify({
                'success': True,
                'message': 'Registration successful',
                'user': {'email': email, 'id': user_id}
            }), 200
        except mysql.connector.Error as e:
            logging.error(f"Database error during registration: {str(e)}")
            return jsonify({'success': False, 'message': f'Registration error: {str(e)}'}), 500

    @app.route('/logout', methods=['POST'])
    @app.route('/api/auth/logout', methods=['POST'])
    def logout():
        logging.info(f"User {session.get('user_email', 'unknown')} logged out")
        session.clear()
        return jsonify({'success': True, 'message': 'Logged out successfully'})

    # Template routes
    @app.route('/templates', methods=['GET'])
    @app.route('/api/templates', methods=['GET'])
    def get_templates():
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /templates: session missing")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("""
                SELECT template_id, template_name, created_at, status
                FROM excel_templates
                WHERE user_id = %s AND status = 'ACTIVE'
                ORDER BY created_at DESC
                LIMIT 100
            """, (session['user_id'],))
            templates = cursor.fetchall()
            cursor.close()
            logging.info(f"Fetched {len(templates)} templates for user {session['user_id']}")
            return jsonify({'success': True, 'templates': templates})
        except mysql.connector.Error as e:
            logging.error(f'Error fetching templates: {str(e)}')
            return jsonify({'success': False, 'message': f'Error fetching templates: {str(e)}'}), 500
        except Exception as e:
            logging.error(f'Unexpected error fetching templates: {str(e)}')
            return jsonify({'success': False, 'message': f'Unexpected error: {str(e)}'}), 500

    # Rule Configuration routes
    @app.route('/rule-configurations', methods=['GET'])
    @app.route('/api/validation/rule-configurations', methods=['GET'])
    def get_rule_configurations():
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning(f"Unauthorized access to /rule-configurations: session={dict(session)}")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            user_id = session['user_id']
            logging.debug(f"Fetching rule configurations for user_id: {user_id}")

            # Main query to fetch templates with configured rules
            cursor.execute("""
                SELECT 
                    t.template_id, 
                    t.template_name, 
                    t.created_at, 
                    COUNT(cvr.column_validation_id) as rule_count
                FROM excel_templates t
                LEFT JOIN template_columns tc ON t.template_id = tc.template_id
                LEFT JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                WHERE t.user_id = %s AND t.status = 'ACTIVE' AND t.is_corrected = FALSE
                GROUP BY t.template_id, t.template_name, t.created_at
                HAVING rule_count > 0
                ORDER BY t.created_at DESC
                LIMIT 100
            """, (user_id,))
            templates = cursor.fetchall()
            logging.debug(f"Fetched rule-configured templates: {templates}")

            cursor.close()

            if not templates:
                logging.info(f"No templates with rules found for user_id: {user_id}")
            else:
                logging.info(f"Found {len(templates)} templates with rules for user_id: {user_id}")

            return jsonify({'success': True, 'templates': templates})
        except mysql.connector.Error as e:
            logging.error(f"Database error fetching rule configurations: {str(e)}")
            return jsonify({'success': False, 'message': f"Database error: {str(e)}"}), 500
        except Exception as e:
            logging.error(f"Unexpected error fetching rule configurations: {str(e)}")
            return jsonify({'success': False, 'message': f"Unexpected error: {str(e)}"}), 500

    # File upload route
    @app.route('/upload', methods=['POST'])
    @app.route('/api/templates/upload', methods=['POST'])
    @app.route('/api/upload', methods=['POST'])  # Additional common path
    def upload():
        logging.info(f"Upload endpoint called: {request.endpoint}, method: {request.method}")
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /upload: session missing")
            return jsonify({'error': 'Not logged in'}), 401
        if 'file' not in request.files:
            logging.warning("No file provided in upload request")
            return jsonify({'error': 'No file uploaded'}), 400
        file = request.files['file']
        if file.filename == '':
            logging.warning("No file selected in upload request")
            return jsonify({'error': 'No file selected'}), 400
        
        file_path = os.path.join(app.config['UPLOAD_FOLDER'], file.filename)
        try:
            file.save(file_path)
            logging.info(f"File saved: {file_path}")
        except Exception as e:
            logging.error(f"Failed to save file {file.filename}: {str(e)}")
            return jsonify({'error': f'Failed to save file: {str(e)}'}), 500

        try:
            # Read the file to get sheets and headers
            if file.filename.endswith('.xlsx') or file.filename.endswith('.xls'):
                xl = pd.ExcelFile(file_path)
                sheets = {sheet_name: pd.read_excel(file_path, sheet_name=sheet_name, header=None) 
                         for sheet_name in xl.sheet_names}
            elif file.filename.endswith(('.txt', '.csv', '.dat')):
                df = pd.read_csv(file_path, header=None, encoding='utf-8')
                sheets = {'Sheet1': df}
            else:
                logging.error("Unsupported file type")
                return jsonify({'error': 'Unsupported file type'}), 400
            
            logging.debug(f"Sheets extracted: {list(sheets.keys())}")
        except Exception as e:
            logging.error(f"Failed to read file {file_path}: {str(e)}")
            return jsonify({'error': f'Failed to read file: {str(e)}'}), 400

        try:
            sheet_names = list(sheets.keys())
            if not sheet_names:
                logging.error("No sheets found in the file")
                return jsonify({'error': 'No sheets found in the file'}), 400
            sheet_name = sheet_names[0]
            df = sheets[sheet_name]
            
            # Find header row
            header_row = 0
            for i in range(min(len(df), 10)):
                row = df.iloc[i].dropna()
                if not row.empty and all(isinstance(x, str) for x in row if pd.notna(x)):
                    header_row = i
                    break
                    
            headers = df.iloc[header_row].tolist()
            logging.debug(f"Headers extracted: {headers}")
            
            if not headers or all(not h for h in headers):
                logging.error("No valid headers found in file")
                return jsonify({'error': 'No valid headers found in the file'}), 400
        except Exception as e:
            logging.error(f"Error processing file {file.filename}: {str(e)}")
            return jsonify({'error': f'Error processing file: {str(e)}'}), 400

        # Clear existing session data
        for key in ['df', 'header_row', 'headers', 'sheet_name', 'current_step', 'selected_headers', 'validations', 'error_cell_locations', 'data_rows', 'corrected_file_path']:
            session.pop(key, None)

        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)

            # Check if template exists
            cursor.execute("""
                SELECT template_id, headers, sheet_name
                FROM excel_templates
                WHERE template_name = %s AND user_id = %s AND status = 'ACTIVE'
                ORDER BY created_at DESC
            """, (file.filename, session['user_id']))
            existing_templates = cursor.fetchall()
            logging.info(f"Found {len(existing_templates)} existing templates with name {file.filename}")

            template_id = None
            has_existing_rules = False
            validations = {}
            selected_headers = []

            # Check for matching template
            matching_template = None
            for template in existing_templates:
                stored_headers = json.loads(template['headers']) if template['headers'] else []
                stored_sheet_name = template['sheet_name']
                if stored_headers == headers and stored_sheet_name == sheet_name:
                    matching_template = template
                    break

            if matching_template:
                template_id = matching_template['template_id']
                # Check for existing rules
                cursor.execute("""
                    SELECT tc.column_name, vrt.rule_name
                    FROM template_columns tc
                    JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                    JOIN validation_rule_types vrt ON cvr.rule_type_id = vrt.rule_type_id
                    WHERE tc.template_id = %s AND tc.is_selected = TRUE
                """, (template_id,))
                rules_data = cursor.fetchall()
                for row in rules_data:
                    column_name = row['column_name']
                    rule_name = row['rule_name']
                    if column_name not in validations:
                        validations[column_name] = []
                    validations[column_name].append(rule_name)
                    if column_name not in selected_headers:
                        selected_headers.append(column_name)
                has_existing_rules = len(validations) > 0
            else:
                # New template
                cursor.execute("""
                    INSERT INTO excel_templates (template_name, user_id, sheet_name, headers, is_corrected)
                    VALUES (%s, %s, %s, %s, %s)
                """, (file.filename, session['user_id'], sheet_name, json.dumps(headers), False))
                template_id = cursor.lastrowid
                column_data = [(template_id, header, i + 1, False) for i, header in enumerate(headers)]
                cursor.executemany("""
                    INSERT INTO template_columns (template_id, column_name, column_position, is_selected)
                    VALUES (%s, %s, %s, %s)
                """, column_data)

            conn.commit()
            cursor.close()

            # Store session data
            session['file_path'] = file_path
            session['template_id'] = template_id
            session['df'] = df.to_json()
            session['header_row'] = header_row
            session['headers'] = headers
            session['sheet_name'] = sheet_name
            session['current_step'] = 1 if not has_existing_rules else 3
            session['validations'] = validations
            session['selected_headers'] = selected_headers
            session['has_existing_rules'] = has_existing_rules

            logging.info(f"Upload processed: template_id={template_id}, filename={file.filename}, has_existing_rules={has_existing_rules}")

            return jsonify({
                'success': True,
                'sheets': {sheet_name: {'headers': headers}},
                'file_name': file.filename,
                'template_id': template_id,
                'has_existing_rules': has_existing_rules,
                'sheet_name': sheet_name,
                'skip_to_step_3': has_existing_rules
            })
        except mysql.connector.Error as e:
            logging.error(f'Error saving template: {str(e)}')
            return jsonify({'error': f'Error saving template: {str(e)}'}), 500
        except Exception as e:
            logging.error(f'Unexpected error saving template: {str(e)}')
            return jsonify({'error': f'Unexpected error: {str(e)}'}), 500

    # Multi-step workflow endpoints
    @app.route('/step/1', methods=['GET', 'POST'])
    @app.route('/api/step/1', methods=['GET', 'POST'])
    def step_one():
        if 'loggedin' not in session:
            return jsonify({'error': 'Not logged in'}), 401
        
        if request.method == 'POST':
            try:
                headers = request.form.getlist('headers')
                new_header_row = request.form.get('new_header_row')
                logging.debug(f"Step 1 submitted: headers={headers}, new_header_row={new_header_row}")
                
                if not headers:
                    logging.error("No headers provided in step 1")
                    return jsonify({'success': False, 'message': 'No headers provided'}), 400
                    
                if 'template_id' not in session:
                    logging.error("Session missing template_id")
                    return jsonify({'success': False, 'message': 'Session data missing'}), 400

                template_id = session['template_id']
                
                # Get the dataframe from session for auto-detection
                df_json = session.get('df')
                if df_json:
                    df = pd.read_json(StringIO(df_json))
                    session_headers = session.get('headers', [])
                    df.columns = session_headers
                    header_row = session.get('header_row', 0)
                    df = df.iloc[header_row + 1:].reset_index(drop=True)
                    
                    # Auto-detect rules for selected headers
                    validations = assign_default_rules_to_columns(df, headers)
                    session['validations'] = validations
                    logging.debug(f"Auto-assigned rules: {validations}")
                else:
                    validations = {}

                session['selected_headers'] = headers
                session['current_step'] = 2

                # Mark selected headers in the database
                conn = get_db_connection()
                cursor = conn.cursor()
                cursor.execute("UPDATE template_columns SET is_selected = FALSE WHERE template_id = %s", (template_id,))
                for header in headers:
                    cursor.execute("""
                        UPDATE template_columns
                        SET is_selected = TRUE
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    
                    # Get column_id and add auto-detected rules
                    cursor.execute("""
                        SELECT column_id FROM template_columns
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    result = cursor.fetchone()
                    if result:
                        column_id = result[0]
                        for rule_name in validations.get(header, []):
                            cursor.execute("""
                                SELECT rule_type_id FROM validation_rule_types
                                WHERE rule_name = %s AND is_custom = FALSE
                            """, (rule_name,))
                            rule_result = cursor.fetchone()
                            if rule_result:
                                rule_type_id = rule_result[0]
                                cursor.execute("""
                                    INSERT IGNORE INTO column_validation_rules (column_id, rule_type_id, rule_config)
                                    VALUES (%s, %s, %s)
                                """, (column_id, rule_type_id, '{}'))
                
                conn.commit()
                cursor.close()

                logging.info(f"Step 1 completed: headers={headers}, auto-assigned rules={validations}")
                return jsonify({'success': True, 'headers': headers, 'validations': validations})
            except Exception as e:
                logging.error(f"Error in step 1: {str(e)}")
                return jsonify({'success': False, 'message': str(e)}), 500
        
        # GET request - return current headers
        headers = session.get('headers', [])
        return jsonify({'headers': headers})

    @app.route('/step/2', methods=['GET', 'POST'])
    @app.route('/api/step/2', methods=['GET', 'POST'])
    def step_two():
        if 'loggedin' not in session:
            return jsonify({'error': 'Not logged in'}), 401
            
        if request.method == 'POST':
            try:
                action = request.form.get('action', 'save')
                validations = {}
                for key, values in request.form.lists():
                    if key.startswith('validations_'):
                        header = key.replace('validations_', '')
                        validations[header] = values
                        
                logging.debug(f"Step 2 submitted: action={action}, validations={validations}")
                
                template_id = session.get('template_id')
                if not template_id:
                    return jsonify({'success': False, 'message': 'Session data missing'}), 400

                # Save validations to database
                conn = get_db_connection()
                cursor = conn.cursor()
                
                # Clear existing rules
                cursor.execute("""
                    DELETE FROM column_validation_rules
                    WHERE column_id IN (
                        SELECT column_id FROM template_columns WHERE template_id = %s
                    )
                """, (template_id,))
                
                # Add new rules
                for header, rules in validations.items():
                    cursor.execute("""
                        SELECT column_id FROM template_columns
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    result = cursor.fetchone()
                    if not result:
                        continue
                    column_id = result[0]
                    
                    for rule_name in rules:
                        cursor.execute("""
                            SELECT rule_type_id FROM validation_rule_types
                            WHERE rule_name = %s
                        """, (rule_name,))
                        result = cursor.fetchone()
                        if result:
                            rule_type_id = result[0]
                            cursor.execute("""
                                INSERT IGNORE INTO column_validation_rules (column_id, rule_type_id, rule_config)
                                VALUES (%s, %s, %s)
                            """, (column_id, rule_type_id, '{}'))
                
                conn.commit()
                cursor.close()

                session['validations'] = validations
                session['current_step'] = 3 if action == 'review' else 2
                
                logging.info(f"Step 2 completed: action={action}, validations={validations}")
                return jsonify({'success': True, 'message': 'Step 2 completed successfully'})
            except Exception as e:
                logging.error(f"Error in step 2: {str(e)}")
                return jsonify({'success': False, 'message': str(e)}), 500
        
        # GET request
        selected_headers = session.get('selected_headers', [])
        return jsonify({'selected_headers': selected_headers})

    # Rules endpoint
    @app.route('/rules', methods=['GET'])
    @app.route('/api/rules', methods=['GET'])
    def get_rules():
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            
            cursor.execute("""
                SELECT rule_type_id AS rule_id, rule_name, description, parameters, is_custom, 
                       column_name, template_id, source_format, target_format, data_type, is_active
                FROM validation_rule_types
            """)
            rules = cursor.fetchall()
            cursor.close()
            
            logging.info(f"Returning {len(rules)} rules from getRules endpoint")
            return jsonify({'success': True, 'rules': rules})
        except mysql.connector.Error as e:
            logging.error(f"Database error fetching rules: {str(e)}")
            return jsonify({'success': False, 'message': str(e)}), 500
        except Exception as e:
            logging.error(f"Unexpected error fetching rules: {str(e)}")
            return jsonify({'success': False, 'message': str(e)}), 500

    # Template details endpoint
    @app.route('/template/<int:template_id>/<sheet_name>', methods=['GET'])
    @app.route('/api/template/<int:template_id>/<sheet_name>', methods=['GET'])
    def get_template(template_id, sheet_name):
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /template: session missing")
            return jsonify({'error': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("""
                SELECT template_name, sheet_name, headers
                FROM excel_templates
                WHERE template_id = %s AND user_id = %s AND status = 'ACTIVE'
            """, (template_id, session['user_id']))
            template_record = cursor.fetchone()
            
            if not template_record:
                logging.error(f"Template not found for template_id: {template_id}, user_id: {session['user_id']}")
                cursor.close()
                return jsonify({'error': 'Template not found'}), 404

            headers = json.loads(template_record['headers']) if template_record['headers'] else []
            stored_sheet_name = template_record['sheet_name'] or sheet_name
            file_path = os.path.join(app.config['UPLOAD_FOLDER'], template_record['template_name'])
            
            cursor.execute("""
                SELECT COUNT(*) as rule_count
                FROM template_columns tc
                JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                WHERE tc.template_id = %s AND tc.is_selected = TRUE
            """, (template_id,))
            rule_count = cursor.fetchone()['rule_count']
            has_existing_rules = rule_count > 0
            
            cursor.close()
            
            return jsonify({
                'success': True,
                'sheets': {stored_sheet_name: {'headers': headers}},
                'file_name': template_record['template_name'],
                'file_path': file_path,
                'sheet_name': stored_sheet_name,
                'has_existing_rules': has_existing_rules
            })
        except mysql.connector.Error as e:
            logging.error(f"Database error in get_template: {str(e)}")
            return jsonify({'error': f'Database error: {str(e)}'}), 500
        except Exception as e:
            logging.error(f"Unexpected error in get_template: {str(e)}")
            return jsonify({'error': f'Unexpected error: {str(e)}'}), 500

    # Debug route to show all registered routes
    @app.route('/debug/routes', methods=['GET'])
    def list_routes():
        routes = []
        for rule in app.url_map.iter_rules():
            routes.append({
                'endpoint': rule.endpoint,
                'methods': list(rule.methods),
                'rule': rule.rule
            })
        return jsonify(routes)

    # 404 handler to debug missing routes
    @app.errorhandler(404)
    def not_found_handler(error):
        logging.error(f"404 Error: {request.method} {request.url} not found")
        logging.error(f"Available routes: {[rule.rule for rule in app.url_map.iter_rules()]}")
        return jsonify({
            'error': 'Endpoint not found', 
            'method': request.method,
            'url': request.url,
            'path': request.path
        }), 404

    return app

def initialize_app_data():
    """Initialize database and create default data"""
    try:
        logging.info("Initializing database schema...")
        init_db()
        
        logging.info("Creating admin user...")
        create_admin_user()
        
        logging.info("Creating default validation rules...")
        create_default_validation_rules()
        
        logging.info("Application initialization completed successfully")
    except Exception as e:
        logging.error(f"Failed to initialize application: {e}")
        raise

DB_CONFIG = {
    'host': os.getenv('MYSQL_HOST', 'localhost'),
    'user': os.getenv('MYSQL_USER', 'root'),
    'password': os.getenv('MYSQL_PASSWORD', 'Keansa@2024'),
    'database': os.getenv('MYSQL_DATABASE', 'data_validation_2'),
}

def get_db_connection():
    if 'db' not in g:
        try:
            conn = mysql.connector.connect(
                host=DB_CONFIG['host'],
                user=DB_CONFIG['user'],
                password=DB_CONFIG['password']
            )
            cursor = conn.cursor()
            cursor.execute(f"CREATE DATABASE IF NOT EXISTS {DB_CONFIG['database']}")
            cursor.close()
            conn.close()
            g.db = mysql.connector.connect(**DB_CONFIG)
            logging.info("Database connection established successfully")
        except mysql.connector.Error as err:
            if err.errno == errorcode.ER_ACCESS_DENIED_ERROR:
                logging.error("Database connection failed: Access denied for user - check username/password")
            elif err.errno == errorcode.ER_BAD_DB_ERROR:
                logging.error("Database connection failed: Database does not exist")
            else:
                logging.error(f"Database connection failed: {err}")
            raise Exception(f"Failed to connect to database: {str(err)}")
    return g.db

def close_db(error):
    db = g.pop('db', None)
    if db is not None:
        db.close()

def init_db():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        tables = [
            """
            CREATE TABLE IF NOT EXISTS login_details (
                id INT AUTO_INCREMENT PRIMARY KEY,
                first_name VARCHAR(100),
                last_name VARCHAR(100),
                email VARCHAR(255) UNIQUE,
                mobile VARCHAR(10),
                password VARCHAR(255)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS excel_templates (
                template_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_name VARCHAR(255) NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
                user_id INT NOT NULL,
                sheet_name VARCHAR(255),
                headers JSON,
                status ENUM('ACTIVE', 'INACTIVE') DEFAULT 'ACTIVE',
                is_corrected BOOLEAN DEFAULT FALSE,
                remote_file_path VARCHAR(512),
                FOREIGN KEY (user_id) REFERENCES login_details(id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS template_columns (
                column_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_id BIGINT NOT NULL,
                column_name VARCHAR(255) NOT NULL,
                column_position INT NOT NULL,
                is_validation_enabled BOOLEAN DEFAULT FALSE,
                is_selected BOOLEAN DEFAULT FALSE,
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE,
                UNIQUE (template_id, column_name)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_rule_types (
                rule_type_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                rule_name VARCHAR(255) NOT NULL,
                description TEXT,
                parameters TEXT,
                is_active BOOLEAN DEFAULT TRUE,
                is_custom BOOLEAN DEFAULT FALSE,
                column_name VARCHAR(255),
                template_id BIGINT,
                data_type VARCHAR(50),
                source_format VARCHAR(50),
                target_format VARCHAR(50),
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS column_validation_rules (
                column_validation_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                column_id BIGINT NOT NULL,
                rule_type_id BIGINT NOT NULL,
                rule_config JSON,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (column_id) REFERENCES template_columns(column_id) ON DELETE CASCADE,
                FOREIGN KEY (rule_type_id) REFERENCES validation_rule_types(rule_type_id) ON DELETE RESTRICT,
                UNIQUE (column_id, rule_type_id)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_history (
                history_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_id BIGINT NOT NULL,
                template_name VARCHAR(255) NOT NULL,
                error_count INT NOT NULL,
                corrected_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                corrected_file_path VARCHAR(512) NOT NULL,
                user_id INT NOT NULL,
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE,
                FOREIGN KEY (user_id) REFERENCES login_details(id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_corrections (
                correction_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                history_id BIGINT NOT NULL,
                row_index INT NOT NULL,
                column_name VARCHAR(255) NOT NULL,
                original_value TEXT,
                corrected_value TEXT,
                rule_failed VARCHAR(255) DEFAULT NULL,
                FOREIGN KEY (history_id) REFERENCES validation_history(history_id) ON DELETE CASCADE
            )
            """
        ]
        for table_sql in tables:
            cursor.execute(table_sql)
        
        # Add missing columns if they don't exist
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'source_format'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN source_format VARCHAR(50)")
            logging.info("Added source_format column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'target_format'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN target_format VARCHAR(50)")
            logging.info("Added target_format column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'data_type'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN data_type VARCHAR(50)")
            logging.info("Added data_type column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM excel_templates LIKE 'remote_file_path'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE excel_templates ADD COLUMN remote_file_path VARCHAR(512)")
            logging.info("Added remote_file_path column to excel_templates table")
            
        cursor.execute("SHOW COLUMNS FROM template_columns LIKE 'is_selected'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE template_columns ADD COLUMN is_selected BOOLEAN DEFAULT FALSE")
            logging.info("Added is_selected column to template_columns table")
            
        conn.commit()
        cursor.close()
        logging.info("Database tables initialized")
    except Exception as e:
        logging.error(f"Failed to initialize database: {str(e)}")
        raise

def create_admin_user():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        admin_password = bcrypt.hashpw('admin'.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
        cursor.execute("""
            INSERT IGNORE INTO login_details (first_name, last_name, email, mobile, password)
            VALUES (%s, %s, %s, %s, %s)
        """, ('Admin', 'User', 'admin@example.com', '1234567890', admin_password))
        conn.commit()
        cursor.close()
        logging.info("Admin user created or already exists")
    except Exception as e:
        logging.error(f"Failed to create admin user: {str(e)}")
        raise

def create_default_validation_rules():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        default_rules = [
            ("Required", "Ensures the field is not null", '{"allow_null": false}', None, None, None),
            ("Int", "Validates integer format", '{"format": "integer"}', None, None, "Int"),
            ("Float", "Validates number format (integer or decimal)", '{"format": "float"}', None, None, "Float"),
            ("Text", "Allows text with quotes and parentheses", '{"allow_special": false}', None, None, "Text"),
            ("Email", "Validates email format", '{"regex": "^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\\\.[a-zA-Z0-9-.]+$"}', None, None, "Email"),
            ("Date(DD-MM-YYYY)", "Validates date format DD-MM-YYYY", '{"format": "%d-%m-%Y"}', "DD-MM-YYYY", None, "Date"),
            ("Boolean", "Validates boolean format (true/false or 0/1)", '{"format": "boolean"}', None, None, "Boolean"),
            ("Alphanumeric", "Validates alphanumeric format", '{"format": "alphanumeric"}', None, None, "Alphanumeric")
        ]
        cursor.executemany("""
            INSERT IGNORE INTO validation_rule_types (rule_name, description, parameters, is_custom, source_format, target_format, data_type)
            VALUES (%s, %s, %s, %s, %s, %s, %s)
        """, [(name, desc, params, False, source, target, dtype) for name, desc, params, source, target, dtype in default_rules])
        conn.commit()
        cursor.close()
        logging.info("Default validation rules ensured successfully")
    except Exception as e:
        logging.error(f"Failed to ensure default validation rules: {str(e)}")
        raise

if __name__ == '__main__':
    try:
        # Create the application using factory pattern
        app = create_app()
        
        # Initialize database and default data within app context
        with app.app_context():
            initialize_app_data()
        
        # Get port from environment or use default
        port = int(os.getenv('PORT', 5000))
        
        # Start the application server
        logging.info("Starting Flask server...")
        app.run(debug=True, host='0.0.0.0', port=port)
        
    except Exception as e:
        logging.error(f"Failed to start application: {e}")
        raise
).all():
        return "Float"
    
    # Alphanumeric detection
    if non_null.str.match(r'^[a-zA-Z0-9]+

def create_app():
    """Application factory pattern for different environments"""
    # Set the path to the frontend dist folder
    current_dir = os.path.dirname(os.path.abspath(__file__))
    frontend_dist_path = os.path.join(current_dir, '..', '..', 'Keansa-Ai-Suite2025may-frontend11', 'dist')
    frontend_dist_path = os.path.abspath(frontend_dist_path)
    
    # Create Flask application instance
    app = Flask(__name__, static_folder=frontend_dist_path, static_url_path='')
    CORS(app, supports_credentials=True, origins=["http://localhost:3000", "http://localhost:8080", "http://localhost:5000", "*"])

    app.secret_key = os.urandom(24).hex()
    app.config['SESSION_TYPE'] = 'filesystem'
    app.config['SESSION_FILE_DIR'] = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'sessions')
    app.config['SESSION_COOKIE_SAMESITE'] = 'Lax'
    app.config['SESSION_COOKIE_HTTPONLY'] = True
    app.config['SESSION_COOKIE_SECURE'] = False
    app.config['PERMANENT_SESSION_LIFETIME'] = 86400  # 24 hours
    app.config['UPLOAD_FOLDER'] = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'uploads')
    Session(app)

    # Ensure directories exist
    try:
        os.makedirs(app.config['UPLOAD_FOLDER'], exist_ok=True)
        os.makedirs(app.config['SESSION_FILE_DIR'], exist_ok=True)
    except OSError as e:
        logging.error(f"Failed to create directories: {e}")

    # Register cleanup handlers
    app.teardown_appcontext(close_db)
    
    # Register all routes directly in create_app
    
    # Static file serving for React frontend
    @app.route('/', defaults={'path': ''})
    @app.route('/<path:path>')
    def serve(path):
        if path and os.path.exists(os.path.join(app.static_folder, path)):
            return app.send_static_file(path)
        return app.send_static_file('index.html')

    # Health check endpoint
    @app.route('/health', methods=['GET'])
    def health_check():
        return jsonify({
            'status': 'healthy',
            'timestamp': datetime.now().isoformat(),
            'version': '2.0.0'
        })

    # Authentication endpoint - both old and new paths
    @app.route('/authenticate', methods=['POST'])
    @app.route('/api/auth/authenticate', methods=['POST'])
    def authenticate():
        try:
            email = request.form.get('username') or request.form.get('email')
            password = request.form.get('password')
            logging.debug(f"Login attempt: email={email}, password={'*' * len(password) if password else 'None'}")
            
            if not email or not password:
                logging.warning(f"Login failed: Email or password missing")
                return jsonify({'success': False, 'message': 'Email and password are required'}), 400

            # Check for admin login
            if email == "admin" and password == "admin":
                session['loggedin'] = True
                session['user_email'] = "admin@example.com"
                session['user_id'] = 1
                session.permanent = True
                logging.info(f"Admin login successful. Session: {dict(session)}")
                return jsonify({'success': True, 'message': 'Login successful', 'user': {'email': 'admin@example.com', 'id': 1}}), 200

            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("SELECT * FROM login_details WHERE LOWER(email) = LOWER(%s)", (email.lower(),))
            account = cursor.fetchone()
            cursor.close()
            
            if account:
                if bcrypt.checkpw(password.encode('utf-8'), account['password'].encode('utf-8')):
                    session['loggedin'] = True
                    session['user_email'] = account['email']
                    session['user_id'] = account['id']
                    session.permanent = True
                    logging.info(f"User {email} logged in successfully. Session: {dict(session)}")
                    return jsonify({
                        'success': True,
                        'message': 'Login successful',
                        'user': {'email': account['email'], 'id': account['id']}
                    }), 200
                else:
                    logging.warning(f"Invalid password for {email}")
                    return jsonify({'success': False, 'message': 'Invalid credentials'}), 401
            else:
                logging.warning(f"Email {email} not found")
                return jsonify({'success': False, 'message': 'Invalid credentials'}), 401
        except Exception as e:
            logging.error(f"Unexpected error during login: {str(e)}")
            return jsonify({'success': False, 'message': f'Unexpected error: {str(e)}'}), 500

    @app.route('/check-auth', methods=['GET'])
    @app.route('/api/auth/check-auth', methods=['GET'])
    def check_auth():
        try:
            logging.debug(f"Checking auth with session: {dict(session)}")
            if 'loggedin' in session and 'user_id' in session:
                conn = get_db_connection()
                cursor = conn.cursor(dictionary=True)
                cursor.execute("SELECT email, first_name FROM login_details WHERE id = %s", (session['user_id'],))
                user = cursor.fetchone()
                cursor.close()
                if user:
                    logging.info(f"User {session.get('user_email')} is authenticated")
                    return jsonify({
                        'success': True,
                        'user': {
                            'email': user['email'],
                            'id': session['user_id'],
                            'first_name': user['first_name']
                        }
                    })
                else:
                    logging.warning("User not found in database")  
                    session.clear()
                    return jsonify({'success': False, 'message': 'User not found'}), 401
            logging.warning("User not authenticated")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        except Exception as e:
            logging.error(f"Error in check-auth endpoint: {str(e)}")
            return jsonify({'success': False, 'message': f'Server error: {str(e)}'}), 500

    @app.route('/register', methods=['POST'])
    @app.route('/api/auth/register', methods=['POST'])
    def register():
        first_name = request.form.get('first_name')
        last_name = request.form.get('last_name')
        email = request.form.get('email')
        mobile = request.form.get('mobile')
        password = request.form.get('password')
        confirm_password = request.form.get('confirm_password')

        if not all([first_name, last_name, email, mobile, password, confirm_password]):
            return jsonify({'success': False, 'message': 'All fields are required'}), 400
        if password != confirm_password:
            return jsonify({'success': False, 'message': 'Passwords do not match'}), 400

        hashed_password = bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
        try:
            conn = get_db_connection()
            cursor = conn.cursor()
            cursor.execute("""
                INSERT INTO login_details (first_name, last_name, email, mobile, password)
                VALUES (%s, %s, %s, %s, %s)
            """, (first_name, last_name, email, mobile, hashed_password))
            user_id = cursor.lastrowid
            conn.commit()
            cursor.close()
            session['loggedin'] = True
            session['user_email'] = email
            session['user_id'] = user_id
            return jsonify({
                'success': True,
                'message': 'Registration successful',
                'user': {'email': email, 'id': user_id}
            }), 200
        except mysql.connector.Error as e:
            logging.error(f"Database error during registration: {str(e)}")
            return jsonify({'success': False, 'message': f'Registration error: {str(e)}'}), 500

    @app.route('/logout', methods=['POST'])
    @app.route('/api/auth/logout', methods=['POST'])
    def logout():
        logging.info(f"User {session.get('user_email', 'unknown')} logged out")
        session.clear()
        return jsonify({'success': True, 'message': 'Logged out successfully'})

    # Template routes
    @app.route('/templates', methods=['GET'])
    @app.route('/api/templates', methods=['GET'])
    def get_templates():
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /templates: session missing")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("""
                SELECT template_id, template_name, created_at, status
                FROM excel_templates
                WHERE user_id = %s AND status = 'ACTIVE'
                ORDER BY created_at DESC
                LIMIT 100
            """, (session['user_id'],))
            templates = cursor.fetchall()
            cursor.close()
            logging.info(f"Fetched {len(templates)} templates for user {session['user_id']}")
            return jsonify({'success': True, 'templates': templates})
        except mysql.connector.Error as e:
            logging.error(f'Error fetching templates: {str(e)}')
            return jsonify({'success': False, 'message': f'Error fetching templates: {str(e)}'}), 500
        except Exception as e:
            logging.error(f'Unexpected error fetching templates: {str(e)}')
            return jsonify({'success': False, 'message': f'Unexpected error: {str(e)}'}), 500

    # Rule Configuration routes
    @app.route('/rule-configurations', methods=['GET'])
    @app.route('/api/validation/rule-configurations', methods=['GET'])
    def get_rule_configurations():
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning(f"Unauthorized access to /rule-configurations: session={dict(session)}")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            user_id = session['user_id']
            logging.debug(f"Fetching rule configurations for user_id: {user_id}")

            # Main query to fetch templates with configured rules
            cursor.execute("""
                SELECT 
                    t.template_id, 
                    t.template_name, 
                    t.created_at, 
                    COUNT(cvr.column_validation_id) as rule_count
                FROM excel_templates t
                LEFT JOIN template_columns tc ON t.template_id = tc.template_id
                LEFT JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                WHERE t.user_id = %s AND t.status = 'ACTIVE' AND t.is_corrected = FALSE
                GROUP BY t.template_id, t.template_name, t.created_at
                HAVING rule_count > 0
                ORDER BY t.created_at DESC
                LIMIT 100
            """, (user_id,))
            templates = cursor.fetchall()
            logging.debug(f"Fetched rule-configured templates: {templates}")

            cursor.close()

            if not templates:
                logging.info(f"No templates with rules found for user_id: {user_id}")
            else:
                logging.info(f"Found {len(templates)} templates with rules for user_id: {user_id}")

            return jsonify({'success': True, 'templates': templates})
        except mysql.connector.Error as e:
            logging.error(f"Database error fetching rule configurations: {str(e)}")
            return jsonify({'success': False, 'message': f"Database error: {str(e)}"}), 500
        except Exception as e:
            logging.error(f"Unexpected error fetching rule configurations: {str(e)}")
            return jsonify({'success': False, 'message': f"Unexpected error: {str(e)}"}), 500

    # File upload route
    @app.route('/upload', methods=['POST'])
    @app.route('/api/templates/upload', methods=['POST'])
    @app.route('/api/upload', methods=['POST'])  # Additional common path
    def upload():
        logging.info(f"Upload endpoint called: {request.endpoint}, method: {request.method}")
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /upload: session missing")
            return jsonify({'error': 'Not logged in'}), 401
        if 'file' not in request.files:
            logging.warning("No file provided in upload request")
            return jsonify({'error': 'No file uploaded'}), 400
        file = request.files['file']
        if file.filename == '':
            logging.warning("No file selected in upload request")
            return jsonify({'error': 'No file selected'}), 400
        
        file_path = os.path.join(app.config['UPLOAD_FOLDER'], file.filename)
        try:
            file.save(file_path)
            logging.info(f"File saved: {file_path}")
        except Exception as e:
            logging.error(f"Failed to save file {file.filename}: {str(e)}")
            return jsonify({'error': f'Failed to save file: {str(e)}'}), 500

        try:
            # Read the file to get sheets and headers
            if file.filename.endswith('.xlsx') or file.filename.endswith('.xls'):
                xl = pd.ExcelFile(file_path)
                sheets = {sheet_name: pd.read_excel(file_path, sheet_name=sheet_name, header=None) 
                         for sheet_name in xl.sheet_names}
            elif file.filename.endswith(('.txt', '.csv', '.dat')):
                df = pd.read_csv(file_path, header=None, encoding='utf-8')
                sheets = {'Sheet1': df}
            else:
                logging.error("Unsupported file type")
                return jsonify({'error': 'Unsupported file type'}), 400
            
            logging.debug(f"Sheets extracted: {list(sheets.keys())}")
        except Exception as e:
            logging.error(f"Failed to read file {file_path}: {str(e)}")
            return jsonify({'error': f'Failed to read file: {str(e)}'}), 400

        try:
            sheet_names = list(sheets.keys())
            if not sheet_names:
                logging.error("No sheets found in the file")
                return jsonify({'error': 'No sheets found in the file'}), 400
            sheet_name = sheet_names[0]
            df = sheets[sheet_name]
            
            # Find header row
            header_row = 0
            for i in range(min(len(df), 10)):
                row = df.iloc[i].dropna()
                if not row.empty and all(isinstance(x, str) for x in row if pd.notna(x)):
                    header_row = i
                    break
                    
            headers = df.iloc[header_row].tolist()
            logging.debug(f"Headers extracted: {headers}")
            
            if not headers or all(not h for h in headers):
                logging.error("No valid headers found in file")
                return jsonify({'error': 'No valid headers found in the file'}), 400
        except Exception as e:
            logging.error(f"Error processing file {file.filename}: {str(e)}")
            return jsonify({'error': f'Error processing file: {str(e)}'}), 400

        # Clear existing session data
        for key in ['df', 'header_row', 'headers', 'sheet_name', 'current_step', 'selected_headers', 'validations', 'error_cell_locations', 'data_rows', 'corrected_file_path']:
            session.pop(key, None)

        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)

            # Check if template exists
            cursor.execute("""
                SELECT template_id, headers, sheet_name
                FROM excel_templates
                WHERE template_name = %s AND user_id = %s AND status = 'ACTIVE'
                ORDER BY created_at DESC
            """, (file.filename, session['user_id']))
            existing_templates = cursor.fetchall()
            logging.info(f"Found {len(existing_templates)} existing templates with name {file.filename}")

            template_id = None
            has_existing_rules = False
            validations = {}
            selected_headers = []

            # Check for matching template
            matching_template = None
            for template in existing_templates:
                stored_headers = json.loads(template['headers']) if template['headers'] else []
                stored_sheet_name = template['sheet_name']
                if stored_headers == headers and stored_sheet_name == sheet_name:
                    matching_template = template
                    break

            if matching_template:
                template_id = matching_template['template_id']
                # Check for existing rules
                cursor.execute("""
                    SELECT tc.column_name, vrt.rule_name
                    FROM template_columns tc
                    JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                    JOIN validation_rule_types vrt ON cvr.rule_type_id = vrt.rule_type_id
                    WHERE tc.template_id = %s AND tc.is_selected = TRUE
                """, (template_id,))
                rules_data = cursor.fetchall()
                for row in rules_data:
                    column_name = row['column_name']
                    rule_name = row['rule_name']
                    if column_name not in validations:
                        validations[column_name] = []
                    validations[column_name].append(rule_name)
                    if column_name not in selected_headers:
                        selected_headers.append(column_name)
                has_existing_rules = len(validations) > 0
            else:
                # New template
                cursor.execute("""
                    INSERT INTO excel_templates (template_name, user_id, sheet_name, headers, is_corrected)
                    VALUES (%s, %s, %s, %s, %s)
                """, (file.filename, session['user_id'], sheet_name, json.dumps(headers), False))
                template_id = cursor.lastrowid
                column_data = [(template_id, header, i + 1, False) for i, header in enumerate(headers)]
                cursor.executemany("""
                    INSERT INTO template_columns (template_id, column_name, column_position, is_selected)
                    VALUES (%s, %s, %s, %s)
                """, column_data)

            conn.commit()
            cursor.close()

            # Store session data
            session['file_path'] = file_path
            session['template_id'] = template_id
            session['df'] = df.to_json()
            session['header_row'] = header_row
            session['headers'] = headers
            session['sheet_name'] = sheet_name
            session['current_step'] = 1 if not has_existing_rules else 3
            session['validations'] = validations
            session['selected_headers'] = selected_headers
            session['has_existing_rules'] = has_existing_rules

            logging.info(f"Upload processed: template_id={template_id}, filename={file.filename}, has_existing_rules={has_existing_rules}")

            return jsonify({
                'success': True,
                'sheets': {sheet_name: {'headers': headers}},
                'file_name': file.filename,
                'template_id': template_id,
                'has_existing_rules': has_existing_rules,
                'sheet_name': sheet_name,
                'skip_to_step_3': has_existing_rules
            })
        except mysql.connector.Error as e:
            logging.error(f'Error saving template: {str(e)}')
            return jsonify({'error': f'Error saving template: {str(e)}'}), 500
        except Exception as e:
            logging.error(f'Unexpected error saving template: {str(e)}')
            return jsonify({'error': f'Unexpected error: {str(e)}'}), 500

    # Multi-step workflow endpoints
    @app.route('/step/1', methods=['GET', 'POST'])
    @app.route('/api/step/1', methods=['GET', 'POST'])
    def step_one():
        if 'loggedin' not in session:
            return jsonify({'error': 'Not logged in'}), 401
        
        if request.method == 'POST':
            try:
                headers = request.form.getlist('headers')
                new_header_row = request.form.get('new_header_row')
                logging.debug(f"Step 1 submitted: headers={headers}, new_header_row={new_header_row}")
                
                if not headers:
                    logging.error("No headers provided in step 1")
                    return jsonify({'success': False, 'message': 'No headers provided'}), 400
                    
                if 'template_id' not in session:
                    logging.error("Session missing template_id")
                    return jsonify({'success': False, 'message': 'Session data missing'}), 400

                template_id = session['template_id']
                
                # Get the dataframe from session for auto-detection
                df_json = session.get('df')
                if df_json:
                    df = pd.read_json(StringIO(df_json))
                    session_headers = session.get('headers', [])
                    df.columns = session_headers
                    header_row = session.get('header_row', 0)
                    df = df.iloc[header_row + 1:].reset_index(drop=True)
                    
                    # Auto-detect rules for selected headers
                    validations = assign_default_rules_to_columns(df, headers)
                    session['validations'] = validations
                    logging.debug(f"Auto-assigned rules: {validations}")
                else:
                    validations = {}

                session['selected_headers'] = headers
                session['current_step'] = 2

                # Mark selected headers in the database
                conn = get_db_connection()
                cursor = conn.cursor()
                cursor.execute("UPDATE template_columns SET is_selected = FALSE WHERE template_id = %s", (template_id,))
                for header in headers:
                    cursor.execute("""
                        UPDATE template_columns
                        SET is_selected = TRUE
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    
                    # Get column_id and add auto-detected rules
                    cursor.execute("""
                        SELECT column_id FROM template_columns
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    result = cursor.fetchone()
                    if result:
                        column_id = result[0]
                        for rule_name in validations.get(header, []):
                            cursor.execute("""
                                SELECT rule_type_id FROM validation_rule_types
                                WHERE rule_name = %s AND is_custom = FALSE
                            """, (rule_name,))
                            rule_result = cursor.fetchone()
                            if rule_result:
                                rule_type_id = rule_result[0]
                                cursor.execute("""
                                    INSERT IGNORE INTO column_validation_rules (column_id, rule_type_id, rule_config)
                                    VALUES (%s, %s, %s)
                                """, (column_id, rule_type_id, '{}'))
                
                conn.commit()
                cursor.close()

                logging.info(f"Step 1 completed: headers={headers}, auto-assigned rules={validations}")
                return jsonify({'success': True, 'headers': headers, 'validations': validations})
            except Exception as e:
                logging.error(f"Error in step 1: {str(e)}")
                return jsonify({'success': False, 'message': str(e)}), 500
        
        # GET request - return current headers
        headers = session.get('headers', [])
        return jsonify({'headers': headers})

    @app.route('/step/2', methods=['GET', 'POST'])
    @app.route('/api/step/2', methods=['GET', 'POST'])
    def step_two():
        if 'loggedin' not in session:
            return jsonify({'error': 'Not logged in'}), 401
            
        if request.method == 'POST':
            try:
                action = request.form.get('action', 'save')
                validations = {}
                for key, values in request.form.lists():
                    if key.startswith('validations_'):
                        header = key.replace('validations_', '')
                        validations[header] = values
                        
                logging.debug(f"Step 2 submitted: action={action}, validations={validations}")
                
                template_id = session.get('template_id')
                if not template_id:
                    return jsonify({'success': False, 'message': 'Session data missing'}), 400

                # Save validations to database
                conn = get_db_connection()
                cursor = conn.cursor()
                
                # Clear existing rules
                cursor.execute("""
                    DELETE FROM column_validation_rules
                    WHERE column_id IN (
                        SELECT column_id FROM template_columns WHERE template_id = %s
                    )
                """, (template_id,))
                
                # Add new rules
                for header, rules in validations.items():
                    cursor.execute("""
                        SELECT column_id FROM template_columns
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    result = cursor.fetchone()
                    if not result:
                        continue
                    column_id = result[0]
                    
                    for rule_name in rules:
                        cursor.execute("""
                            SELECT rule_type_id FROM validation_rule_types
                            WHERE rule_name = %s
                        """, (rule_name,))
                        result = cursor.fetchone()
                        if result:
                            rule_type_id = result[0]
                            cursor.execute("""
                                INSERT IGNORE INTO column_validation_rules (column_id, rule_type_id, rule_config)
                                VALUES (%s, %s, %s)
                            """, (column_id, rule_type_id, '{}'))
                
                conn.commit()
                cursor.close()

                session['validations'] = validations
                session['current_step'] = 3 if action == 'review' else 2
                
                logging.info(f"Step 2 completed: action={action}, validations={validations}")
                return jsonify({'success': True, 'message': 'Step 2 completed successfully'})
            except Exception as e:
                logging.error(f"Error in step 2: {str(e)}")
                return jsonify({'success': False, 'message': str(e)}), 500
        
        # GET request
        selected_headers = session.get('selected_headers', [])
        return jsonify({'selected_headers': selected_headers})

    # Rules endpoint
    @app.route('/rules', methods=['GET'])
    @app.route('/api/rules', methods=['GET'])
    def get_rules():
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            
            cursor.execute("""
                SELECT rule_type_id AS rule_id, rule_name, description, parameters, is_custom, 
                       column_name, template_id, source_format, target_format, data_type, is_active
                FROM validation_rule_types
            """)
            rules = cursor.fetchall()
            cursor.close()
            
            logging.info(f"Returning {len(rules)} rules from getRules endpoint")
            return jsonify({'success': True, 'rules': rules})
        except mysql.connector.Error as e:
            logging.error(f"Database error fetching rules: {str(e)}")
            return jsonify({'success': False, 'message': str(e)}), 500
        except Exception as e:
            logging.error(f"Unexpected error fetching rules: {str(e)}")
            return jsonify({'success': False, 'message': str(e)}), 500

    # Template details endpoint
    @app.route('/template/<int:template_id>/<sheet_name>', methods=['GET'])
    @app.route('/api/template/<int:template_id>/<sheet_name>', methods=['GET'])
    def get_template(template_id, sheet_name):
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /template: session missing")
            return jsonify({'error': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("""
                SELECT template_name, sheet_name, headers
                FROM excel_templates
                WHERE template_id = %s AND user_id = %s AND status = 'ACTIVE'
            """, (template_id, session['user_id']))
            template_record = cursor.fetchone()
            
            if not template_record:
                logging.error(f"Template not found for template_id: {template_id}, user_id: {session['user_id']}")
                cursor.close()
                return jsonify({'error': 'Template not found'}), 404

            headers = json.loads(template_record['headers']) if template_record['headers'] else []
            stored_sheet_name = template_record['sheet_name'] or sheet_name
            file_path = os.path.join(app.config['UPLOAD_FOLDER'], template_record['template_name'])
            
            cursor.execute("""
                SELECT COUNT(*) as rule_count
                FROM template_columns tc
                JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                WHERE tc.template_id = %s AND tc.is_selected = TRUE
            """, (template_id,))
            rule_count = cursor.fetchone()['rule_count']
            has_existing_rules = rule_count > 0
            
            cursor.close()
            
            return jsonify({
                'success': True,
                'sheets': {stored_sheet_name: {'headers': headers}},
                'file_name': template_record['template_name'],
                'file_path': file_path,
                'sheet_name': stored_sheet_name,
                'has_existing_rules': has_existing_rules
            })
        except mysql.connector.Error as e:
            logging.error(f"Database error in get_template: {str(e)}")
            return jsonify({'error': f'Database error: {str(e)}'}), 500
        except Exception as e:
            logging.error(f"Unexpected error in get_template: {str(e)}")
            return jsonify({'error': f'Unexpected error: {str(e)}'}), 500

    # Debug route to show all registered routes
    @app.route('/debug/routes', methods=['GET'])
    def list_routes():
        routes = []
        for rule in app.url_map.iter_rules():
            routes.append({
                'endpoint': rule.endpoint,
                'methods': list(rule.methods),
                'rule': rule.rule
            })
        return jsonify(routes)

    # 404 handler to debug missing routes
    @app.errorhandler(404)
    def not_found_handler(error):
        logging.error(f"404 Error: {request.method} {request.url} not found")
        logging.error(f"Available routes: {[rule.rule for rule in app.url_map.iter_rules()]}")
        return jsonify({
            'error': 'Endpoint not found', 
            'method': request.method,
            'url': request.url,
            'path': request.path
        }), 404

    return app

def initialize_app_data():
    """Initialize database and create default data"""
    try:
        logging.info("Initializing database schema...")
        init_db()
        
        logging.info("Creating admin user...")
        create_admin_user()
        
        logging.info("Creating default validation rules...")
        create_default_validation_rules()
        
        logging.info("Application initialization completed successfully")
    except Exception as e:
        logging.error(f"Failed to initialize application: {e}")
        raise

DB_CONFIG = {
    'host': os.getenv('MYSQL_HOST', 'localhost'),
    'user': os.getenv('MYSQL_USER', 'root'),
    'password': os.getenv('MYSQL_PASSWORD', 'Keansa@2024'),
    'database': os.getenv('MYSQL_DATABASE', 'data_validation_2'),
}

def get_db_connection():
    if 'db' not in g:
        try:
            conn = mysql.connector.connect(
                host=DB_CONFIG['host'],
                user=DB_CONFIG['user'],
                password=DB_CONFIG['password']
            )
            cursor = conn.cursor()
            cursor.execute(f"CREATE DATABASE IF NOT EXISTS {DB_CONFIG['database']}")
            cursor.close()
            conn.close()
            g.db = mysql.connector.connect(**DB_CONFIG)
            logging.info("Database connection established successfully")
        except mysql.connector.Error as err:
            if err.errno == errorcode.ER_ACCESS_DENIED_ERROR:
                logging.error("Database connection failed: Access denied for user - check username/password")
            elif err.errno == errorcode.ER_BAD_DB_ERROR:
                logging.error("Database connection failed: Database does not exist")
            else:
                logging.error(f"Database connection failed: {err}")
            raise Exception(f"Failed to connect to database: {str(err)}")
    return g.db

def close_db(error):
    db = g.pop('db', None)
    if db is not None:
        db.close()

def init_db():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        tables = [
            """
            CREATE TABLE IF NOT EXISTS login_details (
                id INT AUTO_INCREMENT PRIMARY KEY,
                first_name VARCHAR(100),
                last_name VARCHAR(100),
                email VARCHAR(255) UNIQUE,
                mobile VARCHAR(10),
                password VARCHAR(255)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS excel_templates (
                template_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_name VARCHAR(255) NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
                user_id INT NOT NULL,
                sheet_name VARCHAR(255),
                headers JSON,
                status ENUM('ACTIVE', 'INACTIVE') DEFAULT 'ACTIVE',
                is_corrected BOOLEAN DEFAULT FALSE,
                remote_file_path VARCHAR(512),
                FOREIGN KEY (user_id) REFERENCES login_details(id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS template_columns (
                column_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_id BIGINT NOT NULL,
                column_name VARCHAR(255) NOT NULL,
                column_position INT NOT NULL,
                is_validation_enabled BOOLEAN DEFAULT FALSE,
                is_selected BOOLEAN DEFAULT FALSE,
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE,
                UNIQUE (template_id, column_name)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_rule_types (
                rule_type_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                rule_name VARCHAR(255) NOT NULL,
                description TEXT,
                parameters TEXT,
                is_active BOOLEAN DEFAULT TRUE,
                is_custom BOOLEAN DEFAULT FALSE,
                column_name VARCHAR(255),
                template_id BIGINT,
                data_type VARCHAR(50),
                source_format VARCHAR(50),
                target_format VARCHAR(50),
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS column_validation_rules (
                column_validation_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                column_id BIGINT NOT NULL,
                rule_type_id BIGINT NOT NULL,
                rule_config JSON,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (column_id) REFERENCES template_columns(column_id) ON DELETE CASCADE,
                FOREIGN KEY (rule_type_id) REFERENCES validation_rule_types(rule_type_id) ON DELETE RESTRICT,
                UNIQUE (column_id, rule_type_id)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_history (
                history_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_id BIGINT NOT NULL,
                template_name VARCHAR(255) NOT NULL,
                error_count INT NOT NULL,
                corrected_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                corrected_file_path VARCHAR(512) NOT NULL,
                user_id INT NOT NULL,
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE,
                FOREIGN KEY (user_id) REFERENCES login_details(id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_corrections (
                correction_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                history_id BIGINT NOT NULL,
                row_index INT NOT NULL,
                column_name VARCHAR(255) NOT NULL,
                original_value TEXT,
                corrected_value TEXT,
                rule_failed VARCHAR(255) DEFAULT NULL,
                FOREIGN KEY (history_id) REFERENCES validation_history(history_id) ON DELETE CASCADE
            )
            """
        ]
        for table_sql in tables:
            cursor.execute(table_sql)
        
        # Add missing columns if they don't exist
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'source_format'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN source_format VARCHAR(50)")
            logging.info("Added source_format column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'target_format'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN target_format VARCHAR(50)")
            logging.info("Added target_format column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'data_type'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN data_type VARCHAR(50)")
            logging.info("Added data_type column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM excel_templates LIKE 'remote_file_path'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE excel_templates ADD COLUMN remote_file_path VARCHAR(512)")
            logging.info("Added remote_file_path column to excel_templates table")
            
        cursor.execute("SHOW COLUMNS FROM template_columns LIKE 'is_selected'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE template_columns ADD COLUMN is_selected BOOLEAN DEFAULT FALSE")
            logging.info("Added is_selected column to template_columns table")
            
        conn.commit()
        cursor.close()
        logging.info("Database tables initialized")
    except Exception as e:
        logging.error(f"Failed to initialize database: {str(e)}")
        raise

def create_admin_user():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        admin_password = bcrypt.hashpw('admin'.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
        cursor.execute("""
            INSERT IGNORE INTO login_details (first_name, last_name, email, mobile, password)
            VALUES (%s, %s, %s, %s, %s)
        """, ('Admin', 'User', 'admin@example.com', '1234567890', admin_password))
        conn.commit()
        cursor.close()
        logging.info("Admin user created or already exists")
    except Exception as e:
        logging.error(f"Failed to create admin user: {str(e)}")
        raise

def create_default_validation_rules():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        default_rules = [
            ("Required", "Ensures the field is not null", '{"allow_null": false}', None, None, None),
            ("Int", "Validates integer format", '{"format": "integer"}', None, None, "Int"),
            ("Float", "Validates number format (integer or decimal)", '{"format": "float"}', None, None, "Float"),
            ("Text", "Allows text with quotes and parentheses", '{"allow_special": false}', None, None, "Text"),
            ("Email", "Validates email format", '{"regex": "^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\\\.[a-zA-Z0-9-.]+$"}', None, None, "Email"),
            ("Date(DD-MM-YYYY)", "Validates date format DD-MM-YYYY", '{"format": "%d-%m-%Y"}', "DD-MM-YYYY", None, "Date"),
            ("Boolean", "Validates boolean format (true/false or 0/1)", '{"format": "boolean"}', None, None, "Boolean"),
            ("Alphanumeric", "Validates alphanumeric format", '{"format": "alphanumeric"}', None, None, "Alphanumeric")
        ]
        cursor.executemany("""
            INSERT IGNORE INTO validation_rule_types (rule_name, description, parameters, is_custom, source_format, target_format, data_type)
            VALUES (%s, %s, %s, %s, %s, %s, %s)
        """, [(name, desc, params, False, source, target, dtype) for name, desc, params, source, target, dtype in default_rules])
        conn.commit()
        cursor.close()
        logging.info("Default validation rules ensured successfully")
    except Exception as e:
        logging.error(f"Failed to ensure default validation rules: {str(e)}")
        raise

if __name__ == '__main__':
    try:
        # Create the application using factory pattern
        app = create_app()
        
        # Initialize database and default data within app context
        with app.app_context():
            initialize_app_data()
        
        # Get port from environment or use default
        port = int(os.getenv('PORT', 5000))
        
        # Start the application server
        logging.info("Starting Flask server...")
        app.run(debug=True, host='0.0.0.0', port=port)
        
    except Exception as e:
        logging.error(f"Failed to start application: {e}")
        raise
).all():
        return "Alphanumeric"
    
    return "Text"

def assign_default_rules_to_columns(df, headers):
    """Intelligently assign validation rules based on column content"""
    assignments = {}
    
    for col in headers:
        if col not in df.columns:
            logging.warning(f"Column {col} not found in dataframe")
            continue
            
        col_type = detect_column_type(df[col])
        rules = ["Required"]  # Default rule for all columns
        
        # Special handling for optional columns
        if not any(col.lower().startswith(prefix) for prefix in
                  ["name", "address", "phone", "username", "status", "period"]):
            rules.append(col_type)
        else:
            rules.append("Text")  # Optional text fields
        
        assignments[col] = rules
    
    return assignments

def create_app():
    """Application factory pattern for different environments"""
    # Set the path to the frontend dist folder
    current_dir = os.path.dirname(os.path.abspath(__file__))
    frontend_dist_path = os.path.join(current_dir, '..', '..', 'Keansa-Ai-Suite2025may-frontend11', 'dist')
    frontend_dist_path = os.path.abspath(frontend_dist_path)
    
    # Create Flask application instance
    app = Flask(__name__, static_folder=frontend_dist_path, static_url_path='')
    CORS(app, supports_credentials=True, origins=["http://localhost:3000", "http://localhost:8080", "http://localhost:5000", "*"])

    app.secret_key = os.urandom(24).hex()
    app.config['SESSION_TYPE'] = 'filesystem'
    app.config['SESSION_FILE_DIR'] = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'sessions')
    app.config['SESSION_COOKIE_SAMESITE'] = 'Lax'
    app.config['SESSION_COOKIE_HTTPONLY'] = True
    app.config['SESSION_COOKIE_SECURE'] = False
    app.config['PERMANENT_SESSION_LIFETIME'] = 86400  # 24 hours
    app.config['UPLOAD_FOLDER'] = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'uploads')
    Session(app)

    # Ensure directories exist
    try:
        os.makedirs(app.config['UPLOAD_FOLDER'], exist_ok=True)
        os.makedirs(app.config['SESSION_FILE_DIR'], exist_ok=True)
    except OSError as e:
        logging.error(f"Failed to create directories: {e}")

    # Register cleanup handlers
    app.teardown_appcontext(close_db)
    
    # Register all routes directly in create_app
    
    # Static file serving for React frontend
    @app.route('/', defaults={'path': ''})
    @app.route('/<path:path>')
    def serve(path):
        if path and os.path.exists(os.path.join(app.static_folder, path)):
            return app.send_static_file(path)
        return app.send_static_file('index.html')

    # Health check endpoint
    @app.route('/health', methods=['GET'])
    def health_check():
        return jsonify({
            'status': 'healthy',
            'timestamp': datetime.now().isoformat(),
            'version': '2.0.0'
        })

    # Authentication endpoint - both old and new paths
    @app.route('/authenticate', methods=['POST'])
    @app.route('/api/auth/authenticate', methods=['POST'])
    def authenticate():
        try:
            email = request.form.get('username') or request.form.get('email')
            password = request.form.get('password')
            logging.debug(f"Login attempt: email={email}, password={'*' * len(password) if password else 'None'}")
            
            if not email or not password:
                logging.warning(f"Login failed: Email or password missing")
                return jsonify({'success': False, 'message': 'Email and password are required'}), 400

            # Check for admin login
            if email == "admin" and password == "admin":
                session['loggedin'] = True
                session['user_email'] = "admin@example.com"
                session['user_id'] = 1
                session.permanent = True
                logging.info(f"Admin login successful. Session: {dict(session)}")
                return jsonify({'success': True, 'message': 'Login successful', 'user': {'email': 'admin@example.com', 'id': 1}}), 200

            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("SELECT * FROM login_details WHERE LOWER(email) = LOWER(%s)", (email.lower(),))
            account = cursor.fetchone()
            cursor.close()
            
            if account:
                if bcrypt.checkpw(password.encode('utf-8'), account['password'].encode('utf-8')):
                    session['loggedin'] = True
                    session['user_email'] = account['email']
                    session['user_id'] = account['id']
                    session.permanent = True
                    logging.info(f"User {email} logged in successfully. Session: {dict(session)}")
                    return jsonify({
                        'success': True,
                        'message': 'Login successful',
                        'user': {'email': account['email'], 'id': account['id']}
                    }), 200
                else:
                    logging.warning(f"Invalid password for {email}")
                    return jsonify({'success': False, 'message': 'Invalid credentials'}), 401
            else:
                logging.warning(f"Email {email} not found")
                return jsonify({'success': False, 'message': 'Invalid credentials'}), 401
        except Exception as e:
            logging.error(f"Unexpected error during login: {str(e)}")
            return jsonify({'success': False, 'message': f'Unexpected error: {str(e)}'}), 500

    @app.route('/check-auth', methods=['GET'])
    @app.route('/api/auth/check-auth', methods=['GET'])
    def check_auth():
        try:
            logging.debug(f"Checking auth with session: {dict(session)}")
            if 'loggedin' in session and 'user_id' in session:
                conn = get_db_connection()
                cursor = conn.cursor(dictionary=True)
                cursor.execute("SELECT email, first_name FROM login_details WHERE id = %s", (session['user_id'],))
                user = cursor.fetchone()
                cursor.close()
                if user:
                    logging.info(f"User {session.get('user_email')} is authenticated")
                    return jsonify({
                        'success': True,
                        'user': {
                            'email': user['email'],
                            'id': session['user_id'],
                            'first_name': user['first_name']
                        }
                    })
                else:
                    logging.warning("User not found in database")  
                    session.clear()
                    return jsonify({'success': False, 'message': 'User not found'}), 401
            logging.warning("User not authenticated")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        except Exception as e:
            logging.error(f"Error in check-auth endpoint: {str(e)}")
            return jsonify({'success': False, 'message': f'Server error: {str(e)}'}), 500

    @app.route('/register', methods=['POST'])
    @app.route('/api/auth/register', methods=['POST'])
    def register():
        first_name = request.form.get('first_name')
        last_name = request.form.get('last_name')
        email = request.form.get('email')
        mobile = request.form.get('mobile')
        password = request.form.get('password')
        confirm_password = request.form.get('confirm_password')

        if not all([first_name, last_name, email, mobile, password, confirm_password]):
            return jsonify({'success': False, 'message': 'All fields are required'}), 400
        if password != confirm_password:
            return jsonify({'success': False, 'message': 'Passwords do not match'}), 400

        hashed_password = bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
        try:
            conn = get_db_connection()
            cursor = conn.cursor()
            cursor.execute("""
                INSERT INTO login_details (first_name, last_name, email, mobile, password)
                VALUES (%s, %s, %s, %s, %s)
            """, (first_name, last_name, email, mobile, hashed_password))
            user_id = cursor.lastrowid
            conn.commit()
            cursor.close()
            session['loggedin'] = True
            session['user_email'] = email
            session['user_id'] = user_id
            return jsonify({
                'success': True,
                'message': 'Registration successful',
                'user': {'email': email, 'id': user_id}
            }), 200
        except mysql.connector.Error as e:
            logging.error(f"Database error during registration: {str(e)}")
            return jsonify({'success': False, 'message': f'Registration error: {str(e)}'}), 500

    @app.route('/logout', methods=['POST'])
    @app.route('/api/auth/logout', methods=['POST'])
    def logout():
        logging.info(f"User {session.get('user_email', 'unknown')} logged out")
        session.clear()
        return jsonify({'success': True, 'message': 'Logged out successfully'})

    # Template routes
    @app.route('/templates', methods=['GET'])
    @app.route('/api/templates', methods=['GET'])
    def get_templates():
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /templates: session missing")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("""
                SELECT template_id, template_name, created_at, status
                FROM excel_templates
                WHERE user_id = %s AND status = 'ACTIVE'
                ORDER BY created_at DESC
                LIMIT 100
            """, (session['user_id'],))
            templates = cursor.fetchall()
            cursor.close()
            logging.info(f"Fetched {len(templates)} templates for user {session['user_id']}")
            return jsonify({'success': True, 'templates': templates})
        except mysql.connector.Error as e:
            logging.error(f'Error fetching templates: {str(e)}')
            return jsonify({'success': False, 'message': f'Error fetching templates: {str(e)}'}), 500
        except Exception as e:
            logging.error(f'Unexpected error fetching templates: {str(e)}')
            return jsonify({'success': False, 'message': f'Unexpected error: {str(e)}'}), 500

    # Rule Configuration routes
    @app.route('/rule-configurations', methods=['GET'])
    @app.route('/api/validation/rule-configurations', methods=['GET'])
    def get_rule_configurations():
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning(f"Unauthorized access to /rule-configurations: session={dict(session)}")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            user_id = session['user_id']
            logging.debug(f"Fetching rule configurations for user_id: {user_id}")

            # Main query to fetch templates with configured rules
            cursor.execute("""
                SELECT 
                    t.template_id, 
                    t.template_name, 
                    t.created_at, 
                    COUNT(cvr.column_validation_id) as rule_count
                FROM excel_templates t
                LEFT JOIN template_columns tc ON t.template_id = tc.template_id
                LEFT JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                WHERE t.user_id = %s AND t.status = 'ACTIVE' AND t.is_corrected = FALSE
                GROUP BY t.template_id, t.template_name, t.created_at
                HAVING rule_count > 0
                ORDER BY t.created_at DESC
                LIMIT 100
            """, (user_id,))
            templates = cursor.fetchall()
            logging.debug(f"Fetched rule-configured templates: {templates}")

            cursor.close()

            if not templates:
                logging.info(f"No templates with rules found for user_id: {user_id}")
            else:
                logging.info(f"Found {len(templates)} templates with rules for user_id: {user_id}")

            return jsonify({'success': True, 'templates': templates})
        except mysql.connector.Error as e:
            logging.error(f"Database error fetching rule configurations: {str(e)}")
            return jsonify({'success': False, 'message': f"Database error: {str(e)}"}), 500
        except Exception as e:
            logging.error(f"Unexpected error fetching rule configurations: {str(e)}")
            return jsonify({'success': False, 'message': f"Unexpected error: {str(e)}"}), 500

    # File upload route
    @app.route('/upload', methods=['POST'])
    @app.route('/api/templates/upload', methods=['POST'])
    @app.route('/api/upload', methods=['POST'])  # Additional common path
    def upload():
        logging.info(f"Upload endpoint called: {request.endpoint}, method: {request.method}")
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /upload: session missing")
            return jsonify({'error': 'Not logged in'}), 401
        if 'file' not in request.files:
            logging.warning("No file provided in upload request")
            return jsonify({'error': 'No file uploaded'}), 400
        file = request.files['file']
        if file.filename == '':
            logging.warning("No file selected in upload request")
            return jsonify({'error': 'No file selected'}), 400
        
        file_path = os.path.join(app.config['UPLOAD_FOLDER'], file.filename)
        try:
            file.save(file_path)
            logging.info(f"File saved: {file_path}")
        except Exception as e:
            logging.error(f"Failed to save file {file.filename}: {str(e)}")
            return jsonify({'error': f'Failed to save file: {str(e)}'}), 500

        try:
            # Read the file to get sheets and headers
            if file.filename.endswith('.xlsx') or file.filename.endswith('.xls'):
                xl = pd.ExcelFile(file_path)
                sheets = {sheet_name: pd.read_excel(file_path, sheet_name=sheet_name, header=None) 
                         for sheet_name in xl.sheet_names}
            elif file.filename.endswith(('.txt', '.csv', '.dat')):
                df = pd.read_csv(file_path, header=None, encoding='utf-8')
                sheets = {'Sheet1': df}
            else:
                logging.error("Unsupported file type")
                return jsonify({'error': 'Unsupported file type'}), 400
            
            logging.debug(f"Sheets extracted: {list(sheets.keys())}")
        except Exception as e:
            logging.error(f"Failed to read file {file_path}: {str(e)}")
            return jsonify({'error': f'Failed to read file: {str(e)}'}), 400

        try:
            sheet_names = list(sheets.keys())
            if not sheet_names:
                logging.error("No sheets found in the file")
                return jsonify({'error': 'No sheets found in the file'}), 400
            sheet_name = sheet_names[0]
            df = sheets[sheet_name]
            
            # Find header row
            header_row = 0
            for i in range(min(len(df), 10)):
                row = df.iloc[i].dropna()
                if not row.empty and all(isinstance(x, str) for x in row if pd.notna(x)):
                    header_row = i
                    break
                    
            headers = df.iloc[header_row].tolist()
            logging.debug(f"Headers extracted: {headers}")
            
            if not headers or all(not h for h in headers):
                logging.error("No valid headers found in file")
                return jsonify({'error': 'No valid headers found in the file'}), 400
        except Exception as e:
            logging.error(f"Error processing file {file.filename}: {str(e)}")
            return jsonify({'error': f'Error processing file: {str(e)}'}), 400

        # Clear existing session data
        for key in ['df', 'header_row', 'headers', 'sheet_name', 'current_step', 'selected_headers', 'validations', 'error_cell_locations', 'data_rows', 'corrected_file_path']:
            session.pop(key, None)

        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)

            # Check if template exists
            cursor.execute("""
                SELECT template_id, headers, sheet_name
                FROM excel_templates
                WHERE template_name = %s AND user_id = %s AND status = 'ACTIVE'
                ORDER BY created_at DESC
            """, (file.filename, session['user_id']))
            existing_templates = cursor.fetchall()
            logging.info(f"Found {len(existing_templates)} existing templates with name {file.filename}")

            template_id = None
            has_existing_rules = False
            validations = {}
            selected_headers = []

            # Check for matching template
            matching_template = None
            for template in existing_templates:
                stored_headers = json.loads(template['headers']) if template['headers'] else []
                stored_sheet_name = template['sheet_name']
                if stored_headers == headers and stored_sheet_name == sheet_name:
                    matching_template = template
                    break

            if matching_template:
                template_id = matching_template['template_id']
                # Check for existing rules
                cursor.execute("""
                    SELECT tc.column_name, vrt.rule_name
                    FROM template_columns tc
                    JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                    JOIN validation_rule_types vrt ON cvr.rule_type_id = vrt.rule_type_id
                    WHERE tc.template_id = %s AND tc.is_selected = TRUE
                """, (template_id,))
                rules_data = cursor.fetchall()
                for row in rules_data:
                    column_name = row['column_name']
                    rule_name = row['rule_name']
                    if column_name not in validations:
                        validations[column_name] = []
                    validations[column_name].append(rule_name)
                    if column_name not in selected_headers:
                        selected_headers.append(column_name)
                has_existing_rules = len(validations) > 0
            else:
                # New template
                cursor.execute("""
                    INSERT INTO excel_templates (template_name, user_id, sheet_name, headers, is_corrected)
                    VALUES (%s, %s, %s, %s, %s)
                """, (file.filename, session['user_id'], sheet_name, json.dumps(headers), False))
                template_id = cursor.lastrowid
                column_data = [(template_id, header, i + 1, False) for i, header in enumerate(headers)]
                cursor.executemany("""
                    INSERT INTO template_columns (template_id, column_name, column_position, is_selected)
                    VALUES (%s, %s, %s, %s)
                """, column_data)

            conn.commit()
            cursor.close()

            # Store session data
            session['file_path'] = file_path
            session['template_id'] = template_id
            session['df'] = df.to_json()
            session['header_row'] = header_row
            session['headers'] = headers
            session['sheet_name'] = sheet_name
            session['current_step'] = 1 if not has_existing_rules else 3
            session['validations'] = validations
            session['selected_headers'] = selected_headers
            session['has_existing_rules'] = has_existing_rules

            logging.info(f"Upload processed: template_id={template_id}, filename={file.filename}, has_existing_rules={has_existing_rules}")

            return jsonify({
                'success': True,
                'sheets': {sheet_name: {'headers': headers}},
                'file_name': file.filename,
                'template_id': template_id,
                'has_existing_rules': has_existing_rules,
                'sheet_name': sheet_name,
                'skip_to_step_3': has_existing_rules
            })
        except mysql.connector.Error as e:
            logging.error(f'Error saving template: {str(e)}')
            return jsonify({'error': f'Error saving template: {str(e)}'}), 500
        except Exception as e:
            logging.error(f'Unexpected error saving template: {str(e)}')
            return jsonify({'error': f'Unexpected error: {str(e)}'}), 500

    # Multi-step workflow endpoints
    @app.route('/step/1', methods=['GET', 'POST'])
    @app.route('/api/step/1', methods=['GET', 'POST'])
    def step_one():
        if 'loggedin' not in session:
            return jsonify({'error': 'Not logged in'}), 401
        
        if request.method == 'POST':
            try:
                headers = request.form.getlist('headers')
                new_header_row = request.form.get('new_header_row')
                logging.debug(f"Step 1 submitted: headers={headers}, new_header_row={new_header_row}")
                
                if not headers:
                    logging.error("No headers provided in step 1")
                    return jsonify({'success': False, 'message': 'No headers provided'}), 400
                    
                if 'template_id' not in session:
                    logging.error("Session missing template_id")
                    return jsonify({'success': False, 'message': 'Session data missing'}), 400

                template_id = session['template_id']
                
                # Get the dataframe from session for auto-detection
                df_json = session.get('df')
                if df_json:
                    df = pd.read_json(StringIO(df_json))
                    session_headers = session.get('headers', [])
                    df.columns = session_headers
                    header_row = session.get('header_row', 0)
                    df = df.iloc[header_row + 1:].reset_index(drop=True)
                    
                    # Auto-detect rules for selected headers
                    validations = assign_default_rules_to_columns(df, headers)
                    session['validations'] = validations
                    logging.debug(f"Auto-assigned rules: {validations}")
                else:
                    validations = {}

                session['selected_headers'] = headers
                session['current_step'] = 2

                # Mark selected headers in the database
                conn = get_db_connection()
                cursor = conn.cursor()
                cursor.execute("UPDATE template_columns SET is_selected = FALSE WHERE template_id = %s", (template_id,))
                for header in headers:
                    cursor.execute("""
                        UPDATE template_columns
                        SET is_selected = TRUE
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    
                    # Get column_id and add auto-detected rules
                    cursor.execute("""
                        SELECT column_id FROM template_columns
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    result = cursor.fetchone()
                    if result:
                        column_id = result[0]
                        for rule_name in validations.get(header, []):
                            cursor.execute("""
                                SELECT rule_type_id FROM validation_rule_types
                                WHERE rule_name = %s AND is_custom = FALSE
                            """, (rule_name,))
                            rule_result = cursor.fetchone()
                            if rule_result:
                                rule_type_id = rule_result[0]
                                cursor.execute("""
                                    INSERT IGNORE INTO column_validation_rules (column_id, rule_type_id, rule_config)
                                    VALUES (%s, %s, %s)
                                """, (column_id, rule_type_id, '{}'))
                
                conn.commit()
                cursor.close()

                logging.info(f"Step 1 completed: headers={headers}, auto-assigned rules={validations}")
                return jsonify({'success': True, 'headers': headers, 'validations': validations})
            except Exception as e:
                logging.error(f"Error in step 1: {str(e)}")
                return jsonify({'success': False, 'message': str(e)}), 500
        
        # GET request - return current headers
        headers = session.get('headers', [])
        return jsonify({'headers': headers})

    @app.route('/step/2', methods=['GET', 'POST'])
    @app.route('/api/step/2', methods=['GET', 'POST'])
    def step_two():
        if 'loggedin' not in session:
            return jsonify({'error': 'Not logged in'}), 401
            
        if request.method == 'POST':
            try:
                action = request.form.get('action', 'save')
                validations = {}
                for key, values in request.form.lists():
                    if key.startswith('validations_'):
                        header = key.replace('validations_', '')
                        validations[header] = values
                        
                logging.debug(f"Step 2 submitted: action={action}, validations={validations}")
                
                template_id = session.get('template_id')
                if not template_id:
                    return jsonify({'success': False, 'message': 'Session data missing'}), 400

                # Save validations to database
                conn = get_db_connection()
                cursor = conn.cursor()
                
                # Clear existing rules
                cursor.execute("""
                    DELETE FROM column_validation_rules
                    WHERE column_id IN (
                        SELECT column_id FROM template_columns WHERE template_id = %s
                    )
                """, (template_id,))
                
                # Add new rules
                for header, rules in validations.items():
                    cursor.execute("""
                        SELECT column_id FROM template_columns
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    result = cursor.fetchone()
                    if not result:
                        continue
                    column_id = result[0]
                    
                    for rule_name in rules:
                        cursor.execute("""
                            SELECT rule_type_id FROM validation_rule_types
                            WHERE rule_name = %s
                        """, (rule_name,))
                        result = cursor.fetchone()
                        if result:
                            rule_type_id = result[0]
                            cursor.execute("""
                                INSERT IGNORE INTO column_validation_rules (column_id, rule_type_id, rule_config)
                                VALUES (%s, %s, %s)
                            """, (column_id, rule_type_id, '{}'))
                
                conn.commit()
                cursor.close()

                session['validations'] = validations
                session['current_step'] = 3 if action == 'review' else 2
                
                logging.info(f"Step 2 completed: action={action}, validations={validations}")
                return jsonify({'success': True, 'message': 'Step 2 completed successfully'})
            except Exception as e:
                logging.error(f"Error in step 2: {str(e)}")
                return jsonify({'success': False, 'message': str(e)}), 500
        
        # GET request
        selected_headers = session.get('selected_headers', [])
        return jsonify({'selected_headers': selected_headers})

    # Rules endpoint
    @app.route('/rules', methods=['GET'])
    @app.route('/api/rules', methods=['GET'])
    def get_rules():
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            
            cursor.execute("""
                SELECT rule_type_id AS rule_id, rule_name, description, parameters, is_custom, 
                       column_name, template_id, source_format, target_format, data_type, is_active
                FROM validation_rule_types
            """)
            rules = cursor.fetchall()
            cursor.close()
            
            logging.info(f"Returning {len(rules)} rules from getRules endpoint")
            return jsonify({'success': True, 'rules': rules})
        except mysql.connector.Error as e:
            logging.error(f"Database error fetching rules: {str(e)}")
            return jsonify({'success': False, 'message': str(e)}), 500
        except Exception as e:
            logging.error(f"Unexpected error fetching rules: {str(e)}")
            return jsonify({'success': False, 'message': str(e)}), 500

    # Template details endpoint
    @app.route('/template/<int:template_id>/<sheet_name>', methods=['GET'])
    @app.route('/api/template/<int:template_id>/<sheet_name>', methods=['GET'])
    def get_template(template_id, sheet_name):
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /template: session missing")
            return jsonify({'error': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("""
                SELECT template_name, sheet_name, headers
                FROM excel_templates
                WHERE template_id = %s AND user_id = %s AND status = 'ACTIVE'
            """, (template_id, session['user_id']))
            template_record = cursor.fetchone()
            
            if not template_record:
                logging.error(f"Template not found for template_id: {template_id}, user_id: {session['user_id']}")
                cursor.close()
                return jsonify({'error': 'Template not found'}), 404

            headers = json.loads(template_record['headers']) if template_record['headers'] else []
            stored_sheet_name = template_record['sheet_name'] or sheet_name
            file_path = os.path.join(app.config['UPLOAD_FOLDER'], template_record['template_name'])
            
            cursor.execute("""
                SELECT COUNT(*) as rule_count
                FROM template_columns tc
                JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                WHERE tc.template_id = %s AND tc.is_selected = TRUE
            """, (template_id,))
            rule_count = cursor.fetchone()['rule_count']
            has_existing_rules = rule_count > 0
            
            cursor.close()
            
            return jsonify({
                'success': True,
                'sheets': {stored_sheet_name: {'headers': headers}},
                'file_name': template_record['template_name'],
                'file_path': file_path,
                'sheet_name': stored_sheet_name,
                'has_existing_rules': has_existing_rules
            })
        except mysql.connector.Error as e:
            logging.error(f"Database error in get_template: {str(e)}")
            return jsonify({'error': f'Database error: {str(e)}'}), 500
        except Exception as e:
            logging.error(f"Unexpected error in get_template: {str(e)}")
            return jsonify({'error': f'Unexpected error: {str(e)}'}), 500

    # Debug route to show all registered routes
    @app.route('/debug/routes', methods=['GET'])
    def list_routes():
        routes = []
        for rule in app.url_map.iter_rules():
            routes.append({
                'endpoint': rule.endpoint,
                'methods': list(rule.methods),
                'rule': rule.rule
            })
        return jsonify(routes)

    # 404 handler to debug missing routes
    @app.errorhandler(404)
    def not_found_handler(error):
        logging.error(f"404 Error: {request.method} {request.url} not found")
        logging.error(f"Available routes: {[rule.rule for rule in app.url_map.iter_rules()]}")
        return jsonify({
            'error': 'Endpoint not found', 
            'method': request.method,
            'url': request.url,
            'path': request.path
        }), 404

    return app

def initialize_app_data():
    """Initialize database and create default data"""
    try:
        logging.info("Initializing database schema...")
        init_db()
        
        logging.info("Creating admin user...")
        create_admin_user()
        
        logging.info("Creating default validation rules...")
        create_default_validation_rules()
        
        logging.info("Application initialization completed successfully")
    except Exception as e:
        logging.error(f"Failed to initialize application: {e}")
        raise

DB_CONFIG = {
    'host': os.getenv('MYSQL_HOST', 'localhost'),
    'user': os.getenv('MYSQL_USER', 'root'),
    'password': os.getenv('MYSQL_PASSWORD', 'Keansa@2024'),
    'database': os.getenv('MYSQL_DATABASE', 'data_validation_2'),
}

def get_db_connection():
    if 'db' not in g:
        try:
            conn = mysql.connector.connect(
                host=DB_CONFIG['host'],
                user=DB_CONFIG['user'],
                password=DB_CONFIG['password']
            )
            cursor = conn.cursor()
            cursor.execute(f"CREATE DATABASE IF NOT EXISTS {DB_CONFIG['database']}")
            cursor.close()
            conn.close()
            g.db = mysql.connector.connect(**DB_CONFIG)
            logging.info("Database connection established successfully")
        except mysql.connector.Error as err:
            if err.errno == errorcode.ER_ACCESS_DENIED_ERROR:
                logging.error("Database connection failed: Access denied for user - check username/password")
            elif err.errno == errorcode.ER_BAD_DB_ERROR:
                logging.error("Database connection failed: Database does not exist")
            else:
                logging.error(f"Database connection failed: {err}")
            raise Exception(f"Failed to connect to database: {str(err)}")
    return g.db

def close_db(error):
    db = g.pop('db', None)
    if db is not None:
        db.close()

def init_db():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        tables = [
            """
            CREATE TABLE IF NOT EXISTS login_details (
                id INT AUTO_INCREMENT PRIMARY KEY,
                first_name VARCHAR(100),
                last_name VARCHAR(100),
                email VARCHAR(255) UNIQUE,
                mobile VARCHAR(10),
                password VARCHAR(255)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS excel_templates (
                template_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_name VARCHAR(255) NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
                user_id INT NOT NULL,
                sheet_name VARCHAR(255),
                headers JSON,
                status ENUM('ACTIVE', 'INACTIVE') DEFAULT 'ACTIVE',
                is_corrected BOOLEAN DEFAULT FALSE,
                remote_file_path VARCHAR(512),
                FOREIGN KEY (user_id) REFERENCES login_details(id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS template_columns (
                column_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_id BIGINT NOT NULL,
                column_name VARCHAR(255) NOT NULL,
                column_position INT NOT NULL,
                is_validation_enabled BOOLEAN DEFAULT FALSE,
                is_selected BOOLEAN DEFAULT FALSE,
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE,
                UNIQUE (template_id, column_name)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_rule_types (
                rule_type_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                rule_name VARCHAR(255) NOT NULL,
                description TEXT,
                parameters TEXT,
                is_active BOOLEAN DEFAULT TRUE,
                is_custom BOOLEAN DEFAULT FALSE,
                column_name VARCHAR(255),
                template_id BIGINT,
                data_type VARCHAR(50),
                source_format VARCHAR(50),
                target_format VARCHAR(50),
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS column_validation_rules (
                column_validation_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                column_id BIGINT NOT NULL,
                rule_type_id BIGINT NOT NULL,
                rule_config JSON,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (column_id) REFERENCES template_columns(column_id) ON DELETE CASCADE,
                FOREIGN KEY (rule_type_id) REFERENCES validation_rule_types(rule_type_id) ON DELETE RESTRICT,
                UNIQUE (column_id, rule_type_id)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_history (
                history_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_id BIGINT NOT NULL,
                template_name VARCHAR(255) NOT NULL,
                error_count INT NOT NULL,
                corrected_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                corrected_file_path VARCHAR(512) NOT NULL,
                user_id INT NOT NULL,
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE,
                FOREIGN KEY (user_id) REFERENCES login_details(id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_corrections (
                correction_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                history_id BIGINT NOT NULL,
                row_index INT NOT NULL,
                column_name VARCHAR(255) NOT NULL,
                original_value TEXT,
                corrected_value TEXT,
                rule_failed VARCHAR(255) DEFAULT NULL,
                FOREIGN KEY (history_id) REFERENCES validation_history(history_id) ON DELETE CASCADE
            )
            """
        ]
        for table_sql in tables:
            cursor.execute(table_sql)
        
        # Add missing columns if they don't exist
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'source_format'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN source_format VARCHAR(50)")
            logging.info("Added source_format column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'target_format'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN target_format VARCHAR(50)")
            logging.info("Added target_format column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'data_type'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN data_type VARCHAR(50)")
            logging.info("Added data_type column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM excel_templates LIKE 'remote_file_path'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE excel_templates ADD COLUMN remote_file_path VARCHAR(512)")
            logging.info("Added remote_file_path column to excel_templates table")
            
        cursor.execute("SHOW COLUMNS FROM template_columns LIKE 'is_selected'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE template_columns ADD COLUMN is_selected BOOLEAN DEFAULT FALSE")
            logging.info("Added is_selected column to template_columns table")
            
        conn.commit()
        cursor.close()
        logging.info("Database tables initialized")
    except Exception as e:
        logging.error(f"Failed to initialize database: {str(e)}")
        raise

def create_admin_user():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        admin_password = bcrypt.hashpw('admin'.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
        cursor.execute("""
            INSERT IGNORE INTO login_details (first_name, last_name, email, mobile, password)
            VALUES (%s, %s, %s, %s, %s)
        """, ('Admin', 'User', 'admin@example.com', '1234567890', admin_password))
        conn.commit()
        cursor.close()
        logging.info("Admin user created or already exists")
    except Exception as e:
        logging.error(f"Failed to create admin user: {str(e)}")
        raise

def create_default_validation_rules():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        default_rules = [
            ("Required", "Ensures the field is not null", '{"allow_null": false}', None, None, None),
            ("Int", "Validates integer format", '{"format": "integer"}', None, None, "Int"),
            ("Float", "Validates number format (integer or decimal)", '{"format": "float"}', None, None, "Float"),
            ("Text", "Allows text with quotes and parentheses", '{"allow_special": false}', None, None, "Text"),
            ("Email", "Validates email format", '{"regex": "^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\\\.[a-zA-Z0-9-.]+$"}', None, None, "Email"),
            ("Date(DD-MM-YYYY)", "Validates date format DD-MM-YYYY", '{"format": "%d-%m-%Y"}', "DD-MM-YYYY", None, "Date"),
            ("Boolean", "Validates boolean format (true/false or 0/1)", '{"format": "boolean"}', None, None, "Boolean"),
            ("Alphanumeric", "Validates alphanumeric format", '{"format": "alphanumeric"}', None, None, "Alphanumeric")
        ]
        cursor.executemany("""
            INSERT IGNORE INTO validation_rule_types (rule_name, description, parameters, is_custom, source_format, target_format, data_type)
            VALUES (%s, %s, %s, %s, %s, %s, %s)
        """, [(name, desc, params, False, source, target, dtype) for name, desc, params, source, target, dtype in default_rules])
        conn.commit()
        cursor.close()
        logging.info("Default validation rules ensured successfully")
    except Exception as e:
        logging.error(f"Failed to ensure default validation rules: {str(e)}")
        raise

if __name__ == '__main__':
    try:
        # Create the application using factory pattern
        app = create_app()
        
        # Initialize database and default data within app context
        with app.app_context():
            initialize_app_data()
        
        # Get port from environment or use default
        port = int(os.getenv('PORT', 5000))
        
        # Start the application server
        logging.info("Starting Flask server...")
        app.run(debug=True, host='0.0.0.0', port=port)
        
    except Exception as e:
        logging.error(f"Failed to start application: {e}")
        raise
).all():
        return "Alphanumeric"
    
    # Default to Text
    return "Text"

def assign_default_rules_to_columns(df, selected_headers):
    """Assign default validation rules based on column data type detection"""
    validations = {}
    
    for header in selected_headers:
        if header in df.columns:
            column_type = detect_column_type(df[header])
            
            # Assign rules based on detected type
            if column_type == "Email":
                validations[header] = ["Required", "Email"]
            elif column_type == "Date":
                validations[header] = ["Required", "Date(DD-MM-YYYY)"]
            elif column_type == "Int":
                validations[header] = ["Required", "Int"]
            elif column_type == "Float":
                validations[header] = ["Required", "Float"]
            elif column_type == "Boolean":
                validations[header] = ["Required", "Boolean"]
            elif column_type == "Alphanumeric":
                validations[header] = ["Required", "Alphanumeric"]
            else:
                validations[header] = ["Required", "Text"]
    
    return validations

def create_app():
    """Application factory pattern for different environments"""
    # Set the path to the frontend dist folder
    current_dir = os.path.dirname(os.path.abspath(__file__))
    frontend_dist_path = os.path.join(current_dir, '..', '..', 'Keansa-Ai-Suite2025may-frontend11', 'dist')
    frontend_dist_path = os.path.abspath(frontend_dist_path)
    
    # Create Flask application instance
    app = Flask(__name__, static_folder=frontend_dist_path, static_url_path='')
    CORS(app, supports_credentials=True, origins=["http://localhost:3000", "http://localhost:8080", "http://localhost:5000", "*"])

    app.secret_key = os.urandom(24).hex()
    app.config['SESSION_TYPE'] = 'filesystem'
    app.config['SESSION_FILE_DIR'] = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'sessions')
    app.config['SESSION_COOKIE_SAMESITE'] = 'Lax'
    app.config['SESSION_COOKIE_HTTPONLY'] = True
    app.config['SESSION_COOKIE_SECURE'] = False
    app.config['PERMANENT_SESSION_LIFETIME'] = 86400  # 24 hours
    app.config['UPLOAD_FOLDER'] = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'uploads')
    Session(app)

    # Ensure directories exist
    try:
        os.makedirs(app.config['UPLOAD_FOLDER'], exist_ok=True)
        os.makedirs(app.config['SESSION_FILE_DIR'], exist_ok=True)
    except OSError as e:
        logging.error(f"Failed to create directories: {e}")

    # Register cleanup handlers
    app.teardown_appcontext(close_db)
    
    # Register all routes directly in create_app
    
    # Static file serving for React frontend
    @app.route('/', defaults={'path': ''})
    @app.route('/<path:path>')
    def serve(path):
        if path and os.path.exists(os.path.join(app.static_folder, path)):
            return app.send_static_file(path)
        return app.send_static_file('index.html')

    # Health check endpoint
    @app.route('/health', methods=['GET'])
    def health_check():
        return jsonify({
            'status': 'healthy',
            'timestamp': datetime.now().isoformat(),
            'version': '2.0.0'
        })

    # Authentication endpoint - both old and new paths
    @app.route('/authenticate', methods=['POST'])
    @app.route('/api/auth/authenticate', methods=['POST'])
    def authenticate():
        try:
            email = request.form.get('username') or request.form.get('email')
            password = request.form.get('password')
            logging.debug(f"Login attempt: email={email}, password={'*' * len(password) if password else 'None'}")
            
            if not email or not password:
                logging.warning(f"Login failed: Email or password missing")
                return jsonify({'success': False, 'message': 'Email and password are required'}), 400

            # Check for admin login
            if email == "admin" and password == "admin":
                session['loggedin'] = True
                session['user_email'] = "admin@example.com"
                session['user_id'] = 1
                session.permanent = True
                logging.info(f"Admin login successful. Session: {dict(session)}")
                return jsonify({'success': True, 'message': 'Login successful', 'user': {'email': 'admin@example.com', 'id': 1}}), 200

            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("SELECT * FROM login_details WHERE LOWER(email) = LOWER(%s)", (email.lower(),))
            account = cursor.fetchone()
            cursor.close()
            
            if account:
                if bcrypt.checkpw(password.encode('utf-8'), account['password'].encode('utf-8')):
                    session['loggedin'] = True
                    session['user_email'] = account['email']
                    session['user_id'] = account['id']
                    session.permanent = True
                    logging.info(f"User {email} logged in successfully. Session: {dict(session)}")
                    return jsonify({
                        'success': True,
                        'message': 'Login successful',
                        'user': {'email': account['email'], 'id': account['id']}
                    }), 200
                else:
                    logging.warning(f"Invalid password for {email}")
                    return jsonify({'success': False, 'message': 'Invalid credentials'}), 401
            else:
                logging.warning(f"Email {email} not found")
                return jsonify({'success': False, 'message': 'Invalid credentials'}), 401
        except Exception as e:
            logging.error(f"Unexpected error during login: {str(e)}")
            return jsonify({'success': False, 'message': f'Unexpected error: {str(e)}'}), 500

    @app.route('/check-auth', methods=['GET'])
    @app.route('/api/auth/check-auth', methods=['GET'])
    def check_auth():
        try:
            logging.debug(f"Checking auth with session: {dict(session)}")
            if 'loggedin' in session and 'user_id' in session:
                conn = get_db_connection()
                cursor = conn.cursor(dictionary=True)
                cursor.execute("SELECT email, first_name FROM login_details WHERE id = %s", (session['user_id'],))
                user = cursor.fetchone()
                cursor.close()
                if user:
                    logging.info(f"User {session.get('user_email')} is authenticated")
                    return jsonify({
                        'success': True,
                        'user': {
                            'email': user['email'],
                            'id': session['user_id'],
                            'first_name': user['first_name']
                        }
                    })
                else:
                    logging.warning("User not found in database")  
                    session.clear()
                    return jsonify({'success': False, 'message': 'User not found'}), 401
            logging.warning("User not authenticated")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        except Exception as e:
            logging.error(f"Error in check-auth endpoint: {str(e)}")
            return jsonify({'success': False, 'message': f'Server error: {str(e)}'}), 500

    @app.route('/register', methods=['POST'])
    @app.route('/api/auth/register', methods=['POST'])
    def register():
        first_name = request.form.get('first_name')
        last_name = request.form.get('last_name')
        email = request.form.get('email')
        mobile = request.form.get('mobile')
        password = request.form.get('password')
        confirm_password = request.form.get('confirm_password')

        if not all([first_name, last_name, email, mobile, password, confirm_password]):
            return jsonify({'success': False, 'message': 'All fields are required'}), 400
        if password != confirm_password:
            return jsonify({'success': False, 'message': 'Passwords do not match'}), 400

        hashed_password = bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
        try:
            conn = get_db_connection()
            cursor = conn.cursor()
            cursor.execute("""
                INSERT INTO login_details (first_name, last_name, email, mobile, password)
                VALUES (%s, %s, %s, %s, %s)
            """, (first_name, last_name, email, mobile, hashed_password))
            user_id = cursor.lastrowid
            conn.commit()
            cursor.close()
            session['loggedin'] = True
            session['user_email'] = email
            session['user_id'] = user_id
            return jsonify({
                'success': True,
                'message': 'Registration successful',
                'user': {'email': email, 'id': user_id}
            }), 200
        except mysql.connector.Error as e:
            logging.error(f"Database error during registration: {str(e)}")
            return jsonify({'success': False, 'message': f'Registration error: {str(e)}'}), 500

    @app.route('/logout', methods=['POST'])
    @app.route('/api/auth/logout', methods=['POST'])
    def logout():
        logging.info(f"User {session.get('user_email', 'unknown')} logged out")
        session.clear()
        return jsonify({'success': True, 'message': 'Logged out successfully'})

    # Template routes
    @app.route('/templates', methods=['GET'])
    @app.route('/api/templates', methods=['GET'])
    def get_templates():
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /templates: session missing")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("""
                SELECT template_id, template_name, created_at, status
                FROM excel_templates
                WHERE user_id = %s AND status = 'ACTIVE'
                ORDER BY created_at DESC
                LIMIT 100
            """, (session['user_id'],))
            templates = cursor.fetchall()
            cursor.close()
            logging.info(f"Fetched {len(templates)} templates for user {session['user_id']}")
            return jsonify({'success': True, 'templates': templates})
        except mysql.connector.Error as e:
            logging.error(f'Error fetching templates: {str(e)}')
            return jsonify({'success': False, 'message': f'Error fetching templates: {str(e)}'}), 500
        except Exception as e:
            logging.error(f'Unexpected error fetching templates: {str(e)}')
            return jsonify({'success': False, 'message': f'Unexpected error: {str(e)}'}), 500

    # Rule Configuration routes
    @app.route('/rule-configurations', methods=['GET'])
    @app.route('/api/validation/rule-configurations', methods=['GET'])
    def get_rule_configurations():
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning(f"Unauthorized access to /rule-configurations: session={dict(session)}")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            user_id = session['user_id']
            logging.debug(f"Fetching rule configurations for user_id: {user_id}")

            # Main query to fetch templates with configured rules
            cursor.execute("""
                SELECT 
                    t.template_id, 
                    t.template_name, 
                    t.created_at, 
                    COUNT(cvr.column_validation_id) as rule_count
                FROM excel_templates t
                LEFT JOIN template_columns tc ON t.template_id = tc.template_id
                LEFT JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                WHERE t.user_id = %s AND t.status = 'ACTIVE' AND t.is_corrected = FALSE
                GROUP BY t.template_id, t.template_name, t.created_at
                HAVING rule_count > 0
                ORDER BY t.created_at DESC
                LIMIT 100
            """, (user_id,))
            templates = cursor.fetchall()
            logging.debug(f"Fetched rule-configured templates: {templates}")

            cursor.close()

            if not templates:
                logging.info(f"No templates with rules found for user_id: {user_id}")
            else:
                logging.info(f"Found {len(templates)} templates with rules for user_id: {user_id}")

            return jsonify({'success': True, 'templates': templates})
        except mysql.connector.Error as e:
            logging.error(f"Database error fetching rule configurations: {str(e)}")
            return jsonify({'success': False, 'message': f"Database error: {str(e)}"}), 500
        except Exception as e:
            logging.error(f"Unexpected error fetching rule configurations: {str(e)}")
            return jsonify({'success': False, 'message': f"Unexpected error: {str(e)}"}), 500

    # File upload route
    @app.route('/upload', methods=['POST'])
    @app.route('/api/templates/upload', methods=['POST'])
    @app.route('/api/upload', methods=['POST'])  # Additional common path
    def upload():
        logging.info(f"Upload endpoint called: {request.endpoint}, method: {request.method}")
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /upload: session missing")
            return jsonify({'error': 'Not logged in'}), 401
        if 'file' not in request.files:
            logging.warning("No file provided in upload request")
            return jsonify({'error': 'No file uploaded'}), 400
        file = request.files['file']
        if file.filename == '':
            logging.warning("No file selected in upload request")
            return jsonify({'error': 'No file selected'}), 400
        
        file_path = os.path.join(app.config['UPLOAD_FOLDER'], file.filename)
        try:
            file.save(file_path)
            logging.info(f"File saved: {file_path}")
        except Exception as e:
            logging.error(f"Failed to save file {file.filename}: {str(e)}")
            return jsonify({'error': f'Failed to save file: {str(e)}'}), 500

        try:
            # Read the file to get sheets and headers
            if file.filename.endswith('.xlsx') or file.filename.endswith('.xls'):
                xl = pd.ExcelFile(file_path)
                sheets = {sheet_name: pd.read_excel(file_path, sheet_name=sheet_name, header=None) 
                         for sheet_name in xl.sheet_names}
            elif file.filename.endswith(('.txt', '.csv', '.dat')):
                df = pd.read_csv(file_path, header=None, encoding='utf-8')
                sheets = {'Sheet1': df}
            else:
                logging.error("Unsupported file type")
                return jsonify({'error': 'Unsupported file type'}), 400
            
            logging.debug(f"Sheets extracted: {list(sheets.keys())}")
        except Exception as e:
            logging.error(f"Failed to read file {file_path}: {str(e)}")
            return jsonify({'error': f'Failed to read file: {str(e)}'}), 400

        try:
            sheet_names = list(sheets.keys())
            if not sheet_names:
                logging.error("No sheets found in the file")
                return jsonify({'error': 'No sheets found in the file'}), 400
            sheet_name = sheet_names[0]
            df = sheets[sheet_name]
            
            # Find header row
            header_row = 0
            for i in range(min(len(df), 10)):
                row = df.iloc[i].dropna()
                if not row.empty and all(isinstance(x, str) for x in row if pd.notna(x)):
                    header_row = i
                    break
                    
            headers = df.iloc[header_row].tolist()
            logging.debug(f"Headers extracted: {headers}")
            
            if not headers or all(not h for h in headers):
                logging.error("No valid headers found in file")
                return jsonify({'error': 'No valid headers found in the file'}), 400
        except Exception as e:
            logging.error(f"Error processing file {file.filename}: {str(e)}")
            return jsonify({'error': f'Error processing file: {str(e)}'}), 400

        # Clear existing session data
        for key in ['df', 'header_row', 'headers', 'sheet_name', 'current_step', 'selected_headers', 'validations', 'error_cell_locations', 'data_rows', 'corrected_file_path']:
            session.pop(key, None)

        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)

            # Check if template exists
            cursor.execute("""
                SELECT template_id, headers, sheet_name
                FROM excel_templates
                WHERE template_name = %s AND user_id = %s AND status = 'ACTIVE'
                ORDER BY created_at DESC
            """, (file.filename, session['user_id']))
            existing_templates = cursor.fetchall()
            logging.info(f"Found {len(existing_templates)} existing templates with name {file.filename}")

            template_id = None
            has_existing_rules = False
            validations = {}
            selected_headers = []

            # Check for matching template
            matching_template = None
            for template in existing_templates:
                stored_headers = json.loads(template['headers']) if template['headers'] else []
                stored_sheet_name = template['sheet_name']
                if stored_headers == headers and stored_sheet_name == sheet_name:
                    matching_template = template
                    break

            if matching_template:
                template_id = matching_template['template_id']
                # Check for existing rules
                cursor.execute("""
                    SELECT tc.column_name, vrt.rule_name
                    FROM template_columns tc
                    JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                    JOIN validation_rule_types vrt ON cvr.rule_type_id = vrt.rule_type_id
                    WHERE tc.template_id = %s AND tc.is_selected = TRUE
                """, (template_id,))
                rules_data = cursor.fetchall()
                for row in rules_data:
                    column_name = row['column_name']
                    rule_name = row['rule_name']
                    if column_name not in validations:
                        validations[column_name] = []
                    validations[column_name].append(rule_name)
                    if column_name not in selected_headers:
                        selected_headers.append(column_name)
                has_existing_rules = len(validations) > 0
            else:
                # New template
                cursor.execute("""
                    INSERT INTO excel_templates (template_name, user_id, sheet_name, headers, is_corrected)
                    VALUES (%s, %s, %s, %s, %s)
                """, (file.filename, session['user_id'], sheet_name, json.dumps(headers), False))
                template_id = cursor.lastrowid
                column_data = [(template_id, header, i + 1, False) for i, header in enumerate(headers)]
                cursor.executemany("""
                    INSERT INTO template_columns (template_id, column_name, column_position, is_selected)
                    VALUES (%s, %s, %s, %s)
                """, column_data)

            conn.commit()
            cursor.close()

            # Store session data
            session['file_path'] = file_path
            session['template_id'] = template_id
            session['df'] = df.to_json()
            session['header_row'] = header_row
            session['headers'] = headers
            session['sheet_name'] = sheet_name
            session['current_step'] = 1 if not has_existing_rules else 3
            session['validations'] = validations
            session['selected_headers'] = selected_headers
            session['has_existing_rules'] = has_existing_rules

            logging.info(f"Upload processed: template_id={template_id}, filename={file.filename}, has_existing_rules={has_existing_rules}")

            return jsonify({
                'success': True,
                'sheets': {sheet_name: {'headers': headers}},
                'file_name': file.filename,
                'template_id': template_id,
                'has_existing_rules': has_existing_rules,
                'sheet_name': sheet_name,
                'skip_to_step_3': has_existing_rules
            })
        except mysql.connector.Error as e:
            logging.error(f'Error saving template: {str(e)}')
            return jsonify({'error': f'Error saving template: {str(e)}'}), 500
        except Exception as e:
            logging.error(f'Unexpected error saving template: {str(e)}')
            return jsonify({'error': f'Unexpected error: {str(e)}'}), 500

    # Multi-step workflow endpoints
    @app.route('/step/1', methods=['GET', 'POST'])
    @app.route('/api/step/1', methods=['GET', 'POST'])
    def step_one():
        if 'loggedin' not in session:
            return jsonify({'error': 'Not logged in'}), 401
        
        if request.method == 'POST':
            try:
                headers = request.form.getlist('headers')
                new_header_row = request.form.get('new_header_row')
                logging.debug(f"Step 1 submitted: headers={headers}, new_header_row={new_header_row}")
                
                if not headers:
                    logging.error("No headers provided in step 1")
                    return jsonify({'success': False, 'message': 'No headers provided'}), 400
                    
                if 'template_id' not in session:
                    logging.error("Session missing template_id")
                    return jsonify({'success': False, 'message': 'Session data missing'}), 400

                template_id = session['template_id']
                
                # Get the dataframe from session for auto-detection
                df_json = session.get('df')
                if df_json:
                    df = pd.read_json(StringIO(df_json))
                    session_headers = session.get('headers', [])
                    df.columns = session_headers
                    header_row = session.get('header_row', 0)
                    df = df.iloc[header_row + 1:].reset_index(drop=True)
                    
                    # Auto-detect rules for selected headers
                    validations = assign_default_rules_to_columns(df, headers)
                    session['validations'] = validations
                    logging.debug(f"Auto-assigned rules: {validations}")
                else:
                    validations = {}

                session['selected_headers'] = headers
                session['current_step'] = 2

                # Mark selected headers in the database
                conn = get_db_connection()
                cursor = conn.cursor()
                cursor.execute("UPDATE template_columns SET is_selected = FALSE WHERE template_id = %s", (template_id,))
                for header in headers:
                    cursor.execute("""
                        UPDATE template_columns
                        SET is_selected = TRUE
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    
                    # Get column_id and add auto-detected rules
                    cursor.execute("""
                        SELECT column_id FROM template_columns
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    result = cursor.fetchone()
                    if result:
                        column_id = result[0]
                        for rule_name in validations.get(header, []):
                            cursor.execute("""
                                SELECT rule_type_id FROM validation_rule_types
                                WHERE rule_name = %s AND is_custom = FALSE
                            """, (rule_name,))
                            rule_result = cursor.fetchone()
                            if rule_result:
                                rule_type_id = rule_result[0]
                                cursor.execute("""
                                    INSERT IGNORE INTO column_validation_rules (column_id, rule_type_id, rule_config)
                                    VALUES (%s, %s, %s)
                                """, (column_id, rule_type_id, '{}'))
                
                conn.commit()
                cursor.close()

                logging.info(f"Step 1 completed: headers={headers}, auto-assigned rules={validations}")
                return jsonify({'success': True, 'headers': headers, 'validations': validations})
            except Exception as e:
                logging.error(f"Error in step 1: {str(e)}")
                return jsonify({'success': False, 'message': str(e)}), 500
        
        # GET request - return current headers
        headers = session.get('headers', [])
        return jsonify({'headers': headers})

    @app.route('/step/2', methods=['GET', 'POST'])
    @app.route('/api/step/2', methods=['GET', 'POST'])
    def step_two():
        if 'loggedin' not in session:
            return jsonify({'error': 'Not logged in'}), 401
            
        if request.method == 'POST':
            try:
                action = request.form.get('action', 'save')
                validations = {}
                for key, values in request.form.lists():
                    if key.startswith('validations_'):
                        header = key.replace('validations_', '')
                        validations[header] = values
                        
                logging.debug(f"Step 2 submitted: action={action}, validations={validations}")
                
                template_id = session.get('template_id')
                if not template_id:
                    return jsonify({'success': False, 'message': 'Session data missing'}), 400

                # Save validations to database
                conn = get_db_connection()
                cursor = conn.cursor()
                
                # Clear existing rules
                cursor.execute("""
                    DELETE FROM column_validation_rules
                    WHERE column_id IN (
                        SELECT column_id FROM template_columns WHERE template_id = %s
                    )
                """, (template_id,))
                
                # Add new rules
                for header, rules in validations.items():
                    cursor.execute("""
                        SELECT column_id FROM template_columns
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    result = cursor.fetchone()
                    if not result:
                        continue
                    column_id = result[0]
                    
                    for rule_name in rules:
                        cursor.execute("""
                            SELECT rule_type_id FROM validation_rule_types
                            WHERE rule_name = %s
                        """, (rule_name,))
                        result = cursor.fetchone()
                        if result:
                            rule_type_id = result[0]
                            cursor.execute("""
                                INSERT IGNORE INTO column_validation_rules (column_id, rule_type_id, rule_config)
                                VALUES (%s, %s, %s)
                            """, (column_id, rule_type_id, '{}'))
                
                conn.commit()
                cursor.close()

                session['validations'] = validations
                session['current_step'] = 3 if action == 'review' else 2
                
                logging.info(f"Step 2 completed: action={action}, validations={validations}")
                return jsonify({'success': True, 'message': 'Step 2 completed successfully'})
            except Exception as e:
                logging.error(f"Error in step 2: {str(e)}")
                return jsonify({'success': False, 'message': str(e)}), 500
        
        # GET request
        selected_headers = session.get('selected_headers', [])
        return jsonify({'selected_headers': selected_headers})

    # Rules endpoint
    @app.route('/rules', methods=['GET'])
    @app.route('/api/rules', methods=['GET'])
    def get_rules():
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            
            cursor.execute("""
                SELECT rule_type_id AS rule_id, rule_name, description, parameters, is_custom, 
                       column_name, template_id, source_format, target_format, data_type, is_active
                FROM validation_rule_types
            """)
            rules = cursor.fetchall()
            cursor.close()
            
            logging.info(f"Returning {len(rules)} rules from getRules endpoint")
            return jsonify({'success': True, 'rules': rules})
        except mysql.connector.Error as e:
            logging.error(f"Database error fetching rules: {str(e)}")
            return jsonify({'success': False, 'message': str(e)}), 500
        except Exception as e:
            logging.error(f"Unexpected error fetching rules: {str(e)}")
            return jsonify({'success': False, 'message': str(e)}), 500

    # Template details endpoint
    @app.route('/template/<int:template_id>/<sheet_name>', methods=['GET'])
    @app.route('/api/template/<int:template_id>/<sheet_name>', methods=['GET'])
    def get_template(template_id, sheet_name):
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /template: session missing")
            return jsonify({'error': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("""
                SELECT template_name, sheet_name, headers
                FROM excel_templates
                WHERE template_id = %s AND user_id = %s AND status = 'ACTIVE'
            """, (template_id, session['user_id']))
            template_record = cursor.fetchone()
            
            if not template_record:
                logging.error(f"Template not found for template_id: {template_id}, user_id: {session['user_id']}")
                cursor.close()
                return jsonify({'error': 'Template not found'}), 404

            headers = json.loads(template_record['headers']) if template_record['headers'] else []
            stored_sheet_name = template_record['sheet_name'] or sheet_name
            file_path = os.path.join(app.config['UPLOAD_FOLDER'], template_record['template_name'])
            
            cursor.execute("""
                SELECT COUNT(*) as rule_count
                FROM template_columns tc
                JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                WHERE tc.template_id = %s AND tc.is_selected = TRUE
            """, (template_id,))
            rule_count = cursor.fetchone()['rule_count']
            has_existing_rules = rule_count > 0
            
            cursor.close()
            
            return jsonify({
                'success': True,
                'sheets': {stored_sheet_name: {'headers': headers}},
                'file_name': template_record['template_name'],
                'file_path': file_path,
                'sheet_name': stored_sheet_name,
                'has_existing_rules': has_existing_rules
            })
        except mysql.connector.Error as e:
            logging.error(f"Database error in get_template: {str(e)}")
            return jsonify({'error': f'Database error: {str(e)}'}), 500
        except Exception as e:
            logging.error(f"Unexpected error in get_template: {str(e)}")
            return jsonify({'error': f'Unexpected error: {str(e)}'}), 500

    # Debug route to show all registered routes
    @app.route('/debug/routes', methods=['GET'])
    def list_routes():
        routes = []
        for rule in app.url_map.iter_rules():
            routes.append({
                'endpoint': rule.endpoint,
                'methods': list(rule.methods),
                'rule': rule.rule
            })
        return jsonify(routes)

    # 404 handler to debug missing routes
    @app.errorhandler(404)
    def not_found_handler(error):
        logging.error(f"404 Error: {request.method} {request.url} not found")
        logging.error(f"Available routes: {[rule.rule for rule in app.url_map.iter_rules()]}")
        return jsonify({
            'error': 'Endpoint not found', 
            'method': request.method,
            'url': request.url,
            'path': request.path
        }), 404

    return app

def initialize_app_data():
    """Initialize database and create default data"""
    try:
        logging.info("Initializing database schema...")
        init_db()
        
        logging.info("Creating admin user...")
        create_admin_user()
        
        logging.info("Creating default validation rules...")
        create_default_validation_rules()
        
        logging.info("Application initialization completed successfully")
    except Exception as e:
        logging.error(f"Failed to initialize application: {e}")
        raise

DB_CONFIG = {
    'host': os.getenv('MYSQL_HOST', 'localhost'),
    'user': os.getenv('MYSQL_USER', 'root'),
    'password': os.getenv('MYSQL_PASSWORD', 'Keansa@2024'),
    'database': os.getenv('MYSQL_DATABASE', 'data_validation_2'),
}

def get_db_connection():
    if 'db' not in g:
        try:
            conn = mysql.connector.connect(
                host=DB_CONFIG['host'],
                user=DB_CONFIG['user'],
                password=DB_CONFIG['password']
            )
            cursor = conn.cursor()
            cursor.execute(f"CREATE DATABASE IF NOT EXISTS {DB_CONFIG['database']}")
            cursor.close()
            conn.close()
            g.db = mysql.connector.connect(**DB_CONFIG)
            logging.info("Database connection established successfully")
        except mysql.connector.Error as err:
            if err.errno == errorcode.ER_ACCESS_DENIED_ERROR:
                logging.error("Database connection failed: Access denied for user - check username/password")
            elif err.errno == errorcode.ER_BAD_DB_ERROR:
                logging.error("Database connection failed: Database does not exist")
            else:
                logging.error(f"Database connection failed: {err}")
            raise Exception(f"Failed to connect to database: {str(err)}")
    return g.db

def close_db(error):
    db = g.pop('db', None)
    if db is not None:
        db.close()

def init_db():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        tables = [
            """
            CREATE TABLE IF NOT EXISTS login_details (
                id INT AUTO_INCREMENT PRIMARY KEY,
                first_name VARCHAR(100),
                last_name VARCHAR(100),
                email VARCHAR(255) UNIQUE,
                mobile VARCHAR(10),
                password VARCHAR(255)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS excel_templates (
                template_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_name VARCHAR(255) NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
                user_id INT NOT NULL,
                sheet_name VARCHAR(255),
                headers JSON,
                status ENUM('ACTIVE', 'INACTIVE') DEFAULT 'ACTIVE',
                is_corrected BOOLEAN DEFAULT FALSE,
                remote_file_path VARCHAR(512),
                FOREIGN KEY (user_id) REFERENCES login_details(id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS template_columns (
                column_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_id BIGINT NOT NULL,
                column_name VARCHAR(255) NOT NULL,
                column_position INT NOT NULL,
                is_validation_enabled BOOLEAN DEFAULT FALSE,
                is_selected BOOLEAN DEFAULT FALSE,
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE,
                UNIQUE (template_id, column_name)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_rule_types (
                rule_type_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                rule_name VARCHAR(255) NOT NULL,
                description TEXT,
                parameters TEXT,
                is_active BOOLEAN DEFAULT TRUE,
                is_custom BOOLEAN DEFAULT FALSE,
                column_name VARCHAR(255),
                template_id BIGINT,
                data_type VARCHAR(50),
                source_format VARCHAR(50),
                target_format VARCHAR(50),
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS column_validation_rules (
                column_validation_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                column_id BIGINT NOT NULL,
                rule_type_id BIGINT NOT NULL,
                rule_config JSON,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (column_id) REFERENCES template_columns(column_id) ON DELETE CASCADE,
                FOREIGN KEY (rule_type_id) REFERENCES validation_rule_types(rule_type_id) ON DELETE RESTRICT,
                UNIQUE (column_id, rule_type_id)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_history (
                history_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_id BIGINT NOT NULL,
                template_name VARCHAR(255) NOT NULL,
                error_count INT NOT NULL,
                corrected_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                corrected_file_path VARCHAR(512) NOT NULL,
                user_id INT NOT NULL,
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE,
                FOREIGN KEY (user_id) REFERENCES login_details(id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_corrections (
                correction_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                history_id BIGINT NOT NULL,
                row_index INT NOT NULL,
                column_name VARCHAR(255) NOT NULL,
                original_value TEXT,
                corrected_value TEXT,
                rule_failed VARCHAR(255) DEFAULT NULL,
                FOREIGN KEY (history_id) REFERENCES validation_history(history_id) ON DELETE CASCADE
            )
            """
        ]
        for table_sql in tables:
            cursor.execute(table_sql)
        
        # Add missing columns if they don't exist
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'source_format'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN source_format VARCHAR(50)")
            logging.info("Added source_format column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'target_format'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN target_format VARCHAR(50)")
            logging.info("Added target_format column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'data_type'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN data_type VARCHAR(50)")
            logging.info("Added data_type column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM excel_templates LIKE 'remote_file_path'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE excel_templates ADD COLUMN remote_file_path VARCHAR(512)")
            logging.info("Added remote_file_path column to excel_templates table")
            
        cursor.execute("SHOW COLUMNS FROM template_columns LIKE 'is_selected'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE template_columns ADD COLUMN is_selected BOOLEAN DEFAULT FALSE")
            logging.info("Added is_selected column to template_columns table")
            
        conn.commit()
        cursor.close()
        logging.info("Database tables initialized")
    except Exception as e:
        logging.error(f"Failed to initialize database: {str(e)}")
        raise

def create_admin_user():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        admin_password = bcrypt.hashpw('admin'.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
        cursor.execute("""
            INSERT IGNORE INTO login_details (first_name, last_name, email, mobile, password)
            VALUES (%s, %s, %s, %s, %s)
        """, ('Admin', 'User', 'admin@example.com', '1234567890', admin_password))
        conn.commit()
        cursor.close()
        logging.info("Admin user created or already exists")
    except Exception as e:
        logging.error(f"Failed to create admin user: {str(e)}")
        raise

def create_default_validation_rules():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        default_rules = [
            ("Required", "Ensures the field is not null", '{"allow_null": false}', None, None, None),
            ("Int", "Validates integer format", '{"format": "integer"}', None, None, "Int"),
            ("Float", "Validates number format (integer or decimal)", '{"format": "float"}', None, None, "Float"),
            ("Text", "Allows text with quotes and parentheses", '{"allow_special": false}', None, None, "Text"),
            ("Email", "Validates email format", '{"regex": "^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\\\.[a-zA-Z0-9-.]+$"}', None, None, "Email"),
            ("Date(DD-MM-YYYY)", "Validates date format DD-MM-YYYY", '{"format": "%d-%m-%Y"}', "DD-MM-YYYY", None, "Date"),
            ("Boolean", "Validates boolean format (true/false or 0/1)", '{"format": "boolean"}', None, None, "Boolean"),
            ("Alphanumeric", "Validates alphanumeric format", '{"format": "alphanumeric"}', None, None, "Alphanumeric")
        ]
        cursor.executemany("""
            INSERT IGNORE INTO validation_rule_types (rule_name, description, parameters, is_custom, source_format, target_format, data_type)
            VALUES (%s, %s, %s, %s, %s, %s, %s)
        """, [(name, desc, params, False, source, target, dtype) for name, desc, params, source, target, dtype in default_rules])
        conn.commit()
        cursor.close()
        logging.info("Default validation rules ensured successfully")
    except Exception as e:
        logging.error(f"Failed to ensure default validation rules: {str(e)}")
        raise

if __name__ == '__main__':
    try:
        # Create the application using factory pattern
        app = create_app()
        
        # Initialize database and default data within app context
        with app.app_context():
            initialize_app_data()
        
        # Get port from environment or use default
        port = int(os.getenv('PORT', 5000))
        
        # Start the application server
        logging.info("Starting Flask server...")
        app.run(debug=True, host='0.0.0.0', port=port)
        
    except Exception as e:
        logging.error(f"Failed to start application: {e}")
        raise
).all():
        return "Email"
    
    # Date pattern detection
    try:
        pd.to_datetime(non_null, format="%d-%m-%Y")
        return "Date"
    except Exception:
        try:
            pd.to_datetime(non_null, format="%Y-%m-%d")
            return "Date"
        except Exception:
            pass
    
    # Boolean detection
    if non_null.str.lower().isin(['true', 'false', '0', '1']).all():
        return "Boolean"
    
    # Numeric detection
    if non_null.str.match(r'^-?\d+

def create_app():
    """Application factory pattern for different environments"""
    # Set the path to the frontend dist folder
    current_dir = os.path.dirname(os.path.abspath(__file__))
    frontend_dist_path = os.path.join(current_dir, '..', '..', 'Keansa-Ai-Suite2025may-frontend11', 'dist')
    frontend_dist_path = os.path.abspath(frontend_dist_path)
    
    # Create Flask application instance
    app = Flask(__name__, static_folder=frontend_dist_path, static_url_path='')
    CORS(app, supports_credentials=True, origins=["http://localhost:3000", "http://localhost:8080", "http://localhost:5000", "*"])

    app.secret_key = os.urandom(24).hex()
    app.config['SESSION_TYPE'] = 'filesystem'
    app.config['SESSION_FILE_DIR'] = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'sessions')
    app.config['SESSION_COOKIE_SAMESITE'] = 'Lax'
    app.config['SESSION_COOKIE_HTTPONLY'] = True
    app.config['SESSION_COOKIE_SECURE'] = False
    app.config['PERMANENT_SESSION_LIFETIME'] = 86400  # 24 hours
    app.config['UPLOAD_FOLDER'] = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'uploads')
    Session(app)

    # Ensure directories exist
    try:
        os.makedirs(app.config['UPLOAD_FOLDER'], exist_ok=True)
        os.makedirs(app.config['SESSION_FILE_DIR'], exist_ok=True)
    except OSError as e:
        logging.error(f"Failed to create directories: {e}")

    # Register cleanup handlers
    app.teardown_appcontext(close_db)
    
    # Register all routes directly in create_app
    
    # Static file serving for React frontend
    @app.route('/', defaults={'path': ''})
    @app.route('/<path:path>')
    def serve(path):
        if path and os.path.exists(os.path.join(app.static_folder, path)):
            return app.send_static_file(path)
        return app.send_static_file('index.html')

    # Health check endpoint
    @app.route('/health', methods=['GET'])
    def health_check():
        return jsonify({
            'status': 'healthy',
            'timestamp': datetime.now().isoformat(),
            'version': '2.0.0'
        })

    # Authentication endpoint - both old and new paths
    @app.route('/authenticate', methods=['POST'])
    @app.route('/api/auth/authenticate', methods=['POST'])
    def authenticate():
        try:
            email = request.form.get('username') or request.form.get('email')
            password = request.form.get('password')
            logging.debug(f"Login attempt: email={email}, password={'*' * len(password) if password else 'None'}")
            
            if not email or not password:
                logging.warning(f"Login failed: Email or password missing")
                return jsonify({'success': False, 'message': 'Email and password are required'}), 400

            # Check for admin login
            if email == "admin" and password == "admin":
                session['loggedin'] = True
                session['user_email'] = "admin@example.com"
                session['user_id'] = 1
                session.permanent = True
                logging.info(f"Admin login successful. Session: {dict(session)}")
                return jsonify({'success': True, 'message': 'Login successful', 'user': {'email': 'admin@example.com', 'id': 1}}), 200

            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("SELECT * FROM login_details WHERE LOWER(email) = LOWER(%s)", (email.lower(),))
            account = cursor.fetchone()
            cursor.close()
            
            if account:
                if bcrypt.checkpw(password.encode('utf-8'), account['password'].encode('utf-8')):
                    session['loggedin'] = True
                    session['user_email'] = account['email']
                    session['user_id'] = account['id']
                    session.permanent = True
                    logging.info(f"User {email} logged in successfully. Session: {dict(session)}")
                    return jsonify({
                        'success': True,
                        'message': 'Login successful',
                        'user': {'email': account['email'], 'id': account['id']}
                    }), 200
                else:
                    logging.warning(f"Invalid password for {email}")
                    return jsonify({'success': False, 'message': 'Invalid credentials'}), 401
            else:
                logging.warning(f"Email {email} not found")
                return jsonify({'success': False, 'message': 'Invalid credentials'}), 401
        except Exception as e:
            logging.error(f"Unexpected error during login: {str(e)}")
            return jsonify({'success': False, 'message': f'Unexpected error: {str(e)}'}), 500

    @app.route('/check-auth', methods=['GET'])
    @app.route('/api/auth/check-auth', methods=['GET'])
    def check_auth():
        try:
            logging.debug(f"Checking auth with session: {dict(session)}")
            if 'loggedin' in session and 'user_id' in session:
                conn = get_db_connection()
                cursor = conn.cursor(dictionary=True)
                cursor.execute("SELECT email, first_name FROM login_details WHERE id = %s", (session['user_id'],))
                user = cursor.fetchone()
                cursor.close()
                if user:
                    logging.info(f"User {session.get('user_email')} is authenticated")
                    return jsonify({
                        'success': True,
                        'user': {
                            'email': user['email'],
                            'id': session['user_id'],
                            'first_name': user['first_name']
                        }
                    })
                else:
                    logging.warning("User not found in database")  
                    session.clear()
                    return jsonify({'success': False, 'message': 'User not found'}), 401
            logging.warning("User not authenticated")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        except Exception as e:
            logging.error(f"Error in check-auth endpoint: {str(e)}")
            return jsonify({'success': False, 'message': f'Server error: {str(e)}'}), 500

    @app.route('/register', methods=['POST'])
    @app.route('/api/auth/register', methods=['POST'])
    def register():
        first_name = request.form.get('first_name')
        last_name = request.form.get('last_name')
        email = request.form.get('email')
        mobile = request.form.get('mobile')
        password = request.form.get('password')
        confirm_password = request.form.get('confirm_password')

        if not all([first_name, last_name, email, mobile, password, confirm_password]):
            return jsonify({'success': False, 'message': 'All fields are required'}), 400
        if password != confirm_password:
            return jsonify({'success': False, 'message': 'Passwords do not match'}), 400

        hashed_password = bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
        try:
            conn = get_db_connection()
            cursor = conn.cursor()
            cursor.execute("""
                INSERT INTO login_details (first_name, last_name, email, mobile, password)
                VALUES (%s, %s, %s, %s, %s)
            """, (first_name, last_name, email, mobile, hashed_password))
            user_id = cursor.lastrowid
            conn.commit()
            cursor.close()
            session['loggedin'] = True
            session['user_email'] = email
            session['user_id'] = user_id
            return jsonify({
                'success': True,
                'message': 'Registration successful',
                'user': {'email': email, 'id': user_id}
            }), 200
        except mysql.connector.Error as e:
            logging.error(f"Database error during registration: {str(e)}")
            return jsonify({'success': False, 'message': f'Registration error: {str(e)}'}), 500

    @app.route('/logout', methods=['POST'])
    @app.route('/api/auth/logout', methods=['POST'])
    def logout():
        logging.info(f"User {session.get('user_email', 'unknown')} logged out")
        session.clear()
        return jsonify({'success': True, 'message': 'Logged out successfully'})

    # Template routes
    @app.route('/templates', methods=['GET'])
    @app.route('/api/templates', methods=['GET'])
    def get_templates():
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /templates: session missing")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("""
                SELECT template_id, template_name, created_at, status
                FROM excel_templates
                WHERE user_id = %s AND status = 'ACTIVE'
                ORDER BY created_at DESC
                LIMIT 100
            """, (session['user_id'],))
            templates = cursor.fetchall()
            cursor.close()
            logging.info(f"Fetched {len(templates)} templates for user {session['user_id']}")
            return jsonify({'success': True, 'templates': templates})
        except mysql.connector.Error as e:
            logging.error(f'Error fetching templates: {str(e)}')
            return jsonify({'success': False, 'message': f'Error fetching templates: {str(e)}'}), 500
        except Exception as e:
            logging.error(f'Unexpected error fetching templates: {str(e)}')
            return jsonify({'success': False, 'message': f'Unexpected error: {str(e)}'}), 500

    # Rule Configuration routes
    @app.route('/rule-configurations', methods=['GET'])
    @app.route('/api/validation/rule-configurations', methods=['GET'])
    def get_rule_configurations():
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning(f"Unauthorized access to /rule-configurations: session={dict(session)}")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            user_id = session['user_id']
            logging.debug(f"Fetching rule configurations for user_id: {user_id}")

            # Main query to fetch templates with configured rules
            cursor.execute("""
                SELECT 
                    t.template_id, 
                    t.template_name, 
                    t.created_at, 
                    COUNT(cvr.column_validation_id) as rule_count
                FROM excel_templates t
                LEFT JOIN template_columns tc ON t.template_id = tc.template_id
                LEFT JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                WHERE t.user_id = %s AND t.status = 'ACTIVE' AND t.is_corrected = FALSE
                GROUP BY t.template_id, t.template_name, t.created_at
                HAVING rule_count > 0
                ORDER BY t.created_at DESC
                LIMIT 100
            """, (user_id,))
            templates = cursor.fetchall()
            logging.debug(f"Fetched rule-configured templates: {templates}")

            cursor.close()

            if not templates:
                logging.info(f"No templates with rules found for user_id: {user_id}")
            else:
                logging.info(f"Found {len(templates)} templates with rules for user_id: {user_id}")

            return jsonify({'success': True, 'templates': templates})
        except mysql.connector.Error as e:
            logging.error(f"Database error fetching rule configurations: {str(e)}")
            return jsonify({'success': False, 'message': f"Database error: {str(e)}"}), 500
        except Exception as e:
            logging.error(f"Unexpected error fetching rule configurations: {str(e)}")
            return jsonify({'success': False, 'message': f"Unexpected error: {str(e)}"}), 500

    # File upload route
    @app.route('/upload', methods=['POST'])
    @app.route('/api/templates/upload', methods=['POST'])
    @app.route('/api/upload', methods=['POST'])  # Additional common path
    def upload():
        logging.info(f"Upload endpoint called: {request.endpoint}, method: {request.method}")
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /upload: session missing")
            return jsonify({'error': 'Not logged in'}), 401
        if 'file' not in request.files:
            logging.warning("No file provided in upload request")
            return jsonify({'error': 'No file uploaded'}), 400
        file = request.files['file']
        if file.filename == '':
            logging.warning("No file selected in upload request")
            return jsonify({'error': 'No file selected'}), 400
        
        file_path = os.path.join(app.config['UPLOAD_FOLDER'], file.filename)
        try:
            file.save(file_path)
            logging.info(f"File saved: {file_path}")
        except Exception as e:
            logging.error(f"Failed to save file {file.filename}: {str(e)}")
            return jsonify({'error': f'Failed to save file: {str(e)}'}), 500

        try:
            # Read the file to get sheets and headers
            if file.filename.endswith('.xlsx') or file.filename.endswith('.xls'):
                xl = pd.ExcelFile(file_path)
                sheets = {sheet_name: pd.read_excel(file_path, sheet_name=sheet_name, header=None) 
                         for sheet_name in xl.sheet_names}
            elif file.filename.endswith(('.txt', '.csv', '.dat')):
                df = pd.read_csv(file_path, header=None, encoding='utf-8')
                sheets = {'Sheet1': df}
            else:
                logging.error("Unsupported file type")
                return jsonify({'error': 'Unsupported file type'}), 400
            
            logging.debug(f"Sheets extracted: {list(sheets.keys())}")
        except Exception as e:
            logging.error(f"Failed to read file {file_path}: {str(e)}")
            return jsonify({'error': f'Failed to read file: {str(e)}'}), 400

        try:
            sheet_names = list(sheets.keys())
            if not sheet_names:
                logging.error("No sheets found in the file")
                return jsonify({'error': 'No sheets found in the file'}), 400
            sheet_name = sheet_names[0]
            df = sheets[sheet_name]
            
            # Find header row
            header_row = 0
            for i in range(min(len(df), 10)):
                row = df.iloc[i].dropna()
                if not row.empty and all(isinstance(x, str) for x in row if pd.notna(x)):
                    header_row = i
                    break
                    
            headers = df.iloc[header_row].tolist()
            logging.debug(f"Headers extracted: {headers}")
            
            if not headers or all(not h for h in headers):
                logging.error("No valid headers found in file")
                return jsonify({'error': 'No valid headers found in the file'}), 400
        except Exception as e:
            logging.error(f"Error processing file {file.filename}: {str(e)}")
            return jsonify({'error': f'Error processing file: {str(e)}'}), 400

        # Clear existing session data
        for key in ['df', 'header_row', 'headers', 'sheet_name', 'current_step', 'selected_headers', 'validations', 'error_cell_locations', 'data_rows', 'corrected_file_path']:
            session.pop(key, None)

        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)

            # Check if template exists
            cursor.execute("""
                SELECT template_id, headers, sheet_name
                FROM excel_templates
                WHERE template_name = %s AND user_id = %s AND status = 'ACTIVE'
                ORDER BY created_at DESC
            """, (file.filename, session['user_id']))
            existing_templates = cursor.fetchall()
            logging.info(f"Found {len(existing_templates)} existing templates with name {file.filename}")

            template_id = None
            has_existing_rules = False
            validations = {}
            selected_headers = []

            # Check for matching template
            matching_template = None
            for template in existing_templates:
                stored_headers = json.loads(template['headers']) if template['headers'] else []
                stored_sheet_name = template['sheet_name']
                if stored_headers == headers and stored_sheet_name == sheet_name:
                    matching_template = template
                    break

            if matching_template:
                template_id = matching_template['template_id']
                # Check for existing rules
                cursor.execute("""
                    SELECT tc.column_name, vrt.rule_name
                    FROM template_columns tc
                    JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                    JOIN validation_rule_types vrt ON cvr.rule_type_id = vrt.rule_type_id
                    WHERE tc.template_id = %s AND tc.is_selected = TRUE
                """, (template_id,))
                rules_data = cursor.fetchall()
                for row in rules_data:
                    column_name = row['column_name']
                    rule_name = row['rule_name']
                    if column_name not in validations:
                        validations[column_name] = []
                    validations[column_name].append(rule_name)
                    if column_name not in selected_headers:
                        selected_headers.append(column_name)
                has_existing_rules = len(validations) > 0
            else:
                # New template
                cursor.execute("""
                    INSERT INTO excel_templates (template_name, user_id, sheet_name, headers, is_corrected)
                    VALUES (%s, %s, %s, %s, %s)
                """, (file.filename, session['user_id'], sheet_name, json.dumps(headers), False))
                template_id = cursor.lastrowid
                column_data = [(template_id, header, i + 1, False) for i, header in enumerate(headers)]
                cursor.executemany("""
                    INSERT INTO template_columns (template_id, column_name, column_position, is_selected)
                    VALUES (%s, %s, %s, %s)
                """, column_data)

            conn.commit()
            cursor.close()

            # Store session data
            session['file_path'] = file_path
            session['template_id'] = template_id
            session['df'] = df.to_json()
            session['header_row'] = header_row
            session['headers'] = headers
            session['sheet_name'] = sheet_name
            session['current_step'] = 1 if not has_existing_rules else 3
            session['validations'] = validations
            session['selected_headers'] = selected_headers
            session['has_existing_rules'] = has_existing_rules

            logging.info(f"Upload processed: template_id={template_id}, filename={file.filename}, has_existing_rules={has_existing_rules}")

            return jsonify({
                'success': True,
                'sheets': {sheet_name: {'headers': headers}},
                'file_name': file.filename,
                'template_id': template_id,
                'has_existing_rules': has_existing_rules,
                'sheet_name': sheet_name,
                'skip_to_step_3': has_existing_rules
            })
        except mysql.connector.Error as e:
            logging.error(f'Error saving template: {str(e)}')
            return jsonify({'error': f'Error saving template: {str(e)}'}), 500
        except Exception as e:
            logging.error(f'Unexpected error saving template: {str(e)}')
            return jsonify({'error': f'Unexpected error: {str(e)}'}), 500

    # Multi-step workflow endpoints
    @app.route('/step/1', methods=['GET', 'POST'])
    @app.route('/api/step/1', methods=['GET', 'POST'])
    def step_one():
        if 'loggedin' not in session:
            return jsonify({'error': 'Not logged in'}), 401
        
        if request.method == 'POST':
            try:
                headers = request.form.getlist('headers')
                new_header_row = request.form.get('new_header_row')
                logging.debug(f"Step 1 submitted: headers={headers}, new_header_row={new_header_row}")
                
                if not headers:
                    logging.error("No headers provided in step 1")
                    return jsonify({'success': False, 'message': 'No headers provided'}), 400
                    
                if 'template_id' not in session:
                    logging.error("Session missing template_id")
                    return jsonify({'success': False, 'message': 'Session data missing'}), 400

                template_id = session['template_id']
                
                # Get the dataframe from session for auto-detection
                df_json = session.get('df')
                if df_json:
                    df = pd.read_json(StringIO(df_json))
                    session_headers = session.get('headers', [])
                    df.columns = session_headers
                    header_row = session.get('header_row', 0)
                    df = df.iloc[header_row + 1:].reset_index(drop=True)
                    
                    # Auto-detect rules for selected headers
                    validations = assign_default_rules_to_columns(df, headers)
                    session['validations'] = validations
                    logging.debug(f"Auto-assigned rules: {validations}")
                else:
                    validations = {}

                session['selected_headers'] = headers
                session['current_step'] = 2

                # Mark selected headers in the database
                conn = get_db_connection()
                cursor = conn.cursor()
                cursor.execute("UPDATE template_columns SET is_selected = FALSE WHERE template_id = %s", (template_id,))
                for header in headers:
                    cursor.execute("""
                        UPDATE template_columns
                        SET is_selected = TRUE
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    
                    # Get column_id and add auto-detected rules
                    cursor.execute("""
                        SELECT column_id FROM template_columns
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    result = cursor.fetchone()
                    if result:
                        column_id = result[0]
                        for rule_name in validations.get(header, []):
                            cursor.execute("""
                                SELECT rule_type_id FROM validation_rule_types
                                WHERE rule_name = %s AND is_custom = FALSE
                            """, (rule_name,))
                            rule_result = cursor.fetchone()
                            if rule_result:
                                rule_type_id = rule_result[0]
                                cursor.execute("""
                                    INSERT IGNORE INTO column_validation_rules (column_id, rule_type_id, rule_config)
                                    VALUES (%s, %s, %s)
                                """, (column_id, rule_type_id, '{}'))
                
                conn.commit()
                cursor.close()

                logging.info(f"Step 1 completed: headers={headers}, auto-assigned rules={validations}")
                return jsonify({'success': True, 'headers': headers, 'validations': validations})
            except Exception as e:
                logging.error(f"Error in step 1: {str(e)}")
                return jsonify({'success': False, 'message': str(e)}), 500
        
        # GET request - return current headers
        headers = session.get('headers', [])
        return jsonify({'headers': headers})

    @app.route('/step/2', methods=['GET', 'POST'])
    @app.route('/api/step/2', methods=['GET', 'POST'])
    def step_two():
        if 'loggedin' not in session:
            return jsonify({'error': 'Not logged in'}), 401
            
        if request.method == 'POST':
            try:
                action = request.form.get('action', 'save')
                validations = {}
                for key, values in request.form.lists():
                    if key.startswith('validations_'):
                        header = key.replace('validations_', '')
                        validations[header] = values
                        
                logging.debug(f"Step 2 submitted: action={action}, validations={validations}")
                
                template_id = session.get('template_id')
                if not template_id:
                    return jsonify({'success': False, 'message': 'Session data missing'}), 400

                # Save validations to database
                conn = get_db_connection()
                cursor = conn.cursor()
                
                # Clear existing rules
                cursor.execute("""
                    DELETE FROM column_validation_rules
                    WHERE column_id IN (
                        SELECT column_id FROM template_columns WHERE template_id = %s
                    )
                """, (template_id,))
                
                # Add new rules
                for header, rules in validations.items():
                    cursor.execute("""
                        SELECT column_id FROM template_columns
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    result = cursor.fetchone()
                    if not result:
                        continue
                    column_id = result[0]
                    
                    for rule_name in rules:
                        cursor.execute("""
                            SELECT rule_type_id FROM validation_rule_types
                            WHERE rule_name = %s
                        """, (rule_name,))
                        result = cursor.fetchone()
                        if result:
                            rule_type_id = result[0]
                            cursor.execute("""
                                INSERT IGNORE INTO column_validation_rules (column_id, rule_type_id, rule_config)
                                VALUES (%s, %s, %s)
                            """, (column_id, rule_type_id, '{}'))
                
                conn.commit()
                cursor.close()

                session['validations'] = validations
                session['current_step'] = 3 if action == 'review' else 2
                
                logging.info(f"Step 2 completed: action={action}, validations={validations}")
                return jsonify({'success': True, 'message': 'Step 2 completed successfully'})
            except Exception as e:
                logging.error(f"Error in step 2: {str(e)}")
                return jsonify({'success': False, 'message': str(e)}), 500
        
        # GET request
        selected_headers = session.get('selected_headers', [])
        return jsonify({'selected_headers': selected_headers})

    # Rules endpoint
    @app.route('/rules', methods=['GET'])
    @app.route('/api/rules', methods=['GET'])
    def get_rules():
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            
            cursor.execute("""
                SELECT rule_type_id AS rule_id, rule_name, description, parameters, is_custom, 
                       column_name, template_id, source_format, target_format, data_type, is_active
                FROM validation_rule_types
            """)
            rules = cursor.fetchall()
            cursor.close()
            
            logging.info(f"Returning {len(rules)} rules from getRules endpoint")
            return jsonify({'success': True, 'rules': rules})
        except mysql.connector.Error as e:
            logging.error(f"Database error fetching rules: {str(e)}")
            return jsonify({'success': False, 'message': str(e)}), 500
        except Exception as e:
            logging.error(f"Unexpected error fetching rules: {str(e)}")
            return jsonify({'success': False, 'message': str(e)}), 500

    # Template details endpoint
    @app.route('/template/<int:template_id>/<sheet_name>', methods=['GET'])
    @app.route('/api/template/<int:template_id>/<sheet_name>', methods=['GET'])
    def get_template(template_id, sheet_name):
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /template: session missing")
            return jsonify({'error': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("""
                SELECT template_name, sheet_name, headers
                FROM excel_templates
                WHERE template_id = %s AND user_id = %s AND status = 'ACTIVE'
            """, (template_id, session['user_id']))
            template_record = cursor.fetchone()
            
            if not template_record:
                logging.error(f"Template not found for template_id: {template_id}, user_id: {session['user_id']}")
                cursor.close()
                return jsonify({'error': 'Template not found'}), 404

            headers = json.loads(template_record['headers']) if template_record['headers'] else []
            stored_sheet_name = template_record['sheet_name'] or sheet_name
            file_path = os.path.join(app.config['UPLOAD_FOLDER'], template_record['template_name'])
            
            cursor.execute("""
                SELECT COUNT(*) as rule_count
                FROM template_columns tc
                JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                WHERE tc.template_id = %s AND tc.is_selected = TRUE
            """, (template_id,))
            rule_count = cursor.fetchone()['rule_count']
            has_existing_rules = rule_count > 0
            
            cursor.close()
            
            return jsonify({
                'success': True,
                'sheets': {stored_sheet_name: {'headers': headers}},
                'file_name': template_record['template_name'],
                'file_path': file_path,
                'sheet_name': stored_sheet_name,
                'has_existing_rules': has_existing_rules
            })
        except mysql.connector.Error as e:
            logging.error(f"Database error in get_template: {str(e)}")
            return jsonify({'error': f'Database error: {str(e)}'}), 500
        except Exception as e:
            logging.error(f"Unexpected error in get_template: {str(e)}")
            return jsonify({'error': f'Unexpected error: {str(e)}'}), 500

    # Debug route to show all registered routes
    @app.route('/debug/routes', methods=['GET'])
    def list_routes():
        routes = []
        for rule in app.url_map.iter_rules():
            routes.append({
                'endpoint': rule.endpoint,
                'methods': list(rule.methods),
                'rule': rule.rule
            })
        return jsonify(routes)

    # 404 handler to debug missing routes
    @app.errorhandler(404)
    def not_found_handler(error):
        logging.error(f"404 Error: {request.method} {request.url} not found")
        logging.error(f"Available routes: {[rule.rule for rule in app.url_map.iter_rules()]}")
        return jsonify({
            'error': 'Endpoint not found', 
            'method': request.method,
            'url': request.url,
            'path': request.path
        }), 404

    return app

def initialize_app_data():
    """Initialize database and create default data"""
    try:
        logging.info("Initializing database schema...")
        init_db()
        
        logging.info("Creating admin user...")
        create_admin_user()
        
        logging.info("Creating default validation rules...")
        create_default_validation_rules()
        
        logging.info("Application initialization completed successfully")
    except Exception as e:
        logging.error(f"Failed to initialize application: {e}")
        raise

DB_CONFIG = {
    'host': os.getenv('MYSQL_HOST', 'localhost'),
    'user': os.getenv('MYSQL_USER', 'root'),
    'password': os.getenv('MYSQL_PASSWORD', 'Keansa@2024'),
    'database': os.getenv('MYSQL_DATABASE', 'data_validation_2'),
}

def get_db_connection():
    if 'db' not in g:
        try:
            conn = mysql.connector.connect(
                host=DB_CONFIG['host'],
                user=DB_CONFIG['user'],
                password=DB_CONFIG['password']
            )
            cursor = conn.cursor()
            cursor.execute(f"CREATE DATABASE IF NOT EXISTS {DB_CONFIG['database']}")
            cursor.close()
            conn.close()
            g.db = mysql.connector.connect(**DB_CONFIG)
            logging.info("Database connection established successfully")
        except mysql.connector.Error as err:
            if err.errno == errorcode.ER_ACCESS_DENIED_ERROR:
                logging.error("Database connection failed: Access denied for user - check username/password")
            elif err.errno == errorcode.ER_BAD_DB_ERROR:
                logging.error("Database connection failed: Database does not exist")
            else:
                logging.error(f"Database connection failed: {err}")
            raise Exception(f"Failed to connect to database: {str(err)}")
    return g.db

def close_db(error):
    db = g.pop('db', None)
    if db is not None:
        db.close()

def init_db():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        tables = [
            """
            CREATE TABLE IF NOT EXISTS login_details (
                id INT AUTO_INCREMENT PRIMARY KEY,
                first_name VARCHAR(100),
                last_name VARCHAR(100),
                email VARCHAR(255) UNIQUE,
                mobile VARCHAR(10),
                password VARCHAR(255)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS excel_templates (
                template_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_name VARCHAR(255) NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
                user_id INT NOT NULL,
                sheet_name VARCHAR(255),
                headers JSON,
                status ENUM('ACTIVE', 'INACTIVE') DEFAULT 'ACTIVE',
                is_corrected BOOLEAN DEFAULT FALSE,
                remote_file_path VARCHAR(512),
                FOREIGN KEY (user_id) REFERENCES login_details(id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS template_columns (
                column_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_id BIGINT NOT NULL,
                column_name VARCHAR(255) NOT NULL,
                column_position INT NOT NULL,
                is_validation_enabled BOOLEAN DEFAULT FALSE,
                is_selected BOOLEAN DEFAULT FALSE,
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE,
                UNIQUE (template_id, column_name)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_rule_types (
                rule_type_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                rule_name VARCHAR(255) NOT NULL,
                description TEXT,
                parameters TEXT,
                is_active BOOLEAN DEFAULT TRUE,
                is_custom BOOLEAN DEFAULT FALSE,
                column_name VARCHAR(255),
                template_id BIGINT,
                data_type VARCHAR(50),
                source_format VARCHAR(50),
                target_format VARCHAR(50),
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS column_validation_rules (
                column_validation_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                column_id BIGINT NOT NULL,
                rule_type_id BIGINT NOT NULL,
                rule_config JSON,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (column_id) REFERENCES template_columns(column_id) ON DELETE CASCADE,
                FOREIGN KEY (rule_type_id) REFERENCES validation_rule_types(rule_type_id) ON DELETE RESTRICT,
                UNIQUE (column_id, rule_type_id)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_history (
                history_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_id BIGINT NOT NULL,
                template_name VARCHAR(255) NOT NULL,
                error_count INT NOT NULL,
                corrected_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                corrected_file_path VARCHAR(512) NOT NULL,
                user_id INT NOT NULL,
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE,
                FOREIGN KEY (user_id) REFERENCES login_details(id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_corrections (
                correction_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                history_id BIGINT NOT NULL,
                row_index INT NOT NULL,
                column_name VARCHAR(255) NOT NULL,
                original_value TEXT,
                corrected_value TEXT,
                rule_failed VARCHAR(255) DEFAULT NULL,
                FOREIGN KEY (history_id) REFERENCES validation_history(history_id) ON DELETE CASCADE
            )
            """
        ]
        for table_sql in tables:
            cursor.execute(table_sql)
        
        # Add missing columns if they don't exist
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'source_format'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN source_format VARCHAR(50)")
            logging.info("Added source_format column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'target_format'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN target_format VARCHAR(50)")
            logging.info("Added target_format column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'data_type'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN data_type VARCHAR(50)")
            logging.info("Added data_type column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM excel_templates LIKE 'remote_file_path'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE excel_templates ADD COLUMN remote_file_path VARCHAR(512)")
            logging.info("Added remote_file_path column to excel_templates table")
            
        cursor.execute("SHOW COLUMNS FROM template_columns LIKE 'is_selected'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE template_columns ADD COLUMN is_selected BOOLEAN DEFAULT FALSE")
            logging.info("Added is_selected column to template_columns table")
            
        conn.commit()
        cursor.close()
        logging.info("Database tables initialized")
    except Exception as e:
        logging.error(f"Failed to initialize database: {str(e)}")
        raise

def create_admin_user():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        admin_password = bcrypt.hashpw('admin'.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
        cursor.execute("""
            INSERT IGNORE INTO login_details (first_name, last_name, email, mobile, password)
            VALUES (%s, %s, %s, %s, %s)
        """, ('Admin', 'User', 'admin@example.com', '1234567890', admin_password))
        conn.commit()
        cursor.close()
        logging.info("Admin user created or already exists")
    except Exception as e:
        logging.error(f"Failed to create admin user: {str(e)}")
        raise

def create_default_validation_rules():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        default_rules = [
            ("Required", "Ensures the field is not null", '{"allow_null": false}', None, None, None),
            ("Int", "Validates integer format", '{"format": "integer"}', None, None, "Int"),
            ("Float", "Validates number format (integer or decimal)", '{"format": "float"}', None, None, "Float"),
            ("Text", "Allows text with quotes and parentheses", '{"allow_special": false}', None, None, "Text"),
            ("Email", "Validates email format", '{"regex": "^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\\\.[a-zA-Z0-9-.]+$"}', None, None, "Email"),
            ("Date(DD-MM-YYYY)", "Validates date format DD-MM-YYYY", '{"format": "%d-%m-%Y"}', "DD-MM-YYYY", None, "Date"),
            ("Boolean", "Validates boolean format (true/false or 0/1)", '{"format": "boolean"}', None, None, "Boolean"),
            ("Alphanumeric", "Validates alphanumeric format", '{"format": "alphanumeric"}', None, None, "Alphanumeric")
        ]
        cursor.executemany("""
            INSERT IGNORE INTO validation_rule_types (rule_name, description, parameters, is_custom, source_format, target_format, data_type)
            VALUES (%s, %s, %s, %s, %s, %s, %s)
        """, [(name, desc, params, False, source, target, dtype) for name, desc, params, source, target, dtype in default_rules])
        conn.commit()
        cursor.close()
        logging.info("Default validation rules ensured successfully")
    except Exception as e:
        logging.error(f"Failed to ensure default validation rules: {str(e)}")
        raise

if __name__ == '__main__':
    try:
        # Create the application using factory pattern
        app = create_app()
        
        # Initialize database and default data within app context
        with app.app_context():
            initialize_app_data()
        
        # Get port from environment or use default
        port = int(os.getenv('PORT', 5000))
        
        # Start the application server
        logging.info("Starting Flask server...")
        app.run(debug=True, host='0.0.0.0', port=port)
        
    except Exception as e:
        logging.error(f"Failed to start application: {e}")
        raise
).all():
        return "Int"
    
    if non_null.str.match(r'^-?\d+(\.\d+)?

def create_app():
    """Application factory pattern for different environments"""
    # Set the path to the frontend dist folder
    current_dir = os.path.dirname(os.path.abspath(__file__))
    frontend_dist_path = os.path.join(current_dir, '..', '..', 'Keansa-Ai-Suite2025may-frontend11', 'dist')
    frontend_dist_path = os.path.abspath(frontend_dist_path)
    
    # Create Flask application instance
    app = Flask(__name__, static_folder=frontend_dist_path, static_url_path='')
    CORS(app, supports_credentials=True, origins=["http://localhost:3000", "http://localhost:8080", "http://localhost:5000", "*"])

    app.secret_key = os.urandom(24).hex()
    app.config['SESSION_TYPE'] = 'filesystem'
    app.config['SESSION_FILE_DIR'] = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'sessions')
    app.config['SESSION_COOKIE_SAMESITE'] = 'Lax'
    app.config['SESSION_COOKIE_HTTPONLY'] = True
    app.config['SESSION_COOKIE_SECURE'] = False
    app.config['PERMANENT_SESSION_LIFETIME'] = 86400  # 24 hours
    app.config['UPLOAD_FOLDER'] = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'uploads')
    Session(app)

    # Ensure directories exist
    try:
        os.makedirs(app.config['UPLOAD_FOLDER'], exist_ok=True)
        os.makedirs(app.config['SESSION_FILE_DIR'], exist_ok=True)
    except OSError as e:
        logging.error(f"Failed to create directories: {e}")

    # Register cleanup handlers
    app.teardown_appcontext(close_db)
    
    # Register all routes directly in create_app
    
    # Static file serving for React frontend
    @app.route('/', defaults={'path': ''})
    @app.route('/<path:path>')
    def serve(path):
        if path and os.path.exists(os.path.join(app.static_folder, path)):
            return app.send_static_file(path)
        return app.send_static_file('index.html')

    # Health check endpoint
    @app.route('/health', methods=['GET'])
    def health_check():
        return jsonify({
            'status': 'healthy',
            'timestamp': datetime.now().isoformat(),
            'version': '2.0.0'
        })

    # Authentication endpoint - both old and new paths
    @app.route('/authenticate', methods=['POST'])
    @app.route('/api/auth/authenticate', methods=['POST'])
    def authenticate():
        try:
            email = request.form.get('username') or request.form.get('email')
            password = request.form.get('password')
            logging.debug(f"Login attempt: email={email}, password={'*' * len(password) if password else 'None'}")
            
            if not email or not password:
                logging.warning(f"Login failed: Email or password missing")
                return jsonify({'success': False, 'message': 'Email and password are required'}), 400

            # Check for admin login
            if email == "admin" and password == "admin":
                session['loggedin'] = True
                session['user_email'] = "admin@example.com"
                session['user_id'] = 1
                session.permanent = True
                logging.info(f"Admin login successful. Session: {dict(session)}")
                return jsonify({'success': True, 'message': 'Login successful', 'user': {'email': 'admin@example.com', 'id': 1}}), 200

            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("SELECT * FROM login_details WHERE LOWER(email) = LOWER(%s)", (email.lower(),))
            account = cursor.fetchone()
            cursor.close()
            
            if account:
                if bcrypt.checkpw(password.encode('utf-8'), account['password'].encode('utf-8')):
                    session['loggedin'] = True
                    session['user_email'] = account['email']
                    session['user_id'] = account['id']
                    session.permanent = True
                    logging.info(f"User {email} logged in successfully. Session: {dict(session)}")
                    return jsonify({
                        'success': True,
                        'message': 'Login successful',
                        'user': {'email': account['email'], 'id': account['id']}
                    }), 200
                else:
                    logging.warning(f"Invalid password for {email}")
                    return jsonify({'success': False, 'message': 'Invalid credentials'}), 401
            else:
                logging.warning(f"Email {email} not found")
                return jsonify({'success': False, 'message': 'Invalid credentials'}), 401
        except Exception as e:
            logging.error(f"Unexpected error during login: {str(e)}")
            return jsonify({'success': False, 'message': f'Unexpected error: {str(e)}'}), 500

    @app.route('/check-auth', methods=['GET'])
    @app.route('/api/auth/check-auth', methods=['GET'])
    def check_auth():
        try:
            logging.debug(f"Checking auth with session: {dict(session)}")
            if 'loggedin' in session and 'user_id' in session:
                conn = get_db_connection()
                cursor = conn.cursor(dictionary=True)
                cursor.execute("SELECT email, first_name FROM login_details WHERE id = %s", (session['user_id'],))
                user = cursor.fetchone()
                cursor.close()
                if user:
                    logging.info(f"User {session.get('user_email')} is authenticated")
                    return jsonify({
                        'success': True,
                        'user': {
                            'email': user['email'],
                            'id': session['user_id'],
                            'first_name': user['first_name']
                        }
                    })
                else:
                    logging.warning("User not found in database")  
                    session.clear()
                    return jsonify({'success': False, 'message': 'User not found'}), 401
            logging.warning("User not authenticated")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        except Exception as e:
            logging.error(f"Error in check-auth endpoint: {str(e)}")
            return jsonify({'success': False, 'message': f'Server error: {str(e)}'}), 500

    @app.route('/register', methods=['POST'])
    @app.route('/api/auth/register', methods=['POST'])
    def register():
        first_name = request.form.get('first_name')
        last_name = request.form.get('last_name')
        email = request.form.get('email')
        mobile = request.form.get('mobile')
        password = request.form.get('password')
        confirm_password = request.form.get('confirm_password')

        if not all([first_name, last_name, email, mobile, password, confirm_password]):
            return jsonify({'success': False, 'message': 'All fields are required'}), 400
        if password != confirm_password:
            return jsonify({'success': False, 'message': 'Passwords do not match'}), 400

        hashed_password = bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
        try:
            conn = get_db_connection()
            cursor = conn.cursor()
            cursor.execute("""
                INSERT INTO login_details (first_name, last_name, email, mobile, password)
                VALUES (%s, %s, %s, %s, %s)
            """, (first_name, last_name, email, mobile, hashed_password))
            user_id = cursor.lastrowid
            conn.commit()
            cursor.close()
            session['loggedin'] = True
            session['user_email'] = email
            session['user_id'] = user_id
            return jsonify({
                'success': True,
                'message': 'Registration successful',
                'user': {'email': email, 'id': user_id}
            }), 200
        except mysql.connector.Error as e:
            logging.error(f"Database error during registration: {str(e)}")
            return jsonify({'success': False, 'message': f'Registration error: {str(e)}'}), 500

    @app.route('/logout', methods=['POST'])
    @app.route('/api/auth/logout', methods=['POST'])
    def logout():
        logging.info(f"User {session.get('user_email', 'unknown')} logged out")
        session.clear()
        return jsonify({'success': True, 'message': 'Logged out successfully'})

    # Template routes
    @app.route('/templates', methods=['GET'])
    @app.route('/api/templates', methods=['GET'])
    def get_templates():
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /templates: session missing")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("""
                SELECT template_id, template_name, created_at, status
                FROM excel_templates
                WHERE user_id = %s AND status = 'ACTIVE'
                ORDER BY created_at DESC
                LIMIT 100
            """, (session['user_id'],))
            templates = cursor.fetchall()
            cursor.close()
            logging.info(f"Fetched {len(templates)} templates for user {session['user_id']}")
            return jsonify({'success': True, 'templates': templates})
        except mysql.connector.Error as e:
            logging.error(f'Error fetching templates: {str(e)}')
            return jsonify({'success': False, 'message': f'Error fetching templates: {str(e)}'}), 500
        except Exception as e:
            logging.error(f'Unexpected error fetching templates: {str(e)}')
            return jsonify({'success': False, 'message': f'Unexpected error: {str(e)}'}), 500

    # Rule Configuration routes
    @app.route('/rule-configurations', methods=['GET'])
    @app.route('/api/validation/rule-configurations', methods=['GET'])
    def get_rule_configurations():
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning(f"Unauthorized access to /rule-configurations: session={dict(session)}")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            user_id = session['user_id']
            logging.debug(f"Fetching rule configurations for user_id: {user_id}")

            # Main query to fetch templates with configured rules
            cursor.execute("""
                SELECT 
                    t.template_id, 
                    t.template_name, 
                    t.created_at, 
                    COUNT(cvr.column_validation_id) as rule_count
                FROM excel_templates t
                LEFT JOIN template_columns tc ON t.template_id = tc.template_id
                LEFT JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                WHERE t.user_id = %s AND t.status = 'ACTIVE' AND t.is_corrected = FALSE
                GROUP BY t.template_id, t.template_name, t.created_at
                HAVING rule_count > 0
                ORDER BY t.created_at DESC
                LIMIT 100
            """, (user_id,))
            templates = cursor.fetchall()
            logging.debug(f"Fetched rule-configured templates: {templates}")

            cursor.close()

            if not templates:
                logging.info(f"No templates with rules found for user_id: {user_id}")
            else:
                logging.info(f"Found {len(templates)} templates with rules for user_id: {user_id}")

            return jsonify({'success': True, 'templates': templates})
        except mysql.connector.Error as e:
            logging.error(f"Database error fetching rule configurations: {str(e)}")
            return jsonify({'success': False, 'message': f"Database error: {str(e)}"}), 500
        except Exception as e:
            logging.error(f"Unexpected error fetching rule configurations: {str(e)}")
            return jsonify({'success': False, 'message': f"Unexpected error: {str(e)}"}), 500

    # File upload route
    @app.route('/upload', methods=['POST'])
    @app.route('/api/templates/upload', methods=['POST'])
    @app.route('/api/upload', methods=['POST'])  # Additional common path
    def upload():
        logging.info(f"Upload endpoint called: {request.endpoint}, method: {request.method}")
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /upload: session missing")
            return jsonify({'error': 'Not logged in'}), 401
        if 'file' not in request.files:
            logging.warning("No file provided in upload request")
            return jsonify({'error': 'No file uploaded'}), 400
        file = request.files['file']
        if file.filename == '':
            logging.warning("No file selected in upload request")
            return jsonify({'error': 'No file selected'}), 400
        
        file_path = os.path.join(app.config['UPLOAD_FOLDER'], file.filename)
        try:
            file.save(file_path)
            logging.info(f"File saved: {file_path}")
        except Exception as e:
            logging.error(f"Failed to save file {file.filename}: {str(e)}")
            return jsonify({'error': f'Failed to save file: {str(e)}'}), 500

        try:
            # Read the file to get sheets and headers
            if file.filename.endswith('.xlsx') or file.filename.endswith('.xls'):
                xl = pd.ExcelFile(file_path)
                sheets = {sheet_name: pd.read_excel(file_path, sheet_name=sheet_name, header=None) 
                         for sheet_name in xl.sheet_names}
            elif file.filename.endswith(('.txt', '.csv', '.dat')):
                df = pd.read_csv(file_path, header=None, encoding='utf-8')
                sheets = {'Sheet1': df}
            else:
                logging.error("Unsupported file type")
                return jsonify({'error': 'Unsupported file type'}), 400
            
            logging.debug(f"Sheets extracted: {list(sheets.keys())}")
        except Exception as e:
            logging.error(f"Failed to read file {file_path}: {str(e)}")
            return jsonify({'error': f'Failed to read file: {str(e)}'}), 400

        try:
            sheet_names = list(sheets.keys())
            if not sheet_names:
                logging.error("No sheets found in the file")
                return jsonify({'error': 'No sheets found in the file'}), 400
            sheet_name = sheet_names[0]
            df = sheets[sheet_name]
            
            # Find header row
            header_row = 0
            for i in range(min(len(df), 10)):
                row = df.iloc[i].dropna()
                if not row.empty and all(isinstance(x, str) for x in row if pd.notna(x)):
                    header_row = i
                    break
                    
            headers = df.iloc[header_row].tolist()
            logging.debug(f"Headers extracted: {headers}")
            
            if not headers or all(not h for h in headers):
                logging.error("No valid headers found in file")
                return jsonify({'error': 'No valid headers found in the file'}), 400
        except Exception as e:
            logging.error(f"Error processing file {file.filename}: {str(e)}")
            return jsonify({'error': f'Error processing file: {str(e)}'}), 400

        # Clear existing session data
        for key in ['df', 'header_row', 'headers', 'sheet_name', 'current_step', 'selected_headers', 'validations', 'error_cell_locations', 'data_rows', 'corrected_file_path']:
            session.pop(key, None)

        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)

            # Check if template exists
            cursor.execute("""
                SELECT template_id, headers, sheet_name
                FROM excel_templates
                WHERE template_name = %s AND user_id = %s AND status = 'ACTIVE'
                ORDER BY created_at DESC
            """, (file.filename, session['user_id']))
            existing_templates = cursor.fetchall()
            logging.info(f"Found {len(existing_templates)} existing templates with name {file.filename}")

            template_id = None
            has_existing_rules = False
            validations = {}
            selected_headers = []

            # Check for matching template
            matching_template = None
            for template in existing_templates:
                stored_headers = json.loads(template['headers']) if template['headers'] else []
                stored_sheet_name = template['sheet_name']
                if stored_headers == headers and stored_sheet_name == sheet_name:
                    matching_template = template
                    break

            if matching_template:
                template_id = matching_template['template_id']
                # Check for existing rules
                cursor.execute("""
                    SELECT tc.column_name, vrt.rule_name
                    FROM template_columns tc
                    JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                    JOIN validation_rule_types vrt ON cvr.rule_type_id = vrt.rule_type_id
                    WHERE tc.template_id = %s AND tc.is_selected = TRUE
                """, (template_id,))
                rules_data = cursor.fetchall()
                for row in rules_data:
                    column_name = row['column_name']
                    rule_name = row['rule_name']
                    if column_name not in validations:
                        validations[column_name] = []
                    validations[column_name].append(rule_name)
                    if column_name not in selected_headers:
                        selected_headers.append(column_name)
                has_existing_rules = len(validations) > 0
            else:
                # New template
                cursor.execute("""
                    INSERT INTO excel_templates (template_name, user_id, sheet_name, headers, is_corrected)
                    VALUES (%s, %s, %s, %s, %s)
                """, (file.filename, session['user_id'], sheet_name, json.dumps(headers), False))
                template_id = cursor.lastrowid
                column_data = [(template_id, header, i + 1, False) for i, header in enumerate(headers)]
                cursor.executemany("""
                    INSERT INTO template_columns (template_id, column_name, column_position, is_selected)
                    VALUES (%s, %s, %s, %s)
                """, column_data)

            conn.commit()
            cursor.close()

            # Store session data
            session['file_path'] = file_path
            session['template_id'] = template_id
            session['df'] = df.to_json()
            session['header_row'] = header_row
            session['headers'] = headers
            session['sheet_name'] = sheet_name
            session['current_step'] = 1 if not has_existing_rules else 3
            session['validations'] = validations
            session['selected_headers'] = selected_headers
            session['has_existing_rules'] = has_existing_rules

            logging.info(f"Upload processed: template_id={template_id}, filename={file.filename}, has_existing_rules={has_existing_rules}")

            return jsonify({
                'success': True,
                'sheets': {sheet_name: {'headers': headers}},
                'file_name': file.filename,
                'template_id': template_id,
                'has_existing_rules': has_existing_rules,
                'sheet_name': sheet_name,
                'skip_to_step_3': has_existing_rules
            })
        except mysql.connector.Error as e:
            logging.error(f'Error saving template: {str(e)}')
            return jsonify({'error': f'Error saving template: {str(e)}'}), 500
        except Exception as e:
            logging.error(f'Unexpected error saving template: {str(e)}')
            return jsonify({'error': f'Unexpected error: {str(e)}'}), 500

    # Multi-step workflow endpoints
    @app.route('/step/1', methods=['GET', 'POST'])
    @app.route('/api/step/1', methods=['GET', 'POST'])
    def step_one():
        if 'loggedin' not in session:
            return jsonify({'error': 'Not logged in'}), 401
        
        if request.method == 'POST':
            try:
                headers = request.form.getlist('headers')
                new_header_row = request.form.get('new_header_row')
                logging.debug(f"Step 1 submitted: headers={headers}, new_header_row={new_header_row}")
                
                if not headers:
                    logging.error("No headers provided in step 1")
                    return jsonify({'success': False, 'message': 'No headers provided'}), 400
                    
                if 'template_id' not in session:
                    logging.error("Session missing template_id")
                    return jsonify({'success': False, 'message': 'Session data missing'}), 400

                template_id = session['template_id']
                
                # Get the dataframe from session for auto-detection
                df_json = session.get('df')
                if df_json:
                    df = pd.read_json(StringIO(df_json))
                    session_headers = session.get('headers', [])
                    df.columns = session_headers
                    header_row = session.get('header_row', 0)
                    df = df.iloc[header_row + 1:].reset_index(drop=True)
                    
                    # Auto-detect rules for selected headers
                    validations = assign_default_rules_to_columns(df, headers)
                    session['validations'] = validations
                    logging.debug(f"Auto-assigned rules: {validations}")
                else:
                    validations = {}

                session['selected_headers'] = headers
                session['current_step'] = 2

                # Mark selected headers in the database
                conn = get_db_connection()
                cursor = conn.cursor()
                cursor.execute("UPDATE template_columns SET is_selected = FALSE WHERE template_id = %s", (template_id,))
                for header in headers:
                    cursor.execute("""
                        UPDATE template_columns
                        SET is_selected = TRUE
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    
                    # Get column_id and add auto-detected rules
                    cursor.execute("""
                        SELECT column_id FROM template_columns
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    result = cursor.fetchone()
                    if result:
                        column_id = result[0]
                        for rule_name in validations.get(header, []):
                            cursor.execute("""
                                SELECT rule_type_id FROM validation_rule_types
                                WHERE rule_name = %s AND is_custom = FALSE
                            """, (rule_name,))
                            rule_result = cursor.fetchone()
                            if rule_result:
                                rule_type_id = rule_result[0]
                                cursor.execute("""
                                    INSERT IGNORE INTO column_validation_rules (column_id, rule_type_id, rule_config)
                                    VALUES (%s, %s, %s)
                                """, (column_id, rule_type_id, '{}'))
                
                conn.commit()
                cursor.close()

                logging.info(f"Step 1 completed: headers={headers}, auto-assigned rules={validations}")
                return jsonify({'success': True, 'headers': headers, 'validations': validations})
            except Exception as e:
                logging.error(f"Error in step 1: {str(e)}")
                return jsonify({'success': False, 'message': str(e)}), 500
        
        # GET request - return current headers
        headers = session.get('headers', [])
        return jsonify({'headers': headers})

    @app.route('/step/2', methods=['GET', 'POST'])
    @app.route('/api/step/2', methods=['GET', 'POST'])
    def step_two():
        if 'loggedin' not in session:
            return jsonify({'error': 'Not logged in'}), 401
            
        if request.method == 'POST':
            try:
                action = request.form.get('action', 'save')
                validations = {}
                for key, values in request.form.lists():
                    if key.startswith('validations_'):
                        header = key.replace('validations_', '')
                        validations[header] = values
                        
                logging.debug(f"Step 2 submitted: action={action}, validations={validations}")
                
                template_id = session.get('template_id')
                if not template_id:
                    return jsonify({'success': False, 'message': 'Session data missing'}), 400

                # Save validations to database
                conn = get_db_connection()
                cursor = conn.cursor()
                
                # Clear existing rules
                cursor.execute("""
                    DELETE FROM column_validation_rules
                    WHERE column_id IN (
                        SELECT column_id FROM template_columns WHERE template_id = %s
                    )
                """, (template_id,))
                
                # Add new rules
                for header, rules in validations.items():
                    cursor.execute("""
                        SELECT column_id FROM template_columns
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    result = cursor.fetchone()
                    if not result:
                        continue
                    column_id = result[0]
                    
                    for rule_name in rules:
                        cursor.execute("""
                            SELECT rule_type_id FROM validation_rule_types
                            WHERE rule_name = %s
                        """, (rule_name,))
                        result = cursor.fetchone()
                        if result:
                            rule_type_id = result[0]
                            cursor.execute("""
                                INSERT IGNORE INTO column_validation_rules (column_id, rule_type_id, rule_config)
                                VALUES (%s, %s, %s)
                            """, (column_id, rule_type_id, '{}'))
                
                conn.commit()
                cursor.close()

                session['validations'] = validations
                session['current_step'] = 3 if action == 'review' else 2
                
                logging.info(f"Step 2 completed: action={action}, validations={validations}")
                return jsonify({'success': True, 'message': 'Step 2 completed successfully'})
            except Exception as e:
                logging.error(f"Error in step 2: {str(e)}")
                return jsonify({'success': False, 'message': str(e)}), 500
        
        # GET request
        selected_headers = session.get('selected_headers', [])
        return jsonify({'selected_headers': selected_headers})

    # Rules endpoint
    @app.route('/rules', methods=['GET'])
    @app.route('/api/rules', methods=['GET'])
    def get_rules():
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            
            cursor.execute("""
                SELECT rule_type_id AS rule_id, rule_name, description, parameters, is_custom, 
                       column_name, template_id, source_format, target_format, data_type, is_active
                FROM validation_rule_types
            """)
            rules = cursor.fetchall()
            cursor.close()
            
            logging.info(f"Returning {len(rules)} rules from getRules endpoint")
            return jsonify({'success': True, 'rules': rules})
        except mysql.connector.Error as e:
            logging.error(f"Database error fetching rules: {str(e)}")
            return jsonify({'success': False, 'message': str(e)}), 500
        except Exception as e:
            logging.error(f"Unexpected error fetching rules: {str(e)}")
            return jsonify({'success': False, 'message': str(e)}), 500

    # Template details endpoint
    @app.route('/template/<int:template_id>/<sheet_name>', methods=['GET'])
    @app.route('/api/template/<int:template_id>/<sheet_name>', methods=['GET'])
    def get_template(template_id, sheet_name):
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /template: session missing")
            return jsonify({'error': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("""
                SELECT template_name, sheet_name, headers
                FROM excel_templates
                WHERE template_id = %s AND user_id = %s AND status = 'ACTIVE'
            """, (template_id, session['user_id']))
            template_record = cursor.fetchone()
            
            if not template_record:
                logging.error(f"Template not found for template_id: {template_id}, user_id: {session['user_id']}")
                cursor.close()
                return jsonify({'error': 'Template not found'}), 404

            headers = json.loads(template_record['headers']) if template_record['headers'] else []
            stored_sheet_name = template_record['sheet_name'] or sheet_name
            file_path = os.path.join(app.config['UPLOAD_FOLDER'], template_record['template_name'])
            
            cursor.execute("""
                SELECT COUNT(*) as rule_count
                FROM template_columns tc
                JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                WHERE tc.template_id = %s AND tc.is_selected = TRUE
            """, (template_id,))
            rule_count = cursor.fetchone()['rule_count']
            has_existing_rules = rule_count > 0
            
            cursor.close()
            
            return jsonify({
                'success': True,
                'sheets': {stored_sheet_name: {'headers': headers}},
                'file_name': template_record['template_name'],
                'file_path': file_path,
                'sheet_name': stored_sheet_name,
                'has_existing_rules': has_existing_rules
            })
        except mysql.connector.Error as e:
            logging.error(f"Database error in get_template: {str(e)}")
            return jsonify({'error': f'Database error: {str(e)}'}), 500
        except Exception as e:
            logging.error(f"Unexpected error in get_template: {str(e)}")
            return jsonify({'error': f'Unexpected error: {str(e)}'}), 500

    # Debug route to show all registered routes
    @app.route('/debug/routes', methods=['GET'])
    def list_routes():
        routes = []
        for rule in app.url_map.iter_rules():
            routes.append({
                'endpoint': rule.endpoint,
                'methods': list(rule.methods),
                'rule': rule.rule
            })
        return jsonify(routes)

    # 404 handler to debug missing routes
    @app.errorhandler(404)
    def not_found_handler(error):
        logging.error(f"404 Error: {request.method} {request.url} not found")
        logging.error(f"Available routes: {[rule.rule for rule in app.url_map.iter_rules()]}")
        return jsonify({
            'error': 'Endpoint not found', 
            'method': request.method,
            'url': request.url,
            'path': request.path
        }), 404

    return app

def initialize_app_data():
    """Initialize database and create default data"""
    try:
        logging.info("Initializing database schema...")
        init_db()
        
        logging.info("Creating admin user...")
        create_admin_user()
        
        logging.info("Creating default validation rules...")
        create_default_validation_rules()
        
        logging.info("Application initialization completed successfully")
    except Exception as e:
        logging.error(f"Failed to initialize application: {e}")
        raise

DB_CONFIG = {
    'host': os.getenv('MYSQL_HOST', 'localhost'),
    'user': os.getenv('MYSQL_USER', 'root'),
    'password': os.getenv('MYSQL_PASSWORD', 'Keansa@2024'),
    'database': os.getenv('MYSQL_DATABASE', 'data_validation_2'),
}

def get_db_connection():
    if 'db' not in g:
        try:
            conn = mysql.connector.connect(
                host=DB_CONFIG['host'],
                user=DB_CONFIG['user'],
                password=DB_CONFIG['password']
            )
            cursor = conn.cursor()
            cursor.execute(f"CREATE DATABASE IF NOT EXISTS {DB_CONFIG['database']}")
            cursor.close()
            conn.close()
            g.db = mysql.connector.connect(**DB_CONFIG)
            logging.info("Database connection established successfully")
        except mysql.connector.Error as err:
            if err.errno == errorcode.ER_ACCESS_DENIED_ERROR:
                logging.error("Database connection failed: Access denied for user - check username/password")
            elif err.errno == errorcode.ER_BAD_DB_ERROR:
                logging.error("Database connection failed: Database does not exist")
            else:
                logging.error(f"Database connection failed: {err}")
            raise Exception(f"Failed to connect to database: {str(err)}")
    return g.db

def close_db(error):
    db = g.pop('db', None)
    if db is not None:
        db.close()

def init_db():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        tables = [
            """
            CREATE TABLE IF NOT EXISTS login_details (
                id INT AUTO_INCREMENT PRIMARY KEY,
                first_name VARCHAR(100),
                last_name VARCHAR(100),
                email VARCHAR(255) UNIQUE,
                mobile VARCHAR(10),
                password VARCHAR(255)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS excel_templates (
                template_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_name VARCHAR(255) NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
                user_id INT NOT NULL,
                sheet_name VARCHAR(255),
                headers JSON,
                status ENUM('ACTIVE', 'INACTIVE') DEFAULT 'ACTIVE',
                is_corrected BOOLEAN DEFAULT FALSE,
                remote_file_path VARCHAR(512),
                FOREIGN KEY (user_id) REFERENCES login_details(id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS template_columns (
                column_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_id BIGINT NOT NULL,
                column_name VARCHAR(255) NOT NULL,
                column_position INT NOT NULL,
                is_validation_enabled BOOLEAN DEFAULT FALSE,
                is_selected BOOLEAN DEFAULT FALSE,
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE,
                UNIQUE (template_id, column_name)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_rule_types (
                rule_type_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                rule_name VARCHAR(255) NOT NULL,
                description TEXT,
                parameters TEXT,
                is_active BOOLEAN DEFAULT TRUE,
                is_custom BOOLEAN DEFAULT FALSE,
                column_name VARCHAR(255),
                template_id BIGINT,
                data_type VARCHAR(50),
                source_format VARCHAR(50),
                target_format VARCHAR(50),
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS column_validation_rules (
                column_validation_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                column_id BIGINT NOT NULL,
                rule_type_id BIGINT NOT NULL,
                rule_config JSON,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (column_id) REFERENCES template_columns(column_id) ON DELETE CASCADE,
                FOREIGN KEY (rule_type_id) REFERENCES validation_rule_types(rule_type_id) ON DELETE RESTRICT,
                UNIQUE (column_id, rule_type_id)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_history (
                history_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_id BIGINT NOT NULL,
                template_name VARCHAR(255) NOT NULL,
                error_count INT NOT NULL,
                corrected_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                corrected_file_path VARCHAR(512) NOT NULL,
                user_id INT NOT NULL,
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE,
                FOREIGN KEY (user_id) REFERENCES login_details(id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_corrections (
                correction_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                history_id BIGINT NOT NULL,
                row_index INT NOT NULL,
                column_name VARCHAR(255) NOT NULL,
                original_value TEXT,
                corrected_value TEXT,
                rule_failed VARCHAR(255) DEFAULT NULL,
                FOREIGN KEY (history_id) REFERENCES validation_history(history_id) ON DELETE CASCADE
            )
            """
        ]
        for table_sql in tables:
            cursor.execute(table_sql)
        
        # Add missing columns if they don't exist
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'source_format'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN source_format VARCHAR(50)")
            logging.info("Added source_format column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'target_format'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN target_format VARCHAR(50)")
            logging.info("Added target_format column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'data_type'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN data_type VARCHAR(50)")
            logging.info("Added data_type column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM excel_templates LIKE 'remote_file_path'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE excel_templates ADD COLUMN remote_file_path VARCHAR(512)")
            logging.info("Added remote_file_path column to excel_templates table")
            
        cursor.execute("SHOW COLUMNS FROM template_columns LIKE 'is_selected'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE template_columns ADD COLUMN is_selected BOOLEAN DEFAULT FALSE")
            logging.info("Added is_selected column to template_columns table")
            
        conn.commit()
        cursor.close()
        logging.info("Database tables initialized")
    except Exception as e:
        logging.error(f"Failed to initialize database: {str(e)}")
        raise

def create_admin_user():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        admin_password = bcrypt.hashpw('admin'.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
        cursor.execute("""
            INSERT IGNORE INTO login_details (first_name, last_name, email, mobile, password)
            VALUES (%s, %s, %s, %s, %s)
        """, ('Admin', 'User', 'admin@example.com', '1234567890', admin_password))
        conn.commit()
        cursor.close()
        logging.info("Admin user created or already exists")
    except Exception as e:
        logging.error(f"Failed to create admin user: {str(e)}")
        raise

def create_default_validation_rules():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        default_rules = [
            ("Required", "Ensures the field is not null", '{"allow_null": false}', None, None, None),
            ("Int", "Validates integer format", '{"format": "integer"}', None, None, "Int"),
            ("Float", "Validates number format (integer or decimal)", '{"format": "float"}', None, None, "Float"),
            ("Text", "Allows text with quotes and parentheses", '{"allow_special": false}', None, None, "Text"),
            ("Email", "Validates email format", '{"regex": "^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\\\.[a-zA-Z0-9-.]+$"}', None, None, "Email"),
            ("Date(DD-MM-YYYY)", "Validates date format DD-MM-YYYY", '{"format": "%d-%m-%Y"}', "DD-MM-YYYY", None, "Date"),
            ("Boolean", "Validates boolean format (true/false or 0/1)", '{"format": "boolean"}', None, None, "Boolean"),
            ("Alphanumeric", "Validates alphanumeric format", '{"format": "alphanumeric"}', None, None, "Alphanumeric")
        ]
        cursor.executemany("""
            INSERT IGNORE INTO validation_rule_types (rule_name, description, parameters, is_custom, source_format, target_format, data_type)
            VALUES (%s, %s, %s, %s, %s, %s, %s)
        """, [(name, desc, params, False, source, target, dtype) for name, desc, params, source, target, dtype in default_rules])
        conn.commit()
        cursor.close()
        logging.info("Default validation rules ensured successfully")
    except Exception as e:
        logging.error(f"Failed to ensure default validation rules: {str(e)}")
        raise

if __name__ == '__main__':
    try:
        # Create the application using factory pattern
        app = create_app()
        
        # Initialize database and default data within app context
        with app.app_context():
            initialize_app_data()
        
        # Get port from environment or use default
        port = int(os.getenv('PORT', 5000))
        
        # Start the application server
        logging.info("Starting Flask server...")
        app.run(debug=True, host='0.0.0.0', port=port)
        
    except Exception as e:
        logging.error(f"Failed to start application: {e}")
        raise
).all():
        return "Float"
    
    # Alphanumeric detection
    if non_null.str.match(r'^[a-zA-Z0-9]+

def create_app():
    """Application factory pattern for different environments"""
    # Set the path to the frontend dist folder
    current_dir = os.path.dirname(os.path.abspath(__file__))
    frontend_dist_path = os.path.join(current_dir, '..', '..', 'Keansa-Ai-Suite2025may-frontend11', 'dist')
    frontend_dist_path = os.path.abspath(frontend_dist_path)
    
    # Create Flask application instance
    app = Flask(__name__, static_folder=frontend_dist_path, static_url_path='')
    CORS(app, supports_credentials=True, origins=["http://localhost:3000", "http://localhost:8080", "http://localhost:5000", "*"])

    app.secret_key = os.urandom(24).hex()
    app.config['SESSION_TYPE'] = 'filesystem'
    app.config['SESSION_FILE_DIR'] = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'sessions')
    app.config['SESSION_COOKIE_SAMESITE'] = 'Lax'
    app.config['SESSION_COOKIE_HTTPONLY'] = True
    app.config['SESSION_COOKIE_SECURE'] = False
    app.config['PERMANENT_SESSION_LIFETIME'] = 86400  # 24 hours
    app.config['UPLOAD_FOLDER'] = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'uploads')
    Session(app)

    # Ensure directories exist
    try:
        os.makedirs(app.config['UPLOAD_FOLDER'], exist_ok=True)
        os.makedirs(app.config['SESSION_FILE_DIR'], exist_ok=True)
    except OSError as e:
        logging.error(f"Failed to create directories: {e}")

    # Register cleanup handlers
    app.teardown_appcontext(close_db)
    
    # Register all routes directly in create_app
    
    # Static file serving for React frontend
    @app.route('/', defaults={'path': ''})
    @app.route('/<path:path>')
    def serve(path):
        if path and os.path.exists(os.path.join(app.static_folder, path)):
            return app.send_static_file(path)
        return app.send_static_file('index.html')

    # Health check endpoint
    @app.route('/health', methods=['GET'])
    def health_check():
        return jsonify({
            'status': 'healthy',
            'timestamp': datetime.now().isoformat(),
            'version': '2.0.0'
        })

    # Authentication endpoint - both old and new paths
    @app.route('/authenticate', methods=['POST'])
    @app.route('/api/auth/authenticate', methods=['POST'])
    def authenticate():
        try:
            email = request.form.get('username') or request.form.get('email')
            password = request.form.get('password')
            logging.debug(f"Login attempt: email={email}, password={'*' * len(password) if password else 'None'}")
            
            if not email or not password:
                logging.warning(f"Login failed: Email or password missing")
                return jsonify({'success': False, 'message': 'Email and password are required'}), 400

            # Check for admin login
            if email == "admin" and password == "admin":
                session['loggedin'] = True
                session['user_email'] = "admin@example.com"
                session['user_id'] = 1
                session.permanent = True
                logging.info(f"Admin login successful. Session: {dict(session)}")
                return jsonify({'success': True, 'message': 'Login successful', 'user': {'email': 'admin@example.com', 'id': 1}}), 200

            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("SELECT * FROM login_details WHERE LOWER(email) = LOWER(%s)", (email.lower(),))
            account = cursor.fetchone()
            cursor.close()
            
            if account:
                if bcrypt.checkpw(password.encode('utf-8'), account['password'].encode('utf-8')):
                    session['loggedin'] = True
                    session['user_email'] = account['email']
                    session['user_id'] = account['id']
                    session.permanent = True
                    logging.info(f"User {email} logged in successfully. Session: {dict(session)}")
                    return jsonify({
                        'success': True,
                        'message': 'Login successful',
                        'user': {'email': account['email'], 'id': account['id']}
                    }), 200
                else:
                    logging.warning(f"Invalid password for {email}")
                    return jsonify({'success': False, 'message': 'Invalid credentials'}), 401
            else:
                logging.warning(f"Email {email} not found")
                return jsonify({'success': False, 'message': 'Invalid credentials'}), 401
        except Exception as e:
            logging.error(f"Unexpected error during login: {str(e)}")
            return jsonify({'success': False, 'message': f'Unexpected error: {str(e)}'}), 500

    @app.route('/check-auth', methods=['GET'])
    @app.route('/api/auth/check-auth', methods=['GET'])
    def check_auth():
        try:
            logging.debug(f"Checking auth with session: {dict(session)}")
            if 'loggedin' in session and 'user_id' in session:
                conn = get_db_connection()
                cursor = conn.cursor(dictionary=True)
                cursor.execute("SELECT email, first_name FROM login_details WHERE id = %s", (session['user_id'],))
                user = cursor.fetchone()
                cursor.close()
                if user:
                    logging.info(f"User {session.get('user_email')} is authenticated")
                    return jsonify({
                        'success': True,
                        'user': {
                            'email': user['email'],
                            'id': session['user_id'],
                            'first_name': user['first_name']
                        }
                    })
                else:
                    logging.warning("User not found in database")  
                    session.clear()
                    return jsonify({'success': False, 'message': 'User not found'}), 401
            logging.warning("User not authenticated")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        except Exception as e:
            logging.error(f"Error in check-auth endpoint: {str(e)}")
            return jsonify({'success': False, 'message': f'Server error: {str(e)}'}), 500

    @app.route('/register', methods=['POST'])
    @app.route('/api/auth/register', methods=['POST'])
    def register():
        first_name = request.form.get('first_name')
        last_name = request.form.get('last_name')
        email = request.form.get('email')
        mobile = request.form.get('mobile')
        password = request.form.get('password')
        confirm_password = request.form.get('confirm_password')

        if not all([first_name, last_name, email, mobile, password, confirm_password]):
            return jsonify({'success': False, 'message': 'All fields are required'}), 400
        if password != confirm_password:
            return jsonify({'success': False, 'message': 'Passwords do not match'}), 400

        hashed_password = bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
        try:
            conn = get_db_connection()
            cursor = conn.cursor()
            cursor.execute("""
                INSERT INTO login_details (first_name, last_name, email, mobile, password)
                VALUES (%s, %s, %s, %s, %s)
            """, (first_name, last_name, email, mobile, hashed_password))
            user_id = cursor.lastrowid
            conn.commit()
            cursor.close()
            session['loggedin'] = True
            session['user_email'] = email
            session['user_id'] = user_id
            return jsonify({
                'success': True,
                'message': 'Registration successful',
                'user': {'email': email, 'id': user_id}
            }), 200
        except mysql.connector.Error as e:
            logging.error(f"Database error during registration: {str(e)}")
            return jsonify({'success': False, 'message': f'Registration error: {str(e)}'}), 500

    @app.route('/logout', methods=['POST'])
    @app.route('/api/auth/logout', methods=['POST'])
    def logout():
        logging.info(f"User {session.get('user_email', 'unknown')} logged out")
        session.clear()
        return jsonify({'success': True, 'message': 'Logged out successfully'})

    # Template routes
    @app.route('/templates', methods=['GET'])
    @app.route('/api/templates', methods=['GET'])
    def get_templates():
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /templates: session missing")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("""
                SELECT template_id, template_name, created_at, status
                FROM excel_templates
                WHERE user_id = %s AND status = 'ACTIVE'
                ORDER BY created_at DESC
                LIMIT 100
            """, (session['user_id'],))
            templates = cursor.fetchall()
            cursor.close()
            logging.info(f"Fetched {len(templates)} templates for user {session['user_id']}")
            return jsonify({'success': True, 'templates': templates})
        except mysql.connector.Error as e:
            logging.error(f'Error fetching templates: {str(e)}')
            return jsonify({'success': False, 'message': f'Error fetching templates: {str(e)}'}), 500
        except Exception as e:
            logging.error(f'Unexpected error fetching templates: {str(e)}')
            return jsonify({'success': False, 'message': f'Unexpected error: {str(e)}'}), 500

    # Rule Configuration routes
    @app.route('/rule-configurations', methods=['GET'])
    @app.route('/api/validation/rule-configurations', methods=['GET'])
    def get_rule_configurations():
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning(f"Unauthorized access to /rule-configurations: session={dict(session)}")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            user_id = session['user_id']
            logging.debug(f"Fetching rule configurations for user_id: {user_id}")

            # Main query to fetch templates with configured rules
            cursor.execute("""
                SELECT 
                    t.template_id, 
                    t.template_name, 
                    t.created_at, 
                    COUNT(cvr.column_validation_id) as rule_count
                FROM excel_templates t
                LEFT JOIN template_columns tc ON t.template_id = tc.template_id
                LEFT JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                WHERE t.user_id = %s AND t.status = 'ACTIVE' AND t.is_corrected = FALSE
                GROUP BY t.template_id, t.template_name, t.created_at
                HAVING rule_count > 0
                ORDER BY t.created_at DESC
                LIMIT 100
            """, (user_id,))
            templates = cursor.fetchall()
            logging.debug(f"Fetched rule-configured templates: {templates}")

            cursor.close()

            if not templates:
                logging.info(f"No templates with rules found for user_id: {user_id}")
            else:
                logging.info(f"Found {len(templates)} templates with rules for user_id: {user_id}")

            return jsonify({'success': True, 'templates': templates})
        except mysql.connector.Error as e:
            logging.error(f"Database error fetching rule configurations: {str(e)}")
            return jsonify({'success': False, 'message': f"Database error: {str(e)}"}), 500
        except Exception as e:
            logging.error(f"Unexpected error fetching rule configurations: {str(e)}")
            return jsonify({'success': False, 'message': f"Unexpected error: {str(e)}"}), 500

    # File upload route
    @app.route('/upload', methods=['POST'])
    @app.route('/api/templates/upload', methods=['POST'])
    @app.route('/api/upload', methods=['POST'])  # Additional common path
    def upload():
        logging.info(f"Upload endpoint called: {request.endpoint}, method: {request.method}")
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /upload: session missing")
            return jsonify({'error': 'Not logged in'}), 401
        if 'file' not in request.files:
            logging.warning("No file provided in upload request")
            return jsonify({'error': 'No file uploaded'}), 400
        file = request.files['file']
        if file.filename == '':
            logging.warning("No file selected in upload request")
            return jsonify({'error': 'No file selected'}), 400
        
        file_path = os.path.join(app.config['UPLOAD_FOLDER'], file.filename)
        try:
            file.save(file_path)
            logging.info(f"File saved: {file_path}")
        except Exception as e:
            logging.error(f"Failed to save file {file.filename}: {str(e)}")
            return jsonify({'error': f'Failed to save file: {str(e)}'}), 500

        try:
            # Read the file to get sheets and headers
            if file.filename.endswith('.xlsx') or file.filename.endswith('.xls'):
                xl = pd.ExcelFile(file_path)
                sheets = {sheet_name: pd.read_excel(file_path, sheet_name=sheet_name, header=None) 
                         for sheet_name in xl.sheet_names}
            elif file.filename.endswith(('.txt', '.csv', '.dat')):
                df = pd.read_csv(file_path, header=None, encoding='utf-8')
                sheets = {'Sheet1': df}
            else:
                logging.error("Unsupported file type")
                return jsonify({'error': 'Unsupported file type'}), 400
            
            logging.debug(f"Sheets extracted: {list(sheets.keys())}")
        except Exception as e:
            logging.error(f"Failed to read file {file_path}: {str(e)}")
            return jsonify({'error': f'Failed to read file: {str(e)}'}), 400

        try:
            sheet_names = list(sheets.keys())
            if not sheet_names:
                logging.error("No sheets found in the file")
                return jsonify({'error': 'No sheets found in the file'}), 400
            sheet_name = sheet_names[0]
            df = sheets[sheet_name]
            
            # Find header row
            header_row = 0
            for i in range(min(len(df), 10)):
                row = df.iloc[i].dropna()
                if not row.empty and all(isinstance(x, str) for x in row if pd.notna(x)):
                    header_row = i
                    break
                    
            headers = df.iloc[header_row].tolist()
            logging.debug(f"Headers extracted: {headers}")
            
            if not headers or all(not h for h in headers):
                logging.error("No valid headers found in file")
                return jsonify({'error': 'No valid headers found in the file'}), 400
        except Exception as e:
            logging.error(f"Error processing file {file.filename}: {str(e)}")
            return jsonify({'error': f'Error processing file: {str(e)}'}), 400

        # Clear existing session data
        for key in ['df', 'header_row', 'headers', 'sheet_name', 'current_step', 'selected_headers', 'validations', 'error_cell_locations', 'data_rows', 'corrected_file_path']:
            session.pop(key, None)

        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)

            # Check if template exists
            cursor.execute("""
                SELECT template_id, headers, sheet_name
                FROM excel_templates
                WHERE template_name = %s AND user_id = %s AND status = 'ACTIVE'
                ORDER BY created_at DESC
            """, (file.filename, session['user_id']))
            existing_templates = cursor.fetchall()
            logging.info(f"Found {len(existing_templates)} existing templates with name {file.filename}")

            template_id = None
            has_existing_rules = False
            validations = {}
            selected_headers = []

            # Check for matching template
            matching_template = None
            for template in existing_templates:
                stored_headers = json.loads(template['headers']) if template['headers'] else []
                stored_sheet_name = template['sheet_name']
                if stored_headers == headers and stored_sheet_name == sheet_name:
                    matching_template = template
                    break

            if matching_template:
                template_id = matching_template['template_id']
                # Check for existing rules
                cursor.execute("""
                    SELECT tc.column_name, vrt.rule_name
                    FROM template_columns tc
                    JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                    JOIN validation_rule_types vrt ON cvr.rule_type_id = vrt.rule_type_id
                    WHERE tc.template_id = %s AND tc.is_selected = TRUE
                """, (template_id,))
                rules_data = cursor.fetchall()
                for row in rules_data:
                    column_name = row['column_name']
                    rule_name = row['rule_name']
                    if column_name not in validations:
                        validations[column_name] = []
                    validations[column_name].append(rule_name)
                    if column_name not in selected_headers:
                        selected_headers.append(column_name)
                has_existing_rules = len(validations) > 0
            else:
                # New template
                cursor.execute("""
                    INSERT INTO excel_templates (template_name, user_id, sheet_name, headers, is_corrected)
                    VALUES (%s, %s, %s, %s, %s)
                """, (file.filename, session['user_id'], sheet_name, json.dumps(headers), False))
                template_id = cursor.lastrowid
                column_data = [(template_id, header, i + 1, False) for i, header in enumerate(headers)]
                cursor.executemany("""
                    INSERT INTO template_columns (template_id, column_name, column_position, is_selected)
                    VALUES (%s, %s, %s, %s)
                """, column_data)

            conn.commit()
            cursor.close()

            # Store session data
            session['file_path'] = file_path
            session['template_id'] = template_id
            session['df'] = df.to_json()
            session['header_row'] = header_row
            session['headers'] = headers
            session['sheet_name'] = sheet_name
            session['current_step'] = 1 if not has_existing_rules else 3
            session['validations'] = validations
            session['selected_headers'] = selected_headers
            session['has_existing_rules'] = has_existing_rules

            logging.info(f"Upload processed: template_id={template_id}, filename={file.filename}, has_existing_rules={has_existing_rules}")

            return jsonify({
                'success': True,
                'sheets': {sheet_name: {'headers': headers}},
                'file_name': file.filename,
                'template_id': template_id,
                'has_existing_rules': has_existing_rules,
                'sheet_name': sheet_name,
                'skip_to_step_3': has_existing_rules
            })
        except mysql.connector.Error as e:
            logging.error(f'Error saving template: {str(e)}')
            return jsonify({'error': f'Error saving template: {str(e)}'}), 500
        except Exception as e:
            logging.error(f'Unexpected error saving template: {str(e)}')
            return jsonify({'error': f'Unexpected error: {str(e)}'}), 500

    # Multi-step workflow endpoints
    @app.route('/step/1', methods=['GET', 'POST'])
    @app.route('/api/step/1', methods=['GET', 'POST'])
    def step_one():
        if 'loggedin' not in session:
            return jsonify({'error': 'Not logged in'}), 401
        
        if request.method == 'POST':
            try:
                headers = request.form.getlist('headers')
                new_header_row = request.form.get('new_header_row')
                logging.debug(f"Step 1 submitted: headers={headers}, new_header_row={new_header_row}")
                
                if not headers:
                    logging.error("No headers provided in step 1")
                    return jsonify({'success': False, 'message': 'No headers provided'}), 400
                    
                if 'template_id' not in session:
                    logging.error("Session missing template_id")
                    return jsonify({'success': False, 'message': 'Session data missing'}), 400

                template_id = session['template_id']
                
                # Get the dataframe from session for auto-detection
                df_json = session.get('df')
                if df_json:
                    df = pd.read_json(StringIO(df_json))
                    session_headers = session.get('headers', [])
                    df.columns = session_headers
                    header_row = session.get('header_row', 0)
                    df = df.iloc[header_row + 1:].reset_index(drop=True)
                    
                    # Auto-detect rules for selected headers
                    validations = assign_default_rules_to_columns(df, headers)
                    session['validations'] = validations
                    logging.debug(f"Auto-assigned rules: {validations}")
                else:
                    validations = {}

                session['selected_headers'] = headers
                session['current_step'] = 2

                # Mark selected headers in the database
                conn = get_db_connection()
                cursor = conn.cursor()
                cursor.execute("UPDATE template_columns SET is_selected = FALSE WHERE template_id = %s", (template_id,))
                for header in headers:
                    cursor.execute("""
                        UPDATE template_columns
                        SET is_selected = TRUE
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    
                    # Get column_id and add auto-detected rules
                    cursor.execute("""
                        SELECT column_id FROM template_columns
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    result = cursor.fetchone()
                    if result:
                        column_id = result[0]
                        for rule_name in validations.get(header, []):
                            cursor.execute("""
                                SELECT rule_type_id FROM validation_rule_types
                                WHERE rule_name = %s AND is_custom = FALSE
                            """, (rule_name,))
                            rule_result = cursor.fetchone()
                            if rule_result:
                                rule_type_id = rule_result[0]
                                cursor.execute("""
                                    INSERT IGNORE INTO column_validation_rules (column_id, rule_type_id, rule_config)
                                    VALUES (%s, %s, %s)
                                """, (column_id, rule_type_id, '{}'))
                
                conn.commit()
                cursor.close()

                logging.info(f"Step 1 completed: headers={headers}, auto-assigned rules={validations}")
                return jsonify({'success': True, 'headers': headers, 'validations': validations})
            except Exception as e:
                logging.error(f"Error in step 1: {str(e)}")
                return jsonify({'success': False, 'message': str(e)}), 500
        
        # GET request - return current headers
        headers = session.get('headers', [])
        return jsonify({'headers': headers})

    @app.route('/step/2', methods=['GET', 'POST'])
    @app.route('/api/step/2', methods=['GET', 'POST'])
    def step_two():
        if 'loggedin' not in session:
            return jsonify({'error': 'Not logged in'}), 401
            
        if request.method == 'POST':
            try:
                action = request.form.get('action', 'save')
                validations = {}
                for key, values in request.form.lists():
                    if key.startswith('validations_'):
                        header = key.replace('validations_', '')
                        validations[header] = values
                        
                logging.debug(f"Step 2 submitted: action={action}, validations={validations}")
                
                template_id = session.get('template_id')
                if not template_id:
                    return jsonify({'success': False, 'message': 'Session data missing'}), 400

                # Save validations to database
                conn = get_db_connection()
                cursor = conn.cursor()
                
                # Clear existing rules
                cursor.execute("""
                    DELETE FROM column_validation_rules
                    WHERE column_id IN (
                        SELECT column_id FROM template_columns WHERE template_id = %s
                    )
                """, (template_id,))
                
                # Add new rules
                for header, rules in validations.items():
                    cursor.execute("""
                        SELECT column_id FROM template_columns
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    result = cursor.fetchone()
                    if not result:
                        continue
                    column_id = result[0]
                    
                    for rule_name in rules:
                        cursor.execute("""
                            SELECT rule_type_id FROM validation_rule_types
                            WHERE rule_name = %s
                        """, (rule_name,))
                        result = cursor.fetchone()
                        if result:
                            rule_type_id = result[0]
                            cursor.execute("""
                                INSERT IGNORE INTO column_validation_rules (column_id, rule_type_id, rule_config)
                                VALUES (%s, %s, %s)
                            """, (column_id, rule_type_id, '{}'))
                
                conn.commit()
                cursor.close()

                session['validations'] = validations
                session['current_step'] = 3 if action == 'review' else 2
                
                logging.info(f"Step 2 completed: action={action}, validations={validations}")
                return jsonify({'success': True, 'message': 'Step 2 completed successfully'})
            except Exception as e:
                logging.error(f"Error in step 2: {str(e)}")
                return jsonify({'success': False, 'message': str(e)}), 500
        
        # GET request
        selected_headers = session.get('selected_headers', [])
        return jsonify({'selected_headers': selected_headers})

    # Rules endpoint
    @app.route('/rules', methods=['GET'])
    @app.route('/api/rules', methods=['GET'])
    def get_rules():
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            
            cursor.execute("""
                SELECT rule_type_id AS rule_id, rule_name, description, parameters, is_custom, 
                       column_name, template_id, source_format, target_format, data_type, is_active
                FROM validation_rule_types
            """)
            rules = cursor.fetchall()
            cursor.close()
            
            logging.info(f"Returning {len(rules)} rules from getRules endpoint")
            return jsonify({'success': True, 'rules': rules})
        except mysql.connector.Error as e:
            logging.error(f"Database error fetching rules: {str(e)}")
            return jsonify({'success': False, 'message': str(e)}), 500
        except Exception as e:
            logging.error(f"Unexpected error fetching rules: {str(e)}")
            return jsonify({'success': False, 'message': str(e)}), 500

    # Template details endpoint
    @app.route('/template/<int:template_id>/<sheet_name>', methods=['GET'])
    @app.route('/api/template/<int:template_id>/<sheet_name>', methods=['GET'])
    def get_template(template_id, sheet_name):
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /template: session missing")
            return jsonify({'error': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("""
                SELECT template_name, sheet_name, headers
                FROM excel_templates
                WHERE template_id = %s AND user_id = %s AND status = 'ACTIVE'
            """, (template_id, session['user_id']))
            template_record = cursor.fetchone()
            
            if not template_record:
                logging.error(f"Template not found for template_id: {template_id}, user_id: {session['user_id']}")
                cursor.close()
                return jsonify({'error': 'Template not found'}), 404

            headers = json.loads(template_record['headers']) if template_record['headers'] else []
            stored_sheet_name = template_record['sheet_name'] or sheet_name
            file_path = os.path.join(app.config['UPLOAD_FOLDER'], template_record['template_name'])
            
            cursor.execute("""
                SELECT COUNT(*) as rule_count
                FROM template_columns tc
                JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                WHERE tc.template_id = %s AND tc.is_selected = TRUE
            """, (template_id,))
            rule_count = cursor.fetchone()['rule_count']
            has_existing_rules = rule_count > 0
            
            cursor.close()
            
            return jsonify({
                'success': True,
                'sheets': {stored_sheet_name: {'headers': headers}},
                'file_name': template_record['template_name'],
                'file_path': file_path,
                'sheet_name': stored_sheet_name,
                'has_existing_rules': has_existing_rules
            })
        except mysql.connector.Error as e:
            logging.error(f"Database error in get_template: {str(e)}")
            return jsonify({'error': f'Database error: {str(e)}'}), 500
        except Exception as e:
            logging.error(f"Unexpected error in get_template: {str(e)}")
            return jsonify({'error': f'Unexpected error: {str(e)}'}), 500

    # Debug route to show all registered routes
    @app.route('/debug/routes', methods=['GET'])
    def list_routes():
        routes = []
        for rule in app.url_map.iter_rules():
            routes.append({
                'endpoint': rule.endpoint,
                'methods': list(rule.methods),
                'rule': rule.rule
            })
        return jsonify(routes)

    # 404 handler to debug missing routes
    @app.errorhandler(404)
    def not_found_handler(error):
        logging.error(f"404 Error: {request.method} {request.url} not found")
        logging.error(f"Available routes: {[rule.rule for rule in app.url_map.iter_rules()]}")
        return jsonify({
            'error': 'Endpoint not found', 
            'method': request.method,
            'url': request.url,
            'path': request.path
        }), 404

    return app

def initialize_app_data():
    """Initialize database and create default data"""
    try:
        logging.info("Initializing database schema...")
        init_db()
        
        logging.info("Creating admin user...")
        create_admin_user()
        
        logging.info("Creating default validation rules...")
        create_default_validation_rules()
        
        logging.info("Application initialization completed successfully")
    except Exception as e:
        logging.error(f"Failed to initialize application: {e}")
        raise

DB_CONFIG = {
    'host': os.getenv('MYSQL_HOST', 'localhost'),
    'user': os.getenv('MYSQL_USER', 'root'),
    'password': os.getenv('MYSQL_PASSWORD', 'Keansa@2024'),
    'database': os.getenv('MYSQL_DATABASE', 'data_validation_2'),
}

def get_db_connection():
    if 'db' not in g:
        try:
            conn = mysql.connector.connect(
                host=DB_CONFIG['host'],
                user=DB_CONFIG['user'],
                password=DB_CONFIG['password']
            )
            cursor = conn.cursor()
            cursor.execute(f"CREATE DATABASE IF NOT EXISTS {DB_CONFIG['database']}")
            cursor.close()
            conn.close()
            g.db = mysql.connector.connect(**DB_CONFIG)
            logging.info("Database connection established successfully")
        except mysql.connector.Error as err:
            if err.errno == errorcode.ER_ACCESS_DENIED_ERROR:
                logging.error("Database connection failed: Access denied for user - check username/password")
            elif err.errno == errorcode.ER_BAD_DB_ERROR:
                logging.error("Database connection failed: Database does not exist")
            else:
                logging.error(f"Database connection failed: {err}")
            raise Exception(f"Failed to connect to database: {str(err)}")
    return g.db

def close_db(error):
    db = g.pop('db', None)
    if db is not None:
        db.close()

def init_db():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        tables = [
            """
            CREATE TABLE IF NOT EXISTS login_details (
                id INT AUTO_INCREMENT PRIMARY KEY,
                first_name VARCHAR(100),
                last_name VARCHAR(100),
                email VARCHAR(255) UNIQUE,
                mobile VARCHAR(10),
                password VARCHAR(255)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS excel_templates (
                template_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_name VARCHAR(255) NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
                user_id INT NOT NULL,
                sheet_name VARCHAR(255),
                headers JSON,
                status ENUM('ACTIVE', 'INACTIVE') DEFAULT 'ACTIVE',
                is_corrected BOOLEAN DEFAULT FALSE,
                remote_file_path VARCHAR(512),
                FOREIGN KEY (user_id) REFERENCES login_details(id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS template_columns (
                column_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_id BIGINT NOT NULL,
                column_name VARCHAR(255) NOT NULL,
                column_position INT NOT NULL,
                is_validation_enabled BOOLEAN DEFAULT FALSE,
                is_selected BOOLEAN DEFAULT FALSE,
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE,
                UNIQUE (template_id, column_name)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_rule_types (
                rule_type_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                rule_name VARCHAR(255) NOT NULL,
                description TEXT,
                parameters TEXT,
                is_active BOOLEAN DEFAULT TRUE,
                is_custom BOOLEAN DEFAULT FALSE,
                column_name VARCHAR(255),
                template_id BIGINT,
                data_type VARCHAR(50),
                source_format VARCHAR(50),
                target_format VARCHAR(50),
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS column_validation_rules (
                column_validation_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                column_id BIGINT NOT NULL,
                rule_type_id BIGINT NOT NULL,
                rule_config JSON,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (column_id) REFERENCES template_columns(column_id) ON DELETE CASCADE,
                FOREIGN KEY (rule_type_id) REFERENCES validation_rule_types(rule_type_id) ON DELETE RESTRICT,
                UNIQUE (column_id, rule_type_id)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_history (
                history_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_id BIGINT NOT NULL,
                template_name VARCHAR(255) NOT NULL,
                error_count INT NOT NULL,
                corrected_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                corrected_file_path VARCHAR(512) NOT NULL,
                user_id INT NOT NULL,
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE,
                FOREIGN KEY (user_id) REFERENCES login_details(id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_corrections (
                correction_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                history_id BIGINT NOT NULL,
                row_index INT NOT NULL,
                column_name VARCHAR(255) NOT NULL,
                original_value TEXT,
                corrected_value TEXT,
                rule_failed VARCHAR(255) DEFAULT NULL,
                FOREIGN KEY (history_id) REFERENCES validation_history(history_id) ON DELETE CASCADE
            )
            """
        ]
        for table_sql in tables:
            cursor.execute(table_sql)
        
        # Add missing columns if they don't exist
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'source_format'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN source_format VARCHAR(50)")
            logging.info("Added source_format column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'target_format'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN target_format VARCHAR(50)")
            logging.info("Added target_format column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'data_type'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN data_type VARCHAR(50)")
            logging.info("Added data_type column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM excel_templates LIKE 'remote_file_path'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE excel_templates ADD COLUMN remote_file_path VARCHAR(512)")
            logging.info("Added remote_file_path column to excel_templates table")
            
        cursor.execute("SHOW COLUMNS FROM template_columns LIKE 'is_selected'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE template_columns ADD COLUMN is_selected BOOLEAN DEFAULT FALSE")
            logging.info("Added is_selected column to template_columns table")
            
        conn.commit()
        cursor.close()
        logging.info("Database tables initialized")
    except Exception as e:
        logging.error(f"Failed to initialize database: {str(e)}")
        raise

def create_admin_user():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        admin_password = bcrypt.hashpw('admin'.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
        cursor.execute("""
            INSERT IGNORE INTO login_details (first_name, last_name, email, mobile, password)
            VALUES (%s, %s, %s, %s, %s)
        """, ('Admin', 'User', 'admin@example.com', '1234567890', admin_password))
        conn.commit()
        cursor.close()
        logging.info("Admin user created or already exists")
    except Exception as e:
        logging.error(f"Failed to create admin user: {str(e)}")
        raise

def create_default_validation_rules():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        default_rules = [
            ("Required", "Ensures the field is not null", '{"allow_null": false}', None, None, None),
            ("Int", "Validates integer format", '{"format": "integer"}', None, None, "Int"),
            ("Float", "Validates number format (integer or decimal)", '{"format": "float"}', None, None, "Float"),
            ("Text", "Allows text with quotes and parentheses", '{"allow_special": false}', None, None, "Text"),
            ("Email", "Validates email format", '{"regex": "^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\\\.[a-zA-Z0-9-.]+$"}', None, None, "Email"),
            ("Date(DD-MM-YYYY)", "Validates date format DD-MM-YYYY", '{"format": "%d-%m-%Y"}', "DD-MM-YYYY", None, "Date"),
            ("Boolean", "Validates boolean format (true/false or 0/1)", '{"format": "boolean"}', None, None, "Boolean"),
            ("Alphanumeric", "Validates alphanumeric format", '{"format": "alphanumeric"}', None, None, "Alphanumeric")
        ]
        cursor.executemany("""
            INSERT IGNORE INTO validation_rule_types (rule_name, description, parameters, is_custom, source_format, target_format, data_type)
            VALUES (%s, %s, %s, %s, %s, %s, %s)
        """, [(name, desc, params, False, source, target, dtype) for name, desc, params, source, target, dtype in default_rules])
        conn.commit()
        cursor.close()
        logging.info("Default validation rules ensured successfully")
    except Exception as e:
        logging.error(f"Failed to ensure default validation rules: {str(e)}")
        raise

if __name__ == '__main__':
    try:
        # Create the application using factory pattern
        app = create_app()
        
        # Initialize database and default data within app context
        with app.app_context():
            initialize_app_data()
        
        # Get port from environment or use default
        port = int(os.getenv('PORT', 5000))
        
        # Start the application server
        logging.info("Starting Flask server...")
        app.run(debug=True, host='0.0.0.0', port=port)
        
    except Exception as e:
        logging.error(f"Failed to start application: {e}")
        raise
).all():
        return "Alphanumeric"
    
    return "Text"

def assign_default_rules_to_columns(df, headers):
    """Intelligently assign validation rules based on column content"""
    assignments = {}
    
    for col in headers:
        if col not in df.columns:
            logging.warning(f"Column {col} not found in dataframe")
            continue
            
        col_type = detect_column_type(df[col])
        rules = ["Required"]  # Default rule for all columns
        
        # Special handling for optional columns
        if not any(col.lower().startswith(prefix) for prefix in
                  ["name", "address", "phone", "username", "status", "period"]):
            rules.append(col_type)
        else:
            rules.append("Text")  # Optional text fields
        
        assignments[col] = rules
    
    return assignments

def create_app():
    """Application factory pattern for different environments"""
    # Set the path to the frontend dist folder
    current_dir = os.path.dirname(os.path.abspath(__file__))
    frontend_dist_path = os.path.join(current_dir, '..', '..', 'Keansa-Ai-Suite2025may-frontend11', 'dist')
    frontend_dist_path = os.path.abspath(frontend_dist_path)
    
    # Create Flask application instance
    app = Flask(__name__, static_folder=frontend_dist_path, static_url_path='')
    CORS(app, supports_credentials=True, origins=["http://localhost:3000", "http://localhost:8080", "http://localhost:5000", "*"])

    app.secret_key = os.urandom(24).hex()
    app.config['SESSION_TYPE'] = 'filesystem'
    app.config['SESSION_FILE_DIR'] = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'sessions')
    app.config['SESSION_COOKIE_SAMESITE'] = 'Lax'
    app.config['SESSION_COOKIE_HTTPONLY'] = True
    app.config['SESSION_COOKIE_SECURE'] = False
    app.config['PERMANENT_SESSION_LIFETIME'] = 86400  # 24 hours
    app.config['UPLOAD_FOLDER'] = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'uploads')
    Session(app)

    # Ensure directories exist
    try:
        os.makedirs(app.config['UPLOAD_FOLDER'], exist_ok=True)
        os.makedirs(app.config['SESSION_FILE_DIR'], exist_ok=True)
    except OSError as e:
        logging.error(f"Failed to create directories: {e}")

    # Register cleanup handlers
    app.teardown_appcontext(close_db)
    
    # Register all routes directly in create_app
    
    # Static file serving for React frontend
    @app.route('/', defaults={'path': ''})
    @app.route('/<path:path>')
    def serve(path):
        if path and os.path.exists(os.path.join(app.static_folder, path)):
            return app.send_static_file(path)
        return app.send_static_file('index.html')

    # Health check endpoint
    @app.route('/health', methods=['GET'])
    def health_check():
        return jsonify({
            'status': 'healthy',
            'timestamp': datetime.now().isoformat(),
            'version': '2.0.0'
        })

    # Authentication endpoint - both old and new paths
    @app.route('/authenticate', methods=['POST'])
    @app.route('/api/auth/authenticate', methods=['POST'])
    def authenticate():
        try:
            email = request.form.get('username') or request.form.get('email')
            password = request.form.get('password')
            logging.debug(f"Login attempt: email={email}, password={'*' * len(password) if password else 'None'}")
            
            if not email or not password:
                logging.warning(f"Login failed: Email or password missing")
                return jsonify({'success': False, 'message': 'Email and password are required'}), 400

            # Check for admin login
            if email == "admin" and password == "admin":
                session['loggedin'] = True
                session['user_email'] = "admin@example.com"
                session['user_id'] = 1
                session.permanent = True
                logging.info(f"Admin login successful. Session: {dict(session)}")
                return jsonify({'success': True, 'message': 'Login successful', 'user': {'email': 'admin@example.com', 'id': 1}}), 200

            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("SELECT * FROM login_details WHERE LOWER(email) = LOWER(%s)", (email.lower(),))
            account = cursor.fetchone()
            cursor.close()
            
            if account:
                if bcrypt.checkpw(password.encode('utf-8'), account['password'].encode('utf-8')):
                    session['loggedin'] = True
                    session['user_email'] = account['email']
                    session['user_id'] = account['id']
                    session.permanent = True
                    logging.info(f"User {email} logged in successfully. Session: {dict(session)}")
                    return jsonify({
                        'success': True,
                        'message': 'Login successful',
                        'user': {'email': account['email'], 'id': account['id']}
                    }), 200
                else:
                    logging.warning(f"Invalid password for {email}")
                    return jsonify({'success': False, 'message': 'Invalid credentials'}), 401
            else:
                logging.warning(f"Email {email} not found")
                return jsonify({'success': False, 'message': 'Invalid credentials'}), 401
        except Exception as e:
            logging.error(f"Unexpected error during login: {str(e)}")
            return jsonify({'success': False, 'message': f'Unexpected error: {str(e)}'}), 500

    @app.route('/check-auth', methods=['GET'])
    @app.route('/api/auth/check-auth', methods=['GET'])
    def check_auth():
        try:
            logging.debug(f"Checking auth with session: {dict(session)}")
            if 'loggedin' in session and 'user_id' in session:
                conn = get_db_connection()
                cursor = conn.cursor(dictionary=True)
                cursor.execute("SELECT email, first_name FROM login_details WHERE id = %s", (session['user_id'],))
                user = cursor.fetchone()
                cursor.close()
                if user:
                    logging.info(f"User {session.get('user_email')} is authenticated")
                    return jsonify({
                        'success': True,
                        'user': {
                            'email': user['email'],
                            'id': session['user_id'],
                            'first_name': user['first_name']
                        }
                    })
                else:
                    logging.warning("User not found in database")  
                    session.clear()
                    return jsonify({'success': False, 'message': 'User not found'}), 401
            logging.warning("User not authenticated")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        except Exception as e:
            logging.error(f"Error in check-auth endpoint: {str(e)}")
            return jsonify({'success': False, 'message': f'Server error: {str(e)}'}), 500

    @app.route('/register', methods=['POST'])
    @app.route('/api/auth/register', methods=['POST'])
    def register():
        first_name = request.form.get('first_name')
        last_name = request.form.get('last_name')
        email = request.form.get('email')
        mobile = request.form.get('mobile')
        password = request.form.get('password')
        confirm_password = request.form.get('confirm_password')

        if not all([first_name, last_name, email, mobile, password, confirm_password]):
            return jsonify({'success': False, 'message': 'All fields are required'}), 400
        if password != confirm_password:
            return jsonify({'success': False, 'message': 'Passwords do not match'}), 400

        hashed_password = bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
        try:
            conn = get_db_connection()
            cursor = conn.cursor()
            cursor.execute("""
                INSERT INTO login_details (first_name, last_name, email, mobile, password)
                VALUES (%s, %s, %s, %s, %s)
            """, (first_name, last_name, email, mobile, hashed_password))
            user_id = cursor.lastrowid
            conn.commit()
            cursor.close()
            session['loggedin'] = True
            session['user_email'] = email
            session['user_id'] = user_id
            return jsonify({
                'success': True,
                'message': 'Registration successful',
                'user': {'email': email, 'id': user_id}
            }), 200
        except mysql.connector.Error as e:
            logging.error(f"Database error during registration: {str(e)}")
            return jsonify({'success': False, 'message': f'Registration error: {str(e)}'}), 500

    @app.route('/logout', methods=['POST'])
    @app.route('/api/auth/logout', methods=['POST'])
    def logout():
        logging.info(f"User {session.get('user_email', 'unknown')} logged out")
        session.clear()
        return jsonify({'success': True, 'message': 'Logged out successfully'})

    # Template routes
    @app.route('/templates', methods=['GET'])
    @app.route('/api/templates', methods=['GET'])
    def get_templates():
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /templates: session missing")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("""
                SELECT template_id, template_name, created_at, status
                FROM excel_templates
                WHERE user_id = %s AND status = 'ACTIVE'
                ORDER BY created_at DESC
                LIMIT 100
            """, (session['user_id'],))
            templates = cursor.fetchall()
            cursor.close()
            logging.info(f"Fetched {len(templates)} templates for user {session['user_id']}")
            return jsonify({'success': True, 'templates': templates})
        except mysql.connector.Error as e:
            logging.error(f'Error fetching templates: {str(e)}')
            return jsonify({'success': False, 'message': f'Error fetching templates: {str(e)}'}), 500
        except Exception as e:
            logging.error(f'Unexpected error fetching templates: {str(e)}')
            return jsonify({'success': False, 'message': f'Unexpected error: {str(e)}'}), 500

    # Rule Configuration routes
    @app.route('/rule-configurations', methods=['GET'])
    @app.route('/api/validation/rule-configurations', methods=['GET'])
    def get_rule_configurations():
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning(f"Unauthorized access to /rule-configurations: session={dict(session)}")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            user_id = session['user_id']
            logging.debug(f"Fetching rule configurations for user_id: {user_id}")

            # Main query to fetch templates with configured rules
            cursor.execute("""
                SELECT 
                    t.template_id, 
                    t.template_name, 
                    t.created_at, 
                    COUNT(cvr.column_validation_id) as rule_count
                FROM excel_templates t
                LEFT JOIN template_columns tc ON t.template_id = tc.template_id
                LEFT JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                WHERE t.user_id = %s AND t.status = 'ACTIVE' AND t.is_corrected = FALSE
                GROUP BY t.template_id, t.template_name, t.created_at
                HAVING rule_count > 0
                ORDER BY t.created_at DESC
                LIMIT 100
            """, (user_id,))
            templates = cursor.fetchall()
            logging.debug(f"Fetched rule-configured templates: {templates}")

            cursor.close()

            if not templates:
                logging.info(f"No templates with rules found for user_id: {user_id}")
            else:
                logging.info(f"Found {len(templates)} templates with rules for user_id: {user_id}")

            return jsonify({'success': True, 'templates': templates})
        except mysql.connector.Error as e:
            logging.error(f"Database error fetching rule configurations: {str(e)}")
            return jsonify({'success': False, 'message': f"Database error: {str(e)}"}), 500
        except Exception as e:
            logging.error(f"Unexpected error fetching rule configurations: {str(e)}")
            return jsonify({'success': False, 'message': f"Unexpected error: {str(e)}"}), 500

    # File upload route
    @app.route('/upload', methods=['POST'])
    @app.route('/api/templates/upload', methods=['POST'])
    @app.route('/api/upload', methods=['POST'])  # Additional common path
    def upload():
        logging.info(f"Upload endpoint called: {request.endpoint}, method: {request.method}")
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /upload: session missing")
            return jsonify({'error': 'Not logged in'}), 401
        if 'file' not in request.files:
            logging.warning("No file provided in upload request")
            return jsonify({'error': 'No file uploaded'}), 400
        file = request.files['file']
        if file.filename == '':
            logging.warning("No file selected in upload request")
            return jsonify({'error': 'No file selected'}), 400
        
        file_path = os.path.join(app.config['UPLOAD_FOLDER'], file.filename)
        try:
            file.save(file_path)
            logging.info(f"File saved: {file_path}")
        except Exception as e:
            logging.error(f"Failed to save file {file.filename}: {str(e)}")
            return jsonify({'error': f'Failed to save file: {str(e)}'}), 500

        try:
            # Read the file to get sheets and headers
            if file.filename.endswith('.xlsx') or file.filename.endswith('.xls'):
                xl = pd.ExcelFile(file_path)
                sheets = {sheet_name: pd.read_excel(file_path, sheet_name=sheet_name, header=None) 
                         for sheet_name in xl.sheet_names}
            elif file.filename.endswith(('.txt', '.csv', '.dat')):
                df = pd.read_csv(file_path, header=None, encoding='utf-8')
                sheets = {'Sheet1': df}
            else:
                logging.error("Unsupported file type")
                return jsonify({'error': 'Unsupported file type'}), 400
            
            logging.debug(f"Sheets extracted: {list(sheets.keys())}")
        except Exception as e:
            logging.error(f"Failed to read file {file_path}: {str(e)}")
            return jsonify({'error': f'Failed to read file: {str(e)}'}), 400

        try:
            sheet_names = list(sheets.keys())
            if not sheet_names:
                logging.error("No sheets found in the file")
                return jsonify({'error': 'No sheets found in the file'}), 400
            sheet_name = sheet_names[0]
            df = sheets[sheet_name]
            
            # Find header row
            header_row = 0
            for i in range(min(len(df), 10)):
                row = df.iloc[i].dropna()
                if not row.empty and all(isinstance(x, str) for x in row if pd.notna(x)):
                    header_row = i
                    break
                    
            headers = df.iloc[header_row].tolist()
            logging.debug(f"Headers extracted: {headers}")
            
            if not headers or all(not h for h in headers):
                logging.error("No valid headers found in file")
                return jsonify({'error': 'No valid headers found in the file'}), 400
        except Exception as e:
            logging.error(f"Error processing file {file.filename}: {str(e)}")
            return jsonify({'error': f'Error processing file: {str(e)}'}), 400

        # Clear existing session data
        for key in ['df', 'header_row', 'headers', 'sheet_name', 'current_step', 'selected_headers', 'validations', 'error_cell_locations', 'data_rows', 'corrected_file_path']:
            session.pop(key, None)

        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)

            # Check if template exists
            cursor.execute("""
                SELECT template_id, headers, sheet_name
                FROM excel_templates
                WHERE template_name = %s AND user_id = %s AND status = 'ACTIVE'
                ORDER BY created_at DESC
            """, (file.filename, session['user_id']))
            existing_templates = cursor.fetchall()
            logging.info(f"Found {len(existing_templates)} existing templates with name {file.filename}")

            template_id = None
            has_existing_rules = False
            validations = {}
            selected_headers = []

            # Check for matching template
            matching_template = None
            for template in existing_templates:
                stored_headers = json.loads(template['headers']) if template['headers'] else []
                stored_sheet_name = template['sheet_name']
                if stored_headers == headers and stored_sheet_name == sheet_name:
                    matching_template = template
                    break

            if matching_template:
                template_id = matching_template['template_id']
                # Check for existing rules
                cursor.execute("""
                    SELECT tc.column_name, vrt.rule_name
                    FROM template_columns tc
                    JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                    JOIN validation_rule_types vrt ON cvr.rule_type_id = vrt.rule_type_id
                    WHERE tc.template_id = %s AND tc.is_selected = TRUE
                """, (template_id,))
                rules_data = cursor.fetchall()
                for row in rules_data:
                    column_name = row['column_name']
                    rule_name = row['rule_name']
                    if column_name not in validations:
                        validations[column_name] = []
                    validations[column_name].append(rule_name)
                    if column_name not in selected_headers:
                        selected_headers.append(column_name)
                has_existing_rules = len(validations) > 0
            else:
                # New template
                cursor.execute("""
                    INSERT INTO excel_templates (template_name, user_id, sheet_name, headers, is_corrected)
                    VALUES (%s, %s, %s, %s, %s)
                """, (file.filename, session['user_id'], sheet_name, json.dumps(headers), False))
                template_id = cursor.lastrowid
                column_data = [(template_id, header, i + 1, False) for i, header in enumerate(headers)]
                cursor.executemany("""
                    INSERT INTO template_columns (template_id, column_name, column_position, is_selected)
                    VALUES (%s, %s, %s, %s)
                """, column_data)

            conn.commit()
            cursor.close()

            # Store session data
            session['file_path'] = file_path
            session['template_id'] = template_id
            session['df'] = df.to_json()
            session['header_row'] = header_row
            session['headers'] = headers
            session['sheet_name'] = sheet_name
            session['current_step'] = 1 if not has_existing_rules else 3
            session['validations'] = validations
            session['selected_headers'] = selected_headers
            session['has_existing_rules'] = has_existing_rules

            logging.info(f"Upload processed: template_id={template_id}, filename={file.filename}, has_existing_rules={has_existing_rules}")

            return jsonify({
                'success': True,
                'sheets': {sheet_name: {'headers': headers}},
                'file_name': file.filename,
                'template_id': template_id,
                'has_existing_rules': has_existing_rules,
                'sheet_name': sheet_name,
                'skip_to_step_3': has_existing_rules
            })
        except mysql.connector.Error as e:
            logging.error(f'Error saving template: {str(e)}')
            return jsonify({'error': f'Error saving template: {str(e)}'}), 500
        except Exception as e:
            logging.error(f'Unexpected error saving template: {str(e)}')
            return jsonify({'error': f'Unexpected error: {str(e)}'}), 500

    # Multi-step workflow endpoints
    @app.route('/step/1', methods=['GET', 'POST'])
    @app.route('/api/step/1', methods=['GET', 'POST'])
    def step_one():
        if 'loggedin' not in session:
            return jsonify({'error': 'Not logged in'}), 401
        
        if request.method == 'POST':
            try:
                headers = request.form.getlist('headers')
                new_header_row = request.form.get('new_header_row')
                logging.debug(f"Step 1 submitted: headers={headers}, new_header_row={new_header_row}")
                
                if not headers:
                    logging.error("No headers provided in step 1")
                    return jsonify({'success': False, 'message': 'No headers provided'}), 400
                    
                if 'template_id' not in session:
                    logging.error("Session missing template_id")
                    return jsonify({'success': False, 'message': 'Session data missing'}), 400

                template_id = session['template_id']
                
                # Get the dataframe from session for auto-detection
                df_json = session.get('df')
                if df_json:
                    df = pd.read_json(StringIO(df_json))
                    session_headers = session.get('headers', [])
                    df.columns = session_headers
                    header_row = session.get('header_row', 0)
                    df = df.iloc[header_row + 1:].reset_index(drop=True)
                    
                    # Auto-detect rules for selected headers
                    validations = assign_default_rules_to_columns(df, headers)
                    session['validations'] = validations
                    logging.debug(f"Auto-assigned rules: {validations}")
                else:
                    validations = {}

                session['selected_headers'] = headers
                session['current_step'] = 2

                # Mark selected headers in the database
                conn = get_db_connection()
                cursor = conn.cursor()
                cursor.execute("UPDATE template_columns SET is_selected = FALSE WHERE template_id = %s", (template_id,))
                for header in headers:
                    cursor.execute("""
                        UPDATE template_columns
                        SET is_selected = TRUE
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    
                    # Get column_id and add auto-detected rules
                    cursor.execute("""
                        SELECT column_id FROM template_columns
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    result = cursor.fetchone()
                    if result:
                        column_id = result[0]
                        for rule_name in validations.get(header, []):
                            cursor.execute("""
                                SELECT rule_type_id FROM validation_rule_types
                                WHERE rule_name = %s AND is_custom = FALSE
                            """, (rule_name,))
                            rule_result = cursor.fetchone()
                            if rule_result:
                                rule_type_id = rule_result[0]
                                cursor.execute("""
                                    INSERT IGNORE INTO column_validation_rules (column_id, rule_type_id, rule_config)
                                    VALUES (%s, %s, %s)
                                """, (column_id, rule_type_id, '{}'))
                
                conn.commit()
                cursor.close()

                logging.info(f"Step 1 completed: headers={headers}, auto-assigned rules={validations}")
                return jsonify({'success': True, 'headers': headers, 'validations': validations})
            except Exception as e:
                logging.error(f"Error in step 1: {str(e)}")
                return jsonify({'success': False, 'message': str(e)}), 500
        
        # GET request - return current headers
        headers = session.get('headers', [])
        return jsonify({'headers': headers})

    @app.route('/step/2', methods=['GET', 'POST'])
    @app.route('/api/step/2', methods=['GET', 'POST'])
    def step_two():
        if 'loggedin' not in session:
            return jsonify({'error': 'Not logged in'}), 401
            
        if request.method == 'POST':
            try:
                action = request.form.get('action', 'save')
                validations = {}
                for key, values in request.form.lists():
                    if key.startswith('validations_'):
                        header = key.replace('validations_', '')
                        validations[header] = values
                        
                logging.debug(f"Step 2 submitted: action={action}, validations={validations}")
                
                template_id = session.get('template_id')
                if not template_id:
                    return jsonify({'success': False, 'message': 'Session data missing'}), 400

                # Save validations to database
                conn = get_db_connection()
                cursor = conn.cursor()
                
                # Clear existing rules
                cursor.execute("""
                    DELETE FROM column_validation_rules
                    WHERE column_id IN (
                        SELECT column_id FROM template_columns WHERE template_id = %s
                    )
                """, (template_id,))
                
                # Add new rules
                for header, rules in validations.items():
                    cursor.execute("""
                        SELECT column_id FROM template_columns
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    result = cursor.fetchone()
                    if not result:
                        continue
                    column_id = result[0]
                    
                    for rule_name in rules:
                        cursor.execute("""
                            SELECT rule_type_id FROM validation_rule_types
                            WHERE rule_name = %s
                        """, (rule_name,))
                        result = cursor.fetchone()
                        if result:
                            rule_type_id = result[0]
                            cursor.execute("""
                                INSERT IGNORE INTO column_validation_rules (column_id, rule_type_id, rule_config)
                                VALUES (%s, %s, %s)
                            """, (column_id, rule_type_id, '{}'))
                
                conn.commit()
                cursor.close()

                session['validations'] = validations
                session['current_step'] = 3 if action == 'review' else 2
                
                logging.info(f"Step 2 completed: action={action}, validations={validations}")
                return jsonify({'success': True, 'message': 'Step 2 completed successfully'})
            except Exception as e:
                logging.error(f"Error in step 2: {str(e)}")
                return jsonify({'success': False, 'message': str(e)}), 500
        
        # GET request
        selected_headers = session.get('selected_headers', [])
        return jsonify({'selected_headers': selected_headers})

    # Rules endpoint
    @app.route('/rules', methods=['GET'])
    @app.route('/api/rules', methods=['GET'])
    def get_rules():
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            
            cursor.execute("""
                SELECT rule_type_id AS rule_id, rule_name, description, parameters, is_custom, 
                       column_name, template_id, source_format, target_format, data_type, is_active
                FROM validation_rule_types
            """)
            rules = cursor.fetchall()
            cursor.close()
            
            logging.info(f"Returning {len(rules)} rules from getRules endpoint")
            return jsonify({'success': True, 'rules': rules})
        except mysql.connector.Error as e:
            logging.error(f"Database error fetching rules: {str(e)}")
            return jsonify({'success': False, 'message': str(e)}), 500
        except Exception as e:
            logging.error(f"Unexpected error fetching rules: {str(e)}")
            return jsonify({'success': False, 'message': str(e)}), 500

    # Template details endpoint
    @app.route('/template/<int:template_id>/<sheet_name>', methods=['GET'])
    @app.route('/api/template/<int:template_id>/<sheet_name>', methods=['GET'])
    def get_template(template_id, sheet_name):
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /template: session missing")
            return jsonify({'error': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("""
                SELECT template_name, sheet_name, headers
                FROM excel_templates
                WHERE template_id = %s AND user_id = %s AND status = 'ACTIVE'
            """, (template_id, session['user_id']))
            template_record = cursor.fetchone()
            
            if not template_record:
                logging.error(f"Template not found for template_id: {template_id}, user_id: {session['user_id']}")
                cursor.close()
                return jsonify({'error': 'Template not found'}), 404

            headers = json.loads(template_record['headers']) if template_record['headers'] else []
            stored_sheet_name = template_record['sheet_name'] or sheet_name
            file_path = os.path.join(app.config['UPLOAD_FOLDER'], template_record['template_name'])
            
            cursor.execute("""
                SELECT COUNT(*) as rule_count
                FROM template_columns tc
                JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                WHERE tc.template_id = %s AND tc.is_selected = TRUE
            """, (template_id,))
            rule_count = cursor.fetchone()['rule_count']
            has_existing_rules = rule_count > 0
            
            cursor.close()
            
            return jsonify({
                'success': True,
                'sheets': {stored_sheet_name: {'headers': headers}},
                'file_name': template_record['template_name'],
                'file_path': file_path,
                'sheet_name': stored_sheet_name,
                'has_existing_rules': has_existing_rules
            })
        except mysql.connector.Error as e:
            logging.error(f"Database error in get_template: {str(e)}")
            return jsonify({'error': f'Database error: {str(e)}'}), 500
        except Exception as e:
            logging.error(f"Unexpected error in get_template: {str(e)}")
            return jsonify({'error': f'Unexpected error: {str(e)}'}), 500

    # Debug route to show all registered routes
    @app.route('/debug/routes', methods=['GET'])
    def list_routes():
        routes = []
        for rule in app.url_map.iter_rules():
            routes.append({
                'endpoint': rule.endpoint,
                'methods': list(rule.methods),
                'rule': rule.rule
            })
        return jsonify(routes)

    # 404 handler to debug missing routes
    @app.errorhandler(404)
    def not_found_handler(error):
        logging.error(f"404 Error: {request.method} {request.url} not found")
        logging.error(f"Available routes: {[rule.rule for rule in app.url_map.iter_rules()]}")
        return jsonify({
            'error': 'Endpoint not found', 
            'method': request.method,
            'url': request.url,
            'path': request.path
        }), 404

    return app

def initialize_app_data():
    """Initialize database and create default data"""
    try:
        logging.info("Initializing database schema...")
        init_db()
        
        logging.info("Creating admin user...")
        create_admin_user()
        
        logging.info("Creating default validation rules...")
        create_default_validation_rules()
        
        logging.info("Application initialization completed successfully")
    except Exception as e:
        logging.error(f"Failed to initialize application: {e}")
        raise

DB_CONFIG = {
    'host': os.getenv('MYSQL_HOST', 'localhost'),
    'user': os.getenv('MYSQL_USER', 'root'),
    'password': os.getenv('MYSQL_PASSWORD', 'Keansa@2024'),
    'database': os.getenv('MYSQL_DATABASE', 'data_validation_2'),
}

def get_db_connection():
    if 'db' not in g:
        try:
            conn = mysql.connector.connect(
                host=DB_CONFIG['host'],
                user=DB_CONFIG['user'],
                password=DB_CONFIG['password']
            )
            cursor = conn.cursor()
            cursor.execute(f"CREATE DATABASE IF NOT EXISTS {DB_CONFIG['database']}")
            cursor.close()
            conn.close()
            g.db = mysql.connector.connect(**DB_CONFIG)
            logging.info("Database connection established successfully")
        except mysql.connector.Error as err:
            if err.errno == errorcode.ER_ACCESS_DENIED_ERROR:
                logging.error("Database connection failed: Access denied for user - check username/password")
            elif err.errno == errorcode.ER_BAD_DB_ERROR:
                logging.error("Database connection failed: Database does not exist")
            else:
                logging.error(f"Database connection failed: {err}")
            raise Exception(f"Failed to connect to database: {str(err)}")
    return g.db

def close_db(error):
    db = g.pop('db', None)
    if db is not None:
        db.close()

def init_db():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        tables = [
            """
            CREATE TABLE IF NOT EXISTS login_details (
                id INT AUTO_INCREMENT PRIMARY KEY,
                first_name VARCHAR(100),
                last_name VARCHAR(100),
                email VARCHAR(255) UNIQUE,
                mobile VARCHAR(10),
                password VARCHAR(255)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS excel_templates (
                template_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_name VARCHAR(255) NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
                user_id INT NOT NULL,
                sheet_name VARCHAR(255),
                headers JSON,
                status ENUM('ACTIVE', 'INACTIVE') DEFAULT 'ACTIVE',
                is_corrected BOOLEAN DEFAULT FALSE,
                remote_file_path VARCHAR(512),
                FOREIGN KEY (user_id) REFERENCES login_details(id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS template_columns (
                column_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_id BIGINT NOT NULL,
                column_name VARCHAR(255) NOT NULL,
                column_position INT NOT NULL,
                is_validation_enabled BOOLEAN DEFAULT FALSE,
                is_selected BOOLEAN DEFAULT FALSE,
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE,
                UNIQUE (template_id, column_name)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_rule_types (
                rule_type_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                rule_name VARCHAR(255) NOT NULL,
                description TEXT,
                parameters TEXT,
                is_active BOOLEAN DEFAULT TRUE,
                is_custom BOOLEAN DEFAULT FALSE,
                column_name VARCHAR(255),
                template_id BIGINT,
                data_type VARCHAR(50),
                source_format VARCHAR(50),
                target_format VARCHAR(50),
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS column_validation_rules (
                column_validation_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                column_id BIGINT NOT NULL,
                rule_type_id BIGINT NOT NULL,
                rule_config JSON,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (column_id) REFERENCES template_columns(column_id) ON DELETE CASCADE,
                FOREIGN KEY (rule_type_id) REFERENCES validation_rule_types(rule_type_id) ON DELETE RESTRICT,
                UNIQUE (column_id, rule_type_id)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_history (
                history_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_id BIGINT NOT NULL,
                template_name VARCHAR(255) NOT NULL,
                error_count INT NOT NULL,
                corrected_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                corrected_file_path VARCHAR(512) NOT NULL,
                user_id INT NOT NULL,
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE,
                FOREIGN KEY (user_id) REFERENCES login_details(id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_corrections (
                correction_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                history_id BIGINT NOT NULL,
                row_index INT NOT NULL,
                column_name VARCHAR(255) NOT NULL,
                original_value TEXT,
                corrected_value TEXT,
                rule_failed VARCHAR(255) DEFAULT NULL,
                FOREIGN KEY (history_id) REFERENCES validation_history(history_id) ON DELETE CASCADE
            )
            """
        ]
        for table_sql in tables:
            cursor.execute(table_sql)
        
        # Add missing columns if they don't exist
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'source_format'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN source_format VARCHAR(50)")
            logging.info("Added source_format column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'target_format'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN target_format VARCHAR(50)")
            logging.info("Added target_format column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'data_type'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN data_type VARCHAR(50)")
            logging.info("Added data_type column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM excel_templates LIKE 'remote_file_path'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE excel_templates ADD COLUMN remote_file_path VARCHAR(512)")
            logging.info("Added remote_file_path column to excel_templates table")
            
        cursor.execute("SHOW COLUMNS FROM template_columns LIKE 'is_selected'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE template_columns ADD COLUMN is_selected BOOLEAN DEFAULT FALSE")
            logging.info("Added is_selected column to template_columns table")
            
        conn.commit()
        cursor.close()
        logging.info("Database tables initialized")
    except Exception as e:
        logging.error(f"Failed to initialize database: {str(e)}")
        raise

def create_admin_user():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        admin_password = bcrypt.hashpw('admin'.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
        cursor.execute("""
            INSERT IGNORE INTO login_details (first_name, last_name, email, mobile, password)
            VALUES (%s, %s, %s, %s, %s)
        """, ('Admin', 'User', 'admin@example.com', '1234567890', admin_password))
        conn.commit()
        cursor.close()
        logging.info("Admin user created or already exists")
    except Exception as e:
        logging.error(f"Failed to create admin user: {str(e)}")
        raise

def create_default_validation_rules():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        default_rules = [
            ("Required", "Ensures the field is not null", '{"allow_null": false}', None, None, None),
            ("Int", "Validates integer format", '{"format": "integer"}', None, None, "Int"),
            ("Float", "Validates number format (integer or decimal)", '{"format": "float"}', None, None, "Float"),
            ("Text", "Allows text with quotes and parentheses", '{"allow_special": false}', None, None, "Text"),
            ("Email", "Validates email format", '{"regex": "^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\\\.[a-zA-Z0-9-.]+$"}', None, None, "Email"),
            ("Date(DD-MM-YYYY)", "Validates date format DD-MM-YYYY", '{"format": "%d-%m-%Y"}', "DD-MM-YYYY", None, "Date"),
            ("Boolean", "Validates boolean format (true/false or 0/1)", '{"format": "boolean"}', None, None, "Boolean"),
            ("Alphanumeric", "Validates alphanumeric format", '{"format": "alphanumeric"}', None, None, "Alphanumeric")
        ]
        cursor.executemany("""
            INSERT IGNORE INTO validation_rule_types (rule_name, description, parameters, is_custom, source_format, target_format, data_type)
            VALUES (%s, %s, %s, %s, %s, %s, %s)
        """, [(name, desc, params, False, source, target, dtype) for name, desc, params, source, target, dtype in default_rules])
        conn.commit()
        cursor.close()
        logging.info("Default validation rules ensured successfully")
    except Exception as e:
        logging.error(f"Failed to ensure default validation rules: {str(e)}")
        raise

if __name__ == '__main__':
    try:
        # Create the application using factory pattern
        app = create_app()
        
        # Initialize database and default data within app context
        with app.app_context():
            initialize_app_data()
        
        # Get port from environment or use default
        port = int(os.getenv('PORT', 5000))
        
        # Start the application server
        logging.info("Starting Flask server...")
        app.run(debug=True, host='0.0.0.0', port=port)
        
    except Exception as e:
        logging.error(f"Failed to start application: {e}")
        raise
).any():
        return "Email"

def create_app():
    """Application factory pattern for different environments"""
    # Set the path to the frontend dist folder
    current_dir = os.path.dirname(os.path.abspath(__file__))
    frontend_dist_path = os.path.join(current_dir, '..', '..', 'Keansa-Ai-Suite2025may-frontend11', 'dist')
    frontend_dist_path = os.path.abspath(frontend_dist_path)
    
    # Create Flask application instance
    app = Flask(__name__, static_folder=frontend_dist_path, static_url_path='')
    CORS(app, supports_credentials=True, origins=["http://localhost:3000", "http://localhost:8080", "http://localhost:5000", "*"])

    app.secret_key = os.urandom(24).hex()
    app.config['SESSION_TYPE'] = 'filesystem'
    app.config['SESSION_FILE_DIR'] = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'sessions')
    app.config['SESSION_COOKIE_SAMESITE'] = 'Lax'
    app.config['SESSION_COOKIE_HTTPONLY'] = True
    app.config['SESSION_COOKIE_SECURE'] = False
    app.config['PERMANENT_SESSION_LIFETIME'] = 86400  # 24 hours
    app.config['UPLOAD_FOLDER'] = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'uploads')
    Session(app)

    # Ensure directories exist
    try:
        os.makedirs(app.config['UPLOAD_FOLDER'], exist_ok=True)
        os.makedirs(app.config['SESSION_FILE_DIR'], exist_ok=True)
    except OSError as e:
        logging.error(f"Failed to create directories: {e}")

    # Register cleanup handlers
    app.teardown_appcontext(close_db)
    
    # Register all routes directly in create_app
    
    # Static file serving for React frontend
    @app.route('/', defaults={'path': ''})
    @app.route('/<path:path>')
    def serve(path):
        if path and os.path.exists(os.path.join(app.static_folder, path)):
            return app.send_static_file(path)
        return app.send_static_file('index.html')

    # Health check endpoint
    @app.route('/health', methods=['GET'])
    def health_check():
        return jsonify({
            'status': 'healthy',
            'timestamp': datetime.now().isoformat(),
            'version': '2.0.0'
        })

    # Authentication endpoint - both old and new paths
    @app.route('/authenticate', methods=['POST'])
    @app.route('/api/auth/authenticate', methods=['POST'])
    def authenticate():
        try:
            email = request.form.get('username') or request.form.get('email')
            password = request.form.get('password')
            logging.debug(f"Login attempt: email={email}, password={'*' * len(password) if password else 'None'}")
            
            if not email or not password:
                logging.warning(f"Login failed: Email or password missing")
                return jsonify({'success': False, 'message': 'Email and password are required'}), 400

            # Check for admin login
            if email == "admin" and password == "admin":
                session['loggedin'] = True
                session['user_email'] = "admin@example.com"
                session['user_id'] = 1
                session.permanent = True
                logging.info(f"Admin login successful. Session: {dict(session)}")
                return jsonify({'success': True, 'message': 'Login successful', 'user': {'email': 'admin@example.com', 'id': 1}}), 200

            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("SELECT * FROM login_details WHERE LOWER(email) = LOWER(%s)", (email.lower(),))
            account = cursor.fetchone()
            cursor.close()
            
            if account:
                if bcrypt.checkpw(password.encode('utf-8'), account['password'].encode('utf-8')):
                    session['loggedin'] = True
                    session['user_email'] = account['email']
                    session['user_id'] = account['id']
                    session.permanent = True
                    logging.info(f"User {email} logged in successfully. Session: {dict(session)}")
                    return jsonify({
                        'success': True,
                        'message': 'Login successful',
                        'user': {'email': account['email'], 'id': account['id']}
                    }), 200
                else:
                    logging.warning(f"Invalid password for {email}")
                    return jsonify({'success': False, 'message': 'Invalid credentials'}), 401
            else:
                logging.warning(f"Email {email} not found")
                return jsonify({'success': False, 'message': 'Invalid credentials'}), 401
        except Exception as e:
            logging.error(f"Unexpected error during login: {str(e)}")
            return jsonify({'success': False, 'message': f'Unexpected error: {str(e)}'}), 500

    @app.route('/check-auth', methods=['GET'])
    @app.route('/api/auth/check-auth', methods=['GET'])
    def check_auth():
        try:
            logging.debug(f"Checking auth with session: {dict(session)}")
            if 'loggedin' in session and 'user_id' in session:
                conn = get_db_connection()
                cursor = conn.cursor(dictionary=True)
                cursor.execute("SELECT email, first_name FROM login_details WHERE id = %s", (session['user_id'],))
                user = cursor.fetchone()
                cursor.close()
                if user:
                    logging.info(f"User {session.get('user_email')} is authenticated")
                    return jsonify({
                        'success': True,
                        'user': {
                            'email': user['email'],
                            'id': session['user_id'],
                            'first_name': user['first_name']
                        }
                    })
                else:
                    logging.warning("User not found in database")  
                    session.clear()
                    return jsonify({'success': False, 'message': 'User not found'}), 401
            logging.warning("User not authenticated")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        except Exception as e:
            logging.error(f"Error in check-auth endpoint: {str(e)}")
            return jsonify({'success': False, 'message': f'Server error: {str(e)}'}), 500

    @app.route('/register', methods=['POST'])
    @app.route('/api/auth/register', methods=['POST'])
    def register():
        first_name = request.form.get('first_name')
        last_name = request.form.get('last_name')
        email = request.form.get('email')
        mobile = request.form.get('mobile')
        password = request.form.get('password')
        confirm_password = request.form.get('confirm_password')

        if not all([first_name, last_name, email, mobile, password, confirm_password]):
            return jsonify({'success': False, 'message': 'All fields are required'}), 400
        if password != confirm_password:
            return jsonify({'success': False, 'message': 'Passwords do not match'}), 400

        hashed_password = bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
        try:
            conn = get_db_connection()
            cursor = conn.cursor()
            cursor.execute("""
                INSERT INTO login_details (first_name, last_name, email, mobile, password)
                VALUES (%s, %s, %s, %s, %s)
            """, (first_name, last_name, email, mobile, hashed_password))
            user_id = cursor.lastrowid
            conn.commit()
            cursor.close()
            session['loggedin'] = True
            session['user_email'] = email
            session['user_id'] = user_id
            return jsonify({
                'success': True,
                'message': 'Registration successful',
                'user': {'email': email, 'id': user_id}
            }), 200
        except mysql.connector.Error as e:
            logging.error(f"Database error during registration: {str(e)}")
            return jsonify({'success': False, 'message': f'Registration error: {str(e)}'}), 500

    @app.route('/logout', methods=['POST'])
    @app.route('/api/auth/logout', methods=['POST'])
    def logout():
        logging.info(f"User {session.get('user_email', 'unknown')} logged out")
        session.clear()
        return jsonify({'success': True, 'message': 'Logged out successfully'})

    # Template routes
    @app.route('/templates', methods=['GET'])
    @app.route('/api/templates', methods=['GET'])
    def get_templates():
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /templates: session missing")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("""
                SELECT template_id, template_name, created_at, status
                FROM excel_templates
                WHERE user_id = %s AND status = 'ACTIVE'
                ORDER BY created_at DESC
                LIMIT 100
            """, (session['user_id'],))
            templates = cursor.fetchall()
            cursor.close()
            logging.info(f"Fetched {len(templates)} templates for user {session['user_id']}")
            return jsonify({'success': True, 'templates': templates})
        except mysql.connector.Error as e:
            logging.error(f'Error fetching templates: {str(e)}')
            return jsonify({'success': False, 'message': f'Error fetching templates: {str(e)}'}), 500
        except Exception as e:
            logging.error(f'Unexpected error fetching templates: {str(e)}')
            return jsonify({'success': False, 'message': f'Unexpected error: {str(e)}'}), 500

    # Rule Configuration routes
    @app.route('/rule-configurations', methods=['GET'])
    @app.route('/api/validation/rule-configurations', methods=['GET'])
    def get_rule_configurations():
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning(f"Unauthorized access to /rule-configurations: session={dict(session)}")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            user_id = session['user_id']
            logging.debug(f"Fetching rule configurations for user_id: {user_id}")

            # Main query to fetch templates with configured rules
            cursor.execute("""
                SELECT 
                    t.template_id, 
                    t.template_name, 
                    t.created_at, 
                    COUNT(cvr.column_validation_id) as rule_count
                FROM excel_templates t
                LEFT JOIN template_columns tc ON t.template_id = tc.template_id
                LEFT JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                WHERE t.user_id = %s AND t.status = 'ACTIVE' AND t.is_corrected = FALSE
                GROUP BY t.template_id, t.template_name, t.created_at
                HAVING rule_count > 0
                ORDER BY t.created_at DESC
                LIMIT 100
            """, (user_id,))
            templates = cursor.fetchall()
            logging.debug(f"Fetched rule-configured templates: {templates}")

            cursor.close()

            if not templates:
                logging.info(f"No templates with rules found for user_id: {user_id}")
            else:
                logging.info(f"Found {len(templates)} templates with rules for user_id: {user_id}")

            return jsonify({'success': True, 'templates': templates})
        except mysql.connector.Error as e:
            logging.error(f"Database error fetching rule configurations: {str(e)}")
            return jsonify({'success': False, 'message': f"Database error: {str(e)}"}), 500
        except Exception as e:
            logging.error(f"Unexpected error fetching rule configurations: {str(e)}")
            return jsonify({'success': False, 'message': f"Unexpected error: {str(e)}"}), 500

    # File upload route
    @app.route('/upload', methods=['POST'])
    @app.route('/api/templates/upload', methods=['POST'])
    @app.route('/api/upload', methods=['POST'])  # Additional common path
    def upload():
        logging.info(f"Upload endpoint called: {request.endpoint}, method: {request.method}")
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /upload: session missing")
            return jsonify({'error': 'Not logged in'}), 401
        if 'file' not in request.files:
            logging.warning("No file provided in upload request")
            return jsonify({'error': 'No file uploaded'}), 400
        file = request.files['file']
        if file.filename == '':
            logging.warning("No file selected in upload request")
            return jsonify({'error': 'No file selected'}), 400
        
        file_path = os.path.join(app.config['UPLOAD_FOLDER'], file.filename)
        try:
            file.save(file_path)
            logging.info(f"File saved: {file_path}")
        except Exception as e:
            logging.error(f"Failed to save file {file.filename}: {str(e)}")
            return jsonify({'error': f'Failed to save file: {str(e)}'}), 500

        try:
            # Read the file to get sheets and headers
            if file.filename.endswith('.xlsx') or file.filename.endswith('.xls'):
                xl = pd.ExcelFile(file_path)
                sheets = {sheet_name: pd.read_excel(file_path, sheet_name=sheet_name, header=None) 
                         for sheet_name in xl.sheet_names}
            elif file.filename.endswith(('.txt', '.csv', '.dat')):
                df = pd.read_csv(file_path, header=None, encoding='utf-8')
                sheets = {'Sheet1': df}
            else:
                logging.error("Unsupported file type")
                return jsonify({'error': 'Unsupported file type'}), 400
            
            logging.debug(f"Sheets extracted: {list(sheets.keys())}")
        except Exception as e:
            logging.error(f"Failed to read file {file_path}: {str(e)}")
            return jsonify({'error': f'Failed to read file: {str(e)}'}), 400

        try:
            sheet_names = list(sheets.keys())
            if not sheet_names:
                logging.error("No sheets found in the file")
                return jsonify({'error': 'No sheets found in the file'}), 400
            sheet_name = sheet_names[0]
            df = sheets[sheet_name]
            
            # Find header row
            header_row = 0
            for i in range(min(len(df), 10)):
                row = df.iloc[i].dropna()
                if not row.empty and all(isinstance(x, str) for x in row if pd.notna(x)):
                    header_row = i
                    break
                    
            headers = df.iloc[header_row].tolist()
            logging.debug(f"Headers extracted: {headers}")
            
            if not headers or all(not h for h in headers):
                logging.error("No valid headers found in file")
                return jsonify({'error': 'No valid headers found in the file'}), 400
        except Exception as e:
            logging.error(f"Error processing file {file.filename}: {str(e)}")
            return jsonify({'error': f'Error processing file: {str(e)}'}), 400

        # Clear existing session data
        for key in ['df', 'header_row', 'headers', 'sheet_name', 'current_step', 'selected_headers', 'validations', 'error_cell_locations', 'data_rows', 'corrected_file_path']:
            session.pop(key, None)

        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)

            # Check if template exists
            cursor.execute("""
                SELECT template_id, headers, sheet_name
                FROM excel_templates
                WHERE template_name = %s AND user_id = %s AND status = 'ACTIVE'
                ORDER BY created_at DESC
            """, (file.filename, session['user_id']))
            existing_templates = cursor.fetchall()
            logging.info(f"Found {len(existing_templates)} existing templates with name {file.filename}")

            template_id = None
            has_existing_rules = False
            validations = {}
            selected_headers = []

            # Check for matching template
            matching_template = None
            for template in existing_templates:
                stored_headers = json.loads(template['headers']) if template['headers'] else []
                stored_sheet_name = template['sheet_name']
                if stored_headers == headers and stored_sheet_name == sheet_name:
                    matching_template = template
                    break

            if matching_template:
                template_id = matching_template['template_id']
                # Check for existing rules
                cursor.execute("""
                    SELECT tc.column_name, vrt.rule_name
                    FROM template_columns tc
                    JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                    JOIN validation_rule_types vrt ON cvr.rule_type_id = vrt.rule_type_id
                    WHERE tc.template_id = %s AND tc.is_selected = TRUE
                """, (template_id,))
                rules_data = cursor.fetchall()
                for row in rules_data:
                    column_name = row['column_name']
                    rule_name = row['rule_name']
                    if column_name not in validations:
                        validations[column_name] = []
                    validations[column_name].append(rule_name)
                    if column_name not in selected_headers:
                        selected_headers.append(column_name)
                has_existing_rules = len(validations) > 0
            else:
                # New template
                cursor.execute("""
                    INSERT INTO excel_templates (template_name, user_id, sheet_name, headers, is_corrected)
                    VALUES (%s, %s, %s, %s, %s)
                """, (file.filename, session['user_id'], sheet_name, json.dumps(headers), False))
                template_id = cursor.lastrowid
                column_data = [(template_id, header, i + 1, False) for i, header in enumerate(headers)]
                cursor.executemany("""
                    INSERT INTO template_columns (template_id, column_name, column_position, is_selected)
                    VALUES (%s, %s, %s, %s)
                """, column_data)

            conn.commit()
            cursor.close()

            # Store session data
            session['file_path'] = file_path
            session['template_id'] = template_id
            session['df'] = df.to_json()
            session['header_row'] = header_row
            session['headers'] = headers
            session['sheet_name'] = sheet_name
            session['current_step'] = 1 if not has_existing_rules else 3
            session['validations'] = validations
            session['selected_headers'] = selected_headers
            session['has_existing_rules'] = has_existing_rules

            logging.info(f"Upload processed: template_id={template_id}, filename={file.filename}, has_existing_rules={has_existing_rules}")

            return jsonify({
                'success': True,
                'sheets': {sheet_name: {'headers': headers}},
                'file_name': file.filename,
                'template_id': template_id,
                'has_existing_rules': has_existing_rules,
                'sheet_name': sheet_name,
                'skip_to_step_3': has_existing_rules
            })
        except mysql.connector.Error as e:
            logging.error(f'Error saving template: {str(e)}')
            return jsonify({'error': f'Error saving template: {str(e)}'}), 500
        except Exception as e:
            logging.error(f'Unexpected error saving template: {str(e)}')
            return jsonify({'error': f'Unexpected error: {str(e)}'}), 500

    # Multi-step workflow endpoints
    @app.route('/step/1', methods=['GET', 'POST'])
    @app.route('/api/step/1', methods=['GET', 'POST'])
    def step_one():
        if 'loggedin' not in session:
            return jsonify({'error': 'Not logged in'}), 401
        
        if request.method == 'POST':
            try:
                headers = request.form.getlist('headers')
                new_header_row = request.form.get('new_header_row')
                logging.debug(f"Step 1 submitted: headers={headers}, new_header_row={new_header_row}")
                
                if not headers:
                    logging.error("No headers provided in step 1")
                    return jsonify({'success': False, 'message': 'No headers provided'}), 400
                    
                if 'template_id' not in session:
                    logging.error("Session missing template_id")
                    return jsonify({'success': False, 'message': 'Session data missing'}), 400

                template_id = session['template_id']
                
                # Get the dataframe from session for auto-detection
                df_json = session.get('df')
                if df_json:
                    df = pd.read_json(StringIO(df_json))
                    session_headers = session.get('headers', [])
                    df.columns = session_headers
                    header_row = session.get('header_row', 0)
                    df = df.iloc[header_row + 1:].reset_index(drop=True)
                    
                    # Auto-detect rules for selected headers
                    validations = assign_default_rules_to_columns(df, headers)
                    session['validations'] = validations
                    logging.debug(f"Auto-assigned rules: {validations}")
                else:
                    validations = {}

                session['selected_headers'] = headers
                session['current_step'] = 2

                # Mark selected headers in the database
                conn = get_db_connection()
                cursor = conn.cursor()
                cursor.execute("UPDATE template_columns SET is_selected = FALSE WHERE template_id = %s", (template_id,))
                for header in headers:
                    cursor.execute("""
                        UPDATE template_columns
                        SET is_selected = TRUE
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    
                    # Get column_id and add auto-detected rules
                    cursor.execute("""
                        SELECT column_id FROM template_columns
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    result = cursor.fetchone()
                    if result:
                        column_id = result[0]
                        for rule_name in validations.get(header, []):
                            cursor.execute("""
                                SELECT rule_type_id FROM validation_rule_types
                                WHERE rule_name = %s AND is_custom = FALSE
                            """, (rule_name,))
                            rule_result = cursor.fetchone()
                            if rule_result:
                                rule_type_id = rule_result[0]
                                cursor.execute("""
                                    INSERT IGNORE INTO column_validation_rules (column_id, rule_type_id, rule_config)
                                    VALUES (%s, %s, %s)
                                """, (column_id, rule_type_id, '{}'))
                
                conn.commit()
                cursor.close()

                logging.info(f"Step 1 completed: headers={headers}, auto-assigned rules={validations}")
                return jsonify({'success': True, 'headers': headers, 'validations': validations})
            except Exception as e:
                logging.error(f"Error in step 1: {str(e)}")
                return jsonify({'success': False, 'message': str(e)}), 500
        
        # GET request - return current headers
        headers = session.get('headers', [])
        return jsonify({'headers': headers})

    @app.route('/step/2', methods=['GET', 'POST'])
    @app.route('/api/step/2', methods=['GET', 'POST'])
    def step_two():
        if 'loggedin' not in session:
            return jsonify({'error': 'Not logged in'}), 401
            
        if request.method == 'POST':
            try:
                action = request.form.get('action', 'save')
                validations = {}
                for key, values in request.form.lists():
                    if key.startswith('validations_'):
                        header = key.replace('validations_', '')
                        validations[header] = values
                        
                logging.debug(f"Step 2 submitted: action={action}, validations={validations}")
                
                template_id = session.get('template_id')
                if not template_id:
                    return jsonify({'success': False, 'message': 'Session data missing'}), 400

                # Save validations to database
                conn = get_db_connection()
                cursor = conn.cursor()
                
                # Clear existing rules
                cursor.execute("""
                    DELETE FROM column_validation_rules
                    WHERE column_id IN (
                        SELECT column_id FROM template_columns WHERE template_id = %s
                    )
                """, (template_id,))
                
                # Add new rules
                for header, rules in validations.items():
                    cursor.execute("""
                        SELECT column_id FROM template_columns
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    result = cursor.fetchone()
                    if not result:
                        continue
                    column_id = result[0]
                    
                    for rule_name in rules:
                        cursor.execute("""
                            SELECT rule_type_id FROM validation_rule_types
                            WHERE rule_name = %s
                        """, (rule_name,))
                        result = cursor.fetchone()
                        if result:
                            rule_type_id = result[0]
                            cursor.execute("""
                                INSERT IGNORE INTO column_validation_rules (column_id, rule_type_id, rule_config)
                                VALUES (%s, %s, %s)
                            """, (column_id, rule_type_id, '{}'))
                
                conn.commit()
                cursor.close()

                session['validations'] = validations
                session['current_step'] = 3 if action == 'review' else 2
                
                logging.info(f"Step 2 completed: action={action}, validations={validations}")
                return jsonify({'success': True, 'message': 'Step 2 completed successfully'})
            except Exception as e:
                logging.error(f"Error in step 2: {str(e)}")
                return jsonify({'success': False, 'message': str(e)}), 500
        
        # GET request
        selected_headers = session.get('selected_headers', [])
        return jsonify({'selected_headers': selected_headers})

    # Rules endpoint
    @app.route('/rules', methods=['GET'])
    @app.route('/api/rules', methods=['GET'])
    def get_rules():
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            
            cursor.execute("""
                SELECT rule_type_id AS rule_id, rule_name, description, parameters, is_custom, 
                       column_name, template_id, source_format, target_format, data_type, is_active
                FROM validation_rule_types
            """)
            rules = cursor.fetchall()
            cursor.close()
            
            logging.info(f"Returning {len(rules)} rules from getRules endpoint")
            return jsonify({'success': True, 'rules': rules})
        except mysql.connector.Error as e:
            logging.error(f"Database error fetching rules: {str(e)}")
            return jsonify({'success': False, 'message': str(e)}), 500
        except Exception as e:
            logging.error(f"Unexpected error fetching rules: {str(e)}")
            return jsonify({'success': False, 'message': str(e)}), 500

    # Template details endpoint
    @app.route('/template/<int:template_id>/<sheet_name>', methods=['GET'])
    @app.route('/api/template/<int:template_id>/<sheet_name>', methods=['GET'])
    def get_template(template_id, sheet_name):
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /template: session missing")
            return jsonify({'error': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("""
                SELECT template_name, sheet_name, headers
                FROM excel_templates
                WHERE template_id = %s AND user_id = %s AND status = 'ACTIVE'
            """, (template_id, session['user_id']))
            template_record = cursor.fetchone()
            
            if not template_record:
                logging.error(f"Template not found for template_id: {template_id}, user_id: {session['user_id']}")
                cursor.close()
                return jsonify({'error': 'Template not found'}), 404

            headers = json.loads(template_record['headers']) if template_record['headers'] else []
            stored_sheet_name = template_record['sheet_name'] or sheet_name
            file_path = os.path.join(app.config['UPLOAD_FOLDER'], template_record['template_name'])
            
            cursor.execute("""
                SELECT COUNT(*) as rule_count
                FROM template_columns tc
                JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                WHERE tc.template_id = %s AND tc.is_selected = TRUE
            """, (template_id,))
            rule_count = cursor.fetchone()['rule_count']
            has_existing_rules = rule_count > 0
            
            cursor.close()
            
            return jsonify({
                'success': True,
                'sheets': {stored_sheet_name: {'headers': headers}},
                'file_name': template_record['template_name'],
                'file_path': file_path,
                'sheet_name': stored_sheet_name,
                'has_existing_rules': has_existing_rules
            })
        except mysql.connector.Error as e:
            logging.error(f"Database error in get_template: {str(e)}")
            return jsonify({'error': f'Database error: {str(e)}'}), 500
        except Exception as e:
            logging.error(f"Unexpected error in get_template: {str(e)}")
            return jsonify({'error': f'Unexpected error: {str(e)}'}), 500

    # Debug route to show all registered routes
    @app.route('/debug/routes', methods=['GET'])
    def list_routes():
        routes = []
        for rule in app.url_map.iter_rules():
            routes.append({
                'endpoint': rule.endpoint,
                'methods': list(rule.methods),
                'rule': rule.rule
            })
        return jsonify(routes)

    # 404 handler to debug missing routes
    @app.errorhandler(404)
    def not_found_handler(error):
        logging.error(f"404 Error: {request.method} {request.url} not found")
        logging.error(f"Available routes: {[rule.rule for rule in app.url_map.iter_rules()]}")
        return jsonify({
            'error': 'Endpoint not found', 
            'method': request.method,
            'url': request.url,
            'path': request.path
        }), 404

    return app

def initialize_app_data():
    """Initialize database and create default data"""
    try:
        logging.info("Initializing database schema...")
        init_db()
        
        logging.info("Creating admin user...")
        create_admin_user()
        
        logging.info("Creating default validation rules...")
        create_default_validation_rules()
        
        logging.info("Application initialization completed successfully")
    except Exception as e:
        logging.error(f"Failed to initialize application: {e}")
        raise

DB_CONFIG = {
    'host': os.getenv('MYSQL_HOST', 'localhost'),
    'user': os.getenv('MYSQL_USER', 'root'),
    'password': os.getenv('MYSQL_PASSWORD', 'Keansa@2024'),
    'database': os.getenv('MYSQL_DATABASE', 'data_validation_2'),
}

def get_db_connection():
    if 'db' not in g:
        try:
            conn = mysql.connector.connect(
                host=DB_CONFIG['host'],
                user=DB_CONFIG['user'],
                password=DB_CONFIG['password']
            )
            cursor = conn.cursor()
            cursor.execute(f"CREATE DATABASE IF NOT EXISTS {DB_CONFIG['database']}")
            cursor.close()
            conn.close()
            g.db = mysql.connector.connect(**DB_CONFIG)
            logging.info("Database connection established successfully")
        except mysql.connector.Error as err:
            if err.errno == errorcode.ER_ACCESS_DENIED_ERROR:
                logging.error("Database connection failed: Access denied for user - check username/password")
            elif err.errno == errorcode.ER_BAD_DB_ERROR:
                logging.error("Database connection failed: Database does not exist")
            else:
                logging.error(f"Database connection failed: {err}")
            raise Exception(f"Failed to connect to database: {str(err)}")
    return g.db

def close_db(error):
    db = g.pop('db', None)
    if db is not None:
        db.close()

def init_db():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        tables = [
            """
            CREATE TABLE IF NOT EXISTS login_details (
                id INT AUTO_INCREMENT PRIMARY KEY,
                first_name VARCHAR(100),
                last_name VARCHAR(100),
                email VARCHAR(255) UNIQUE,
                mobile VARCHAR(10),
                password VARCHAR(255)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS excel_templates (
                template_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_name VARCHAR(255) NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
                user_id INT NOT NULL,
                sheet_name VARCHAR(255),
                headers JSON,
                status ENUM('ACTIVE', 'INACTIVE') DEFAULT 'ACTIVE',
                is_corrected BOOLEAN DEFAULT FALSE,
                remote_file_path VARCHAR(512),
                FOREIGN KEY (user_id) REFERENCES login_details(id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS template_columns (
                column_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_id BIGINT NOT NULL,
                column_name VARCHAR(255) NOT NULL,
                column_position INT NOT NULL,
                is_validation_enabled BOOLEAN DEFAULT FALSE,
                is_selected BOOLEAN DEFAULT FALSE,
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE,
                UNIQUE (template_id, column_name)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_rule_types (
                rule_type_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                rule_name VARCHAR(255) NOT NULL,
                description TEXT,
                parameters TEXT,
                is_active BOOLEAN DEFAULT TRUE,
                is_custom BOOLEAN DEFAULT FALSE,
                column_name VARCHAR(255),
                template_id BIGINT,
                data_type VARCHAR(50),
                source_format VARCHAR(50),
                target_format VARCHAR(50),
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS column_validation_rules (
                column_validation_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                column_id BIGINT NOT NULL,
                rule_type_id BIGINT NOT NULL,
                rule_config JSON,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (column_id) REFERENCES template_columns(column_id) ON DELETE CASCADE,
                FOREIGN KEY (rule_type_id) REFERENCES validation_rule_types(rule_type_id) ON DELETE RESTRICT,
                UNIQUE (column_id, rule_type_id)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_history (
                history_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_id BIGINT NOT NULL,
                template_name VARCHAR(255) NOT NULL,
                error_count INT NOT NULL,
                corrected_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                corrected_file_path VARCHAR(512) NOT NULL,
                user_id INT NOT NULL,
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE,
                FOREIGN KEY (user_id) REFERENCES login_details(id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_corrections (
                correction_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                history_id BIGINT NOT NULL,
                row_index INT NOT NULL,
                column_name VARCHAR(255) NOT NULL,
                original_value TEXT,
                corrected_value TEXT,
                rule_failed VARCHAR(255) DEFAULT NULL,
                FOREIGN KEY (history_id) REFERENCES validation_history(history_id) ON DELETE CASCADE
            )
            """
        ]
        for table_sql in tables:
            cursor.execute(table_sql)
        
        # Add missing columns if they don't exist
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'source_format'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN source_format VARCHAR(50)")
            logging.info("Added source_format column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'target_format'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN target_format VARCHAR(50)")
            logging.info("Added target_format column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'data_type'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN data_type VARCHAR(50)")
            logging.info("Added data_type column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM excel_templates LIKE 'remote_file_path'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE excel_templates ADD COLUMN remote_file_path VARCHAR(512)")
            logging.info("Added remote_file_path column to excel_templates table")
            
        cursor.execute("SHOW COLUMNS FROM template_columns LIKE 'is_selected'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE template_columns ADD COLUMN is_selected BOOLEAN DEFAULT FALSE")
            logging.info("Added is_selected column to template_columns table")
            
        conn.commit()
        cursor.close()
        logging.info("Database tables initialized")
    except Exception as e:
        logging.error(f"Failed to initialize database: {str(e)}")
        raise

def create_admin_user():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        admin_password = bcrypt.hashpw('admin'.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
        cursor.execute("""
            INSERT IGNORE INTO login_details (first_name, last_name, email, mobile, password)
            VALUES (%s, %s, %s, %s, %s)
        """, ('Admin', 'User', 'admin@example.com', '1234567890', admin_password))
        conn.commit()
        cursor.close()
        logging.info("Admin user created or already exists")
    except Exception as e:
        logging.error(f"Failed to create admin user: {str(e)}")
        raise

def create_default_validation_rules():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        default_rules = [
            ("Required", "Ensures the field is not null", '{"allow_null": false}', None, None, None),
            ("Int", "Validates integer format", '{"format": "integer"}', None, None, "Int"),
            ("Float", "Validates number format (integer or decimal)", '{"format": "float"}', None, None, "Float"),
            ("Text", "Allows text with quotes and parentheses", '{"allow_special": false}', None, None, "Text"),
            ("Email", "Validates email format", '{"regex": "^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\\\.[a-zA-Z0-9-.]+$"}', None, None, "Email"),
            ("Date(DD-MM-YYYY)", "Validates date format DD-MM-YYYY", '{"format": "%d-%m-%Y"}', "DD-MM-YYYY", None, "Date"),
            ("Boolean", "Validates boolean format (true/false or 0/1)", '{"format": "boolean"}', None, None, "Boolean"),
            ("Alphanumeric", "Validates alphanumeric format", '{"format": "alphanumeric"}', None, None, "Alphanumeric")
        ]
        cursor.executemany("""
            INSERT IGNORE INTO validation_rule_types (rule_name, description, parameters, is_custom, source_format, target_format, data_type)
            VALUES (%s, %s, %s, %s, %s, %s, %s)
        """, [(name, desc, params, False, source, target, dtype) for name, desc, params, source, target, dtype in default_rules])
        conn.commit()
        cursor.close()
        logging.info("Default validation rules ensured successfully")
    except Exception as e:
        logging.error(f"Failed to ensure default validation rules: {str(e)}")
        raise

if __name__ == '__main__':
    try:
        # Create the application using factory pattern
        app = create_app()
        
        # Initialize database and default data within app context
        with app.app_context():
            initialize_app_data()
        
        # Get port from environment or use default
        port = int(os.getenv('PORT', 5000))
        
        # Start the application server
        logging.info("Starting Flask server...")
        app.run(debug=True, host='0.0.0.0', port=port)
        
    except Exception as e:
        logging.error(f"Failed to start application: {e}")
        raise
).all():
        return "Email"
    
    # Date pattern detection
    try:
        pd.to_datetime(non_null, format="%d-%m-%Y")
        return "Date"
    except Exception:
        try:
            pd.to_datetime(non_null, format="%Y-%m-%d")
            return "Date"
        except Exception:
            pass
    
    # Boolean detection
    if non_null.str.lower().isin(['true', 'false', '0', '1']).all():
        return "Boolean"
    
    # Numeric detection
    if non_null.str.match(r'^-?\d+

def create_app():
    """Application factory pattern for different environments"""
    # Set the path to the frontend dist folder
    current_dir = os.path.dirname(os.path.abspath(__file__))
    frontend_dist_path = os.path.join(current_dir, '..', '..', 'Keansa-Ai-Suite2025may-frontend11', 'dist')
    frontend_dist_path = os.path.abspath(frontend_dist_path)
    
    # Create Flask application instance
    app = Flask(__name__, static_folder=frontend_dist_path, static_url_path='')
    CORS(app, supports_credentials=True, origins=["http://localhost:3000", "http://localhost:8080", "http://localhost:5000", "*"])

    app.secret_key = os.urandom(24).hex()
    app.config['SESSION_TYPE'] = 'filesystem'
    app.config['SESSION_FILE_DIR'] = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'sessions')
    app.config['SESSION_COOKIE_SAMESITE'] = 'Lax'
    app.config['SESSION_COOKIE_HTTPONLY'] = True
    app.config['SESSION_COOKIE_SECURE'] = False
    app.config['PERMANENT_SESSION_LIFETIME'] = 86400  # 24 hours
    app.config['UPLOAD_FOLDER'] = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'uploads')
    Session(app)

    # Ensure directories exist
    try:
        os.makedirs(app.config['UPLOAD_FOLDER'], exist_ok=True)
        os.makedirs(app.config['SESSION_FILE_DIR'], exist_ok=True)
    except OSError as e:
        logging.error(f"Failed to create directories: {e}")

    # Register cleanup handlers
    app.teardown_appcontext(close_db)
    
    # Register all routes directly in create_app
    
    # Static file serving for React frontend
    @app.route('/', defaults={'path': ''})
    @app.route('/<path:path>')
    def serve(path):
        if path and os.path.exists(os.path.join(app.static_folder, path)):
            return app.send_static_file(path)
        return app.send_static_file('index.html')

    # Health check endpoint
    @app.route('/health', methods=['GET'])
    def health_check():
        return jsonify({
            'status': 'healthy',
            'timestamp': datetime.now().isoformat(),
            'version': '2.0.0'
        })

    # Authentication endpoint - both old and new paths
    @app.route('/authenticate', methods=['POST'])
    @app.route('/api/auth/authenticate', methods=['POST'])
    def authenticate():
        try:
            email = request.form.get('username') or request.form.get('email')
            password = request.form.get('password')
            logging.debug(f"Login attempt: email={email}, password={'*' * len(password) if password else 'None'}")
            
            if not email or not password:
                logging.warning(f"Login failed: Email or password missing")
                return jsonify({'success': False, 'message': 'Email and password are required'}), 400

            # Check for admin login
            if email == "admin" and password == "admin":
                session['loggedin'] = True
                session['user_email'] = "admin@example.com"
                session['user_id'] = 1
                session.permanent = True
                logging.info(f"Admin login successful. Session: {dict(session)}")
                return jsonify({'success': True, 'message': 'Login successful', 'user': {'email': 'admin@example.com', 'id': 1}}), 200

            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("SELECT * FROM login_details WHERE LOWER(email) = LOWER(%s)", (email.lower(),))
            account = cursor.fetchone()
            cursor.close()
            
            if account:
                if bcrypt.checkpw(password.encode('utf-8'), account['password'].encode('utf-8')):
                    session['loggedin'] = True
                    session['user_email'] = account['email']
                    session['user_id'] = account['id']
                    session.permanent = True
                    logging.info(f"User {email} logged in successfully. Session: {dict(session)}")
                    return jsonify({
                        'success': True,
                        'message': 'Login successful',
                        'user': {'email': account['email'], 'id': account['id']}
                    }), 200
                else:
                    logging.warning(f"Invalid password for {email}")
                    return jsonify({'success': False, 'message': 'Invalid credentials'}), 401
            else:
                logging.warning(f"Email {email} not found")
                return jsonify({'success': False, 'message': 'Invalid credentials'}), 401
        except Exception as e:
            logging.error(f"Unexpected error during login: {str(e)}")
            return jsonify({'success': False, 'message': f'Unexpected error: {str(e)}'}), 500

    @app.route('/check-auth', methods=['GET'])
    @app.route('/api/auth/check-auth', methods=['GET'])
    def check_auth():
        try:
            logging.debug(f"Checking auth with session: {dict(session)}")
            if 'loggedin' in session and 'user_id' in session:
                conn = get_db_connection()
                cursor = conn.cursor(dictionary=True)
                cursor.execute("SELECT email, first_name FROM login_details WHERE id = %s", (session['user_id'],))
                user = cursor.fetchone()
                cursor.close()
                if user:
                    logging.info(f"User {session.get('user_email')} is authenticated")
                    return jsonify({
                        'success': True,
                        'user': {
                            'email': user['email'],
                            'id': session['user_id'],
                            'first_name': user['first_name']
                        }
                    })
                else:
                    logging.warning("User not found in database")  
                    session.clear()
                    return jsonify({'success': False, 'message': 'User not found'}), 401
            logging.warning("User not authenticated")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        except Exception as e:
            logging.error(f"Error in check-auth endpoint: {str(e)}")
            return jsonify({'success': False, 'message': f'Server error: {str(e)}'}), 500

    @app.route('/register', methods=['POST'])
    @app.route('/api/auth/register', methods=['POST'])
    def register():
        first_name = request.form.get('first_name')
        last_name = request.form.get('last_name')
        email = request.form.get('email')
        mobile = request.form.get('mobile')
        password = request.form.get('password')
        confirm_password = request.form.get('confirm_password')

        if not all([first_name, last_name, email, mobile, password, confirm_password]):
            return jsonify({'success': False, 'message': 'All fields are required'}), 400
        if password != confirm_password:
            return jsonify({'success': False, 'message': 'Passwords do not match'}), 400

        hashed_password = bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
        try:
            conn = get_db_connection()
            cursor = conn.cursor()
            cursor.execute("""
                INSERT INTO login_details (first_name, last_name, email, mobile, password)
                VALUES (%s, %s, %s, %s, %s)
            """, (first_name, last_name, email, mobile, hashed_password))
            user_id = cursor.lastrowid
            conn.commit()
            cursor.close()
            session['loggedin'] = True
            session['user_email'] = email
            session['user_id'] = user_id
            return jsonify({
                'success': True,
                'message': 'Registration successful',
                'user': {'email': email, 'id': user_id}
            }), 200
        except mysql.connector.Error as e:
            logging.error(f"Database error during registration: {str(e)}")
            return jsonify({'success': False, 'message': f'Registration error: {str(e)}'}), 500

    @app.route('/logout', methods=['POST'])
    @app.route('/api/auth/logout', methods=['POST'])
    def logout():
        logging.info(f"User {session.get('user_email', 'unknown')} logged out")
        session.clear()
        return jsonify({'success': True, 'message': 'Logged out successfully'})

    # Template routes
    @app.route('/templates', methods=['GET'])
    @app.route('/api/templates', methods=['GET'])
    def get_templates():
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /templates: session missing")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("""
                SELECT template_id, template_name, created_at, status
                FROM excel_templates
                WHERE user_id = %s AND status = 'ACTIVE'
                ORDER BY created_at DESC
                LIMIT 100
            """, (session['user_id'],))
            templates = cursor.fetchall()
            cursor.close()
            logging.info(f"Fetched {len(templates)} templates for user {session['user_id']}")
            return jsonify({'success': True, 'templates': templates})
        except mysql.connector.Error as e:
            logging.error(f'Error fetching templates: {str(e)}')
            return jsonify({'success': False, 'message': f'Error fetching templates: {str(e)}'}), 500
        except Exception as e:
            logging.error(f'Unexpected error fetching templates: {str(e)}')
            return jsonify({'success': False, 'message': f'Unexpected error: {str(e)}'}), 500

    # Rule Configuration routes
    @app.route('/rule-configurations', methods=['GET'])
    @app.route('/api/validation/rule-configurations', methods=['GET'])
    def get_rule_configurations():
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning(f"Unauthorized access to /rule-configurations: session={dict(session)}")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            user_id = session['user_id']
            logging.debug(f"Fetching rule configurations for user_id: {user_id}")

            # Main query to fetch templates with configured rules
            cursor.execute("""
                SELECT 
                    t.template_id, 
                    t.template_name, 
                    t.created_at, 
                    COUNT(cvr.column_validation_id) as rule_count
                FROM excel_templates t
                LEFT JOIN template_columns tc ON t.template_id = tc.template_id
                LEFT JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                WHERE t.user_id = %s AND t.status = 'ACTIVE' AND t.is_corrected = FALSE
                GROUP BY t.template_id, t.template_name, t.created_at
                HAVING rule_count > 0
                ORDER BY t.created_at DESC
                LIMIT 100
            """, (user_id,))
            templates = cursor.fetchall()
            logging.debug(f"Fetched rule-configured templates: {templates}")

            cursor.close()

            if not templates:
                logging.info(f"No templates with rules found for user_id: {user_id}")
            else:
                logging.info(f"Found {len(templates)} templates with rules for user_id: {user_id}")

            return jsonify({'success': True, 'templates': templates})
        except mysql.connector.Error as e:
            logging.error(f"Database error fetching rule configurations: {str(e)}")
            return jsonify({'success': False, 'message': f"Database error: {str(e)}"}), 500
        except Exception as e:
            logging.error(f"Unexpected error fetching rule configurations: {str(e)}")
            return jsonify({'success': False, 'message': f"Unexpected error: {str(e)}"}), 500

    # File upload route
    @app.route('/upload', methods=['POST'])
    @app.route('/api/templates/upload', methods=['POST'])
    @app.route('/api/upload', methods=['POST'])  # Additional common path
    def upload():
        logging.info(f"Upload endpoint called: {request.endpoint}, method: {request.method}")
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /upload: session missing")
            return jsonify({'error': 'Not logged in'}), 401
        if 'file' not in request.files:
            logging.warning("No file provided in upload request")
            return jsonify({'error': 'No file uploaded'}), 400
        file = request.files['file']
        if file.filename == '':
            logging.warning("No file selected in upload request")
            return jsonify({'error': 'No file selected'}), 400
        
        file_path = os.path.join(app.config['UPLOAD_FOLDER'], file.filename)
        try:
            file.save(file_path)
            logging.info(f"File saved: {file_path}")
        except Exception as e:
            logging.error(f"Failed to save file {file.filename}: {str(e)}")
            return jsonify({'error': f'Failed to save file: {str(e)}'}), 500

        try:
            # Read the file to get sheets and headers
            if file.filename.endswith('.xlsx') or file.filename.endswith('.xls'):
                xl = pd.ExcelFile(file_path)
                sheets = {sheet_name: pd.read_excel(file_path, sheet_name=sheet_name, header=None) 
                         for sheet_name in xl.sheet_names}
            elif file.filename.endswith(('.txt', '.csv', '.dat')):
                df = pd.read_csv(file_path, header=None, encoding='utf-8')
                sheets = {'Sheet1': df}
            else:
                logging.error("Unsupported file type")
                return jsonify({'error': 'Unsupported file type'}), 400
            
            logging.debug(f"Sheets extracted: {list(sheets.keys())}")
        except Exception as e:
            logging.error(f"Failed to read file {file_path}: {str(e)}")
            return jsonify({'error': f'Failed to read file: {str(e)}'}), 400

        try:
            sheet_names = list(sheets.keys())
            if not sheet_names:
                logging.error("No sheets found in the file")
                return jsonify({'error': 'No sheets found in the file'}), 400
            sheet_name = sheet_names[0]
            df = sheets[sheet_name]
            
            # Find header row
            header_row = 0
            for i in range(min(len(df), 10)):
                row = df.iloc[i].dropna()
                if not row.empty and all(isinstance(x, str) for x in row if pd.notna(x)):
                    header_row = i
                    break
                    
            headers = df.iloc[header_row].tolist()
            logging.debug(f"Headers extracted: {headers}")
            
            if not headers or all(not h for h in headers):
                logging.error("No valid headers found in file")
                return jsonify({'error': 'No valid headers found in the file'}), 400
        except Exception as e:
            logging.error(f"Error processing file {file.filename}: {str(e)}")
            return jsonify({'error': f'Error processing file: {str(e)}'}), 400

        # Clear existing session data
        for key in ['df', 'header_row', 'headers', 'sheet_name', 'current_step', 'selected_headers', 'validations', 'error_cell_locations', 'data_rows', 'corrected_file_path']:
            session.pop(key, None)

        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)

            # Check if template exists
            cursor.execute("""
                SELECT template_id, headers, sheet_name
                FROM excel_templates
                WHERE template_name = %s AND user_id = %s AND status = 'ACTIVE'
                ORDER BY created_at DESC
            """, (file.filename, session['user_id']))
            existing_templates = cursor.fetchall()
            logging.info(f"Found {len(existing_templates)} existing templates with name {file.filename}")

            template_id = None
            has_existing_rules = False
            validations = {}
            selected_headers = []

            # Check for matching template
            matching_template = None
            for template in existing_templates:
                stored_headers = json.loads(template['headers']) if template['headers'] else []
                stored_sheet_name = template['sheet_name']
                if stored_headers == headers and stored_sheet_name == sheet_name:
                    matching_template = template
                    break

            if matching_template:
                template_id = matching_template['template_id']
                # Check for existing rules
                cursor.execute("""
                    SELECT tc.column_name, vrt.rule_name
                    FROM template_columns tc
                    JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                    JOIN validation_rule_types vrt ON cvr.rule_type_id = vrt.rule_type_id
                    WHERE tc.template_id = %s AND tc.is_selected = TRUE
                """, (template_id,))
                rules_data = cursor.fetchall()
                for row in rules_data:
                    column_name = row['column_name']
                    rule_name = row['rule_name']
                    if column_name not in validations:
                        validations[column_name] = []
                    validations[column_name].append(rule_name)
                    if column_name not in selected_headers:
                        selected_headers.append(column_name)
                has_existing_rules = len(validations) > 0
            else:
                # New template
                cursor.execute("""
                    INSERT INTO excel_templates (template_name, user_id, sheet_name, headers, is_corrected)
                    VALUES (%s, %s, %s, %s, %s)
                """, (file.filename, session['user_id'], sheet_name, json.dumps(headers), False))
                template_id = cursor.lastrowid
                column_data = [(template_id, header, i + 1, False) for i, header in enumerate(headers)]
                cursor.executemany("""
                    INSERT INTO template_columns (template_id, column_name, column_position, is_selected)
                    VALUES (%s, %s, %s, %s)
                """, column_data)

            conn.commit()
            cursor.close()

            # Store session data
            session['file_path'] = file_path
            session['template_id'] = template_id
            session['df'] = df.to_json()
            session['header_row'] = header_row
            session['headers'] = headers
            session['sheet_name'] = sheet_name
            session['current_step'] = 1 if not has_existing_rules else 3
            session['validations'] = validations
            session['selected_headers'] = selected_headers
            session['has_existing_rules'] = has_existing_rules

            logging.info(f"Upload processed: template_id={template_id}, filename={file.filename}, has_existing_rules={has_existing_rules}")

            return jsonify({
                'success': True,
                'sheets': {sheet_name: {'headers': headers}},
                'file_name': file.filename,
                'template_id': template_id,
                'has_existing_rules': has_existing_rules,
                'sheet_name': sheet_name,
                'skip_to_step_3': has_existing_rules
            })
        except mysql.connector.Error as e:
            logging.error(f'Error saving template: {str(e)}')
            return jsonify({'error': f'Error saving template: {str(e)}'}), 500
        except Exception as e:
            logging.error(f'Unexpected error saving template: {str(e)}')
            return jsonify({'error': f'Unexpected error: {str(e)}'}), 500

    # Multi-step workflow endpoints
    @app.route('/step/1', methods=['GET', 'POST'])
    @app.route('/api/step/1', methods=['GET', 'POST'])
    def step_one():
        if 'loggedin' not in session:
            return jsonify({'error': 'Not logged in'}), 401
        
        if request.method == 'POST':
            try:
                headers = request.form.getlist('headers')
                new_header_row = request.form.get('new_header_row')
                logging.debug(f"Step 1 submitted: headers={headers}, new_header_row={new_header_row}")
                
                if not headers:
                    logging.error("No headers provided in step 1")
                    return jsonify({'success': False, 'message': 'No headers provided'}), 400
                    
                if 'template_id' not in session:
                    logging.error("Session missing template_id")
                    return jsonify({'success': False, 'message': 'Session data missing'}), 400

                template_id = session['template_id']
                
                # Get the dataframe from session for auto-detection
                df_json = session.get('df')
                if df_json:
                    df = pd.read_json(StringIO(df_json))
                    session_headers = session.get('headers', [])
                    df.columns = session_headers
                    header_row = session.get('header_row', 0)
                    df = df.iloc[header_row + 1:].reset_index(drop=True)
                    
                    # Auto-detect rules for selected headers
                    validations = assign_default_rules_to_columns(df, headers)
                    session['validations'] = validations
                    logging.debug(f"Auto-assigned rules: {validations}")
                else:
                    validations = {}

                session['selected_headers'] = headers
                session['current_step'] = 2

                # Mark selected headers in the database
                conn = get_db_connection()
                cursor = conn.cursor()
                cursor.execute("UPDATE template_columns SET is_selected = FALSE WHERE template_id = %s", (template_id,))
                for header in headers:
                    cursor.execute("""
                        UPDATE template_columns
                        SET is_selected = TRUE
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    
                    # Get column_id and add auto-detected rules
                    cursor.execute("""
                        SELECT column_id FROM template_columns
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    result = cursor.fetchone()
                    if result:
                        column_id = result[0]
                        for rule_name in validations.get(header, []):
                            cursor.execute("""
                                SELECT rule_type_id FROM validation_rule_types
                                WHERE rule_name = %s AND is_custom = FALSE
                            """, (rule_name,))
                            rule_result = cursor.fetchone()
                            if rule_result:
                                rule_type_id = rule_result[0]
                                cursor.execute("""
                                    INSERT IGNORE INTO column_validation_rules (column_id, rule_type_id, rule_config)
                                    VALUES (%s, %s, %s)
                                """, (column_id, rule_type_id, '{}'))
                
                conn.commit()
                cursor.close()

                logging.info(f"Step 1 completed: headers={headers}, auto-assigned rules={validations}")
                return jsonify({'success': True, 'headers': headers, 'validations': validations})
            except Exception as e:
                logging.error(f"Error in step 1: {str(e)}")
                return jsonify({'success': False, 'message': str(e)}), 500
        
        # GET request - return current headers
        headers = session.get('headers', [])
        return jsonify({'headers': headers})

    @app.route('/step/2', methods=['GET', 'POST'])
    @app.route('/api/step/2', methods=['GET', 'POST'])
    def step_two():
        if 'loggedin' not in session:
            return jsonify({'error': 'Not logged in'}), 401
            
        if request.method == 'POST':
            try:
                action = request.form.get('action', 'save')
                validations = {}
                for key, values in request.form.lists():
                    if key.startswith('validations_'):
                        header = key.replace('validations_', '')
                        validations[header] = values
                        
                logging.debug(f"Step 2 submitted: action={action}, validations={validations}")
                
                template_id = session.get('template_id')
                if not template_id:
                    return jsonify({'success': False, 'message': 'Session data missing'}), 400

                # Save validations to database
                conn = get_db_connection()
                cursor = conn.cursor()
                
                # Clear existing rules
                cursor.execute("""
                    DELETE FROM column_validation_rules
                    WHERE column_id IN (
                        SELECT column_id FROM template_columns WHERE template_id = %s
                    )
                """, (template_id,))
                
                # Add new rules
                for header, rules in validations.items():
                    cursor.execute("""
                        SELECT column_id FROM template_columns
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    result = cursor.fetchone()
                    if not result:
                        continue
                    column_id = result[0]
                    
                    for rule_name in rules:
                        cursor.execute("""
                            SELECT rule_type_id FROM validation_rule_types
                            WHERE rule_name = %s
                        """, (rule_name,))
                        result = cursor.fetchone()
                        if result:
                            rule_type_id = result[0]
                            cursor.execute("""
                                INSERT IGNORE INTO column_validation_rules (column_id, rule_type_id, rule_config)
                                VALUES (%s, %s, %s)
                            """, (column_id, rule_type_id, '{}'))
                
                conn.commit()
                cursor.close()

                session['validations'] = validations
                session['current_step'] = 3 if action == 'review' else 2
                
                logging.info(f"Step 2 completed: action={action}, validations={validations}")
                return jsonify({'success': True, 'message': 'Step 2 completed successfully'})
            except Exception as e:
                logging.error(f"Error in step 2: {str(e)}")
                return jsonify({'success': False, 'message': str(e)}), 500
        
        # GET request
        selected_headers = session.get('selected_headers', [])
        return jsonify({'selected_headers': selected_headers})

    # Rules endpoint
    @app.route('/rules', methods=['GET'])
    @app.route('/api/rules', methods=['GET'])
    def get_rules():
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            
            cursor.execute("""
                SELECT rule_type_id AS rule_id, rule_name, description, parameters, is_custom, 
                       column_name, template_id, source_format, target_format, data_type, is_active
                FROM validation_rule_types
            """)
            rules = cursor.fetchall()
            cursor.close()
            
            logging.info(f"Returning {len(rules)} rules from getRules endpoint")
            return jsonify({'success': True, 'rules': rules})
        except mysql.connector.Error as e:
            logging.error(f"Database error fetching rules: {str(e)}")
            return jsonify({'success': False, 'message': str(e)}), 500
        except Exception as e:
            logging.error(f"Unexpected error fetching rules: {str(e)}")
            return jsonify({'success': False, 'message': str(e)}), 500

    # Template details endpoint
    @app.route('/template/<int:template_id>/<sheet_name>', methods=['GET'])
    @app.route('/api/template/<int:template_id>/<sheet_name>', methods=['GET'])
    def get_template(template_id, sheet_name):
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /template: session missing")
            return jsonify({'error': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("""
                SELECT template_name, sheet_name, headers
                FROM excel_templates
                WHERE template_id = %s AND user_id = %s AND status = 'ACTIVE'
            """, (template_id, session['user_id']))
            template_record = cursor.fetchone()
            
            if not template_record:
                logging.error(f"Template not found for template_id: {template_id}, user_id: {session['user_id']}")
                cursor.close()
                return jsonify({'error': 'Template not found'}), 404

            headers = json.loads(template_record['headers']) if template_record['headers'] else []
            stored_sheet_name = template_record['sheet_name'] or sheet_name
            file_path = os.path.join(app.config['UPLOAD_FOLDER'], template_record['template_name'])
            
            cursor.execute("""
                SELECT COUNT(*) as rule_count
                FROM template_columns tc
                JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                WHERE tc.template_id = %s AND tc.is_selected = TRUE
            """, (template_id,))
            rule_count = cursor.fetchone()['rule_count']
            has_existing_rules = rule_count > 0
            
            cursor.close()
            
            return jsonify({
                'success': True,
                'sheets': {stored_sheet_name: {'headers': headers}},
                'file_name': template_record['template_name'],
                'file_path': file_path,
                'sheet_name': stored_sheet_name,
                'has_existing_rules': has_existing_rules
            })
        except mysql.connector.Error as e:
            logging.error(f"Database error in get_template: {str(e)}")
            return jsonify({'error': f'Database error: {str(e)}'}), 500
        except Exception as e:
            logging.error(f"Unexpected error in get_template: {str(e)}")
            return jsonify({'error': f'Unexpected error: {str(e)}'}), 500

    # Debug route to show all registered routes
    @app.route('/debug/routes', methods=['GET'])
    def list_routes():
        routes = []
        for rule in app.url_map.iter_rules():
            routes.append({
                'endpoint': rule.endpoint,
                'methods': list(rule.methods),
                'rule': rule.rule
            })
        return jsonify(routes)

    # 404 handler to debug missing routes
    @app.errorhandler(404)
    def not_found_handler(error):
        logging.error(f"404 Error: {request.method} {request.url} not found")
        logging.error(f"Available routes: {[rule.rule for rule in app.url_map.iter_rules()]}")
        return jsonify({
            'error': 'Endpoint not found', 
            'method': request.method,
            'url': request.url,
            'path': request.path
        }), 404

    return app

def initialize_app_data():
    """Initialize database and create default data"""
    try:
        logging.info("Initializing database schema...")
        init_db()
        
        logging.info("Creating admin user...")
        create_admin_user()
        
        logging.info("Creating default validation rules...")
        create_default_validation_rules()
        
        logging.info("Application initialization completed successfully")
    except Exception as e:
        logging.error(f"Failed to initialize application: {e}")
        raise

DB_CONFIG = {
    'host': os.getenv('MYSQL_HOST', 'localhost'),
    'user': os.getenv('MYSQL_USER', 'root'),
    'password': os.getenv('MYSQL_PASSWORD', 'Keansa@2024'),
    'database': os.getenv('MYSQL_DATABASE', 'data_validation_2'),
}

def get_db_connection():
    if 'db' not in g:
        try:
            conn = mysql.connector.connect(
                host=DB_CONFIG['host'],
                user=DB_CONFIG['user'],
                password=DB_CONFIG['password']
            )
            cursor = conn.cursor()
            cursor.execute(f"CREATE DATABASE IF NOT EXISTS {DB_CONFIG['database']}")
            cursor.close()
            conn.close()
            g.db = mysql.connector.connect(**DB_CONFIG)
            logging.info("Database connection established successfully")
        except mysql.connector.Error as err:
            if err.errno == errorcode.ER_ACCESS_DENIED_ERROR:
                logging.error("Database connection failed: Access denied for user - check username/password")
            elif err.errno == errorcode.ER_BAD_DB_ERROR:
                logging.error("Database connection failed: Database does not exist")
            else:
                logging.error(f"Database connection failed: {err}")
            raise Exception(f"Failed to connect to database: {str(err)}")
    return g.db

def close_db(error):
    db = g.pop('db', None)
    if db is not None:
        db.close()

def init_db():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        tables = [
            """
            CREATE TABLE IF NOT EXISTS login_details (
                id INT AUTO_INCREMENT PRIMARY KEY,
                first_name VARCHAR(100),
                last_name VARCHAR(100),
                email VARCHAR(255) UNIQUE,
                mobile VARCHAR(10),
                password VARCHAR(255)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS excel_templates (
                template_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_name VARCHAR(255) NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
                user_id INT NOT NULL,
                sheet_name VARCHAR(255),
                headers JSON,
                status ENUM('ACTIVE', 'INACTIVE') DEFAULT 'ACTIVE',
                is_corrected BOOLEAN DEFAULT FALSE,
                remote_file_path VARCHAR(512),
                FOREIGN KEY (user_id) REFERENCES login_details(id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS template_columns (
                column_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_id BIGINT NOT NULL,
                column_name VARCHAR(255) NOT NULL,
                column_position INT NOT NULL,
                is_validation_enabled BOOLEAN DEFAULT FALSE,
                is_selected BOOLEAN DEFAULT FALSE,
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE,
                UNIQUE (template_id, column_name)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_rule_types (
                rule_type_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                rule_name VARCHAR(255) NOT NULL,
                description TEXT,
                parameters TEXT,
                is_active BOOLEAN DEFAULT TRUE,
                is_custom BOOLEAN DEFAULT FALSE,
                column_name VARCHAR(255),
                template_id BIGINT,
                data_type VARCHAR(50),
                source_format VARCHAR(50),
                target_format VARCHAR(50),
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS column_validation_rules (
                column_validation_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                column_id BIGINT NOT NULL,
                rule_type_id BIGINT NOT NULL,
                rule_config JSON,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (column_id) REFERENCES template_columns(column_id) ON DELETE CASCADE,
                FOREIGN KEY (rule_type_id) REFERENCES validation_rule_types(rule_type_id) ON DELETE RESTRICT,
                UNIQUE (column_id, rule_type_id)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_history (
                history_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_id BIGINT NOT NULL,
                template_name VARCHAR(255) NOT NULL,
                error_count INT NOT NULL,
                corrected_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                corrected_file_path VARCHAR(512) NOT NULL,
                user_id INT NOT NULL,
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE,
                FOREIGN KEY (user_id) REFERENCES login_details(id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_corrections (
                correction_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                history_id BIGINT NOT NULL,
                row_index INT NOT NULL,
                column_name VARCHAR(255) NOT NULL,
                original_value TEXT,
                corrected_value TEXT,
                rule_failed VARCHAR(255) DEFAULT NULL,
                FOREIGN KEY (history_id) REFERENCES validation_history(history_id) ON DELETE CASCADE
            )
            """
        ]
        for table_sql in tables:
            cursor.execute(table_sql)
        
        # Add missing columns if they don't exist
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'source_format'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN source_format VARCHAR(50)")
            logging.info("Added source_format column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'target_format'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN target_format VARCHAR(50)")
            logging.info("Added target_format column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'data_type'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN data_type VARCHAR(50)")
            logging.info("Added data_type column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM excel_templates LIKE 'remote_file_path'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE excel_templates ADD COLUMN remote_file_path VARCHAR(512)")
            logging.info("Added remote_file_path column to excel_templates table")
            
        cursor.execute("SHOW COLUMNS FROM template_columns LIKE 'is_selected'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE template_columns ADD COLUMN is_selected BOOLEAN DEFAULT FALSE")
            logging.info("Added is_selected column to template_columns table")
            
        conn.commit()
        cursor.close()
        logging.info("Database tables initialized")
    except Exception as e:
        logging.error(f"Failed to initialize database: {str(e)}")
        raise

def create_admin_user():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        admin_password = bcrypt.hashpw('admin'.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
        cursor.execute("""
            INSERT IGNORE INTO login_details (first_name, last_name, email, mobile, password)
            VALUES (%s, %s, %s, %s, %s)
        """, ('Admin', 'User', 'admin@example.com', '1234567890', admin_password))
        conn.commit()
        cursor.close()
        logging.info("Admin user created or already exists")
    except Exception as e:
        logging.error(f"Failed to create admin user: {str(e)}")
        raise

def create_default_validation_rules():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        default_rules = [
            ("Required", "Ensures the field is not null", '{"allow_null": false}', None, None, None),
            ("Int", "Validates integer format", '{"format": "integer"}', None, None, "Int"),
            ("Float", "Validates number format (integer or decimal)", '{"format": "float"}', None, None, "Float"),
            ("Text", "Allows text with quotes and parentheses", '{"allow_special": false}', None, None, "Text"),
            ("Email", "Validates email format", '{"regex": "^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\\\.[a-zA-Z0-9-.]+$"}', None, None, "Email"),
            ("Date(DD-MM-YYYY)", "Validates date format DD-MM-YYYY", '{"format": "%d-%m-%Y"}', "DD-MM-YYYY", None, "Date"),
            ("Boolean", "Validates boolean format (true/false or 0/1)", '{"format": "boolean"}', None, None, "Boolean"),
            ("Alphanumeric", "Validates alphanumeric format", '{"format": "alphanumeric"}', None, None, "Alphanumeric")
        ]
        cursor.executemany("""
            INSERT IGNORE INTO validation_rule_types (rule_name, description, parameters, is_custom, source_format, target_format, data_type)
            VALUES (%s, %s, %s, %s, %s, %s, %s)
        """, [(name, desc, params, False, source, target, dtype) for name, desc, params, source, target, dtype in default_rules])
        conn.commit()
        cursor.close()
        logging.info("Default validation rules ensured successfully")
    except Exception as e:
        logging.error(f"Failed to ensure default validation rules: {str(e)}")
        raise

if __name__ == '__main__':
    try:
        # Create the application using factory pattern
        app = create_app()
        
        # Initialize database and default data within app context
        with app.app_context():
            initialize_app_data()
        
        # Get port from environment or use default
        port = int(os.getenv('PORT', 5000))
        
        # Start the application server
        logging.info("Starting Flask server...")
        app.run(debug=True, host='0.0.0.0', port=port)
        
    except Exception as e:
        logging.error(f"Failed to start application: {e}")
        raise
).all():
        return "Int"
    
    if non_null.str.match(r'^-?\d+(\.\d+)?

def create_app():
    """Application factory pattern for different environments"""
    # Set the path to the frontend dist folder
    current_dir = os.path.dirname(os.path.abspath(__file__))
    frontend_dist_path = os.path.join(current_dir, '..', '..', 'Keansa-Ai-Suite2025may-frontend11', 'dist')
    frontend_dist_path = os.path.abspath(frontend_dist_path)
    
    # Create Flask application instance
    app = Flask(__name__, static_folder=frontend_dist_path, static_url_path='')
    CORS(app, supports_credentials=True, origins=["http://localhost:3000", "http://localhost:8080", "http://localhost:5000", "*"])

    app.secret_key = os.urandom(24).hex()
    app.config['SESSION_TYPE'] = 'filesystem'
    app.config['SESSION_FILE_DIR'] = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'sessions')
    app.config['SESSION_COOKIE_SAMESITE'] = 'Lax'
    app.config['SESSION_COOKIE_HTTPONLY'] = True
    app.config['SESSION_COOKIE_SECURE'] = False
    app.config['PERMANENT_SESSION_LIFETIME'] = 86400  # 24 hours
    app.config['UPLOAD_FOLDER'] = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'uploads')
    Session(app)

    # Ensure directories exist
    try:
        os.makedirs(app.config['UPLOAD_FOLDER'], exist_ok=True)
        os.makedirs(app.config['SESSION_FILE_DIR'], exist_ok=True)
    except OSError as e:
        logging.error(f"Failed to create directories: {e}")

    # Register cleanup handlers
    app.teardown_appcontext(close_db)
    
    # Register all routes directly in create_app
    
    # Static file serving for React frontend
    @app.route('/', defaults={'path': ''})
    @app.route('/<path:path>')
    def serve(path):
        if path and os.path.exists(os.path.join(app.static_folder, path)):
            return app.send_static_file(path)
        return app.send_static_file('index.html')

    # Health check endpoint
    @app.route('/health', methods=['GET'])
    def health_check():
        return jsonify({
            'status': 'healthy',
            'timestamp': datetime.now().isoformat(),
            'version': '2.0.0'
        })

    # Authentication endpoint - both old and new paths
    @app.route('/authenticate', methods=['POST'])
    @app.route('/api/auth/authenticate', methods=['POST'])
    def authenticate():
        try:
            email = request.form.get('username') or request.form.get('email')
            password = request.form.get('password')
            logging.debug(f"Login attempt: email={email}, password={'*' * len(password) if password else 'None'}")
            
            if not email or not password:
                logging.warning(f"Login failed: Email or password missing")
                return jsonify({'success': False, 'message': 'Email and password are required'}), 400

            # Check for admin login
            if email == "admin" and password == "admin":
                session['loggedin'] = True
                session['user_email'] = "admin@example.com"
                session['user_id'] = 1
                session.permanent = True
                logging.info(f"Admin login successful. Session: {dict(session)}")
                return jsonify({'success': True, 'message': 'Login successful', 'user': {'email': 'admin@example.com', 'id': 1}}), 200

            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("SELECT * FROM login_details WHERE LOWER(email) = LOWER(%s)", (email.lower(),))
            account = cursor.fetchone()
            cursor.close()
            
            if account:
                if bcrypt.checkpw(password.encode('utf-8'), account['password'].encode('utf-8')):
                    session['loggedin'] = True
                    session['user_email'] = account['email']
                    session['user_id'] = account['id']
                    session.permanent = True
                    logging.info(f"User {email} logged in successfully. Session: {dict(session)}")
                    return jsonify({
                        'success': True,
                        'message': 'Login successful',
                        'user': {'email': account['email'], 'id': account['id']}
                    }), 200
                else:
                    logging.warning(f"Invalid password for {email}")
                    return jsonify({'success': False, 'message': 'Invalid credentials'}), 401
            else:
                logging.warning(f"Email {email} not found")
                return jsonify({'success': False, 'message': 'Invalid credentials'}), 401
        except Exception as e:
            logging.error(f"Unexpected error during login: {str(e)}")
            return jsonify({'success': False, 'message': f'Unexpected error: {str(e)}'}), 500

    @app.route('/check-auth', methods=['GET'])
    @app.route('/api/auth/check-auth', methods=['GET'])
    def check_auth():
        try:
            logging.debug(f"Checking auth with session: {dict(session)}")
            if 'loggedin' in session and 'user_id' in session:
                conn = get_db_connection()
                cursor = conn.cursor(dictionary=True)
                cursor.execute("SELECT email, first_name FROM login_details WHERE id = %s", (session['user_id'],))
                user = cursor.fetchone()
                cursor.close()
                if user:
                    logging.info(f"User {session.get('user_email')} is authenticated")
                    return jsonify({
                        'success': True,
                        'user': {
                            'email': user['email'],
                            'id': session['user_id'],
                            'first_name': user['first_name']
                        }
                    })
                else:
                    logging.warning("User not found in database")  
                    session.clear()
                    return jsonify({'success': False, 'message': 'User not found'}), 401
            logging.warning("User not authenticated")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        except Exception as e:
            logging.error(f"Error in check-auth endpoint: {str(e)}")
            return jsonify({'success': False, 'message': f'Server error: {str(e)}'}), 500

    @app.route('/register', methods=['POST'])
    @app.route('/api/auth/register', methods=['POST'])
    def register():
        first_name = request.form.get('first_name')
        last_name = request.form.get('last_name')
        email = request.form.get('email')
        mobile = request.form.get('mobile')
        password = request.form.get('password')
        confirm_password = request.form.get('confirm_password')

        if not all([first_name, last_name, email, mobile, password, confirm_password]):
            return jsonify({'success': False, 'message': 'All fields are required'}), 400
        if password != confirm_password:
            return jsonify({'success': False, 'message': 'Passwords do not match'}), 400

        hashed_password = bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
        try:
            conn = get_db_connection()
            cursor = conn.cursor()
            cursor.execute("""
                INSERT INTO login_details (first_name, last_name, email, mobile, password)
                VALUES (%s, %s, %s, %s, %s)
            """, (first_name, last_name, email, mobile, hashed_password))
            user_id = cursor.lastrowid
            conn.commit()
            cursor.close()
            session['loggedin'] = True
            session['user_email'] = email
            session['user_id'] = user_id
            return jsonify({
                'success': True,
                'message': 'Registration successful',
                'user': {'email': email, 'id': user_id}
            }), 200
        except mysql.connector.Error as e:
            logging.error(f"Database error during registration: {str(e)}")
            return jsonify({'success': False, 'message': f'Registration error: {str(e)}'}), 500

    @app.route('/logout', methods=['POST'])
    @app.route('/api/auth/logout', methods=['POST'])
    def logout():
        logging.info(f"User {session.get('user_email', 'unknown')} logged out")
        session.clear()
        return jsonify({'success': True, 'message': 'Logged out successfully'})

    # Template routes
    @app.route('/templates', methods=['GET'])
    @app.route('/api/templates', methods=['GET'])
    def get_templates():
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /templates: session missing")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("""
                SELECT template_id, template_name, created_at, status
                FROM excel_templates
                WHERE user_id = %s AND status = 'ACTIVE'
                ORDER BY created_at DESC
                LIMIT 100
            """, (session['user_id'],))
            templates = cursor.fetchall()
            cursor.close()
            logging.info(f"Fetched {len(templates)} templates for user {session['user_id']}")
            return jsonify({'success': True, 'templates': templates})
        except mysql.connector.Error as e:
            logging.error(f'Error fetching templates: {str(e)}')
            return jsonify({'success': False, 'message': f'Error fetching templates: {str(e)}'}), 500
        except Exception as e:
            logging.error(f'Unexpected error fetching templates: {str(e)}')
            return jsonify({'success': False, 'message': f'Unexpected error: {str(e)}'}), 500

    # Rule Configuration routes
    @app.route('/rule-configurations', methods=['GET'])
    @app.route('/api/validation/rule-configurations', methods=['GET'])
    def get_rule_configurations():
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning(f"Unauthorized access to /rule-configurations: session={dict(session)}")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            user_id = session['user_id']
            logging.debug(f"Fetching rule configurations for user_id: {user_id}")

            # Main query to fetch templates with configured rules
            cursor.execute("""
                SELECT 
                    t.template_id, 
                    t.template_name, 
                    t.created_at, 
                    COUNT(cvr.column_validation_id) as rule_count
                FROM excel_templates t
                LEFT JOIN template_columns tc ON t.template_id = tc.template_id
                LEFT JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                WHERE t.user_id = %s AND t.status = 'ACTIVE' AND t.is_corrected = FALSE
                GROUP BY t.template_id, t.template_name, t.created_at
                HAVING rule_count > 0
                ORDER BY t.created_at DESC
                LIMIT 100
            """, (user_id,))
            templates = cursor.fetchall()
            logging.debug(f"Fetched rule-configured templates: {templates}")

            cursor.close()

            if not templates:
                logging.info(f"No templates with rules found for user_id: {user_id}")
            else:
                logging.info(f"Found {len(templates)} templates with rules for user_id: {user_id}")

            return jsonify({'success': True, 'templates': templates})
        except mysql.connector.Error as e:
            logging.error(f"Database error fetching rule configurations: {str(e)}")
            return jsonify({'success': False, 'message': f"Database error: {str(e)}"}), 500
        except Exception as e:
            logging.error(f"Unexpected error fetching rule configurations: {str(e)}")
            return jsonify({'success': False, 'message': f"Unexpected error: {str(e)}"}), 500

    # File upload route
    @app.route('/upload', methods=['POST'])
    @app.route('/api/templates/upload', methods=['POST'])
    @app.route('/api/upload', methods=['POST'])  # Additional common path
    def upload():
        logging.info(f"Upload endpoint called: {request.endpoint}, method: {request.method}")
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /upload: session missing")
            return jsonify({'error': 'Not logged in'}), 401
        if 'file' not in request.files:
            logging.warning("No file provided in upload request")
            return jsonify({'error': 'No file uploaded'}), 400
        file = request.files['file']
        if file.filename == '':
            logging.warning("No file selected in upload request")
            return jsonify({'error': 'No file selected'}), 400
        
        file_path = os.path.join(app.config['UPLOAD_FOLDER'], file.filename)
        try:
            file.save(file_path)
            logging.info(f"File saved: {file_path}")
        except Exception as e:
            logging.error(f"Failed to save file {file.filename}: {str(e)}")
            return jsonify({'error': f'Failed to save file: {str(e)}'}), 500

        try:
            # Read the file to get sheets and headers
            if file.filename.endswith('.xlsx') or file.filename.endswith('.xls'):
                xl = pd.ExcelFile(file_path)
                sheets = {sheet_name: pd.read_excel(file_path, sheet_name=sheet_name, header=None) 
                         for sheet_name in xl.sheet_names}
            elif file.filename.endswith(('.txt', '.csv', '.dat')):
                df = pd.read_csv(file_path, header=None, encoding='utf-8')
                sheets = {'Sheet1': df}
            else:
                logging.error("Unsupported file type")
                return jsonify({'error': 'Unsupported file type'}), 400
            
            logging.debug(f"Sheets extracted: {list(sheets.keys())}")
        except Exception as e:
            logging.error(f"Failed to read file {file_path}: {str(e)}")
            return jsonify({'error': f'Failed to read file: {str(e)}'}), 400

        try:
            sheet_names = list(sheets.keys())
            if not sheet_names:
                logging.error("No sheets found in the file")
                return jsonify({'error': 'No sheets found in the file'}), 400
            sheet_name = sheet_names[0]
            df = sheets[sheet_name]
            
            # Find header row
            header_row = 0
            for i in range(min(len(df), 10)):
                row = df.iloc[i].dropna()
                if not row.empty and all(isinstance(x, str) for x in row if pd.notna(x)):
                    header_row = i
                    break
                    
            headers = df.iloc[header_row].tolist()
            logging.debug(f"Headers extracted: {headers}")
            
            if not headers or all(not h for h in headers):
                logging.error("No valid headers found in file")
                return jsonify({'error': 'No valid headers found in the file'}), 400
        except Exception as e:
            logging.error(f"Error processing file {file.filename}: {str(e)}")
            return jsonify({'error': f'Error processing file: {str(e)}'}), 400

        # Clear existing session data
        for key in ['df', 'header_row', 'headers', 'sheet_name', 'current_step', 'selected_headers', 'validations', 'error_cell_locations', 'data_rows', 'corrected_file_path']:
            session.pop(key, None)

        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)

            # Check if template exists
            cursor.execute("""
                SELECT template_id, headers, sheet_name
                FROM excel_templates
                WHERE template_name = %s AND user_id = %s AND status = 'ACTIVE'
                ORDER BY created_at DESC
            """, (file.filename, session['user_id']))
            existing_templates = cursor.fetchall()
            logging.info(f"Found {len(existing_templates)} existing templates with name {file.filename}")

            template_id = None
            has_existing_rules = False
            validations = {}
            selected_headers = []

            # Check for matching template
            matching_template = None
            for template in existing_templates:
                stored_headers = json.loads(template['headers']) if template['headers'] else []
                stored_sheet_name = template['sheet_name']
                if stored_headers == headers and stored_sheet_name == sheet_name:
                    matching_template = template
                    break

            if matching_template:
                template_id = matching_template['template_id']
                # Check for existing rules
                cursor.execute("""
                    SELECT tc.column_name, vrt.rule_name
                    FROM template_columns tc
                    JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                    JOIN validation_rule_types vrt ON cvr.rule_type_id = vrt.rule_type_id
                    WHERE tc.template_id = %s AND tc.is_selected = TRUE
                """, (template_id,))
                rules_data = cursor.fetchall()
                for row in rules_data:
                    column_name = row['column_name']
                    rule_name = row['rule_name']
                    if column_name not in validations:
                        validations[column_name] = []
                    validations[column_name].append(rule_name)
                    if column_name not in selected_headers:
                        selected_headers.append(column_name)
                has_existing_rules = len(validations) > 0
            else:
                # New template
                cursor.execute("""
                    INSERT INTO excel_templates (template_name, user_id, sheet_name, headers, is_corrected)
                    VALUES (%s, %s, %s, %s, %s)
                """, (file.filename, session['user_id'], sheet_name, json.dumps(headers), False))
                template_id = cursor.lastrowid
                column_data = [(template_id, header, i + 1, False) for i, header in enumerate(headers)]
                cursor.executemany("""
                    INSERT INTO template_columns (template_id, column_name, column_position, is_selected)
                    VALUES (%s, %s, %s, %s)
                """, column_data)

            conn.commit()
            cursor.close()

            # Store session data
            session['file_path'] = file_path
            session['template_id'] = template_id
            session['df'] = df.to_json()
            session['header_row'] = header_row
            session['headers'] = headers
            session['sheet_name'] = sheet_name
            session['current_step'] = 1 if not has_existing_rules else 3
            session['validations'] = validations
            session['selected_headers'] = selected_headers
            session['has_existing_rules'] = has_existing_rules

            logging.info(f"Upload processed: template_id={template_id}, filename={file.filename}, has_existing_rules={has_existing_rules}")

            return jsonify({
                'success': True,
                'sheets': {sheet_name: {'headers': headers}},
                'file_name': file.filename,
                'template_id': template_id,
                'has_existing_rules': has_existing_rules,
                'sheet_name': sheet_name,
                'skip_to_step_3': has_existing_rules
            })
        except mysql.connector.Error as e:
            logging.error(f'Error saving template: {str(e)}')
            return jsonify({'error': f'Error saving template: {str(e)}'}), 500
        except Exception as e:
            logging.error(f'Unexpected error saving template: {str(e)}')
            return jsonify({'error': f'Unexpected error: {str(e)}'}), 500

    # Multi-step workflow endpoints
    @app.route('/step/1', methods=['GET', 'POST'])
    @app.route('/api/step/1', methods=['GET', 'POST'])
    def step_one():
        if 'loggedin' not in session:
            return jsonify({'error': 'Not logged in'}), 401
        
        if request.method == 'POST':
            try:
                headers = request.form.getlist('headers')
                new_header_row = request.form.get('new_header_row')
                logging.debug(f"Step 1 submitted: headers={headers}, new_header_row={new_header_row}")
                
                if not headers:
                    logging.error("No headers provided in step 1")
                    return jsonify({'success': False, 'message': 'No headers provided'}), 400
                    
                if 'template_id' not in session:
                    logging.error("Session missing template_id")
                    return jsonify({'success': False, 'message': 'Session data missing'}), 400

                template_id = session['template_id']
                
                # Get the dataframe from session for auto-detection
                df_json = session.get('df')
                if df_json:
                    df = pd.read_json(StringIO(df_json))
                    session_headers = session.get('headers', [])
                    df.columns = session_headers
                    header_row = session.get('header_row', 0)
                    df = df.iloc[header_row + 1:].reset_index(drop=True)
                    
                    # Auto-detect rules for selected headers
                    validations = assign_default_rules_to_columns(df, headers)
                    session['validations'] = validations
                    logging.debug(f"Auto-assigned rules: {validations}")
                else:
                    validations = {}

                session['selected_headers'] = headers
                session['current_step'] = 2

                # Mark selected headers in the database
                conn = get_db_connection()
                cursor = conn.cursor()
                cursor.execute("UPDATE template_columns SET is_selected = FALSE WHERE template_id = %s", (template_id,))
                for header in headers:
                    cursor.execute("""
                        UPDATE template_columns
                        SET is_selected = TRUE
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    
                    # Get column_id and add auto-detected rules
                    cursor.execute("""
                        SELECT column_id FROM template_columns
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    result = cursor.fetchone()
                    if result:
                        column_id = result[0]
                        for rule_name in validations.get(header, []):
                            cursor.execute("""
                                SELECT rule_type_id FROM validation_rule_types
                                WHERE rule_name = %s AND is_custom = FALSE
                            """, (rule_name,))
                            rule_result = cursor.fetchone()
                            if rule_result:
                                rule_type_id = rule_result[0]
                                cursor.execute("""
                                    INSERT IGNORE INTO column_validation_rules (column_id, rule_type_id, rule_config)
                                    VALUES (%s, %s, %s)
                                """, (column_id, rule_type_id, '{}'))
                
                conn.commit()
                cursor.close()

                logging.info(f"Step 1 completed: headers={headers}, auto-assigned rules={validations}")
                return jsonify({'success': True, 'headers': headers, 'validations': validations})
            except Exception as e:
                logging.error(f"Error in step 1: {str(e)}")
                return jsonify({'success': False, 'message': str(e)}), 500
        
        # GET request - return current headers
        headers = session.get('headers', [])
        return jsonify({'headers': headers})

    @app.route('/step/2', methods=['GET', 'POST'])
    @app.route('/api/step/2', methods=['GET', 'POST'])
    def step_two():
        if 'loggedin' not in session:
            return jsonify({'error': 'Not logged in'}), 401
            
        if request.method == 'POST':
            try:
                action = request.form.get('action', 'save')
                validations = {}
                for key, values in request.form.lists():
                    if key.startswith('validations_'):
                        header = key.replace('validations_', '')
                        validations[header] = values
                        
                logging.debug(f"Step 2 submitted: action={action}, validations={validations}")
                
                template_id = session.get('template_id')
                if not template_id:
                    return jsonify({'success': False, 'message': 'Session data missing'}), 400

                # Save validations to database
                conn = get_db_connection()
                cursor = conn.cursor()
                
                # Clear existing rules
                cursor.execute("""
                    DELETE FROM column_validation_rules
                    WHERE column_id IN (
                        SELECT column_id FROM template_columns WHERE template_id = %s
                    )
                """, (template_id,))
                
                # Add new rules
                for header, rules in validations.items():
                    cursor.execute("""
                        SELECT column_id FROM template_columns
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    result = cursor.fetchone()
                    if not result:
                        continue
                    column_id = result[0]
                    
                    for rule_name in rules:
                        cursor.execute("""
                            SELECT rule_type_id FROM validation_rule_types
                            WHERE rule_name = %s
                        """, (rule_name,))
                        result = cursor.fetchone()
                        if result:
                            rule_type_id = result[0]
                            cursor.execute("""
                                INSERT IGNORE INTO column_validation_rules (column_id, rule_type_id, rule_config)
                                VALUES (%s, %s, %s)
                            """, (column_id, rule_type_id, '{}'))
                
                conn.commit()
                cursor.close()

                session['validations'] = validations
                session['current_step'] = 3 if action == 'review' else 2
                
                logging.info(f"Step 2 completed: action={action}, validations={validations}")
                return jsonify({'success': True, 'message': 'Step 2 completed successfully'})
            except Exception as e:
                logging.error(f"Error in step 2: {str(e)}")
                return jsonify({'success': False, 'message': str(e)}), 500
        
        # GET request
        selected_headers = session.get('selected_headers', [])
        return jsonify({'selected_headers': selected_headers})

    # Rules endpoint
    @app.route('/rules', methods=['GET'])
    @app.route('/api/rules', methods=['GET'])
    def get_rules():
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            
            cursor.execute("""
                SELECT rule_type_id AS rule_id, rule_name, description, parameters, is_custom, 
                       column_name, template_id, source_format, target_format, data_type, is_active
                FROM validation_rule_types
            """)
            rules = cursor.fetchall()
            cursor.close()
            
            logging.info(f"Returning {len(rules)} rules from getRules endpoint")
            return jsonify({'success': True, 'rules': rules})
        except mysql.connector.Error as e:
            logging.error(f"Database error fetching rules: {str(e)}")
            return jsonify({'success': False, 'message': str(e)}), 500
        except Exception as e:
            logging.error(f"Unexpected error fetching rules: {str(e)}")
            return jsonify({'success': False, 'message': str(e)}), 500

    # Template details endpoint
    @app.route('/template/<int:template_id>/<sheet_name>', methods=['GET'])
    @app.route('/api/template/<int:template_id>/<sheet_name>', methods=['GET'])
    def get_template(template_id, sheet_name):
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /template: session missing")
            return jsonify({'error': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("""
                SELECT template_name, sheet_name, headers
                FROM excel_templates
                WHERE template_id = %s AND user_id = %s AND status = 'ACTIVE'
            """, (template_id, session['user_id']))
            template_record = cursor.fetchone()
            
            if not template_record:
                logging.error(f"Template not found for template_id: {template_id}, user_id: {session['user_id']}")
                cursor.close()
                return jsonify({'error': 'Template not found'}), 404

            headers = json.loads(template_record['headers']) if template_record['headers'] else []
            stored_sheet_name = template_record['sheet_name'] or sheet_name
            file_path = os.path.join(app.config['UPLOAD_FOLDER'], template_record['template_name'])
            
            cursor.execute("""
                SELECT COUNT(*) as rule_count
                FROM template_columns tc
                JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                WHERE tc.template_id = %s AND tc.is_selected = TRUE
            """, (template_id,))
            rule_count = cursor.fetchone()['rule_count']
            has_existing_rules = rule_count > 0
            
            cursor.close()
            
            return jsonify({
                'success': True,
                'sheets': {stored_sheet_name: {'headers': headers}},
                'file_name': template_record['template_name'],
                'file_path': file_path,
                'sheet_name': stored_sheet_name,
                'has_existing_rules': has_existing_rules
            })
        except mysql.connector.Error as e:
            logging.error(f"Database error in get_template: {str(e)}")
            return jsonify({'error': f'Database error: {str(e)}'}), 500
        except Exception as e:
            logging.error(f"Unexpected error in get_template: {str(e)}")
            return jsonify({'error': f'Unexpected error: {str(e)}'}), 500

    # Debug route to show all registered routes
    @app.route('/debug/routes', methods=['GET'])
    def list_routes():
        routes = []
        for rule in app.url_map.iter_rules():
            routes.append({
                'endpoint': rule.endpoint,
                'methods': list(rule.methods),
                'rule': rule.rule
            })
        return jsonify(routes)

    # 404 handler to debug missing routes
    @app.errorhandler(404)
    def not_found_handler(error):
        logging.error(f"404 Error: {request.method} {request.url} not found")
        logging.error(f"Available routes: {[rule.rule for rule in app.url_map.iter_rules()]}")
        return jsonify({
            'error': 'Endpoint not found', 
            'method': request.method,
            'url': request.url,
            'path': request.path
        }), 404

    return app

def initialize_app_data():
    """Initialize database and create default data"""
    try:
        logging.info("Initializing database schema...")
        init_db()
        
        logging.info("Creating admin user...")
        create_admin_user()
        
        logging.info("Creating default validation rules...")
        create_default_validation_rules()
        
        logging.info("Application initialization completed successfully")
    except Exception as e:
        logging.error(f"Failed to initialize application: {e}")
        raise

DB_CONFIG = {
    'host': os.getenv('MYSQL_HOST', 'localhost'),
    'user': os.getenv('MYSQL_USER', 'root'),
    'password': os.getenv('MYSQL_PASSWORD', 'Keansa@2024'),
    'database': os.getenv('MYSQL_DATABASE', 'data_validation_2'),
}

def get_db_connection():
    if 'db' not in g:
        try:
            conn = mysql.connector.connect(
                host=DB_CONFIG['host'],
                user=DB_CONFIG['user'],
                password=DB_CONFIG['password']
            )
            cursor = conn.cursor()
            cursor.execute(f"CREATE DATABASE IF NOT EXISTS {DB_CONFIG['database']}")
            cursor.close()
            conn.close()
            g.db = mysql.connector.connect(**DB_CONFIG)
            logging.info("Database connection established successfully")
        except mysql.connector.Error as err:
            if err.errno == errorcode.ER_ACCESS_DENIED_ERROR:
                logging.error("Database connection failed: Access denied for user - check username/password")
            elif err.errno == errorcode.ER_BAD_DB_ERROR:
                logging.error("Database connection failed: Database does not exist")
            else:
                logging.error(f"Database connection failed: {err}")
            raise Exception(f"Failed to connect to database: {str(err)}")
    return g.db

def close_db(error):
    db = g.pop('db', None)
    if db is not None:
        db.close()

def init_db():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        tables = [
            """
            CREATE TABLE IF NOT EXISTS login_details (
                id INT AUTO_INCREMENT PRIMARY KEY,
                first_name VARCHAR(100),
                last_name VARCHAR(100),
                email VARCHAR(255) UNIQUE,
                mobile VARCHAR(10),
                password VARCHAR(255)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS excel_templates (
                template_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_name VARCHAR(255) NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
                user_id INT NOT NULL,
                sheet_name VARCHAR(255),
                headers JSON,
                status ENUM('ACTIVE', 'INACTIVE') DEFAULT 'ACTIVE',
                is_corrected BOOLEAN DEFAULT FALSE,
                remote_file_path VARCHAR(512),
                FOREIGN KEY (user_id) REFERENCES login_details(id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS template_columns (
                column_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_id BIGINT NOT NULL,
                column_name VARCHAR(255) NOT NULL,
                column_position INT NOT NULL,
                is_validation_enabled BOOLEAN DEFAULT FALSE,
                is_selected BOOLEAN DEFAULT FALSE,
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE,
                UNIQUE (template_id, column_name)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_rule_types (
                rule_type_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                rule_name VARCHAR(255) NOT NULL,
                description TEXT,
                parameters TEXT,
                is_active BOOLEAN DEFAULT TRUE,
                is_custom BOOLEAN DEFAULT FALSE,
                column_name VARCHAR(255),
                template_id BIGINT,
                data_type VARCHAR(50),
                source_format VARCHAR(50),
                target_format VARCHAR(50),
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS column_validation_rules (
                column_validation_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                column_id BIGINT NOT NULL,
                rule_type_id BIGINT NOT NULL,
                rule_config JSON,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (column_id) REFERENCES template_columns(column_id) ON DELETE CASCADE,
                FOREIGN KEY (rule_type_id) REFERENCES validation_rule_types(rule_type_id) ON DELETE RESTRICT,
                UNIQUE (column_id, rule_type_id)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_history (
                history_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_id BIGINT NOT NULL,
                template_name VARCHAR(255) NOT NULL,
                error_count INT NOT NULL,
                corrected_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                corrected_file_path VARCHAR(512) NOT NULL,
                user_id INT NOT NULL,
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE,
                FOREIGN KEY (user_id) REFERENCES login_details(id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_corrections (
                correction_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                history_id BIGINT NOT NULL,
                row_index INT NOT NULL,
                column_name VARCHAR(255) NOT NULL,
                original_value TEXT,
                corrected_value TEXT,
                rule_failed VARCHAR(255) DEFAULT NULL,
                FOREIGN KEY (history_id) REFERENCES validation_history(history_id) ON DELETE CASCADE
            )
            """
        ]
        for table_sql in tables:
            cursor.execute(table_sql)
        
        # Add missing columns if they don't exist
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'source_format'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN source_format VARCHAR(50)")
            logging.info("Added source_format column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'target_format'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN target_format VARCHAR(50)")
            logging.info("Added target_format column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'data_type'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN data_type VARCHAR(50)")
            logging.info("Added data_type column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM excel_templates LIKE 'remote_file_path'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE excel_templates ADD COLUMN remote_file_path VARCHAR(512)")
            logging.info("Added remote_file_path column to excel_templates table")
            
        cursor.execute("SHOW COLUMNS FROM template_columns LIKE 'is_selected'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE template_columns ADD COLUMN is_selected BOOLEAN DEFAULT FALSE")
            logging.info("Added is_selected column to template_columns table")
            
        conn.commit()
        cursor.close()
        logging.info("Database tables initialized")
    except Exception as e:
        logging.error(f"Failed to initialize database: {str(e)}")
        raise

def create_admin_user():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        admin_password = bcrypt.hashpw('admin'.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
        cursor.execute("""
            INSERT IGNORE INTO login_details (first_name, last_name, email, mobile, password)
            VALUES (%s, %s, %s, %s, %s)
        """, ('Admin', 'User', 'admin@example.com', '1234567890', admin_password))
        conn.commit()
        cursor.close()
        logging.info("Admin user created or already exists")
    except Exception as e:
        logging.error(f"Failed to create admin user: {str(e)}")
        raise

def create_default_validation_rules():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        default_rules = [
            ("Required", "Ensures the field is not null", '{"allow_null": false}', None, None, None),
            ("Int", "Validates integer format", '{"format": "integer"}', None, None, "Int"),
            ("Float", "Validates number format (integer or decimal)", '{"format": "float"}', None, None, "Float"),
            ("Text", "Allows text with quotes and parentheses", '{"allow_special": false}', None, None, "Text"),
            ("Email", "Validates email format", '{"regex": "^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\\\.[a-zA-Z0-9-.]+$"}', None, None, "Email"),
            ("Date(DD-MM-YYYY)", "Validates date format DD-MM-YYYY", '{"format": "%d-%m-%Y"}', "DD-MM-YYYY", None, "Date"),
            ("Boolean", "Validates boolean format (true/false or 0/1)", '{"format": "boolean"}', None, None, "Boolean"),
            ("Alphanumeric", "Validates alphanumeric format", '{"format": "alphanumeric"}', None, None, "Alphanumeric")
        ]
        cursor.executemany("""
            INSERT IGNORE INTO validation_rule_types (rule_name, description, parameters, is_custom, source_format, target_format, data_type)
            VALUES (%s, %s, %s, %s, %s, %s, %s)
        """, [(name, desc, params, False, source, target, dtype) for name, desc, params, source, target, dtype in default_rules])
        conn.commit()
        cursor.close()
        logging.info("Default validation rules ensured successfully")
    except Exception as e:
        logging.error(f"Failed to ensure default validation rules: {str(e)}")
        raise

if __name__ == '__main__':
    try:
        # Create the application using factory pattern
        app = create_app()
        
        # Initialize database and default data within app context
        with app.app_context():
            initialize_app_data()
        
        # Get port from environment or use default
        port = int(os.getenv('PORT', 5000))
        
        # Start the application server
        logging.info("Starting Flask server...")
        app.run(debug=True, host='0.0.0.0', port=port)
        
    except Exception as e:
        logging.error(f"Failed to start application: {e}")
        raise
).all():
        return "Float"
    
    # Alphanumeric detection
    if non_null.str.match(r'^[a-zA-Z0-9]+

def create_app():
    """Application factory pattern for different environments"""
    # Set the path to the frontend dist folder
    current_dir = os.path.dirname(os.path.abspath(__file__))
    frontend_dist_path = os.path.join(current_dir, '..', '..', 'Keansa-Ai-Suite2025may-frontend11', 'dist')
    frontend_dist_path = os.path.abspath(frontend_dist_path)
    
    # Create Flask application instance
    app = Flask(__name__, static_folder=frontend_dist_path, static_url_path='')
    CORS(app, supports_credentials=True, origins=["http://localhost:3000", "http://localhost:8080", "http://localhost:5000", "*"])

    app.secret_key = os.urandom(24).hex()
    app.config['SESSION_TYPE'] = 'filesystem'
    app.config['SESSION_FILE_DIR'] = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'sessions')
    app.config['SESSION_COOKIE_SAMESITE'] = 'Lax'
    app.config['SESSION_COOKIE_HTTPONLY'] = True
    app.config['SESSION_COOKIE_SECURE'] = False
    app.config['PERMANENT_SESSION_LIFETIME'] = 86400  # 24 hours
    app.config['UPLOAD_FOLDER'] = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'uploads')
    Session(app)

    # Ensure directories exist
    try:
        os.makedirs(app.config['UPLOAD_FOLDER'], exist_ok=True)
        os.makedirs(app.config['SESSION_FILE_DIR'], exist_ok=True)
    except OSError as e:
        logging.error(f"Failed to create directories: {e}")

    # Register cleanup handlers
    app.teardown_appcontext(close_db)
    
    # Register all routes directly in create_app
    
    # Static file serving for React frontend
    @app.route('/', defaults={'path': ''})
    @app.route('/<path:path>')
    def serve(path):
        if path and os.path.exists(os.path.join(app.static_folder, path)):
            return app.send_static_file(path)
        return app.send_static_file('index.html')

    # Health check endpoint
    @app.route('/health', methods=['GET'])
    def health_check():
        return jsonify({
            'status': 'healthy',
            'timestamp': datetime.now().isoformat(),
            'version': '2.0.0'
        })

    # Authentication endpoint - both old and new paths
    @app.route('/authenticate', methods=['POST'])
    @app.route('/api/auth/authenticate', methods=['POST'])
    def authenticate():
        try:
            email = request.form.get('username') or request.form.get('email')
            password = request.form.get('password')
            logging.debug(f"Login attempt: email={email}, password={'*' * len(password) if password else 'None'}")
            
            if not email or not password:
                logging.warning(f"Login failed: Email or password missing")
                return jsonify({'success': False, 'message': 'Email and password are required'}), 400

            # Check for admin login
            if email == "admin" and password == "admin":
                session['loggedin'] = True
                session['user_email'] = "admin@example.com"
                session['user_id'] = 1
                session.permanent = True
                logging.info(f"Admin login successful. Session: {dict(session)}")
                return jsonify({'success': True, 'message': 'Login successful', 'user': {'email': 'admin@example.com', 'id': 1}}), 200

            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("SELECT * FROM login_details WHERE LOWER(email) = LOWER(%s)", (email.lower(),))
            account = cursor.fetchone()
            cursor.close()
            
            if account:
                if bcrypt.checkpw(password.encode('utf-8'), account['password'].encode('utf-8')):
                    session['loggedin'] = True
                    session['user_email'] = account['email']
                    session['user_id'] = account['id']
                    session.permanent = True
                    logging.info(f"User {email} logged in successfully. Session: {dict(session)}")
                    return jsonify({
                        'success': True,
                        'message': 'Login successful',
                        'user': {'email': account['email'], 'id': account['id']}
                    }), 200
                else:
                    logging.warning(f"Invalid password for {email}")
                    return jsonify({'success': False, 'message': 'Invalid credentials'}), 401
            else:
                logging.warning(f"Email {email} not found")
                return jsonify({'success': False, 'message': 'Invalid credentials'}), 401
        except Exception as e:
            logging.error(f"Unexpected error during login: {str(e)}")
            return jsonify({'success': False, 'message': f'Unexpected error: {str(e)}'}), 500

    @app.route('/check-auth', methods=['GET'])
    @app.route('/api/auth/check-auth', methods=['GET'])
    def check_auth():
        try:
            logging.debug(f"Checking auth with session: {dict(session)}")
            if 'loggedin' in session and 'user_id' in session:
                conn = get_db_connection()
                cursor = conn.cursor(dictionary=True)
                cursor.execute("SELECT email, first_name FROM login_details WHERE id = %s", (session['user_id'],))
                user = cursor.fetchone()
                cursor.close()
                if user:
                    logging.info(f"User {session.get('user_email')} is authenticated")
                    return jsonify({
                        'success': True,
                        'user': {
                            'email': user['email'],
                            'id': session['user_id'],
                            'first_name': user['first_name']
                        }
                    })
                else:
                    logging.warning("User not found in database")  
                    session.clear()
                    return jsonify({'success': False, 'message': 'User not found'}), 401
            logging.warning("User not authenticated")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        except Exception as e:
            logging.error(f"Error in check-auth endpoint: {str(e)}")
            return jsonify({'success': False, 'message': f'Server error: {str(e)}'}), 500

    @app.route('/register', methods=['POST'])
    @app.route('/api/auth/register', methods=['POST'])
    def register():
        first_name = request.form.get('first_name')
        last_name = request.form.get('last_name')
        email = request.form.get('email')
        mobile = request.form.get('mobile')
        password = request.form.get('password')
        confirm_password = request.form.get('confirm_password')

        if not all([first_name, last_name, email, mobile, password, confirm_password]):
            return jsonify({'success': False, 'message': 'All fields are required'}), 400
        if password != confirm_password:
            return jsonify({'success': False, 'message': 'Passwords do not match'}), 400

        hashed_password = bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
        try:
            conn = get_db_connection()
            cursor = conn.cursor()
            cursor.execute("""
                INSERT INTO login_details (first_name, last_name, email, mobile, password)
                VALUES (%s, %s, %s, %s, %s)
            """, (first_name, last_name, email, mobile, hashed_password))
            user_id = cursor.lastrowid
            conn.commit()
            cursor.close()
            session['loggedin'] = True
            session['user_email'] = email
            session['user_id'] = user_id
            return jsonify({
                'success': True,
                'message': 'Registration successful',
                'user': {'email': email, 'id': user_id}
            }), 200
        except mysql.connector.Error as e:
            logging.error(f"Database error during registration: {str(e)}")
            return jsonify({'success': False, 'message': f'Registration error: {str(e)}'}), 500

    @app.route('/logout', methods=['POST'])
    @app.route('/api/auth/logout', methods=['POST'])
    def logout():
        logging.info(f"User {session.get('user_email', 'unknown')} logged out")
        session.clear()
        return jsonify({'success': True, 'message': 'Logged out successfully'})

    # Template routes
    @app.route('/templates', methods=['GET'])
    @app.route('/api/templates', methods=['GET'])
    def get_templates():
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /templates: session missing")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("""
                SELECT template_id, template_name, created_at, status
                FROM excel_templates
                WHERE user_id = %s AND status = 'ACTIVE'
                ORDER BY created_at DESC
                LIMIT 100
            """, (session['user_id'],))
            templates = cursor.fetchall()
            cursor.close()
            logging.info(f"Fetched {len(templates)} templates for user {session['user_id']}")
            return jsonify({'success': True, 'templates': templates})
        except mysql.connector.Error as e:
            logging.error(f'Error fetching templates: {str(e)}')
            return jsonify({'success': False, 'message': f'Error fetching templates: {str(e)}'}), 500
        except Exception as e:
            logging.error(f'Unexpected error fetching templates: {str(e)}')
            return jsonify({'success': False, 'message': f'Unexpected error: {str(e)}'}), 500

    # Rule Configuration routes
    @app.route('/rule-configurations', methods=['GET'])
    @app.route('/api/validation/rule-configurations', methods=['GET'])
    def get_rule_configurations():
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning(f"Unauthorized access to /rule-configurations: session={dict(session)}")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            user_id = session['user_id']
            logging.debug(f"Fetching rule configurations for user_id: {user_id}")

            # Main query to fetch templates with configured rules
            cursor.execute("""
                SELECT 
                    t.template_id, 
                    t.template_name, 
                    t.created_at, 
                    COUNT(cvr.column_validation_id) as rule_count
                FROM excel_templates t
                LEFT JOIN template_columns tc ON t.template_id = tc.template_id
                LEFT JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                WHERE t.user_id = %s AND t.status = 'ACTIVE' AND t.is_corrected = FALSE
                GROUP BY t.template_id, t.template_name, t.created_at
                HAVING rule_count > 0
                ORDER BY t.created_at DESC
                LIMIT 100
            """, (user_id,))
            templates = cursor.fetchall()
            logging.debug(f"Fetched rule-configured templates: {templates}")

            cursor.close()

            if not templates:
                logging.info(f"No templates with rules found for user_id: {user_id}")
            else:
                logging.info(f"Found {len(templates)} templates with rules for user_id: {user_id}")

            return jsonify({'success': True, 'templates': templates})
        except mysql.connector.Error as e:
            logging.error(f"Database error fetching rule configurations: {str(e)}")
            return jsonify({'success': False, 'message': f"Database error: {str(e)}"}), 500
        except Exception as e:
            logging.error(f"Unexpected error fetching rule configurations: {str(e)}")
            return jsonify({'success': False, 'message': f"Unexpected error: {str(e)}"}), 500

    # File upload route
    @app.route('/upload', methods=['POST'])
    @app.route('/api/templates/upload', methods=['POST'])
    @app.route('/api/upload', methods=['POST'])  # Additional common path
    def upload():
        logging.info(f"Upload endpoint called: {request.endpoint}, method: {request.method}")
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /upload: session missing")
            return jsonify({'error': 'Not logged in'}), 401
        if 'file' not in request.files:
            logging.warning("No file provided in upload request")
            return jsonify({'error': 'No file uploaded'}), 400
        file = request.files['file']
        if file.filename == '':
            logging.warning("No file selected in upload request")
            return jsonify({'error': 'No file selected'}), 400
        
        file_path = os.path.join(app.config['UPLOAD_FOLDER'], file.filename)
        try:
            file.save(file_path)
            logging.info(f"File saved: {file_path}")
        except Exception as e:
            logging.error(f"Failed to save file {file.filename}: {str(e)}")
            return jsonify({'error': f'Failed to save file: {str(e)}'}), 500

        try:
            # Read the file to get sheets and headers
            if file.filename.endswith('.xlsx') or file.filename.endswith('.xls'):
                xl = pd.ExcelFile(file_path)
                sheets = {sheet_name: pd.read_excel(file_path, sheet_name=sheet_name, header=None) 
                         for sheet_name in xl.sheet_names}
            elif file.filename.endswith(('.txt', '.csv', '.dat')):
                df = pd.read_csv(file_path, header=None, encoding='utf-8')
                sheets = {'Sheet1': df}
            else:
                logging.error("Unsupported file type")
                return jsonify({'error': 'Unsupported file type'}), 400
            
            logging.debug(f"Sheets extracted: {list(sheets.keys())}")
        except Exception as e:
            logging.error(f"Failed to read file {file_path}: {str(e)}")
            return jsonify({'error': f'Failed to read file: {str(e)}'}), 400

        try:
            sheet_names = list(sheets.keys())
            if not sheet_names:
                logging.error("No sheets found in the file")
                return jsonify({'error': 'No sheets found in the file'}), 400
            sheet_name = sheet_names[0]
            df = sheets[sheet_name]
            
            # Find header row
            header_row = 0
            for i in range(min(len(df), 10)):
                row = df.iloc[i].dropna()
                if not row.empty and all(isinstance(x, str) for x in row if pd.notna(x)):
                    header_row = i
                    break
                    
            headers = df.iloc[header_row].tolist()
            logging.debug(f"Headers extracted: {headers}")
            
            if not headers or all(not h for h in headers):
                logging.error("No valid headers found in file")
                return jsonify({'error': 'No valid headers found in the file'}), 400
        except Exception as e:
            logging.error(f"Error processing file {file.filename}: {str(e)}")
            return jsonify({'error': f'Error processing file: {str(e)}'}), 400

        # Clear existing session data
        for key in ['df', 'header_row', 'headers', 'sheet_name', 'current_step', 'selected_headers', 'validations', 'error_cell_locations', 'data_rows', 'corrected_file_path']:
            session.pop(key, None)

        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)

            # Check if template exists
            cursor.execute("""
                SELECT template_id, headers, sheet_name
                FROM excel_templates
                WHERE template_name = %s AND user_id = %s AND status = 'ACTIVE'
                ORDER BY created_at DESC
            """, (file.filename, session['user_id']))
            existing_templates = cursor.fetchall()
            logging.info(f"Found {len(existing_templates)} existing templates with name {file.filename}")

            template_id = None
            has_existing_rules = False
            validations = {}
            selected_headers = []

            # Check for matching template
            matching_template = None
            for template in existing_templates:
                stored_headers = json.loads(template['headers']) if template['headers'] else []
                stored_sheet_name = template['sheet_name']
                if stored_headers == headers and stored_sheet_name == sheet_name:
                    matching_template = template
                    break

            if matching_template:
                template_id = matching_template['template_id']
                # Check for existing rules
                cursor.execute("""
                    SELECT tc.column_name, vrt.rule_name
                    FROM template_columns tc
                    JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                    JOIN validation_rule_types vrt ON cvr.rule_type_id = vrt.rule_type_id
                    WHERE tc.template_id = %s AND tc.is_selected = TRUE
                """, (template_id,))
                rules_data = cursor.fetchall()
                for row in rules_data:
                    column_name = row['column_name']
                    rule_name = row['rule_name']
                    if column_name not in validations:
                        validations[column_name] = []
                    validations[column_name].append(rule_name)
                    if column_name not in selected_headers:
                        selected_headers.append(column_name)
                has_existing_rules = len(validations) > 0
            else:
                # New template
                cursor.execute("""
                    INSERT INTO excel_templates (template_name, user_id, sheet_name, headers, is_corrected)
                    VALUES (%s, %s, %s, %s, %s)
                """, (file.filename, session['user_id'], sheet_name, json.dumps(headers), False))
                template_id = cursor.lastrowid
                column_data = [(template_id, header, i + 1, False) for i, header in enumerate(headers)]
                cursor.executemany("""
                    INSERT INTO template_columns (template_id, column_name, column_position, is_selected)
                    VALUES (%s, %s, %s, %s)
                """, column_data)

            conn.commit()
            cursor.close()

            # Store session data
            session['file_path'] = file_path
            session['template_id'] = template_id
            session['df'] = df.to_json()
            session['header_row'] = header_row
            session['headers'] = headers
            session['sheet_name'] = sheet_name
            session['current_step'] = 1 if not has_existing_rules else 3
            session['validations'] = validations
            session['selected_headers'] = selected_headers
            session['has_existing_rules'] = has_existing_rules

            logging.info(f"Upload processed: template_id={template_id}, filename={file.filename}, has_existing_rules={has_existing_rules}")

            return jsonify({
                'success': True,
                'sheets': {sheet_name: {'headers': headers}},
                'file_name': file.filename,
                'template_id': template_id,
                'has_existing_rules': has_existing_rules,
                'sheet_name': sheet_name,
                'skip_to_step_3': has_existing_rules
            })
        except mysql.connector.Error as e:
            logging.error(f'Error saving template: {str(e)}')
            return jsonify({'error': f'Error saving template: {str(e)}'}), 500
        except Exception as e:
            logging.error(f'Unexpected error saving template: {str(e)}')
            return jsonify({'error': f'Unexpected error: {str(e)}'}), 500

    # Multi-step workflow endpoints
    @app.route('/step/1', methods=['GET', 'POST'])
    @app.route('/api/step/1', methods=['GET', 'POST'])
    def step_one():
        if 'loggedin' not in session:
            return jsonify({'error': 'Not logged in'}), 401
        
        if request.method == 'POST':
            try:
                headers = request.form.getlist('headers')
                new_header_row = request.form.get('new_header_row')
                logging.debug(f"Step 1 submitted: headers={headers}, new_header_row={new_header_row}")
                
                if not headers:
                    logging.error("No headers provided in step 1")
                    return jsonify({'success': False, 'message': 'No headers provided'}), 400
                    
                if 'template_id' not in session:
                    logging.error("Session missing template_id")
                    return jsonify({'success': False, 'message': 'Session data missing'}), 400

                template_id = session['template_id']
                
                # Get the dataframe from session for auto-detection
                df_json = session.get('df')
                if df_json:
                    df = pd.read_json(StringIO(df_json))
                    session_headers = session.get('headers', [])
                    df.columns = session_headers
                    header_row = session.get('header_row', 0)
                    df = df.iloc[header_row + 1:].reset_index(drop=True)
                    
                    # Auto-detect rules for selected headers
                    validations = assign_default_rules_to_columns(df, headers)
                    session['validations'] = validations
                    logging.debug(f"Auto-assigned rules: {validations}")
                else:
                    validations = {}

                session['selected_headers'] = headers
                session['current_step'] = 2

                # Mark selected headers in the database
                conn = get_db_connection()
                cursor = conn.cursor()
                cursor.execute("UPDATE template_columns SET is_selected = FALSE WHERE template_id = %s", (template_id,))
                for header in headers:
                    cursor.execute("""
                        UPDATE template_columns
                        SET is_selected = TRUE
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    
                    # Get column_id and add auto-detected rules
                    cursor.execute("""
                        SELECT column_id FROM template_columns
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    result = cursor.fetchone()
                    if result:
                        column_id = result[0]
                        for rule_name in validations.get(header, []):
                            cursor.execute("""
                                SELECT rule_type_id FROM validation_rule_types
                                WHERE rule_name = %s AND is_custom = FALSE
                            """, (rule_name,))
                            rule_result = cursor.fetchone()
                            if rule_result:
                                rule_type_id = rule_result[0]
                                cursor.execute("""
                                    INSERT IGNORE INTO column_validation_rules (column_id, rule_type_id, rule_config)
                                    VALUES (%s, %s, %s)
                                """, (column_id, rule_type_id, '{}'))
                
                conn.commit()
                cursor.close()

                logging.info(f"Step 1 completed: headers={headers}, auto-assigned rules={validations}")
                return jsonify({'success': True, 'headers': headers, 'validations': validations})
            except Exception as e:
                logging.error(f"Error in step 1: {str(e)}")
                return jsonify({'success': False, 'message': str(e)}), 500
        
        # GET request - return current headers
        headers = session.get('headers', [])
        return jsonify({'headers': headers})

    @app.route('/step/2', methods=['GET', 'POST'])
    @app.route('/api/step/2', methods=['GET', 'POST'])
    def step_two():
        if 'loggedin' not in session:
            return jsonify({'error': 'Not logged in'}), 401
            
        if request.method == 'POST':
            try:
                action = request.form.get('action', 'save')
                validations = {}
                for key, values in request.form.lists():
                    if key.startswith('validations_'):
                        header = key.replace('validations_', '')
                        validations[header] = values
                        
                logging.debug(f"Step 2 submitted: action={action}, validations={validations}")
                
                template_id = session.get('template_id')
                if not template_id:
                    return jsonify({'success': False, 'message': 'Session data missing'}), 400

                # Save validations to database
                conn = get_db_connection()
                cursor = conn.cursor()
                
                # Clear existing rules
                cursor.execute("""
                    DELETE FROM column_validation_rules
                    WHERE column_id IN (
                        SELECT column_id FROM template_columns WHERE template_id = %s
                    )
                """, (template_id,))
                
                # Add new rules
                for header, rules in validations.items():
                    cursor.execute("""
                        SELECT column_id FROM template_columns
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    result = cursor.fetchone()
                    if not result:
                        continue
                    column_id = result[0]
                    
                    for rule_name in rules:
                        cursor.execute("""
                            SELECT rule_type_id FROM validation_rule_types
                            WHERE rule_name = %s
                        """, (rule_name,))
                        result = cursor.fetchone()
                        if result:
                            rule_type_id = result[0]
                            cursor.execute("""
                                INSERT IGNORE INTO column_validation_rules (column_id, rule_type_id, rule_config)
                                VALUES (%s, %s, %s)
                            """, (column_id, rule_type_id, '{}'))
                
                conn.commit()
                cursor.close()

                session['validations'] = validations
                session['current_step'] = 3 if action == 'review' else 2
                
                logging.info(f"Step 2 completed: action={action}, validations={validations}")
                return jsonify({'success': True, 'message': 'Step 2 completed successfully'})
            except Exception as e:
                logging.error(f"Error in step 2: {str(e)}")
                return jsonify({'success': False, 'message': str(e)}), 500
        
        # GET request
        selected_headers = session.get('selected_headers', [])
        return jsonify({'selected_headers': selected_headers})

    # Rules endpoint
    @app.route('/rules', methods=['GET'])
    @app.route('/api/rules', methods=['GET'])
    def get_rules():
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            
            cursor.execute("""
                SELECT rule_type_id AS rule_id, rule_name, description, parameters, is_custom, 
                       column_name, template_id, source_format, target_format, data_type, is_active
                FROM validation_rule_types
            """)
            rules = cursor.fetchall()
            cursor.close()
            
            logging.info(f"Returning {len(rules)} rules from getRules endpoint")
            return jsonify({'success': True, 'rules': rules})
        except mysql.connector.Error as e:
            logging.error(f"Database error fetching rules: {str(e)}")
            return jsonify({'success': False, 'message': str(e)}), 500
        except Exception as e:
            logging.error(f"Unexpected error fetching rules: {str(e)}")
            return jsonify({'success': False, 'message': str(e)}), 500

    # Template details endpoint
    @app.route('/template/<int:template_id>/<sheet_name>', methods=['GET'])
    @app.route('/api/template/<int:template_id>/<sheet_name>', methods=['GET'])
    def get_template(template_id, sheet_name):
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /template: session missing")
            return jsonify({'error': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("""
                SELECT template_name, sheet_name, headers
                FROM excel_templates
                WHERE template_id = %s AND user_id = %s AND status = 'ACTIVE'
            """, (template_id, session['user_id']))
            template_record = cursor.fetchone()
            
            if not template_record:
                logging.error(f"Template not found for template_id: {template_id}, user_id: {session['user_id']}")
                cursor.close()
                return jsonify({'error': 'Template not found'}), 404

            headers = json.loads(template_record['headers']) if template_record['headers'] else []
            stored_sheet_name = template_record['sheet_name'] or sheet_name
            file_path = os.path.join(app.config['UPLOAD_FOLDER'], template_record['template_name'])
            
            cursor.execute("""
                SELECT COUNT(*) as rule_count
                FROM template_columns tc
                JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                WHERE tc.template_id = %s AND tc.is_selected = TRUE
            """, (template_id,))
            rule_count = cursor.fetchone()['rule_count']
            has_existing_rules = rule_count > 0
            
            cursor.close()
            
            return jsonify({
                'success': True,
                'sheets': {stored_sheet_name: {'headers': headers}},
                'file_name': template_record['template_name'],
                'file_path': file_path,
                'sheet_name': stored_sheet_name,
                'has_existing_rules': has_existing_rules
            })
        except mysql.connector.Error as e:
            logging.error(f"Database error in get_template: {str(e)}")
            return jsonify({'error': f'Database error: {str(e)}'}), 500
        except Exception as e:
            logging.error(f"Unexpected error in get_template: {str(e)}")
            return jsonify({'error': f'Unexpected error: {str(e)}'}), 500

    # Debug route to show all registered routes
    @app.route('/debug/routes', methods=['GET'])
    def list_routes():
        routes = []
        for rule in app.url_map.iter_rules():
            routes.append({
                'endpoint': rule.endpoint,
                'methods': list(rule.methods),
                'rule': rule.rule
            })
        return jsonify(routes)

    # 404 handler to debug missing routes
    @app.errorhandler(404)
    def not_found_handler(error):
        logging.error(f"404 Error: {request.method} {request.url} not found")
        logging.error(f"Available routes: {[rule.rule for rule in app.url_map.iter_rules()]}")
        return jsonify({
            'error': 'Endpoint not found', 
            'method': request.method,
            'url': request.url,
            'path': request.path
        }), 404

    return app

def initialize_app_data():
    """Initialize database and create default data"""
    try:
        logging.info("Initializing database schema...")
        init_db()
        
        logging.info("Creating admin user...")
        create_admin_user()
        
        logging.info("Creating default validation rules...")
        create_default_validation_rules()
        
        logging.info("Application initialization completed successfully")
    except Exception as e:
        logging.error(f"Failed to initialize application: {e}")
        raise

DB_CONFIG = {
    'host': os.getenv('MYSQL_HOST', 'localhost'),
    'user': os.getenv('MYSQL_USER', 'root'),
    'password': os.getenv('MYSQL_PASSWORD', 'Keansa@2024'),
    'database': os.getenv('MYSQL_DATABASE', 'data_validation_2'),
}

def get_db_connection():
    if 'db' not in g:
        try:
            conn = mysql.connector.connect(
                host=DB_CONFIG['host'],
                user=DB_CONFIG['user'],
                password=DB_CONFIG['password']
            )
            cursor = conn.cursor()
            cursor.execute(f"CREATE DATABASE IF NOT EXISTS {DB_CONFIG['database']}")
            cursor.close()
            conn.close()
            g.db = mysql.connector.connect(**DB_CONFIG)
            logging.info("Database connection established successfully")
        except mysql.connector.Error as err:
            if err.errno == errorcode.ER_ACCESS_DENIED_ERROR:
                logging.error("Database connection failed: Access denied for user - check username/password")
            elif err.errno == errorcode.ER_BAD_DB_ERROR:
                logging.error("Database connection failed: Database does not exist")
            else:
                logging.error(f"Database connection failed: {err}")
            raise Exception(f"Failed to connect to database: {str(err)}")
    return g.db

def close_db(error):
    db = g.pop('db', None)
    if db is not None:
        db.close()

def init_db():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        tables = [
            """
            CREATE TABLE IF NOT EXISTS login_details (
                id INT AUTO_INCREMENT PRIMARY KEY,
                first_name VARCHAR(100),
                last_name VARCHAR(100),
                email VARCHAR(255) UNIQUE,
                mobile VARCHAR(10),
                password VARCHAR(255)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS excel_templates (
                template_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_name VARCHAR(255) NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
                user_id INT NOT NULL,
                sheet_name VARCHAR(255),
                headers JSON,
                status ENUM('ACTIVE', 'INACTIVE') DEFAULT 'ACTIVE',
                is_corrected BOOLEAN DEFAULT FALSE,
                remote_file_path VARCHAR(512),
                FOREIGN KEY (user_id) REFERENCES login_details(id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS template_columns (
                column_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_id BIGINT NOT NULL,
                column_name VARCHAR(255) NOT NULL,
                column_position INT NOT NULL,
                is_validation_enabled BOOLEAN DEFAULT FALSE,
                is_selected BOOLEAN DEFAULT FALSE,
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE,
                UNIQUE (template_id, column_name)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_rule_types (
                rule_type_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                rule_name VARCHAR(255) NOT NULL,
                description TEXT,
                parameters TEXT,
                is_active BOOLEAN DEFAULT TRUE,
                is_custom BOOLEAN DEFAULT FALSE,
                column_name VARCHAR(255),
                template_id BIGINT,
                data_type VARCHAR(50),
                source_format VARCHAR(50),
                target_format VARCHAR(50),
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS column_validation_rules (
                column_validation_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                column_id BIGINT NOT NULL,
                rule_type_id BIGINT NOT NULL,
                rule_config JSON,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (column_id) REFERENCES template_columns(column_id) ON DELETE CASCADE,
                FOREIGN KEY (rule_type_id) REFERENCES validation_rule_types(rule_type_id) ON DELETE RESTRICT,
                UNIQUE (column_id, rule_type_id)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_history (
                history_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_id BIGINT NOT NULL,
                template_name VARCHAR(255) NOT NULL,
                error_count INT NOT NULL,
                corrected_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                corrected_file_path VARCHAR(512) NOT NULL,
                user_id INT NOT NULL,
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE,
                FOREIGN KEY (user_id) REFERENCES login_details(id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_corrections (
                correction_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                history_id BIGINT NOT NULL,
                row_index INT NOT NULL,
                column_name VARCHAR(255) NOT NULL,
                original_value TEXT,
                corrected_value TEXT,
                rule_failed VARCHAR(255) DEFAULT NULL,
                FOREIGN KEY (history_id) REFERENCES validation_history(history_id) ON DELETE CASCADE
            )
            """
        ]
        for table_sql in tables:
            cursor.execute(table_sql)
        
        # Add missing columns if they don't exist
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'source_format'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN source_format VARCHAR(50)")
            logging.info("Added source_format column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'target_format'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN target_format VARCHAR(50)")
            logging.info("Added target_format column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'data_type'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN data_type VARCHAR(50)")
            logging.info("Added data_type column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM excel_templates LIKE 'remote_file_path'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE excel_templates ADD COLUMN remote_file_path VARCHAR(512)")
            logging.info("Added remote_file_path column to excel_templates table")
            
        cursor.execute("SHOW COLUMNS FROM template_columns LIKE 'is_selected'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE template_columns ADD COLUMN is_selected BOOLEAN DEFAULT FALSE")
            logging.info("Added is_selected column to template_columns table")
            
        conn.commit()
        cursor.close()
        logging.info("Database tables initialized")
    except Exception as e:
        logging.error(f"Failed to initialize database: {str(e)}")
        raise

def create_admin_user():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        admin_password = bcrypt.hashpw('admin'.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
        cursor.execute("""
            INSERT IGNORE INTO login_details (first_name, last_name, email, mobile, password)
            VALUES (%s, %s, %s, %s, %s)
        """, ('Admin', 'User', 'admin@example.com', '1234567890', admin_password))
        conn.commit()
        cursor.close()
        logging.info("Admin user created or already exists")
    except Exception as e:
        logging.error(f"Failed to create admin user: {str(e)}")
        raise

def create_default_validation_rules():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        default_rules = [
            ("Required", "Ensures the field is not null", '{"allow_null": false}', None, None, None),
            ("Int", "Validates integer format", '{"format": "integer"}', None, None, "Int"),
            ("Float", "Validates number format (integer or decimal)", '{"format": "float"}', None, None, "Float"),
            ("Text", "Allows text with quotes and parentheses", '{"allow_special": false}', None, None, "Text"),
            ("Email", "Validates email format", '{"regex": "^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\\\.[a-zA-Z0-9-.]+$"}', None, None, "Email"),
            ("Date(DD-MM-YYYY)", "Validates date format DD-MM-YYYY", '{"format": "%d-%m-%Y"}', "DD-MM-YYYY", None, "Date"),
            ("Boolean", "Validates boolean format (true/false or 0/1)", '{"format": "boolean"}', None, None, "Boolean"),
            ("Alphanumeric", "Validates alphanumeric format", '{"format": "alphanumeric"}', None, None, "Alphanumeric")
        ]
        cursor.executemany("""
            INSERT IGNORE INTO validation_rule_types (rule_name, description, parameters, is_custom, source_format, target_format, data_type)
            VALUES (%s, %s, %s, %s, %s, %s, %s)
        """, [(name, desc, params, False, source, target, dtype) for name, desc, params, source, target, dtype in default_rules])
        conn.commit()
        cursor.close()
        logging.info("Default validation rules ensured successfully")
    except Exception as e:
        logging.error(f"Failed to ensure default validation rules: {str(e)}")
        raise

if __name__ == '__main__':
    try:
        # Create the application using factory pattern
        app = create_app()
        
        # Initialize database and default data within app context
        with app.app_context():
            initialize_app_data()
        
        # Get port from environment or use default
        port = int(os.getenv('PORT', 5000))
        
        # Start the application server
        logging.info("Starting Flask server...")
        app.run(debug=True, host='0.0.0.0', port=port)
        
    except Exception as e:
        logging.error(f"Failed to start application: {e}")
        raise
).all():
        return "Alphanumeric"
    
    return "Text"

def assign_default_rules_to_columns(df, headers):
    """Intelligently assign validation rules based on column content"""
    assignments = {}
    
    for col in headers:
        if col not in df.columns:
            logging.warning(f"Column {col} not found in dataframe")
            continue
            
        col_type = detect_column_type(df[col])
        rules = ["Required"]  # Default rule for all columns
        
        # Special handling for optional columns
        if not any(col.lower().startswith(prefix) for prefix in
                  ["name", "address", "phone", "username", "status", "period"]):
            rules.append(col_type)
        else:
            rules.append("Text")  # Optional text fields
        
        assignments[col] = rules
    
    return assignments

def create_app():
    """Application factory pattern for different environments"""
    # Set the path to the frontend dist folder
    current_dir = os.path.dirname(os.path.abspath(__file__))
    frontend_dist_path = os.path.join(current_dir, '..', '..', 'Keansa-Ai-Suite2025may-frontend11', 'dist')
    frontend_dist_path = os.path.abspath(frontend_dist_path)
    
    # Create Flask application instance
    app = Flask(__name__, static_folder=frontend_dist_path, static_url_path='')
    CORS(app, supports_credentials=True, origins=["http://localhost:3000", "http://localhost:8080", "http://localhost:5000", "*"])

    app.secret_key = os.urandom(24).hex()
    app.config['SESSION_TYPE'] = 'filesystem'
    app.config['SESSION_FILE_DIR'] = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'sessions')
    app.config['SESSION_COOKIE_SAMESITE'] = 'Lax'
    app.config['SESSION_COOKIE_HTTPONLY'] = True
    app.config['SESSION_COOKIE_SECURE'] = False
    app.config['PERMANENT_SESSION_LIFETIME'] = 86400  # 24 hours
    app.config['UPLOAD_FOLDER'] = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'uploads')
    Session(app)

    # Ensure directories exist
    try:
        os.makedirs(app.config['UPLOAD_FOLDER'], exist_ok=True)
        os.makedirs(app.config['SESSION_FILE_DIR'], exist_ok=True)
    except OSError as e:
        logging.error(f"Failed to create directories: {e}")

    # Register cleanup handlers
    app.teardown_appcontext(close_db)
    
    # Register all routes directly in create_app
    
    # Static file serving for React frontend
    @app.route('/', defaults={'path': ''})
    @app.route('/<path:path>')
    def serve(path):
        if path and os.path.exists(os.path.join(app.static_folder, path)):
            return app.send_static_file(path)
        return app.send_static_file('index.html')

    # Health check endpoint
    @app.route('/health', methods=['GET'])
    def health_check():
        return jsonify({
            'status': 'healthy',
            'timestamp': datetime.now().isoformat(),
            'version': '2.0.0'
        })

    # Authentication endpoint - both old and new paths
    @app.route('/authenticate', methods=['POST'])
    @app.route('/api/auth/authenticate', methods=['POST'])
    def authenticate():
        try:
            email = request.form.get('username') or request.form.get('email')
            password = request.form.get('password')
            logging.debug(f"Login attempt: email={email}, password={'*' * len(password) if password else 'None'}")
            
            if not email or not password:
                logging.warning(f"Login failed: Email or password missing")
                return jsonify({'success': False, 'message': 'Email and password are required'}), 400

            # Check for admin login
            if email == "admin" and password == "admin":
                session['loggedin'] = True
                session['user_email'] = "admin@example.com"
                session['user_id'] = 1
                session.permanent = True
                logging.info(f"Admin login successful. Session: {dict(session)}")
                return jsonify({'success': True, 'message': 'Login successful', 'user': {'email': 'admin@example.com', 'id': 1}}), 200

            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("SELECT * FROM login_details WHERE LOWER(email) = LOWER(%s)", (email.lower(),))
            account = cursor.fetchone()
            cursor.close()
            
            if account:
                if bcrypt.checkpw(password.encode('utf-8'), account['password'].encode('utf-8')):
                    session['loggedin'] = True
                    session['user_email'] = account['email']
                    session['user_id'] = account['id']
                    session.permanent = True
                    logging.info(f"User {email} logged in successfully. Session: {dict(session)}")
                    return jsonify({
                        'success': True,
                        'message': 'Login successful',
                        'user': {'email': account['email'], 'id': account['id']}
                    }), 200
                else:
                    logging.warning(f"Invalid password for {email}")
                    return jsonify({'success': False, 'message': 'Invalid credentials'}), 401
            else:
                logging.warning(f"Email {email} not found")
                return jsonify({'success': False, 'message': 'Invalid credentials'}), 401
        except Exception as e:
            logging.error(f"Unexpected error during login: {str(e)}")
            return jsonify({'success': False, 'message': f'Unexpected error: {str(e)}'}), 500

    @app.route('/check-auth', methods=['GET'])
    @app.route('/api/auth/check-auth', methods=['GET'])
    def check_auth():
        try:
            logging.debug(f"Checking auth with session: {dict(session)}")
            if 'loggedin' in session and 'user_id' in session:
                conn = get_db_connection()
                cursor = conn.cursor(dictionary=True)
                cursor.execute("SELECT email, first_name FROM login_details WHERE id = %s", (session['user_id'],))
                user = cursor.fetchone()
                cursor.close()
                if user:
                    logging.info(f"User {session.get('user_email')} is authenticated")
                    return jsonify({
                        'success': True,
                        'user': {
                            'email': user['email'],
                            'id': session['user_id'],
                            'first_name': user['first_name']
                        }
                    })
                else:
                    logging.warning("User not found in database")  
                    session.clear()
                    return jsonify({'success': False, 'message': 'User not found'}), 401
            logging.warning("User not authenticated")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        except Exception as e:
            logging.error(f"Error in check-auth endpoint: {str(e)}")
            return jsonify({'success': False, 'message': f'Server error: {str(e)}'}), 500

    @app.route('/register', methods=['POST'])
    @app.route('/api/auth/register', methods=['POST'])
    def register():
        first_name = request.form.get('first_name')
        last_name = request.form.get('last_name')
        email = request.form.get('email')
        mobile = request.form.get('mobile')
        password = request.form.get('password')
        confirm_password = request.form.get('confirm_password')

        if not all([first_name, last_name, email, mobile, password, confirm_password]):
            return jsonify({'success': False, 'message': 'All fields are required'}), 400
        if password != confirm_password:
            return jsonify({'success': False, 'message': 'Passwords do not match'}), 400

        hashed_password = bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
        try:
            conn = get_db_connection()
            cursor = conn.cursor()
            cursor.execute("""
                INSERT INTO login_details (first_name, last_name, email, mobile, password)
                VALUES (%s, %s, %s, %s, %s)
            """, (first_name, last_name, email, mobile, hashed_password))
            user_id = cursor.lastrowid
            conn.commit()
            cursor.close()
            session['loggedin'] = True
            session['user_email'] = email
            session['user_id'] = user_id
            return jsonify({
                'success': True,
                'message': 'Registration successful',
                'user': {'email': email, 'id': user_id}
            }), 200
        except mysql.connector.Error as e:
            logging.error(f"Database error during registration: {str(e)}")
            return jsonify({'success': False, 'message': f'Registration error: {str(e)}'}), 500

    @app.route('/logout', methods=['POST'])
    @app.route('/api/auth/logout', methods=['POST'])
    def logout():
        logging.info(f"User {session.get('user_email', 'unknown')} logged out")
        session.clear()
        return jsonify({'success': True, 'message': 'Logged out successfully'})

    # Template routes
    @app.route('/templates', methods=['GET'])
    @app.route('/api/templates', methods=['GET'])
    def get_templates():
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /templates: session missing")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("""
                SELECT template_id, template_name, created_at, status
                FROM excel_templates
                WHERE user_id = %s AND status = 'ACTIVE'
                ORDER BY created_at DESC
                LIMIT 100
            """, (session['user_id'],))
            templates = cursor.fetchall()
            cursor.close()
            logging.info(f"Fetched {len(templates)} templates for user {session['user_id']}")
            return jsonify({'success': True, 'templates': templates})
        except mysql.connector.Error as e:
            logging.error(f'Error fetching templates: {str(e)}')
            return jsonify({'success': False, 'message': f'Error fetching templates: {str(e)}'}), 500
        except Exception as e:
            logging.error(f'Unexpected error fetching templates: {str(e)}')
            return jsonify({'success': False, 'message': f'Unexpected error: {str(e)}'}), 500

    # Rule Configuration routes
    @app.route('/rule-configurations', methods=['GET'])
    @app.route('/api/validation/rule-configurations', methods=['GET'])
    def get_rule_configurations():
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning(f"Unauthorized access to /rule-configurations: session={dict(session)}")
            return jsonify({'success': False, 'message': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            user_id = session['user_id']
            logging.debug(f"Fetching rule configurations for user_id: {user_id}")

            # Main query to fetch templates with configured rules
            cursor.execute("""
                SELECT 
                    t.template_id, 
                    t.template_name, 
                    t.created_at, 
                    COUNT(cvr.column_validation_id) as rule_count
                FROM excel_templates t
                LEFT JOIN template_columns tc ON t.template_id = tc.template_id
                LEFT JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                WHERE t.user_id = %s AND t.status = 'ACTIVE' AND t.is_corrected = FALSE
                GROUP BY t.template_id, t.template_name, t.created_at
                HAVING rule_count > 0
                ORDER BY t.created_at DESC
                LIMIT 100
            """, (user_id,))
            templates = cursor.fetchall()
            logging.debug(f"Fetched rule-configured templates: {templates}")

            cursor.close()

            if not templates:
                logging.info(f"No templates with rules found for user_id: {user_id}")
            else:
                logging.info(f"Found {len(templates)} templates with rules for user_id: {user_id}")

            return jsonify({'success': True, 'templates': templates})
        except mysql.connector.Error as e:
            logging.error(f"Database error fetching rule configurations: {str(e)}")
            return jsonify({'success': False, 'message': f"Database error: {str(e)}"}), 500
        except Exception as e:
            logging.error(f"Unexpected error fetching rule configurations: {str(e)}")
            return jsonify({'success': False, 'message': f"Unexpected error: {str(e)}"}), 500

    # File upload route
    @app.route('/upload', methods=['POST'])
    @app.route('/api/templates/upload', methods=['POST'])
    @app.route('/api/upload', methods=['POST'])  # Additional common path
    def upload():
        logging.info(f"Upload endpoint called: {request.endpoint}, method: {request.method}")
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /upload: session missing")
            return jsonify({'error': 'Not logged in'}), 401
        if 'file' not in request.files:
            logging.warning("No file provided in upload request")
            return jsonify({'error': 'No file uploaded'}), 400
        file = request.files['file']
        if file.filename == '':
            logging.warning("No file selected in upload request")
            return jsonify({'error': 'No file selected'}), 400
        
        file_path = os.path.join(app.config['UPLOAD_FOLDER'], file.filename)
        try:
            file.save(file_path)
            logging.info(f"File saved: {file_path}")
        except Exception as e:
            logging.error(f"Failed to save file {file.filename}: {str(e)}")
            return jsonify({'error': f'Failed to save file: {str(e)}'}), 500

        try:
            # Read the file to get sheets and headers
            if file.filename.endswith('.xlsx') or file.filename.endswith('.xls'):
                xl = pd.ExcelFile(file_path)
                sheets = {sheet_name: pd.read_excel(file_path, sheet_name=sheet_name, header=None) 
                         for sheet_name in xl.sheet_names}
            elif file.filename.endswith(('.txt', '.csv', '.dat')):
                df = pd.read_csv(file_path, header=None, encoding='utf-8')
                sheets = {'Sheet1': df}
            else:
                logging.error("Unsupported file type")
                return jsonify({'error': 'Unsupported file type'}), 400
            
            logging.debug(f"Sheets extracted: {list(sheets.keys())}")
        except Exception as e:
            logging.error(f"Failed to read file {file_path}: {str(e)}")
            return jsonify({'error': f'Failed to read file: {str(e)}'}), 400

        try:
            sheet_names = list(sheets.keys())
            if not sheet_names:
                logging.error("No sheets found in the file")
                return jsonify({'error': 'No sheets found in the file'}), 400
            sheet_name = sheet_names[0]
            df = sheets[sheet_name]
            
            # Find header row
            header_row = 0
            for i in range(min(len(df), 10)):
                row = df.iloc[i].dropna()
                if not row.empty and all(isinstance(x, str) for x in row if pd.notna(x)):
                    header_row = i
                    break
                    
            headers = df.iloc[header_row].tolist()
            logging.debug(f"Headers extracted: {headers}")
            
            if not headers or all(not h for h in headers):
                logging.error("No valid headers found in file")
                return jsonify({'error': 'No valid headers found in the file'}), 400
        except Exception as e:
            logging.error(f"Error processing file {file.filename}: {str(e)}")
            return jsonify({'error': f'Error processing file: {str(e)}'}), 400

        # Clear existing session data
        for key in ['df', 'header_row', 'headers', 'sheet_name', 'current_step', 'selected_headers', 'validations', 'error_cell_locations', 'data_rows', 'corrected_file_path']:
            session.pop(key, None)

        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)

            # Check if template exists
            cursor.execute("""
                SELECT template_id, headers, sheet_name
                FROM excel_templates
                WHERE template_name = %s AND user_id = %s AND status = 'ACTIVE'
                ORDER BY created_at DESC
            """, (file.filename, session['user_id']))
            existing_templates = cursor.fetchall()
            logging.info(f"Found {len(existing_templates)} existing templates with name {file.filename}")

            template_id = None
            has_existing_rules = False
            validations = {}
            selected_headers = []

            # Check for matching template
            matching_template = None
            for template in existing_templates:
                stored_headers = json.loads(template['headers']) if template['headers'] else []
                stored_sheet_name = template['sheet_name']
                if stored_headers == headers and stored_sheet_name == sheet_name:
                    matching_template = template
                    break

            if matching_template:
                template_id = matching_template['template_id']
                # Check for existing rules
                cursor.execute("""
                    SELECT tc.column_name, vrt.rule_name
                    FROM template_columns tc
                    JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                    JOIN validation_rule_types vrt ON cvr.rule_type_id = vrt.rule_type_id
                    WHERE tc.template_id = %s AND tc.is_selected = TRUE
                """, (template_id,))
                rules_data = cursor.fetchall()
                for row in rules_data:
                    column_name = row['column_name']
                    rule_name = row['rule_name']
                    if column_name not in validations:
                        validations[column_name] = []
                    validations[column_name].append(rule_name)
                    if column_name not in selected_headers:
                        selected_headers.append(column_name)
                has_existing_rules = len(validations) > 0
            else:
                # New template
                cursor.execute("""
                    INSERT INTO excel_templates (template_name, user_id, sheet_name, headers, is_corrected)
                    VALUES (%s, %s, %s, %s, %s)
                """, (file.filename, session['user_id'], sheet_name, json.dumps(headers), False))
                template_id = cursor.lastrowid
                column_data = [(template_id, header, i + 1, False) for i, header in enumerate(headers)]
                cursor.executemany("""
                    INSERT INTO template_columns (template_id, column_name, column_position, is_selected)
                    VALUES (%s, %s, %s, %s)
                """, column_data)

            conn.commit()
            cursor.close()

            # Store session data
            session['file_path'] = file_path
            session['template_id'] = template_id
            session['df'] = df.to_json()
            session['header_row'] = header_row
            session['headers'] = headers
            session['sheet_name'] = sheet_name
            session['current_step'] = 1 if not has_existing_rules else 3
            session['validations'] = validations
            session['selected_headers'] = selected_headers
            session['has_existing_rules'] = has_existing_rules

            logging.info(f"Upload processed: template_id={template_id}, filename={file.filename}, has_existing_rules={has_existing_rules}")

            return jsonify({
                'success': True,
                'sheets': {sheet_name: {'headers': headers}},
                'file_name': file.filename,
                'template_id': template_id,
                'has_existing_rules': has_existing_rules,
                'sheet_name': sheet_name,
                'skip_to_step_3': has_existing_rules
            })
        except mysql.connector.Error as e:
            logging.error(f'Error saving template: {str(e)}')
            return jsonify({'error': f'Error saving template: {str(e)}'}), 500
        except Exception as e:
            logging.error(f'Unexpected error saving template: {str(e)}')
            return jsonify({'error': f'Unexpected error: {str(e)}'}), 500

    # Multi-step workflow endpoints
    @app.route('/step/1', methods=['GET', 'POST'])
    @app.route('/api/step/1', methods=['GET', 'POST'])
    def step_one():
        if 'loggedin' not in session:
            return jsonify({'error': 'Not logged in'}), 401
        
        if request.method == 'POST':
            try:
                headers = request.form.getlist('headers')
                new_header_row = request.form.get('new_header_row')
                logging.debug(f"Step 1 submitted: headers={headers}, new_header_row={new_header_row}")
                
                if not headers:
                    logging.error("No headers provided in step 1")
                    return jsonify({'success': False, 'message': 'No headers provided'}), 400
                    
                if 'template_id' not in session:
                    logging.error("Session missing template_id")
                    return jsonify({'success': False, 'message': 'Session data missing'}), 400

                template_id = session['template_id']
                
                # Get the dataframe from session for auto-detection
                df_json = session.get('df')
                if df_json:
                    df = pd.read_json(StringIO(df_json))
                    session_headers = session.get('headers', [])
                    df.columns = session_headers
                    header_row = session.get('header_row', 0)
                    df = df.iloc[header_row + 1:].reset_index(drop=True)
                    
                    # Auto-detect rules for selected headers
                    validations = assign_default_rules_to_columns(df, headers)
                    session['validations'] = validations
                    logging.debug(f"Auto-assigned rules: {validations}")
                else:
                    validations = {}

                session['selected_headers'] = headers
                session['current_step'] = 2

                # Mark selected headers in the database
                conn = get_db_connection()
                cursor = conn.cursor()
                cursor.execute("UPDATE template_columns SET is_selected = FALSE WHERE template_id = %s", (template_id,))
                for header in headers:
                    cursor.execute("""
                        UPDATE template_columns
                        SET is_selected = TRUE
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    
                    # Get column_id and add auto-detected rules
                    cursor.execute("""
                        SELECT column_id FROM template_columns
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    result = cursor.fetchone()
                    if result:
                        column_id = result[0]
                        for rule_name in validations.get(header, []):
                            cursor.execute("""
                                SELECT rule_type_id FROM validation_rule_types
                                WHERE rule_name = %s AND is_custom = FALSE
                            """, (rule_name,))
                            rule_result = cursor.fetchone()
                            if rule_result:
                                rule_type_id = rule_result[0]
                                cursor.execute("""
                                    INSERT IGNORE INTO column_validation_rules (column_id, rule_type_id, rule_config)
                                    VALUES (%s, %s, %s)
                                """, (column_id, rule_type_id, '{}'))
                
                conn.commit()
                cursor.close()

                logging.info(f"Step 1 completed: headers={headers}, auto-assigned rules={validations}")
                return jsonify({'success': True, 'headers': headers, 'validations': validations})
            except Exception as e:
                logging.error(f"Error in step 1: {str(e)}")
                return jsonify({'success': False, 'message': str(e)}), 500
        
        # GET request - return current headers
        headers = session.get('headers', [])
        return jsonify({'headers': headers})

    @app.route('/step/2', methods=['GET', 'POST'])
    @app.route('/api/step/2', methods=['GET', 'POST'])
    def step_two():
        if 'loggedin' not in session:
            return jsonify({'error': 'Not logged in'}), 401
            
        if request.method == 'POST':
            try:
                action = request.form.get('action', 'save')
                validations = {}
                for key, values in request.form.lists():
                    if key.startswith('validations_'):
                        header = key.replace('validations_', '')
                        validations[header] = values
                        
                logging.debug(f"Step 2 submitted: action={action}, validations={validations}")
                
                template_id = session.get('template_id')
                if not template_id:
                    return jsonify({'success': False, 'message': 'Session data missing'}), 400

                # Save validations to database
                conn = get_db_connection()
                cursor = conn.cursor()
                
                # Clear existing rules
                cursor.execute("""
                    DELETE FROM column_validation_rules
                    WHERE column_id IN (
                        SELECT column_id FROM template_columns WHERE template_id = %s
                    )
                """, (template_id,))
                
                # Add new rules
                for header, rules in validations.items():
                    cursor.execute("""
                        SELECT column_id FROM template_columns
                        WHERE template_id = %s AND column_name = %s
                    """, (template_id, header))
                    result = cursor.fetchone()
                    if not result:
                        continue
                    column_id = result[0]
                    
                    for rule_name in rules:
                        cursor.execute("""
                            SELECT rule_type_id FROM validation_rule_types
                            WHERE rule_name = %s
                        """, (rule_name,))
                        result = cursor.fetchone()
                        if result:
                            rule_type_id = result[0]
                            cursor.execute("""
                                INSERT IGNORE INTO column_validation_rules (column_id, rule_type_id, rule_config)
                                VALUES (%s, %s, %s)
                            """, (column_id, rule_type_id, '{}'))
                
                conn.commit()
                cursor.close()

                session['validations'] = validations
                session['current_step'] = 3 if action == 'review' else 2
                
                logging.info(f"Step 2 completed: action={action}, validations={validations}")
                return jsonify({'success': True, 'message': 'Step 2 completed successfully'})
            except Exception as e:
                logging.error(f"Error in step 2: {str(e)}")
                return jsonify({'success': False, 'message': str(e)}), 500
        
        # GET request
        selected_headers = session.get('selected_headers', [])
        return jsonify({'selected_headers': selected_headers})

    # Rules endpoint
    @app.route('/rules', methods=['GET'])
    @app.route('/api/rules', methods=['GET'])
    def get_rules():
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            
            cursor.execute("""
                SELECT rule_type_id AS rule_id, rule_name, description, parameters, is_custom, 
                       column_name, template_id, source_format, target_format, data_type, is_active
                FROM validation_rule_types
            """)
            rules = cursor.fetchall()
            cursor.close()
            
            logging.info(f"Returning {len(rules)} rules from getRules endpoint")
            return jsonify({'success': True, 'rules': rules})
        except mysql.connector.Error as e:
            logging.error(f"Database error fetching rules: {str(e)}")
            return jsonify({'success': False, 'message': str(e)}), 500
        except Exception as e:
            logging.error(f"Unexpected error fetching rules: {str(e)}")
            return jsonify({'success': False, 'message': str(e)}), 500

    # Template details endpoint
    @app.route('/template/<int:template_id>/<sheet_name>', methods=['GET'])
    @app.route('/api/template/<int:template_id>/<sheet_name>', methods=['GET'])
    def get_template(template_id, sheet_name):
        if 'loggedin' not in session or 'user_id' not in session:
            logging.warning("Unauthorized access to /template: session missing")
            return jsonify({'error': 'Not logged in'}), 401
        try:
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("""
                SELECT template_name, sheet_name, headers
                FROM excel_templates
                WHERE template_id = %s AND user_id = %s AND status = 'ACTIVE'
            """, (template_id, session['user_id']))
            template_record = cursor.fetchone()
            
            if not template_record:
                logging.error(f"Template not found for template_id: {template_id}, user_id: {session['user_id']}")
                cursor.close()
                return jsonify({'error': 'Template not found'}), 404

            headers = json.loads(template_record['headers']) if template_record['headers'] else []
            stored_sheet_name = template_record['sheet_name'] or sheet_name
            file_path = os.path.join(app.config['UPLOAD_FOLDER'], template_record['template_name'])
            
            cursor.execute("""
                SELECT COUNT(*) as rule_count
                FROM template_columns tc
                JOIN column_validation_rules cvr ON tc.column_id = cvr.column_id
                WHERE tc.template_id = %s AND tc.is_selected = TRUE
            """, (template_id,))
            rule_count = cursor.fetchone()['rule_count']
            has_existing_rules = rule_count > 0
            
            cursor.close()
            
            return jsonify({
                'success': True,
                'sheets': {stored_sheet_name: {'headers': headers}},
                'file_name': template_record['template_name'],
                'file_path': file_path,
                'sheet_name': stored_sheet_name,
                'has_existing_rules': has_existing_rules
            })
        except mysql.connector.Error as e:
            logging.error(f"Database error in get_template: {str(e)}")
            return jsonify({'error': f'Database error: {str(e)}'}), 500
        except Exception as e:
            logging.error(f"Unexpected error in get_template: {str(e)}")
            return jsonify({'error': f'Unexpected error: {str(e)}'}), 500

    # Debug route to show all registered routes
    @app.route('/debug/routes', methods=['GET'])
    def list_routes():
        routes = []
        for rule in app.url_map.iter_rules():
            routes.append({
                'endpoint': rule.endpoint,
                'methods': list(rule.methods),
                'rule': rule.rule
            })
        return jsonify(routes)

    # 404 handler to debug missing routes
    @app.errorhandler(404)
    def not_found_handler(error):
        logging.error(f"404 Error: {request.method} {request.url} not found")
        logging.error(f"Available routes: {[rule.rule for rule in app.url_map.iter_rules()]}")
        return jsonify({
            'error': 'Endpoint not found', 
            'method': request.method,
            'url': request.url,
            'path': request.path
        }), 404

    return app

def initialize_app_data():
    """Initialize database and create default data"""
    try:
        logging.info("Initializing database schema...")
        init_db()
        
        logging.info("Creating admin user...")
        create_admin_user()
        
        logging.info("Creating default validation rules...")
        create_default_validation_rules()
        
        logging.info("Application initialization completed successfully")
    except Exception as e:
        logging.error(f"Failed to initialize application: {e}")
        raise

DB_CONFIG = {
    'host': os.getenv('MYSQL_HOST', 'localhost'),
    'user': os.getenv('MYSQL_USER', 'root'),
    'password': os.getenv('MYSQL_PASSWORD', 'Keansa@2024'),
    'database': os.getenv('MYSQL_DATABASE', 'data_validation_2'),
}

def get_db_connection():
    if 'db' not in g:
        try:
            conn = mysql.connector.connect(
                host=DB_CONFIG['host'],
                user=DB_CONFIG['user'],
                password=DB_CONFIG['password']
            )
            cursor = conn.cursor()
            cursor.execute(f"CREATE DATABASE IF NOT EXISTS {DB_CONFIG['database']}")
            cursor.close()
            conn.close()
            g.db = mysql.connector.connect(**DB_CONFIG)
            logging.info("Database connection established successfully")
        except mysql.connector.Error as err:
            if err.errno == errorcode.ER_ACCESS_DENIED_ERROR:
                logging.error("Database connection failed: Access denied for user - check username/password")
            elif err.errno == errorcode.ER_BAD_DB_ERROR:
                logging.error("Database connection failed: Database does not exist")
            else:
                logging.error(f"Database connection failed: {err}")
            raise Exception(f"Failed to connect to database: {str(err)}")
    return g.db

def close_db(error):
    db = g.pop('db', None)
    if db is not None:
        db.close()

def init_db():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        tables = [
            """
            CREATE TABLE IF NOT EXISTS login_details (
                id INT AUTO_INCREMENT PRIMARY KEY,
                first_name VARCHAR(100),
                last_name VARCHAR(100),
                email VARCHAR(255) UNIQUE,
                mobile VARCHAR(10),
                password VARCHAR(255)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS excel_templates (
                template_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_name VARCHAR(255) NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
                user_id INT NOT NULL,
                sheet_name VARCHAR(255),
                headers JSON,
                status ENUM('ACTIVE', 'INACTIVE') DEFAULT 'ACTIVE',
                is_corrected BOOLEAN DEFAULT FALSE,
                remote_file_path VARCHAR(512),
                FOREIGN KEY (user_id) REFERENCES login_details(id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS template_columns (
                column_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_id BIGINT NOT NULL,
                column_name VARCHAR(255) NOT NULL,
                column_position INT NOT NULL,
                is_validation_enabled BOOLEAN DEFAULT FALSE,
                is_selected BOOLEAN DEFAULT FALSE,
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE,
                UNIQUE (template_id, column_name)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_rule_types (
                rule_type_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                rule_name VARCHAR(255) NOT NULL,
                description TEXT,
                parameters TEXT,
                is_active BOOLEAN DEFAULT TRUE,
                is_custom BOOLEAN DEFAULT FALSE,
                column_name VARCHAR(255),
                template_id BIGINT,
                data_type VARCHAR(50),
                source_format VARCHAR(50),
                target_format VARCHAR(50),
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS column_validation_rules (
                column_validation_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                column_id BIGINT NOT NULL,
                rule_type_id BIGINT NOT NULL,
                rule_config JSON,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (column_id) REFERENCES template_columns(column_id) ON DELETE CASCADE,
                FOREIGN KEY (rule_type_id) REFERENCES validation_rule_types(rule_type_id) ON DELETE RESTRICT,
                UNIQUE (column_id, rule_type_id)
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_history (
                history_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                template_id BIGINT NOT NULL,
                template_name VARCHAR(255) NOT NULL,
                error_count INT NOT NULL,
                corrected_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                corrected_file_path VARCHAR(512) NOT NULL,
                user_id INT NOT NULL,
                FOREIGN KEY (template_id) REFERENCES excel_templates(template_id) ON DELETE CASCADE,
                FOREIGN KEY (user_id) REFERENCES login_details(id) ON DELETE CASCADE
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS validation_corrections (
                correction_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                history_id BIGINT NOT NULL,
                row_index INT NOT NULL,
                column_name VARCHAR(255) NOT NULL,
                original_value TEXT,
                corrected_value TEXT,
                rule_failed VARCHAR(255) DEFAULT NULL,
                FOREIGN KEY (history_id) REFERENCES validation_history(history_id) ON DELETE CASCADE
            )
            """
        ]
        for table_sql in tables:
            cursor.execute(table_sql)
        
        # Add missing columns if they don't exist
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'source_format'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN source_format VARCHAR(50)")
            logging.info("Added source_format column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'target_format'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN target_format VARCHAR(50)")
            logging.info("Added target_format column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM validation_rule_types LIKE 'data_type'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE validation_rule_types ADD COLUMN data_type VARCHAR(50)")
            logging.info("Added data_type column to validation_rule_types table")
            
        cursor.execute("SHOW COLUMNS FROM excel_templates LIKE 'remote_file_path'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE excel_templates ADD COLUMN remote_file_path VARCHAR(512)")
            logging.info("Added remote_file_path column to excel_templates table")
            
        cursor.execute("SHOW COLUMNS FROM template_columns LIKE 'is_selected'")
        if not cursor.fetchone():
            cursor.execute("ALTER TABLE template_columns ADD COLUMN is_selected BOOLEAN DEFAULT FALSE")
            logging.info("Added is_selected column to template_columns table")
            
        conn.commit()
        cursor.close()
        logging.info("Database tables initialized")
    except Exception as e:
        logging.error(f"Failed to initialize database: {str(e)}")
        raise

def create_admin_user():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        admin_password = bcrypt.hashpw('admin'.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
        cursor.execute("""
            INSERT IGNORE INTO login_details (first_name, last_name, email, mobile, password)
            VALUES (%s, %s, %s, %s, %s)
        """, ('Admin', 'User', 'admin@example.com', '1234567890', admin_password))
        conn.commit()
        cursor.close()
        logging.info("Admin user created or already exists")
    except Exception as e:
        logging.error(f"Failed to create admin user: {str(e)}")
        raise

def create_default_validation_rules():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        default_rules = [
            ("Required", "Ensures the field is not null", '{"allow_null": false}', None, None, None),
            ("Int", "Validates integer format", '{"format": "integer"}', None, None, "Int"),
            ("Float", "Validates number format (integer or decimal)", '{"format": "float"}', None, None, "Float"),
            ("Text", "Allows text with quotes and parentheses", '{"allow_special": false}', None, None, "Text"),
            ("Email", "Validates email format", '{"regex": "^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\\\.[a-zA-Z0-9-.]+$"}', None, None, "Email"),
            ("Date(DD-MM-YYYY)", "Validates date format DD-MM-YYYY", '{"format": "%d-%m-%Y"}', "DD-MM-YYYY", None, "Date"),
            ("Boolean", "Validates boolean format (true/false or 0/1)", '{"format": "boolean"}', None, None, "Boolean"),
            ("Alphanumeric", "Validates alphanumeric format", '{"format": "alphanumeric"}', None, None, "Alphanumeric")
        ]
        cursor.executemany("""
            INSERT IGNORE INTO validation_rule_types (rule_name, description, parameters, is_custom, source_format, target_format, data_type)
            VALUES (%s, %s, %s, %s, %s, %s, %s)
        """, [(name, desc, params, False, source, target, dtype) for name, desc, params, source, target, dtype in default_rules])
        conn.commit()
        cursor.close()
        logging.info("Default validation rules ensured successfully")
    except Exception as e:
        logging.error(f"Failed to ensure default validation rules: {str(e)}")
        raise

if __name__ == '__main__':
    try:
        # Create the application using factory pattern
        app = create_app()
        
        # Initialize database and default data within app context
        with app.app_context():
            initialize_app_data()
        
        # Get port from environment or use default
        port = int(os.getenv('PORT', 5000))
        
        # Start the application server
        logging.info("Starting Flask server...")
        app.run(debug=True, host='0.0.0.0', port=port)
        
    except Exception as e:
        logging.error(f"Failed to start application: {e}")
        raise
